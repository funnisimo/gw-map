{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/flags/horde.js","../js/entity/key.js","../js/entity/entity.js","../js/entity/kind.js","../js/actor/actor.js","../js/actor/kind.js","../js/actor/make.js","../js/item/item.js","../js/item/kind.js","../js/item/make.js","../js/effect/handler.js","../js/effect/make.js","../js/tile/tile.js","../js/tile/tiles.js","../js/tile/index.js","../js/layer/mapLayer.js","../js/layer/tileLayer.js","../js/layer/actorLayer.js","../js/layer/itemLayer.js","../js/layer/gasLayer.js","../js/effect/fire.js","../js/effect/handlers/emit.js","../js/effect/handlers/fn.js","../js/effect/handlers/message.js","../js/effect/handlers/activateMachine.js","../js/effect/handlers/effect.js","../js/effect/handlers/tile.js","../js/layer/fireLayer.js","../js/map/cell.js","../js/map/map.js","../js/map/analyze.js","../js/map/snapshot.js","../js/map/utils.js","../js/path.js","../js/horde/horde.js","../js/horde/make.js","../js/memory/memory.js","../js/memory/system.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_LIST_IN_SIDEBAR\"] = Fl(13)] = \"L_LIST_IN_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(0)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(1)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"KNOWN_TO_BE_TRAP_FREE\"] = Fl(2)] = \"KNOWN_TO_BE_TRAP_FREE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(14)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"STABLE_SNAPSHOT\"] = Fl(15)] = \"STABLE_SNAPSHOT\";\n    // These are to help memory\n    Cell[Cell[\"HAS_SURFACE\"] = Fl(16)] = \"HAS_SURFACE\";\n    Cell[Cell[\"HAS_LIQUID\"] = Fl(17)] = \"HAS_LIQUID\";\n    Cell[Cell[\"HAS_GAS\"] = Fl(18)] = \"HAS_GAS\";\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(19)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(20)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(21)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(22)] = \"HAS_ITEM\";\n    Cell[Cell[\"IS_IN_PATH\"] = Fl(23)] = \"IS_IN_PATH\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(24)] = \"IS_CURSOR\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_TRAP_FREE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_SIDEBAR_TILES_CHANGED\"] = Fl(10)] = \"MAP_SIDEBAR_TILES_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_SPREAD_CIRCLE\"] = Fl(13)] = \"E_SPREAD_CIRCLE\";\n    Effect[Effect[\"E_SPREAD_LINE\"] = Fl(14)] = \"E_SPREAD_LINE\";\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Horde;\n(function (Horde) {\n    Horde[Horde[\"HORDE_DIES_ON_LEADER_DEATH\"] = Fl(0)] = \"HORDE_DIES_ON_LEADER_DEATH\";\n    Horde[Horde[\"HORDE_IS_SUMMONED\"] = Fl(1)] = \"HORDE_IS_SUMMONED\";\n    Horde[Horde[\"HORDE_SUMMONED_AT_DISTANCE\"] = Fl(2)] = \"HORDE_SUMMONED_AT_DISTANCE\";\n    Horde[Horde[\"HORDE_NO_PERIODIC_SPAWN\"] = Fl(4)] = \"HORDE_NO_PERIODIC_SPAWN\";\n    Horde[Horde[\"HORDE_ALLIED_WITH_PLAYER\"] = Fl(5)] = \"HORDE_ALLIED_WITH_PLAYER\";\n    Horde[Horde[\"HORDE_NEVER_OOD\"] = Fl(15)] = \"HORDE_NEVER_OOD\";\n    // Move all these to tags?\n    // HORDE_LEADER_CAPTIVE = Fl(3), // the leader is in chains and the followers are guards\n    // HORDE_MACHINE_BOSS = Fl(6), // used in machines for a boss challenge\n    // HORDE_MACHINE_WATER_MONSTER = Fl(7), // used in machines where the room floods with shallow water\n    // HORDE_MACHINE_CAPTIVE = Fl(8), // powerful captive monsters without any captors\n    // HORDE_MACHINE_STATUE = Fl(9), // the kinds of monsters that make sense in a statue\n    // HORDE_MACHINE_TURRET = Fl(10), // turrets, for hiding in walls\n    // HORDE_MACHINE_MUD = Fl(11), // bog monsters, for hiding in mud\n    // HORDE_MACHINE_KENNEL = Fl(12), // monsters that can appear in cages in kennels\n    // HORDE_VAMPIRE_FODDER = Fl(13), // monsters that are prone to capture and farming by vampires\n    // HORDE_MACHINE_LEGENDARY_ALLY = Fl(14), // legendary allies\n    // HORDE_MACHINE_THIEF = Fl(16), // monsters that can be generated in the key thief area machines\n    // HORDE_MACHINE_GOBLIN_WARREN = Fl(17), // can spawn in goblin warrens\n    // HORDE_SACRIFICE_TARGET = Fl(18), // can be the target of an assassination challenge; leader will get scary light.\n    // HORDE_MACHINE_ONLY = HORDE_MACHINE_BOSS |\n    //     HORDE_MACHINE_WATER_MONSTER |\n    //     HORDE_MACHINE_CAPTIVE |\n    //     HORDE_MACHINE_STATUE |\n    //     HORDE_MACHINE_TURRET |\n    //     HORDE_MACHINE_MUD |\n    //     HORDE_MACHINE_KENNEL |\n    //     HORDE_VAMPIRE_FODDER |\n    //     HORDE_MACHINE_LEGENDARY_ALLY |\n    //     HORDE_MACHINE_THIEF |\n    //     HORDE_MACHINE_GOBLIN_WARREN |\n    //     HORDE_SACRIFICE_TARGET,\n})(Horde || (Horde = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","import * as Flags from '../flags/entity';\nlet lastId = 0;\nexport class Entity {\n    constructor(kind) {\n        this.map = null;\n        this.key = null;\n        this.machineHome = 0;\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n        this.id = '' + ++lastId;\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    isAt(x, y) {\n        return this.x === x && this.y === y;\n    }\n    clone() {\n        const other = new this.constructor(this.kind);\n        other.copy(this);\n        return other;\n    }\n    copy(other) {\n        this.depth = other.depth;\n        this.light = other.light;\n        Object.assign(this.flags, other.flags);\n        this.next = other.next;\n        this.x = other.x;\n        this.y = other.y;\n        this.kind = other.kind;\n        this.id = other.id;\n    }\n    canBeSeen() {\n        return this.kind.canBeSeen(this);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isKey(x, y) {\n        return this.key && this.key.matches(x, y);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(cell, this);\n    }\n    avoidsCell(cell) {\n        return this.kind.avoidsCell(cell, this);\n    }\n    getName(opts) {\n        return this.kind.getName(this, opts);\n    }\n    getDescription(opts) {\n        return this.kind.getDescription(this, opts);\n    }\n    getFlavor(opts) {\n        return this.kind.getFlavor(this, opts);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n    drawStatus(sidebar) {\n        this.kind.drawStatus(this, sidebar);\n    }\n    toString() {\n        return `${this.constructor.name}-${this.id} @ ${this.x},${this.y}`;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity } from './entity';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.requiredTileTags = [];\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        if (config.requiredTileTags) {\n            if (typeof config.requiredTileTags === 'string') {\n                this.requiredTileTags = config.requiredTileTags\n                    .split(/[,|]/)\n                    .map((t) => t.trim());\n            }\n            else {\n                this.requiredTileTags = config.requiredTileTags\n                    .slice()\n                    .map((t) => t.trim());\n            }\n        }\n    }\n    make(opts) {\n        const entity = new Entity(this);\n        this.init(entity, opts);\n        return entity;\n    }\n    init(entity, opts = {}) {\n        if (opts.machineHome) {\n            entity.machineHome = opts.machineHome;\n        }\n    }\n    canBeSeen(_entity) {\n        return true;\n    }\n    forbidsCell(cell, _entity) {\n        if (this.requiredTileTags.length &&\n            !cell.hasAllTileTags(this.requiredTileTags))\n            return true;\n        return false;\n    }\n    avoidsCell(cell, _entity) {\n        if (this.requiredTileTags.length &&\n            !cell.hasAnyTileTag(this.requiredTileTags))\n            return true;\n        return false;\n    }\n    getName(_entity, _opts) {\n        return this.name;\n    }\n    getDescription(_entity, _opts) {\n        return this.description;\n    }\n    getFlavor(_entity, _opts) {\n        return this.flavor;\n    }\n    getVerb(_entity, verb) {\n        return verb;\n    }\n    drawStatus(entity, sidebar) {\n        if (!entity.map)\n            return;\n        if (entity.isDestroyed)\n            return;\n        entity.map.getAppearanceAt(entity.x, entity.y, sidebar.mixer);\n        sidebar.drawTitle(sidebar.mixer, entity.getName());\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.next = null;\n        this.leader = null;\n        this.items = null;\n        this.fov = null;\n        // @ts-ignore - initialized in Entity\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n        this.kind = kind;\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    canSee(x, y) {\n        if (x instanceof Entity.Entity) {\n            return this.canSee(x.x, x.y) && this.kind.isAbleToSee(this, x);\n        }\n        if (this.fov) {\n            return this.fov.isDirectlyVisible(x, y);\n        }\n        else if (this.map) {\n            return GWU.xy.forLineBetween(this.x, this.y, x, y, (i, j) => !this.map.cell(i, j).blocksVision());\n        }\n        else {\n            return false; // need a map or an fov\n        }\n    }\n    canSeeOrSense(x, y) {\n        if (x instanceof Entity.Entity) {\n            return (this.canSeeOrSense(x.x, x.y) &&\n                (this.kind.isAbleToSee(this, x) ||\n                    this.kind.isAbleToSense(this, x)));\n        }\n        if (this.fov) {\n            return this.fov.isAnyKindOfVisible(x, y);\n        }\n        return this.canSee(x, y);\n    }\n    isAbleToSee(entity) {\n        return this.kind.isAbleToSee(this, entity);\n    }\n    isAbleToSense(entity) {\n        return this.kind.isAbleToSense(this, entity);\n    }\n    ////////////////// INVENTORY\n    async pickupItem(item, opts) {\n        return this.kind.pickupItem(this, item, opts);\n    }\n    async dropItem(item, opts) {\n        return this.kind.dropItem(this, item, opts);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport { Actor } from './actor';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n        actor.fov = options.fov || null;\n    }\n    canSeeEntity(_actor, _entity) {\n        return true;\n    }\n    isAbleToSee(_actor, _entity) {\n        return true;\n    }\n    isAbleToSense(_actor, _entity) {\n        return true;\n    }\n    forbidsCell(cell, actor) {\n        if (super.forbidsCell(cell, actor))\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    }\n    avoidsCell(cell, actor) {\n        if (super.avoidsCell(cell, actor))\n            return true;\n        if (cell.blocksMove())\n            return true;\n        if (cell.blocksPathing())\n            return true;\n        return false;\n    }\n    getFlavor(actor, opts) {\n        const flavor = actor.isPlayer() ? 'yourself' : this.flavor;\n        if (opts && opts.action) {\n            return flavor + ' standing';\n        }\n        return flavor;\n    }\n    async pickupItem(actor, item, _opts) {\n        if (!GWU.list.push(actor, 'items', item))\n            return false;\n        // TODO - Pickup effects\n        return true;\n    }\n    async dropItem(actor, item, _opts) {\n        if (!GWU.list.remove(actor, 'items', item))\n            return false;\n        // TODO - Drop effects\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ActorKind } from './kind';\nexport function make(id, makeOptions) {\n    const kind = get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ActorKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ActorKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ActorKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ActorKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import { Entity } from '../entity';\nimport { Depth } from '../flags';\nexport class Item extends Entity {\n    constructor(kind) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore - initialized in constructor\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n    }\n    copy(other) {\n        super.copy(other);\n        this.quantity = other.quantity;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n}\n","// import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport { Item } from './item';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n    init(item, options = {}) {\n        super.init(item, options);\n        item.quantity = options.quantity || 1;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ItemKind } from './kind';\nexport function make(id, makeOptions) {\n    const kind = get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","// @ts-nocheck\nexport class Handler {\n    make(src, dest) {\n        return true;\n    }\n    fire(config, map, x, y, ctx) {\n        return false;\n    }\n}\nexport const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id] = handler;\n}\n","import * as GWU from 'gw-utils';\nimport { handlers } from './handler';\nimport { Effect as Flags } from '../flags';\nexport function make(opts) {\n    var _a;\n    if (!opts)\n        throw new Error('opts required to make effect.');\n    if (typeof opts === 'string') {\n        throw new Error('Cannot make effect from string: ' + opts);\n    }\n    if (typeof opts === 'function') {\n        opts = { fn: opts };\n    }\n    // now make base effect stuff\n    const info = {\n        flags: GWU.flag.from(Flags, opts.flags),\n        chance: (_a = opts.chance) !== null && _a !== void 0 ? _a : 0,\n        next: null,\n        id: opts.id || 'n/a',\n    };\n    if (opts.next) {\n        if (typeof opts.next === 'string') {\n            info.next = opts.next;\n        }\n        else {\n            info.next = make(opts.next);\n        }\n    }\n    // and all the handlers\n    Object.values(handlers).forEach((v) => v.make(opts, info));\n    return info;\n}\nexport function from(opts) {\n    if (!opts)\n        throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'string') {\n        const effect = effects[opts];\n        if (effect)\n            return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\n// resetMessageDisplayed\nexport function reset(effect) {\n    effect.flags &= ~Flags.E_FIRED;\n}\nexport function resetAll() {\n    Object.values(effects).forEach((e) => reset(e));\n}\nexport const effects = {};\nexport function install(id, config) {\n    const effect = make(config);\n    effects[id] = effect;\n    effect.id = id;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import * as GWU from 'gw-utils';\nimport { make as makeEffect } from '../effect/make';\nimport * as Flags from '../flags';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.effects = {};\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.tags = [];\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.effects) {\n            Object.assign(this.effects, config.effects);\n        }\n        if (this.hasEffect('fire')) {\n            this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n        }\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                config.tags\n                    .split(/[,|]/)\n                    .map((t) => t.trim())\n                    .forEach((t) => {\n                    this.tags.push(t);\n                });\n            }\n            else {\n                this.tags = config.tags.slice().map((t) => t.trim());\n            }\n        }\n    }\n    hasTag(tag) {\n        return this.tags.includes(tag);\n    }\n    hasAnyTag(tags) {\n        return GWU.arraysIntersect(this.tags, tags);\n    }\n    hasAllTags(tags) {\n        return tags.every((t) => this.tags.includes(t));\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    hasEffect(name) {\n        return name in this.effects;\n    }\n    getName(arg) {\n        let opts = {};\n        if (typeof arg === 'boolean') {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription(opts) {\n        return this.description || this.getName(opts);\n    }\n    getFlavor(opts) {\n        return this.flavor || this.getName(opts);\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { effects: {}, flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const effects = {};\n    Object.assign(effects, base.effects);\n    if (options.effects) {\n        Object.entries(options.effects).forEach(([key, value]) => {\n            if (value === null) {\n                delete effects[key];\n                return;\n            }\n            if (typeof value === 'string') {\n                effects[key] = value;\n                return;\n            }\n            effects[key] = makeEffect(value);\n        });\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        effects,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n        tags: options.tags || null,\n    };\n    const tile = new Tile(config);\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import * as Tile from './tile';\n// These are the minimal set of tiles to make the diggers work\nTile.install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: [30, 30, 30, 20, 0, 0, 0],\n    bg: [2, 2, 10, 0, 2, 2, 0],\n    priority: 10,\n    article: 'the',\n    flavor: 'the stone floor',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: { tile: 'DOOR_OPEN' },\n        open: { tile: 'DOOR_OPEN_ALWAYS' },\n    },\n    flavor: 'a closed door',\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            tile: 'DOOR',\n            flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY',\n        },\n        enter: null,\n        open: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n    flavor: 'an open door',\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n    flavor: 'an open door',\n});\nTile.install('UP_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'upward staircase',\n    article: 'an',\n    effects: {\n        player: { emit: 'UP_STAIRS' },\n    },\n    flavor: 'stairs leading upwards',\n});\nTile.install('DOWN_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'downward staircase',\n    article: 'a',\n    effects: {\n        player: { emit: 'DOWN_STAIRS' },\n    },\n    flavor: 'downward leading stairs',\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'a very hard wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: [5, 8, 20, 10, 0, 4, 15, true],\n    bg: [10, 15, 41, 6, 5, 5, 5, true],\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n    flavor: 'some deep water',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: [5, 8, 10, 10, 0, 4, 15, true],\n    bg: [10, 30, 30, 6, 0, 10, 10, true],\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    depth: 'SURFACE',\n    flavor: 'some shallow water',\n});\nTile.install('BRIDGE', {\n    ch: '=',\n    fg: [100, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n    flavor: 'a bridge',\n});\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\nimport './tiles';\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n    putAppearance(_dest, _cell) { }\n}\n","import * as Tile from '../tile';\nimport * as Flags from '../flags';\nimport { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts = {}) {\n        const cell = this.map.cell(x, y);\n        const current = cell.depthTile(tile.depth) || Tile.tiles.NULL;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (cell.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && cell.hasItem())\n            return false;\n        if (opts.blockedByActors && cell.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && cell.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const ground = cell.depthTile(Flags.Depth.GROUND);\n            if (!ground || ground === Tile.tiles.NULL) {\n                this.setTile(x, y, Tile.get(tile.groundTile));\n            }\n        }\n        // if nothing changed... return false\n        if (!cell.setTile(tile))\n            return false;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            cell.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            cell.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (current.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR) !==\n            tile.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR)) {\n            this.map.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        // if (this.map.fov.isAnyKindOfVisible(x, y)) {\n        //     cell.clearCellFlag(\n        //         Flags.Cell.STABLE_MEMORY | Flags.Cell.STABLE_SNAPSHOT\n        //     );\n        // }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            cell.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clear() {\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearDepth(this.depth);\n            }\n        }\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    async tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire, pressure plates and key-activated tiles.\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (!cell.hasCellFlag(Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM) &&\n                    cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)) {\n                    cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n                }\n                if (cell.hasEffect('noKey') && !this.map.hasKey(x, y)) {\n                    await cell.fire('noKey', this.map, x, y);\n                }\n            }\n        }\n        return true;\n    }\n    putAppearance(dest, cell) {\n        const tile = cell.depthTile(this.depth);\n        if (tile) {\n            dest.drawSprite(tile.sprite);\n        }\n    }\n}\n","import * as Flags from '../flags';\nimport { MapLayer } from './mapLayer';\nexport class ActorLayer extends MapLayer {\n    constructor(map, name = 'actor') {\n        super(map, name);\n    }\n    clear() {\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.HAS_PLAYER);\n            }\n        }\n        this.map.actors = [];\n    }\n    async addActor(x, y, obj, _opts) {\n        const actor = obj;\n        if (actor.isDestroyed)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (actor.forbidsCell(cell))\n            return false;\n        cell.addActor(actor);\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('key')) {\n            await cell.fire('key', this.map, x, y, { actor });\n        }\n        return true;\n    }\n    forceActor(x, y, actor, _opts) {\n        if (actor.isDestroyed)\n            return false;\n        if (this.map.actors.includes(actor)) {\n            const oldCell = this.map.cell(actor.x, actor.y);\n            oldCell.removeActor(actor);\n        }\n        const cell = this.map.cell(x, y);\n        cell.addActor(actor);\n        actor.depth = this.depth;\n        return true;\n    }\n    async removeActor(actor) {\n        const x = actor.x;\n        const y = actor.y;\n        const cell = this.map.cell(x, y);\n        if (!cell.removeActor(actor))\n            return false;\n        if (actor.key && actor.key.matches(x, y) && cell.hasEffect('nokey')) {\n            await cell.fire('nokey', this.map, x, y, { actor });\n        }\n        if (cell.hasEffect('removeActor')) {\n            await cell.fire('removeActor', this.map, x, y, { actor });\n        }\n        return true;\n    }\n    putAppearance(dest, cell) {\n        if (!cell.hasActor())\n            return;\n        const actor = this.map.actorAt(cell.x, cell.y);\n        if (actor) {\n            dest.drawSprite(actor.sprite);\n        }\n    }\n}\n","import { MapLayer } from './mapLayer';\nimport * as Flags from '../flags';\nexport class ItemLayer extends MapLayer {\n    constructor(map, name = 'item') {\n        super(map, name);\n    }\n    clear() {\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(Flags.Cell.HAS_ITEM);\n            }\n        }\n        this.map.items = [];\n    }\n    async addItem(x, y, item, _opts) {\n        if (item.isDestroyed)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (item.forbidsCell(cell))\n            return false;\n        cell.addItem(item);\n        item.depth = this.depth;\n        if (item.key && item.key.matches(x, y) && cell.hasEffect('key')) {\n            await cell.fire('key', this.map, x, y, { item });\n            if (item.key.disposable) {\n                cell.removeItem(item);\n                item.destroy();\n                return true; // TODO - ??? Is this correct!?!?\n            }\n        }\n        if (cell.hasEffect('addItem')) {\n            await cell.fire('addItem', this.map, x, y, { item });\n        }\n        return true;\n    }\n    forceItem(x, y, item, _opts) {\n        if (!this.map.hasXY(x, y))\n            return false;\n        // If item is already in map.items, then this is a move\n        if (this.map.items.includes(item)) {\n            const oldCell = this.map.cell(item.x, item.y);\n            oldCell.removeItem(item);\n        }\n        const cell = this.map.cell(x, y);\n        cell.addItem(item);\n        item.depth = this.depth;\n        return true;\n    }\n    async removeItem(item) {\n        const x = item.x;\n        const y = item.y;\n        const cell = this.map.cell(x, y);\n        if (!cell.removeItem(item))\n            return false;\n        if (item.key && item.key.matches(x, y) && cell.hasEffect('nokey')) {\n            await cell.fire('nokey', this.map, x, y, { item });\n        }\n        if (cell.hasEffect('removeItem')) {\n            await cell.fire('removeItem', this.map, x, y, { item });\n        }\n        return true;\n    }\n    putAppearance(dest, cell) {\n        if (!cell.hasItem())\n            return;\n        const item = this.map.itemAt(cell.x, cell.y);\n        if (item) {\n            dest.drawSprite(item.sprite);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    clear() {\n        this.volume.fill(0);\n    }\n    setTile(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.setTile(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.changed = true;\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n        this.changed = other.changed;\n    }\n    async tick(_dt) {\n        if (!this.changed)\n            return false;\n        this.changed = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.changed = true;\n            }\n            else {\n                this.clearTile(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clearTile(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n    putAppearance(dest, cell) {\n        const volume = this.volume[cell.x][cell.y];\n        if (!volume)\n            return;\n        const tile = cell.depthTile(this.depth);\n        if (tile) {\n            const opacity = this.calcOpacity(volume);\n            dest.drawSprite(tile.sprite, opacity);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Effect as Flags } from '../flags';\nimport { from } from './make';\nimport { handlers } from './handler';\nexport async function fire(effect, map, x, y, ctx_ = {}) {\n    if (!effect)\n        return false;\n    if (typeof effect === 'string') {\n        const name = effect;\n        effect = from(name);\n        if (!effect)\n            throw new Error('Failed to find effect: ' + name);\n    }\n    const ctx = ctx_;\n    if (!ctx.force && effect.chance && !map.rng.chance(effect.chance, 10000))\n        return false;\n    const grid = (ctx.grid = GWU.grid.alloc(map.width, map.height));\n    let didSomething = false;\n    const allHandlers = Object.values(handlers);\n    for (let h of allHandlers) {\n        if (await h.fire(effect, map, x, y, ctx)) {\n            didSomething = true;\n        }\n    }\n    // do the next effect - if applicable\n    if (effect.next &&\n        (didSomething || effect.flags & Flags.E_NEXT_ALWAYS) &&\n        !GWU.data.gameHasEnded) {\n        const nextInfo = typeof effect.next === 'string' ? from(effect.next) : effect.next;\n        if (effect.flags & Flags.E_NEXT_EVERYWHERE) {\n            await grid.forEachAsync(async (v, i, j) => {\n                if (!v)\n                    return;\n                didSomething =\n                    (await fire(nextInfo, map, i, j, ctx)) || didSomething;\n            });\n        }\n        else {\n            didSomething =\n                (await fire(nextInfo, map, x, y, ctx)) || didSomething;\n        }\n    }\n    // bookkeeping\n    if (didSomething &&\n        // map.isVisible(x, y) &&\n        !(effect.flags & Flags.E_NO_MARK_FIRED)) {\n        effect.flags |= Flags.E_FIRED;\n    }\n    GWU.grid.free(grid);\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport { Handler, installHandler } from '../handler';\n//////////////////////////////////////////////\n// EMIT\nexport class EmitEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.emit)\n            return true;\n        if (typeof src.emit !== 'string') {\n            throw new Error('emit effects must be string name to emit: { emit: \"EVENT\" }');\n        }\n        dest.emit = src.emit;\n        return true;\n    }\n    async fire(config, _map, x, y, ctx) {\n        if (config.emit) {\n            await GWU.events.emit(config.emit, x, y, ctx);\n            return true;\n        }\n        return false;\n    }\n}\ninstallHandler('emit', new EmitEffect());\n","import { Handler, installHandler } from '../handler';\n//////////////////////////////////////////////\n// FN\nexport class FnEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.fn)\n            return true;\n        if (typeof src.fn !== 'function') {\n            throw new Error('fn effects must be functions.');\n        }\n        dest.fn = src.fn;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.fn) {\n            return await config.fn(config, map, x, y, ctx);\n        }\n        return false;\n    }\n}\ninstallHandler('fn', new FnEffect());\n","import * as GWU from 'gw-utils';\nimport { Handler, installHandler } from '../handler';\nimport { Effect as Flags } from '../../flags';\n//////////////////////////////////////////////\n// MESSAGE\nexport class MessageEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.message)\n            return true;\n        if (typeof src.message !== 'string') {\n            throw new Error('Emit must be configured with name of event to emit');\n        }\n        dest.message = src.message;\n        return true;\n    }\n    async fire(config, _map, x, y, ctx) {\n        if (!config.message)\n            return false;\n        const fired = !!(config.flags & Flags.E_FIRED);\n        if (config.message &&\n            config.message.length &&\n            !fired\n        // && map.isVisible(x, y)\n        ) {\n            GWU.message.addAt(x, y, config.message, ctx);\n            return true;\n        }\n        return false;\n    }\n}\ninstallHandler('message', new MessageEffect());\n","import { Handler, installHandler } from '../handler';\n//////////////////////////////////////////////\n// ActivateMachine\nexport class ActivateMachineEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.activateMachine)\n            return true;\n        dest.activateMachine = true;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.activateMachine) {\n            const cell = map.cell(x, y);\n            const machine = cell.machineId;\n            if (!machine)\n                return false;\n            return await map.activateMachine(machine, x, y, ctx);\n        }\n        return false;\n    }\n}\ninstallHandler('activateMachine', new ActivateMachineEffect());\n","import { Handler, installHandler } from '../handler';\nimport * as FIRE from '../fire';\n//////////////////////////////////////////////\n// EMIT\nexport class EffectEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.effect)\n            return true;\n        dest.effect = src.effect;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.effect) {\n            return await FIRE.fire(config.effect, map, x, y, ctx);\n        }\n        return false;\n    }\n}\ninstallHandler('effect', new EffectEffect());\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../../flags';\nimport * as Tile from '../../tile';\nimport { Handler, installHandler } from '../handler';\nexport class SpawnEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (!src.tile)\n            return true; // no error\n        let config = src.tile;\n        if (typeof config === 'string') {\n            const parts = config.split(/[,|]/).map((p) => p.trim());\n            config = {\n                tile: parts[0],\n                grow: Number.parseInt(parts[1] || '0'),\n                decrement: Number.parseInt(parts[2] || '0'),\n            };\n        }\n        const info = {\n            grow: (_b = (_a = config.grow) !== null && _a !== void 0 ? _a : config.spread) !== null && _b !== void 0 ? _b : 0,\n            decrement: (_c = config.decrement) !== null && _c !== void 0 ? _c : 0,\n            flags: GWU.flag.from(Flags.Effect, config.flags),\n            volume: (_d = config.volume) !== null && _d !== void 0 ? _d : 0,\n            next: (_e = config.next) !== null && _e !== void 0 ? _e : null,\n        };\n        const id = (_f = config.tile) !== null && _f !== void 0 ? _f : config.id;\n        if (typeof id === 'string') {\n            info.tile = id;\n        }\n        else {\n            throw new Error('Invalid tile spawn config: ' + id);\n        }\n        if (!info.tile) {\n            throw new Error('Must have tile.');\n        }\n        const match = (_g = config.matchTile) !== null && _g !== void 0 ? _g : config.match;\n        if (typeof match === 'string') {\n            info.matchTile = match;\n        }\n        else if (match) {\n            throw new Error('Invalid tile spawn match tile: ' + config.matchTile);\n        }\n        dest.tile = info;\n        return true;\n    }\n    fire(effect, map, x, y, ctx) {\n        if (!effect.tile)\n            return false; // did nothing\n        const id = effect.tile.tile;\n        const tile = Tile.tiles[id] || null;\n        if (!tile) {\n            throw new Error('Failed to find tile for effect: ' + id);\n        }\n        const abortIfBlocking = !!(effect.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n        const isBlocking = !!(abortIfBlocking &&\n            !(effect.flags & Flags.Effect.E_PERMIT_BLOCKING) &&\n            (tile.blocksPathing() ||\n                effect.flags & Flags.Effect.E_TREAT_AS_BLOCKING));\n        let didSomething = false;\n        didSomething = computeSpawnMap(effect, map, x, y, ctx);\n        if (!didSomething) {\n            return false;\n        }\n        if (abortIfBlocking &&\n            isBlocking &&\n            this.mapDisruptedBy(map, ctx.grid)) {\n            // GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (effect.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, ctx.grid)) {\n                didSomething = true;\n            }\n        }\n        if (effect.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, ctx.grid)) {\n                didSomething = true;\n            }\n        }\n        if (effect.flags & Flags.Effect.E_CLEAR_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (clearCells(map, ctx.grid, effect.flags)) {\n                didSomething = true;\n            }\n        }\n        const spawned = spawnTiles(effect.flags, ctx.grid, map, tile, effect.tile.volume, ctx.machine);\n        return spawned;\n    }\n    mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n        const walkableGrid = GWU.grid.alloc(map.width, map.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GWU.xy.forRect(map.width, map.height, (i, j) => {\n            const lakeX = i + blockingToMapX;\n            const lakeY = j + blockingToMapY;\n            if (blockingGrid.get(lakeX, lakeY)) {\n                if (map.cell(i, j).isStairs()) {\n                    disrupts = true;\n                }\n            }\n            else if (!map.cell(i, j).blocksMove()) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGWU.grid.dump();\n        GWU.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\ninstallHandler('tile', new SpawnEffect());\n// tick\n// Spawn\nexport function spawnTiles(flags, spawnMap, map, tile, volume = 0, machine) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = !!(flags & Flags.Effect.E_BLOCKED_BY_OTHER_LAYERS);\n    const superpriority = !!(flags & Flags.Effect.E_SUPERPRIORITY);\n    const blockedByActors = !!(flags & Flags.Effect.E_BLOCKED_BY_ACTORS);\n    const blockedByItems = !!(flags & Flags.Effect.E_BLOCKED_BY_ITEMS);\n    // const applyEffects = ctx.refreshCell;\n    volume = volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            // const isRoot = spawnMap[i][j] === 1;\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.hasTile(tile)) {\n                // If the new cell already contains the fill terrain,\n                // if (tile.depth == Flags.Depth.GAS) {\n                //     spawnMap[i][j] = 1;\n                //     cell.gasVolume += volume;\n                // } else if (tile.depth == Flags.Depth.LIQUID) {\n                //     spawnMap[i][j] = 1;\n                //     cell.liquidVolume += volume;\n                // }\n            }\n            else if (map.setTile(i, j, tile, {\n                volume,\n                superpriority,\n                blockedByOtherLayers,\n                blockedByActors,\n                blockedByItems,\n                machine,\n            })) {\n                // if the fill won't violate the priority of the most important terrain in this cell:\n                spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                // map.redrawCell(cell);\n                // if (volume && cell.gas) {\n                //     cell.volume += (feat.volume || 0);\n                // }\n                cell.flags.cell |= Flags.Cell.EVENT_FIRED_THIS_TURN;\n                if (flags & Flags.Effect.E_PROTECTED) {\n                    cell.flags.cell |= Flags.Cell.EVENT_PROTECTED;\n                }\n                accomplishedSomething = true;\n                // debug('- tile', i, j, 'tile=', tile.id);\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.setMapFlag(Flags.Map.MAP_CHANGED);\n    }\n    return accomplishedSomething;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.tile.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cell(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cell(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.tile.matchTile &&\n        !isStart &&\n        !cell.hasTile(effect.tile.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, map, x, y, ctx) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const config = effect.tile;\n    let startProb = config.grow || 0;\n    let probDec = config.decrement || 0;\n    const spawnMap = ctx.grid;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, x, y, true)) {\n        return false;\n    }\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\n// export function spreadCircle(\n//     this: any,\n//     ctx: Effect.EffectCtx,\n//     spawnMap: GWU.grid.NumGrid\n// ) {\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     let radius = 0;\n//     startProb = startProb || 100;\n//     if (startProb >= 100) {\n//         probDec = probDec || 100;\n//     }\n//     while (map.rng.chance(startProb)) {\n//         startProb -= probDec;\n//         ++radius;\n//     }\n//     // startProb = 100;\n//     // probDec = 0;\n//     spawnMap.updateCircle(x, y, radius, (_v, i, j) => {\n//         if (!cellIsOk(this, i, j, ctx)) return 0;\n//         // const dist = Math.floor(GWU.utils.distanceBetween(x, y, i, j));\n//         // const prob = startProb - dist * probDec;\n//         // if (!map.rng.chance(prob)) return 0;\n//         return 1;\n//     });\n//     // spawnMap[x][y] = 1;\n//     // if (!isOk(flags, x, y, ctx)) {\n//     //     spawnMap[x][y] = 0;\n//     // }\n//     return true;\n// }\n// export function spreadLine(\n//     this: any,\n//     ctx: Effect.EffectCtx,\n//     spawnMap: GWU.grid.NumGrid\n// ) {\n//     let x2, y2;\n//     let madeChange;\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     if (startProb) {\n//         madeChange = true;\n//         if (startProb >= 100) {\n//             probDec = probDec || 100;\n//         }\n//         x2 = x;\n//         y2 = y;\n//         const dir = GWU.xy.DIRS[map.rng.number(4)];\n//         while (madeChange) {\n//             madeChange = false;\n//             x2 = x2 + dir[0];\n//             y2 = y2 + dir[1];\n//             if (\n//                 spawnMap.hasXY(x2, y2) &&\n//                 !spawnMap[x2][y2] &&\n//                 cellIsOk(this, x2, y2, ctx) &&\n//                 map.rng.chance(startProb)\n//             ) {\n//                 spawnMap[x2][y2] = 1;\n//                 madeChange = true;\n//                 startProb -= probDec;\n//             }\n//         }\n//     }\n//     if (!cellIsOk(this, x, y, ctx)) {\n//         spawnMap[x][y] = 0;\n//     }\n//     return true;\n// }\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap[a.x][a.y])\n            return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const c = map.cell(x, y);\n            return !a.forbidsCell(c);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.forceActor(loc[0], loc[1], a);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap[i.x][i.y])\n            return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const dest = map.cell(x, y);\n            return !i.forbidsCell(dest);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.forceItem(loc[0], loc[1], i);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nclass ClearTileEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.clear)\n            return true;\n        let config = src.clear;\n        let layers = 0;\n        if (typeof config === 'string') {\n            config = config.split(/[,|]/).map((t) => t.trim());\n        }\n        if (config === true) {\n            layers = Flags.Depth.ALL_LAYERS;\n        }\n        else if (typeof config === 'number') {\n            layers = config;\n        }\n        else if (Array.isArray(config)) {\n            layers = config.reduce((out, v) => {\n                if (typeof v === 'number')\n                    return out | v;\n                const depth = Flags.Depth[v] || 0;\n                return out | depth;\n            }, 0);\n        }\n        else {\n            throw new Error('clear effect must have number or string config.');\n        }\n        dest.clear = layers;\n        return layers > 0;\n    }\n    async fire(config, map, x, y, ctx) {\n        return this.fireSync(config, map, x, y, ctx);\n    }\n    fireSync(config, map, x, y, _ctx) {\n        if (!config.clear)\n            return false;\n        if (!map)\n            return false;\n        const cell = map.cell(x, y);\n        return cell.clearDepth(config.clear);\n    }\n}\ninstallHandler('clear', new ClearTileEffect());\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nimport * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    async tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    await this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.xy.DIRS[d];\n                        await this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    async exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = Effect.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && this.map.rng.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            await cell.fire(event, this.map, x, y, {\n                force: true,\n            });\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as Effect from '../effect';\n// class CellEntities {\n//     cell: Cell;\n//     constructor(cell: Cell) {\n//         this.cell = cell;\n//     }\n//     eachItem(cb: EachCb<Item>): void {\n//         let object: Item | null = this.cell._item;\n//         while (object) {\n//             cb(object);\n//             object = object.next;\n//         }\n//     }\n//     eachActor(cb: EachCb<Actor>): void {\n//         let object: Actor | null = this.cell._actor;\n//         while (object) {\n//             cb(object);\n//             object = object.next;\n//         }\n//     }\n//     forEach(cb: EachCb<Entity>): void {\n//         this.eachItem(cb);\n//         this.eachActor(cb);\n//     }\n//     some(cb: MatchCb<Entity>): boolean {\n//         let object: Entity | null = this.cell._item;\n//         while (object) {\n//             if (cb(object)) return true;\n//             object = object.next;\n//         }\n//         object = this.cell._actor;\n//         while (object) {\n//             if (cb(object)) return true;\n//             object = object.next;\n//         }\n//         return false;\n//     }\n//     reduce(cb: ReduceCb<Entity>, start?: any): any {\n//         let object: Entity | null = this.cell._item;\n//         while (object) {\n//             if (start === undefined) {\n//                 start = object;\n//             } else {\n//                 start = cb(start, object);\n//             }\n//             object = object.next;\n//         }\n//         object = this.cell._actor;\n//         while (object) {\n//             if (start === undefined) {\n//                 start = object;\n//             } else {\n//                 start = cb(start, object);\n//             }\n//             object = object.next;\n//         }\n//         return start;\n//     }\n// }\nexport class Cell {\n    constructor(map, x, y, groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.x = -1;\n        this.y = -1;\n        // this._entities = new CellEntities(this);\n        this.flags = { cell: Flags.Cell.NEEDS_REDRAW };\n        this.tiles = [TILE.tiles.NULL];\n        this.map = map;\n        this.x = x;\n        this.y = y;\n        this.snapshot = GWU.sprite.makeMixer();\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get hasStableSnapshot() {\n        return this.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    }\n    get hasStableMemory() {\n        return this.hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this.machineId = other.machineId;\n        // this._actor = other.actor;\n        // this._item = other.item;\n        this.map = other.map;\n        this.x = other.x;\n        this.y = other.y;\n        other.getSnapshot(this.snapshot);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.entityFlags() & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    hasTileTag(tag) {\n        return this.tiles.some((tile) => tile && tile.hasTag(tag));\n    }\n    hasAllTileTags(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAllTags(tags);\n        });\n    }\n    hasAnyTileTag(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAnyTag(tags);\n        });\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0);\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return this.tiles.some((t) => t && t.blocksVision());\n    }\n    blocksPathing() {\n        return this.tiles.some((t) => t && t.blocksPathing());\n    }\n    blocksMove() {\n        return this.tiles.some((t) => t && t.blocksMove());\n    }\n    blocksEffects() {\n        return this.tiles.some((t) => t && t.blocksEffects());\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isNull() {\n        return this.tiles.every((t) => !t || t === TILE.tiles.NULL);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    // hasKey(): boolean {\n    //     return this._entities.some(\n    //         (e) => !!e.key && e.key.matches(this.x, this.y)\n    //     );\n    // }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile)\n            return false;\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        // if (current.light !== tile.light) {\n        //     this.setCellFlag(Flags.Cell.LIGHT_CHANGED);\n        // }\n        // if (current.blocksVision() !== tile.blocksVision()) {\n        //     this.setCellFlag(Flags.Cell.FOV_CHANGED);\n        // }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.needsRedraw = true;\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.snapshot.blackOut();\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    async fire(event, map, x, y, ctx = {}) {\n        ctx.cell = this;\n        let didSomething = false;\n        if (ctx.depth !== undefined) {\n            const tile = (ctx.tile = this.depthTile(ctx.depth));\n            if (tile && tile.effects) {\n                const ev = tile.effects[event];\n                didSomething = await this._activate(ev, map, x, y, ctx);\n            }\n        }\n        else {\n            // console.log('fire event - %s', event);\n            for (ctx.tile of this.tiles) {\n                if (!ctx.tile || !ctx.tile.effects)\n                    continue;\n                const ev = ctx.tile.effects[event];\n                // console.log(' - ', ev);\n                if (await this._activate(ev, map, x, y, ctx)) {\n                    didSomething = true;\n                    break;\n                }\n                // }\n            }\n        }\n        return didSomething;\n    }\n    async _activate(effect, map, x, y, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.effects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = await Effect.fire(effect, map, x, y, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    addItem(item) {\n        this.setCellFlag(Flags.Cell.HAS_ITEM);\n        item.x = this.x;\n        item.y = this.y;\n        item.map = this.map;\n        this.map.items.push(item);\n        this.needsRedraw = true;\n    }\n    removeItem(item) {\n        let hasItems = false;\n        let foundIndex = -1;\n        this.map.items.forEach((obj, index) => {\n            if (obj === item) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasItems = true;\n            }\n        });\n        if (!hasItems) {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.map.items.splice(foundIndex, 1); // delete the item\n        this.needsRedraw = true;\n        return true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    addActor(actor) {\n        this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        if (actor.isPlayer()) {\n            this.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        actor.x = this.x;\n        actor.y = this.y;\n        actor.map = this.map;\n        this.map.actors.push(actor);\n        this.needsRedraw = true;\n    }\n    removeActor(actor) {\n        let hasActor = false;\n        let foundIndex = -1;\n        this.map.actors.forEach((obj, index) => {\n            if (obj === actor) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasActor = true;\n            }\n        });\n        if (!hasActor) {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.HAS_PLAYER);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.map.actors.splice(foundIndex, 1); // delete the actor\n        this.needsRedraw = true;\n        return true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n    drawStatus(sidebar) {\n        if (!this.map)\n            return;\n        this.map.getAppearanceAt(this.x, this.y, sidebar.mixer);\n        sidebar.drawTitle(sidebar.mixer, this.getName());\n    }\n    toString() {\n        return `Cell @ ${this.x},${this.y}`;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport * as Layer from '../layer';\n// import { CellMemory } from './cellMemory';\nimport * as Effect from '../effect';\nexport class Map {\n    constructor(width, height, opts = {}) {\n        // _memory: GWU.grid.Grid<CellMemory>;\n        this.machineCount = 0;\n        this._seed = 0;\n        this.rng = GWU.rng.random;\n        this.id = 'MAP';\n        this.actors = [];\n        this.items = [];\n        this.width = width;\n        this.height = height;\n        this.flags = { map: 0 };\n        this.layers = [];\n        if (opts.id) {\n            this.id = opts.id;\n        }\n        this.cells = GWU.grid.make(width, height, (x, y) => new Cell(this, x, y));\n        // this._memory = GWU.grid.make(\n        //     width,\n        //     height,\n        //     (x, y) => new CellMemory(this, x, y)\n        // );\n        if (opts.seed) {\n            this._seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        // this.fov = new GWU.fov.FovSystem(this, opts);\n        this.properties = {};\n        this.initLayers();\n    }\n    get seed() {\n        return this._seed;\n    }\n    set seed(v) {\n        this._seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    // memory(x: number, y: number): CellMemory {\n    //     return this._memory[x][y];\n    // }\n    // knowledge(x: number, y: number): CellInfoType {\n    //     if (this.fov.isAnyKindOfVisible(x, y)) return this.cell(x,y);\n    //     return this._memory[x][y];\n    // }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n        this.addLayer(Flags.Depth.SURFACE, new Layer.FireLayer(this, 'surface'));\n        this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n        this.addLayer(Flags.Depth.ITEM, new Layer.ItemLayer(this, 'item'));\n        this.addLayer(Flags.Depth.ACTOR, new Layer.ActorLayer(this, 'actor'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // items\n    hasItem(x, y) {\n        return this.cell(x, y).hasItem();\n    }\n    itemAt(x, y) {\n        return this.items.find((i) => i.isAt(x, y)) || null;\n    }\n    eachItem(cb) {\n        this.items.forEach(cb);\n    }\n    async addItem(x, y, item) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && (await layer.addItem(x, y, item))) {\n                // this.items.push(item);\n                return true;\n            }\n        }\n        return false;\n    }\n    forceItem(x, y, item) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && layer.forceItem(x, y, item)) {\n                // this.items.push(item);\n                return true;\n            }\n        }\n        return false;\n    }\n    async removeItem(item) {\n        const layer = this.layers[item.depth];\n        if (await layer.removeItem(item)) {\n            // GWU.arrayDelete(this.items, item);\n            return true;\n        }\n        return false;\n    }\n    async moveItem(item, dir) {\n        if (typeof dir === 'number') {\n            dir = GWU.xy.DIRS[dir];\n        }\n        const oldX = item.x;\n        const oldY = item.y;\n        const x = oldX + dir[0];\n        const y = oldY + dir[1];\n        if (!this.hasXY(x, y))\n            return false;\n        const layer = this.layers[item.depth];\n        if (!(await layer.removeItem(item)))\n            return false;\n        if (!(await this.addItem(x, y, item))) {\n            layer.forceItem(item.x, item.y, item);\n            return false;\n        }\n        // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n        // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n        // if (isVisible && !wasVisible) {\n        //     if (item.lastSeen) {\n        //         this._memory[item.lastSeen.x][item.lastSeen.y].removeItem(item);\n        //         this.clearCellFlag(\n        //             item.lastSeen.x,\n        //             item.lastSeen.y,\n        //             Flags.Cell.STABLE_SNAPSHOT\n        //         );\n        //         item.lastSeen = null;\n        //     }\n        // } else if (wasVisible && !isVisible) {\n        //     const mem = this._memory[x][y];\n        //     mem.item = item;\n        //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n        //     item.lastSeen = this.cell(x, y);\n        // }\n        return true;\n    }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    actorAt(x, y) {\n        return this.actors.find((a) => a.isAt(x, y)) || null;\n    }\n    eachActor(cb) {\n        this.actors.forEach(cb);\n    }\n    async addActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && (await layer.addActor(x, y, actor))) {\n                // this.actors.push(actor);\n                return true;\n            }\n        }\n        return false;\n    }\n    forceActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && layer.forceActor(x, y, actor)) {\n                // this.actors.push(actor);\n                return true;\n            }\n        }\n        return false;\n    }\n    async removeActor(actor) {\n        const layer = this.layers[actor.depth];\n        if (await layer.removeActor(actor)) {\n            // GWU.arrayDelete(this.actors, actor);\n            return true;\n        }\n        return false;\n    }\n    async moveActor(actor, dir) {\n        if (typeof dir === 'number') {\n            dir = GWU.xy.DIRS[dir];\n        }\n        const oldX = actor.x;\n        const oldY = actor.y;\n        const x = oldX + dir[0];\n        const y = oldY + dir[1];\n        if (!this.hasXY(x, y))\n            return false;\n        const layer = this.layers[actor.depth];\n        if (!(await layer.removeActor(actor)))\n            return false;\n        if (!(await layer.addActor(x, y, actor))) {\n            layer.forceActor(actor.x, actor.y, actor);\n            return false;\n        }\n        // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n        // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n        // if (isVisible && !wasVisible) {\n        //     if (actor.lastSeen) {\n        //         this._memory[actor.lastSeen.x][actor.lastSeen.y].removeActor(\n        //             actor\n        //         );\n        //         this.clearCellFlag(\n        //             actor.lastSeen.x,\n        //             actor.lastSeen.y,\n        //             Flags.Cell.STABLE_SNAPSHOT\n        //         );\n        //         actor.lastSeen = null;\n        //     }\n        // } else if (wasVisible && !isVisible) {\n        //     const mem = this._memory[x][y];\n        //     mem.actor = actor;\n        //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n        //     actor.lastSeen = this.cell(x, y);\n        // }\n        return true;\n    }\n    // Information\n    // isVisible(x: number, y: number): boolean {\n    //     return this.fov.isAnyKindOfVisible(x, y);\n    // }\n    hasKey(x, y) {\n        const actor = this.actorAt(x, y);\n        if (actor && actor.isKey(x, y))\n            return true;\n        const item = this.itemAt(x, y);\n        if (item && item.isKey(x, y))\n            return true;\n        return false;\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        const mixer = new GWU.sprite.Mixer();\n        const getCh = (_cell, x, y) => {\n            this.getAppearanceAt(x, y, mixer);\n            if (mixer.ch < 0)\n                return ' ';\n            return mixer.ch;\n        };\n        this.cells.dump(fmt || getCh, log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        // this.fov.needsUpdate = true;\n        this.layers.forEach((l) => l.clear());\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cells[i][j];\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile\n    // useMemory = false\n    ) {\n        return this.cell(x, y).hasTile(tile);\n        // if (!useMemory) return this.cell(x, y).hasTile(tile);\n        // return this.memory(x, y).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof Layer.TileLayer))\n            return false;\n        return layer.setTile(x, y, tile, opts);\n    }\n    clearTiles(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clearTiles(tile);\n    }\n    async tick(dt) {\n        let didSomething = await this.fireAll('tick');\n        for (let layer of this.layers) {\n            if (layer && (await layer.tick(dt))) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cell(x, y));\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.actors = src.actors.slice();\n        this.items = src.items.slice();\n        this.flags.map = src.flags.map;\n        // this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        this.machineCount = src.machineCount;\n        this._seed = src._seed;\n        this.properties = Object.assign({}, src.properties);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    async fire(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.fire(event, this, x, y, ctx);\n    }\n    async fireAll(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        await willFire.forEachAsync(async (w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    await cell.fire(event, this, x, y, {\n                        force: true,\n                        depth,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    async activateMachine(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        (await cell.fire('machine', this, x, y, ctx)) ||\n                            didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    // DRAW\n    drawInto(dest, opts = {}) {\n        const buffer = dest instanceof GWU.canvas.Canvas ? dest.buffer : dest;\n        if (typeof opts === 'boolean')\n            opts = { force: opts };\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                this.getAppearanceAt(x, y, mixer);\n                buffer.drawSprite(x, y, mixer);\n            }\n        }\n    }\n    getCellAppearance(cell, dest) {\n        dest.blackOut();\n        const isVisible = true; // this.fov.isAnyKindOfVisible(x, y);\n        const isRevealed = true; // this.fov.isRevealed(x, y);\n        const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (needSnapshot || (cell.needsRedraw && isVisible)) {\n            this.layers.forEach((layer) => layer.putAppearance(dest, cell));\n            if (dest.dances) {\n                cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n            }\n            else {\n                cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n            }\n            dest.bake();\n            cell.putSnapshot(dest);\n            cell.needsRedraw = false;\n            cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n        else {\n            cell.getSnapshot(dest);\n        }\n        if (isVisible) {\n            const light = this.light.getLight(cell.x, cell.y);\n            dest.multiply(light);\n        }\n        else if (isRevealed) {\n            dest.scale(50);\n        }\n        else {\n            dest.blackOut();\n        }\n        if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n            GWU.color.separate(dest.fg, dest.bg);\n        }\n    }\n    getAppearanceAt(x, y, dest) {\n        const cell = this.cell(x, y);\n        return this.getCellAppearance(cell, dest);\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            // cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(_cb) {\n        // TODO !!\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    onCellRevealed(_x, _y) {\n        // if (DATA.automationActive) {\n        // if (cell.item) {\n        //     const theItem: GW.types.ItemType = cell.item;\n        //     if (\n        //         theItem.hasObjectFlag(ObjectFlags.L_INTERRUPT_WHEN_SEEN)\n        //     ) {\n        //         GW.message.add(\n        //             '§you§ §see§ ΩitemMessageColorΩ§item§∆.',\n        //             {\n        //                 item: theItem,\n        //                 actor: DATA.player,\n        //             }\n        //         );\n        //     }\n        // }\n        // if (\n        //     !(this.fov.isMagicMapped(x, y)) &&\n        //     this.site.hasObjectFlag(\n        //         x,\n        //         y,\n        //         ObjectFlags.L_INTERRUPT_WHEN_SEEN\n        //     )\n        // ) {\n        //     const tile = cell.tileWithLayerFlag(\n        //         ObjectFlags.L_INTERRUPT_WHEN_SEEN\n        //     );\n        //     if (tile) {\n        //         GW.message.add(\n        //             '§you§ §see§ ΩbackgroundMessageColorΩ§item§∆.',\n        //             {\n        //                 actor: DATA.player,\n        //                 item: tile.name,\n        //             }\n        //         );\n        //     }\n        // }\n    }\n    redrawCell(x, y) {\n        // if (clearMemory) {\n        //     this.clearMemory(x, y);\n        // }\n        this.cell(x, y).needsRedraw = true;\n    }\n}\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n        map.light.update();\n    }\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    // // In case we reveal the map or make it all visible we need our memory set correctly\n    // map.cells.forEach((_c, x, y) => {\n    //     if (map.fov.isRevealed(x, y)) {\n    //         map.storeMemory(x, y, true); // with snapshot\n    //     }\n    // });\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount = cellCount;\n                                            map.cell(i2, j2).flags.cell &= ~Flags.Cell\n                                                .IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        this.layerVersion = [];\n        this.lightVersion = 0;\n        // fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        // if (this.map.fov.changed) {\n        //     this.fovVersion = this.version;\n        //     this.map.fov.changed = false;\n        // }\n        // if (snap.version !== this.fovVersion) {\n        //     snap.map.fov.copy(this.map.fov);\n        // }\n        // layers\n        this.map.layers.forEach((layer, index) => {\n            const snapLayer = snap.map.layers[index];\n            if (layer.changed) {\n                this.layerVersion[index] = this.version;\n            }\n            if (this.layerVersion[index] !== snap.version) {\n                snapLayer.copy(layer);\n            }\n        });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        // if (snap.version < this.fovVersion || this.map.fov.changed) {\n        //     this.map.fov.copy(snap.map.fov);\n        //     this.fovVersion = snap.version;\n        // }\n        // layers\n        this.layerVersion.forEach((v, index) => {\n            if (v < snap.version)\n                return;\n            const destLayer = this.map.layers[index];\n            if (v > snap.version || destLayer.changed) {\n                const srcLayer = snap.map.layers[index];\n                destLayer.copy(srcLayer);\n                this.layerVersion[index] = snap.version;\n            }\n        });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function isHallway(map, x, y) {\n    return (GWU.xy.arcCount(x, y, (i, j) => {\n        return map.cell(i, j).isPassable();\n    }) > 1);\n}\n","import * as GWU from 'gw-utils';\nexport function getCellPathCost(map, x, y) {\n    const cell = map.cell(x, y);\n    if (cell.blocksMove())\n        return GWU.path.OBSTRUCTION;\n    if (cell.blocksPathing())\n        return GWU.path.FORBIDDEN;\n    if (cell.hasActor())\n        return 10;\n    return 1;\n}\nexport function fillCostMap(map, costMap) {\n    costMap.update((_v, x, y) => getCellPathCost(map, x, y));\n}\nexport function getPathBetween(map, x0, y0, x1, y1, options = {}) {\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = GWU.grid.alloc(map.width, map.height);\n    fillCostMap(map, costMap);\n    GWU.path.calculateDistances(distanceMap, x0, y0, costMap, options.eightWays, GWU.xy.straightDistanceBetween(x0, y0, x1, y1) + 1);\n    const path = GWU.path.getPath(distanceMap, x1, y1, (x, y) => map.cell(x, y).blocksMove(), options.eightWays);\n    GWU.grid.free(costMap);\n    GWU.grid.free(distanceMap);\n    return path;\n}\n","import * as GWU from 'gw-utils';\nimport { Horde as Flags } from '../flags/horde';\nimport * as Map from '../map';\nimport * as Actor from '../actor';\nexport class Horde {\n    // requiredTile: string | null = null;\n    constructor(config) {\n        this.tags = [];\n        this.members = {};\n        // blueprintId: string | null = null;\n        this.flags = { horde: 0 };\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        this.leader = config.leader;\n        if (config.members) {\n            Object.entries(config.members).forEach(([id, range]) => {\n                this.members[id] = GWU.range.make(range);\n            });\n        }\n        this.frequency = GWU.frequency.make(config.frequency || 100);\n        // this.blueprintId = config.blueprintId || null;\n        this.flags.horde = GWU.flag.from(Flags, config.flags);\n        // if (config.requiredTile) this.requiredTile = config.requiredTile;\n    }\n    async spawn(map, x = -1, y = -1, opts = {}) {\n        var _a;\n        opts.canSpawn = opts.canSpawn || GWU.TRUE;\n        opts.rng = opts.rng || map.rng;\n        opts.machine = (_a = opts.machine) !== null && _a !== void 0 ? _a : 0;\n        const leader = await this._spawnLeader(map, x, y, opts);\n        if (!leader)\n            return null;\n        await this._spawnMembers(leader, map, opts);\n        return leader;\n    }\n    async _spawnLeader(map, x, y, opts) {\n        const leaderKind = Actor.get(this.leader);\n        if (!leaderKind) {\n            throw new Error('Failed to find leader kind = ' + this.leader);\n        }\n        if (x >= 0 && y >= 0) {\n            if (leaderKind.avoidsCell(map.cell(x, y)))\n                return null;\n        }\n        const leader = Actor.make(leaderKind, { machineHome: opts.machine });\n        if (!leader)\n            throw new Error('Failed to make horde leader - ' + this.leader);\n        if (x < 0 || y < 0) {\n            [x, y] = this._pickLeaderLoc(leader, map, opts) || [-1, -1];\n            if (x < 0 || y < 0) {\n                return null;\n            }\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!(await this._addLeader(leader, map, x, y, opts))) {\n            return null;\n        }\n        return leader;\n    }\n    async _addLeader(leader, map, x, y, _opts) {\n        return map.addActor(x, y, leader);\n    }\n    async _addMember(member, map, x, y, leader, _opts) {\n        member.leader = leader;\n        return map.addActor(x, y, member);\n    }\n    async _spawnMembers(leader, map, opts) {\n        const entries = Object.entries(this.members);\n        if (entries.length == 0)\n            return 0;\n        let count = 0;\n        await Promise.all(entries.map(async ([kindId, countRange]) => {\n            const count = countRange.value(opts.rng);\n            for (let i = 0; i < count; ++i) {\n                await this._spawnMember(kindId, map, leader, opts);\n            }\n        }));\n        return count;\n    }\n    async _spawnMember(kindId, map, leader, opts) {\n        const kind = Actor.get(kindId);\n        if (!kind) {\n            throw new Error('Failed to find member kind = ' + kindId);\n        }\n        const member = Actor.make(kind, { machineHome: opts.machine });\n        if (!member)\n            throw new Error('Failed to make horde member - ' + kindId);\n        const [x, y] = this._pickMemberLoc(member, map, leader, opts) || [\n            -1,\n            -1,\n        ];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!(await this._addMember(member, map, x, y, leader, opts))) {\n            return null;\n        }\n        return member;\n    }\n    _pickLeaderLoc(leader, map, opts) {\n        let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            if (!opts.canSpawn(x, y))\n                return false;\n            if (leader.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n    _pickMemberLoc(actor, map, leader, opts) {\n        let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Horde } from './horde';\nimport { Horde as Flags } from '../flags/horde';\nexport const hordes = {};\nexport function install(id, horde) {\n    if (typeof horde === 'string') {\n        horde = { leader: horde };\n    }\n    if (!(horde instanceof Horde)) {\n        horde = new Horde(horde);\n    }\n    hordes[id] = horde;\n    return horde;\n}\nexport function installAll(hordes) {\n    Object.entries(hordes).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function from(id) {\n    if (id instanceof Horde) {\n        return id;\n    }\n    if (typeof id === 'string') {\n        return hordes[id];\n    }\n    return new Horde(id);\n}\nexport function random(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n        flags: 0,\n        forbidFlags: 0,\n        depth: 0,\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    const rng = opts.rng || GWU.rng.random;\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    if (opts.flags) {\n        if (typeof opts.flags === 'string') {\n            opts.flags\n                .split(/[,|]/)\n                .map((t) => t.trim())\n                .forEach((flag) => {\n                if (flag.startsWith('!')) {\n                    const key = flag.substring(1);\n                    match.forbidFlags |= Flags[key];\n                }\n                else {\n                    match.flags |= Flags[flag];\n                }\n            });\n        }\n    }\n    if (opts.forbidFlags) {\n        match.forbidFlags = GWU.flag.from(Flags, opts.forbidFlags);\n    }\n    if (opts.depth) {\n        match.depth = opts.depth;\n    }\n    if (match.depth && opts.oodChance) {\n        while (rng.chance(opts.oodChance)) {\n            match.depth += 1;\n        }\n        match.forbidFlags |= Flags.HORDE_NEVER_OOD;\n    }\n    const matches = Object.values(hordes).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        if (match.flags && !(k.flags.horde & match.flags)) {\n            return false;\n        }\n        if (match.forbidFlags && k.flags.horde & match.forbidFlags) {\n            return false;\n        }\n        return true;\n    });\n    if (match.depth) {\n        return rng.item(matches) || null;\n    }\n    const depth = match.depth;\n    const weights = matches.map((h) => h.frequency(depth));\n    const index = rng.weighted(weights);\n    if (index < 0)\n        return null;\n    return matches[index];\n}\n","import * as GWU from 'gw-utils';\nimport { Map } from '../map/map';\nimport * as Flags from '../flags';\nexport class Memory extends Map {\n    constructor(map) {\n        super(map.width, map.height);\n        // this.actor = actor;\n        this.source = map;\n        this.cells.forEach((c) => c.setCellFlag(Flags.Cell.STABLE_MEMORY));\n    }\n    cell(x, y) {\n        let cell = this.cells[x][y];\n        if (!cell.hasCellFlag(Flags.Cell.STABLE_MEMORY)) {\n            cell = this.source.cell(x, y);\n        }\n        return cell;\n    }\n    memory(x, y) {\n        return this.cells[x][y];\n    }\n    isMemory(x, y) {\n        return this.cells[x][y].hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    setTile() {\n        throw new Error('Cannot set tiles on memory.');\n    }\n    async addItem() {\n        throw new Error('Cannot add Items to memory!');\n    }\n    forceItem() {\n        throw new Error('Cannot force Items in memory!');\n    }\n    async removeItem() {\n        throw new Error('Cannot remove Items from memory!');\n    }\n    async moveItem() {\n        throw new Error('Cannot move Items on memory!');\n    }\n    eachItem(cb) {\n        this.source.eachItem((i) => {\n            if (!this.isMemory(i.x, i.y)) {\n                cb(i);\n                const i2 = this.items.find((other) => other.id == i.id);\n                if (i2) {\n                    const mem = this.cell(i2.x, i2.y);\n                    mem.clearCellFlag(Flags.Cell.HAS_ITEM | Flags.Cell.STABLE_SNAPSHOT);\n                    GWU.arrayDelete(this.items, i2);\n                }\n            }\n        });\n        this.items.forEach(cb);\n    }\n    async addActor() {\n        throw new Error('Cannot add Actors to memory!');\n    }\n    forceActor() {\n        throw new Error('Cannot force Actors in memory!');\n    }\n    async removeActor() {\n        throw new Error('Cannot remove Actors from memory!');\n    }\n    async moveActor() {\n        throw new Error('Cannot move Actors on memory!');\n    }\n    eachActor(cb) {\n        this.source.eachActor((a) => {\n            if (!this.isMemory(a.x, a.y)) {\n                cb(a);\n                const a2 = this.actors.find((other) => other.id == a.id);\n                if (a2) {\n                    const mem = this.cell(a2.x, a2.y);\n                    mem.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.STABLE_SNAPSHOT);\n                    GWU.arrayDelete(this.actors, a2);\n                }\n            }\n        });\n        this.actors.forEach(cb);\n    }\n    storeMemory(x, y) {\n        const mem = this.memory(x, y);\n        // cleanup any old items+actors\n        if (mem.hasItem()) {\n            this.items = this.items.filter((i) => i.x !== x || i.y !== y);\n        }\n        if (mem.hasActor()) {\n            this.actors = this.actors.filter((a) => a.x !== x || a.y !== y);\n        }\n        const cell = this.source.cell(x, y);\n        mem.copy(cell);\n        mem.setCellFlag(Flags.Cell.STABLE_MEMORY);\n        // add any current items+actors\n        if (cell.hasItem()) {\n            const item = this.source.itemAt(x, y);\n            if (item) {\n                this.items.push(item.clone());\n            }\n        }\n        if (cell.hasActor()) {\n            const actor = this.source.actorAt(x, y);\n            if (actor) {\n                this.actors.push(actor.clone());\n            }\n        }\n    }\n    forget(x, y) {\n        const mem = this.memory(x, y);\n        // cleanup any old items+actors\n        if (mem.hasItem()) {\n            this.items = this.items.filter((i) => i.x !== x || i.y !== y);\n        }\n        if (mem.hasActor()) {\n            this.actors = this.actors.filter((a) => a.x !== x || a.y !== y);\n        }\n        mem.clearCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    onFovChange(x, y, isVisible) {\n        if (!isVisible) {\n            this.storeMemory(x, y);\n        }\n        else {\n            this.forget(x, y);\n        }\n    }\n}\n","import { Memory } from './memory';\nconst cache = {};\nexport function store(actor, map, memory) {\n    let actorMemory = cache[actor.id];\n    if (!actorMemory) {\n        cache[actor.id] = actorMemory = {};\n    }\n    actorMemory[map.id] = memory;\n}\nexport function get(actor, map) {\n    let actorMemory = cache[actor.id];\n    if (actorMemory) {\n        const memory = actorMemory[map.id];\n        if (memory)\n            return memory;\n    }\n    return new Memory(map);\n}\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","TileMech","Cell","NEEDS_REDRAW","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_TRAP_FREE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Horde","KeyInfo","[object Object]","x","y","disposable","this","lastId","kind","map","key","machineHome","depth","light","flags","entity","next","id","sprite","isDestroyed","hasEntityFlag","Flags.Entity","L_DESTROYED","other","constructor","copy","Object","assign","canBeSeen","tag","tags","includes","matches","cell","forbidsCell","avoidsCell","opts","getName","getDescription","getFlavor","verb","getVerb","sidebar","drawStatus","name","EntityKind","config","requiredTileTags","flavor","description","make","split","t","trim","slice","init","_entity","length","hasAllTileTags","hasAnyTileTag","_opts","getAppearanceAt","mixer","drawTitle","Entity.Entity","super","leader","items","fov","actor","Flags.Depth","ACTOR","hasActorFlag","Flags.Actor","IS_PLAYER","canSee","isAbleToSee","isDirectlyVisible","xy","forLineBetween","i","j","blocksVision","canSeeOrSense","isAbleToSense","isAnyKindOfVisible","item","pickupItem","dropItem","ActorKind","Entity.EntityKind","options","_actor","blocksMove","blocksPathing","isPlayer","action","list","push","remove","makeOptions","get","Error","kinds","makeKind","info","randomKind","match","forbidTags","forEach","startsWith","substring","Array","isArray","values","filter","k","arraysIntersect","rng","random","JSON","stringify","made","quantity","ITEM","ItemKind","Handler","src","dest","ctx","handlers","installHandler","handler","_a","fn","from","Flags","chance","v","effect","effects","reset","E_FIRED","install","_b","_c","_d","index","dissipate","priority","groundTile","article","tile","tileMech","hasEffect","Flags.Tile","T_IS_FLAMMABLE","every","hasTileFlag","T_PATHING_BLOCKER","arg","color","result","fg","toString","_e","_f","base","extends","tiles","text","replace","search","Number","parseInt","delta","undefined","entries","value","makeEffect","Flags.TileMech","ch","bg","opacity","all","args","enter","open","tick","close","player","emit","MapLayer","changed","properties","_other","_x","_y","_tile","_item","_dt","_dest","_cell","TileLayer","current","depthTile","Tile.tiles","NULL","superpriority","blocksLayer","blockedByItems","hasItem","blockedByActors","hasActor","blockedByOtherLayers","highestPriority","GROUND","ground","setTile","Tile.get","clearDepth","SURFACE","machine","machineId","glowLightChanged","L_LIST_IN_SIDEBAR","setMapFlag","Flags.Map","MAP_SIDEBAR_TILES_CHANGED","setCellFlag","Flags.Cell","CAUGHT_FIRE_THIS_TURN","width","height","hasCellFlag","clearCellFlag","hasKey","fire","drawSprite","ActorLayer","actors","obj","addActor","removeActor","actorAt","ItemLayer","addItem","removeItem","destroy","hasXY","itemAt","GasLayer","volume","grid","alloc","fill","startingVolume","spread","free","update","d","Math","max","clearTile","floor","min","total","count","highestVolume","startingTile","highestTile","needsRedraw","updateCellVolume","calcOpacity","async","ctx_","force","didSomething","allHandlers","h","E_NEXT_ALWAYS","data","gameHasEnded","nextInfo","E_NEXT_EVERYWHERE","forEachAsync","E_NO_MARK_FIRED","EmitEffect","_map","events","FnEffect","MessageEffect","message","fired","addAt","ActivateMachineEffect","activateMachine","EffectEffect","FIRE.fire","SpawnEffect","_g","parts","p","grow","decrement","Flags.Effect","matchTile","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","isBlocking","E_PERMIT_BLOCKING","E_TREAT_AS_BLOCKING","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","spawnTiles","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","isStairs","first","floodFill","spawnMap","accomplishedSomething","E_BLOCKED_BY_OTHER_LAYERS","E_SUPERPRIORITY","hasTile","EVENT_FIRED_THIS_TURN","E_PROTECTED","EVENT_PROTECTED","MAP_CHANGED","cellIsOk","isStart","blocksEffects","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","ok","eachNeighbor","E_NO_TOUCH_WALLS","dir","x2","y2","madeChange","startProb","probDec","DIRS","clearAll","clear","GAS","LIQUID","blockingMap","eachActor","a","loc","matchingLocNear","c","forceActor","eachItem","forceItem","layers","ALL_LAYERS","reduce","out","fireSync","_ctx","e","ObjectFlags","TileFlags","TileMechFlags","CellFlags","FireLayer","exposeToFire","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","Effect.from","hasTileMechFlag","TM_EXPLOSIVE_PROMOTE","x0","y0","n","event","chokeCount","TILE.tiles","snapshot","makeMixer","TILE.get","hasStableSnapshot","STABLE_SNAPSHOT","hasStableMemory","getSnapshot","some","entityFlags","tileFlags","tileMechFlags","hasTag","hasAllTags","hasAnyTag","CHANGED","TILE.Tile","highestPriorityTile","cb","find","TILE.flags","T_BLOCKS_OTHER_LAYERS","hasAllEntityFlags","L_BLOCKS_EVERYTHING","L_SECRETLY_PASSABLE","blackOut","tileFlag","tileMechFlag","ev","_activate","Effect.effects","Effect.fire","hasItems","foundIndex","splice","machineCount","_seed","cells","seed","LightSystem","initLayers","addLayer","Layer.TileLayer","Layer.FireLayer","Layer.GasLayer","Layer.ItemLayer","Layer.ActorLayer","layer","isAt","oldX","oldY","hasPlayer","isKey","fmt","log","console","Mixer","dump","l","boundary","isBoundaryXY","clearTiles","dt","fireAll","willFire","promoteChance","w","originX","originY","buffer","canvas","Canvas","putAppearance","dances","COLORS_DANCE","bake","putSnapshot","getLight","multiply","L_VISUALLY_DISTINCT","separate","getCellAppearance","eachGlowLight","_cb","isDark","updateChokepoints","updateCounts","passMap","passableArcCount","CLOCK_DIRS","newX","newY","cellCount","floodFillCount","i2","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","eachCell","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","up","left","designationSurvives","Snapshot","version","isHallway","arcCount","isPassable","prefab","charToTile","isStringArray","len","line","updateChokeCounts","layerVersion","lightVersion","cellVersion","snap","srcCell","snapLayer","destCell","destLayer","srcLayer","getCellPathCost","path","OBSTRUCTION","FORBIDDEN","fillCostMap","costMap","_v","x1","y1","distanceMap","calculateDistances","eightWays","straightDistanceBetween","getPath","members","horde","range","frequency","canSpawn","TRUE","_spawnLeader","_spawnMembers","leaderKind","Actor.get","Actor.make","_pickLeaderLoc","_addLeader","member","Promise","kindId","countRange","_spawnMember","_pickMemberLoc","_addMember","matchingLoc","Map.isHallway","hordes","forbidFlags","oodChance","HORDE_NEVER_OOD","weights","weighted","Memory","source","isMemory","arrayDelete","a2","mem","memory","clone","isVisible","forget","storeMemory","cache","actorMemory"],"mappings":"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"}