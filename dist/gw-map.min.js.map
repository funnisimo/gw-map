{"version":3,"file":"gw-map.min.js","sources":["../js/gameObject/flags.js","../js/gameObject/gameObject.js","../js/actor/flags.js","../js/actor/index.js","../js/item/index.js","../js/tile/flags.js","../js/effect/flags.js","../js/effect/make.js","../js/effect/effect.js","../js/effect/fire.js","../js/effect/message.js","../js/effect/emit.js","../js/effect/fn.js","../js/effect/activateMachine.js","../js/tile/tile.js","../js/tile/tiles.js","../js/tile/index.js","../js/map/flags.js","../js/map/cell.js","../js/map/layers.js","../js/map/cellMemory.js","../js/map/fireLayer.js","../js/map/gasLayer.js","../js/map/map.js","../js/map/analyze.js","../js/map/effect.js","../js/map/index.js"],"sourcesContent":["import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var GameObject;\n(function (GameObject) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    GameObject[GameObject[\"L_SUPERPRIORITY\"] = Fl(1)] = \"L_SUPERPRIORITY\";\n    GameObject[GameObject[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    GameObject[GameObject[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    GameObject[GameObject[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    GameObject[GameObject[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    GameObject[GameObject[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    GameObject[GameObject[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    GameObject[GameObject[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    GameObject[GameObject[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    GameObject[GameObject[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    GameObject[GameObject[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    GameObject[GameObject[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    GameObject[GameObject[\"L_LIST_IN_SIDEBAR\"] = Fl(13)] = \"L_LIST_IN_SIDEBAR\";\n    GameObject[GameObject[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    GameObject[GameObject[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    GameObject[GameObject[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    GameObject[GameObject[\"L_BLOCKED_BY_STAIRS\"] = GameObject.L_BLOCKS_ITEMS |\n        GameObject.L_BLOCKS_SURFACE |\n        GameObject.L_BLOCKS_GAS |\n        GameObject.L_BLOCKS_LIQUID |\n        GameObject.L_BLOCKS_EFFECTS |\n        GameObject.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    GameObject[GameObject[\"L_BLOCKS_SCENT\"] = GameObject.L_BLOCKS_MOVE | GameObject.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    GameObject[GameObject[\"L_DIVIDES_LEVEL\"] = GameObject.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    GameObject[GameObject[\"L_WAYPOINT_BLOCKER\"] = GameObject.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    GameObject[GameObject[\"L_WALL_FLAGS\"] = GameObject.L_BLOCKS_MOVE |\n        GameObject.L_BLOCKS_VISION |\n        GameObject.L_BLOCKS_LIQUID |\n        GameObject.L_BLOCKS_GAS |\n        GameObject.L_BLOCKS_EFFECTS |\n        GameObject.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    GameObject[GameObject[\"L_BLOCKS_EVERYTHING\"] = GameObject.L_WALL_FLAGS |\n        GameObject.L_BLOCKS_ITEMS |\n        GameObject.L_BLOCKS_ACTORS |\n        GameObject.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(GameObject || (GameObject = {}));\nexport var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nimport * as Flags from './flags';\nexport class GameObject {\n    constructor() {\n        this.sprite = new GWU.sprite.Sprite();\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { object: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n    }\n    hasObjectFlag(flag) {\n        return !!(this.flags.object & flag);\n    }\n    hasAllObjectFlags(flags) {\n        return (this.flags.object & flags) === flags;\n    }\n    blocksMove() {\n        return this.hasObjectFlag(Flags.GameObject.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasObjectFlag(Flags.GameObject.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasObjectFlag(Flags.GameObject.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasObjectFlag(Flags.GameObject.L_BLOCKS_EFFECTS);\n    }\n    itemFlags() {\n        return 0;\n    }\n    actorFlags() {\n        return 0;\n    }\n}\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport { GameObject, Depth } from '../gameObject/flags';\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n})(Actor || (Actor = {}));\n","import { GameObject } from '../gameObject';\nimport * as Flags from './flags';\nimport * as flags_1 from './flags';\nexport { flags_1 as flags };\nexport class Actor extends GameObject {\n    constructor() {\n        super();\n        this.next = null;\n        // @ts-ignore\n        this.flags = this.flags || {};\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    isVisible() {\n        return true;\n    }\n    forbidsCell(_cell) {\n        return false;\n    }\n}\n","import { GameObject } from '../gameObject';\nimport { Depth } from '../gameObject/flags';\nexport class Item extends GameObject {\n    constructor() {\n        super();\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore\n        this.flags = this.flags || {};\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n    forbidsCell(_cell) {\n        return false;\n    }\n}\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n})(Tile || (Tile = {}));\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_SPREAD_CIRCLE\"] = Fl(13)] = \"E_SPREAD_CIRCLE\";\n    Effect[Effect[\"E_SPREAD_LINE\"] = Fl(14)] = \"E_SPREAD_LINE\";\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nimport { Effect as Flags } from './flags';\nimport { handlers, effects } from './effect';\nexport function make(opts) {\n    var _a;\n    if (!opts)\n        throw new Error('opts required to make effect.');\n    if (typeof opts === 'string') {\n        throw new Error('Cannot make effect from string: ' + opts);\n    }\n    if (typeof opts === 'function') {\n        opts = { fn: opts };\n    }\n    // now make base effect stuff\n    const info = {\n        flags: GWU.flag.from(Flags, opts.flags),\n        chance: (_a = opts.chance) !== null && _a !== void 0 ? _a : 0,\n        next: null,\n        id: opts.id || 'n/a',\n    };\n    if (opts.next) {\n        if (typeof opts.next === 'string') {\n            info.next = opts.next;\n        }\n        else {\n            info.next = make(opts.next);\n        }\n    }\n    // and all the handlers\n    Object.values(handlers).forEach((v) => v.make(opts, info));\n    return info;\n}\nexport function from(opts) {\n    if (!opts)\n        throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'string') {\n        const effect = effects[opts];\n        if (effect)\n            return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\n","import { Effect as Flags } from './flags';\nimport { make } from './make';\n// resetMessageDisplayed\nexport function reset(effect) {\n    effect.flags &= ~Flags.E_FIRED;\n}\nexport function resetAll() {\n    Object.values(effects).forEach((e) => reset(e));\n}\nexport const effects = {};\nexport function install(id, config) {\n    const effect = make(config);\n    effects[id] = effect;\n    effect.id = id;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id] = handler;\n}\n","import * as GWU from 'gw-utils';\nimport { Effect as Flags } from './flags';\nimport { handlers } from './effect';\nimport { from } from './make';\nexport async function fire(effect, map, x, y, ctx_ = {}) {\n    if (!effect)\n        return false;\n    if (typeof effect === 'string') {\n        const name = effect;\n        effect = from(name);\n        if (!effect)\n            throw new Error('Failed to find effect: ' + name);\n    }\n    const ctx = ctx_;\n    if (!ctx.force && effect.chance && !GWU.random.chance(effect.chance, 10000))\n        return false;\n    const grid = (ctx.grid = GWU.grid.alloc(map.width, map.height));\n    let didSomething = true;\n    const allHandlers = Object.values(handlers);\n    for (let h of allHandlers) {\n        if (await h.fire(effect, map, x, y, ctx)) {\n            didSomething = true;\n        }\n    }\n    // bookkeeping\n    if (didSomething &&\n        map.isVisible(x, y) &&\n        !(effect.flags & Flags.E_NO_MARK_FIRED)) {\n        effect.flags |= Flags.E_FIRED;\n    }\n    // do the next effect - if applicable\n    if (effect.next &&\n        (didSomething || effect.flags & Flags.E_NEXT_ALWAYS) &&\n        !GWU.data.gameHasEnded) {\n        const nextInfo = typeof effect.next === 'string' ? from(effect.next) : effect.next;\n        if (effect.flags & Flags.E_NEXT_EVERYWHERE) {\n            await grid.forEachAsync(async (v, i, j) => {\n                if (!v)\n                    return;\n                // @ts-ignore\n                await fire(nextInfo, map, i, j, ctx);\n            });\n        }\n        else {\n            await fire(nextInfo, map, x, y, ctx);\n        }\n    }\n    GWU.grid.free(grid);\n    return didSomething;\n}\nexport function fireSync(effect, map, x, y, ctx_ = {}) {\n    if (!effect)\n        return false;\n    if (typeof effect === 'string') {\n        const name = effect;\n        effect = from(name);\n        if (!effect)\n            throw new Error('Failed to find effect: ' + name);\n    }\n    const ctx = ctx_;\n    if (!ctx.force && effect.chance && !GWU.random.chance(effect.chance, 10000))\n        return false;\n    const grid = (ctx.grid = GWU.grid.alloc(map.width, map.height));\n    let didSomething = true;\n    const allHandlers = Object.values(handlers);\n    for (let h of allHandlers) {\n        if (h.fireSync(effect, map, x, y, ctx)) {\n            didSomething = true;\n        }\n    }\n    // bookkeeping\n    if (didSomething &&\n        map.isVisible(x, y) &&\n        !(effect.flags & Flags.E_NO_MARK_FIRED)) {\n        effect.flags |= Flags.E_FIRED;\n    }\n    // do the next effect - if applicable\n    if (effect.next &&\n        (didSomething || effect.flags & Flags.E_NEXT_ALWAYS) &&\n        !GWU.data.gameHasEnded) {\n        const nextInfo = typeof effect.next === 'string' ? from(effect.next) : effect.next;\n        if (effect.flags & Flags.E_NEXT_EVERYWHERE) {\n            grid.forEach(async (v, i, j) => {\n                if (!v)\n                    return;\n                fireSync(nextInfo, map, i, j, ctx);\n            });\n        }\n        else {\n            fireSync(nextInfo, map, x, y, ctx);\n        }\n    }\n    GWU.grid.free(grid);\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport * as EFFECT from './effect';\nimport { Effect as Flags } from './flags';\n//////////////////////////////////////////////\n// MESSAGE\nexport class MessageEffect {\n    make(src, dest) {\n        if (!src.message)\n            return true;\n        if (typeof src.message !== 'string') {\n            throw new Error('Emit must be configured with name of event to emit');\n        }\n        dest.message = src.message;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (!config.message)\n            return false;\n        const fired = !!(config.flags & Flags.E_FIRED);\n        if (config.message &&\n            config.message.length &&\n            !fired &&\n            map.isVisible(x, y)) {\n            GWU.message.addAt(x, y, config.message, ctx);\n            return true;\n        }\n        return false;\n    }\n    fireSync(config, _map, _x, _y, _ctx) {\n        if (!config.message)\n            return false;\n        throw new Error('Cannot use \"message\" effects in build steps.');\n    }\n}\nEFFECT.installHandler('message', new MessageEffect());\n","import * as GWU from 'gw-utils';\nimport * as EFFECT from './effect';\n//////////////////////////////////////////////\n// EMIT\nexport class EmitEffect {\n    make(src, dest) {\n        if (!src.emit)\n            return true;\n        if (typeof src.emit !== 'string') {\n            throw new Error('emit effects must be string name to emit: { emit: \"EVENT\" }');\n        }\n        dest.emit = src.emit;\n        return true;\n    }\n    async fire(config, _map, x, y, ctx) {\n        if (config.emit) {\n            return await GWU.events.emit(config.emit, x, y, ctx);\n        }\n        return false;\n    }\n    fireSync(config, _map, _x, _y, _ctx) {\n        if (!config.emit)\n            return false;\n        throw new Error('Cannot use \"emit\" effects in build steps.');\n    }\n}\nEFFECT.installHandler('emit', new EmitEffect());\n","import * as EFFECT from './effect';\n//////////////////////////////////////////////\n// FN\nexport class FnEffect {\n    make(src, dest) {\n        if (!src.fn)\n            return true;\n        if (typeof src.fn !== 'function') {\n            throw new Error('fn effects must be functions.');\n        }\n        dest.fn = src.fn;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.fn) {\n            return await config.fn(config, map, x, y, ctx);\n        }\n        return false;\n    }\n    fireSync(config, map, x, y, ctx) {\n        if (config.fn) {\n            const result = config.fn(config, map, x, y, ctx);\n            if (result === true || result === false) {\n                return result;\n            }\n            throw new Error('Cannot use async function effects in build steps.');\n        }\n        return false;\n    }\n}\nEFFECT.installHandler('fn', new FnEffect());\n","import * as EFFECT from './effect';\n//////////////////////////////////////////////\n// ActivateMachine\nexport class ActivateMachineEffect {\n    make(src, dest) {\n        if (!src.activateMachine)\n            return true;\n        dest.activateMachine = true;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.activateMachine) {\n            const cell = map.cell(x, y);\n            const machine = cell.machineId;\n            if (!machine)\n                return false;\n            return await map.activateMachine(machine, x, y, ctx);\n        }\n        return false;\n    }\n    fireSync(config, map, x, y, ctx) {\n        if (config.activateMachine) {\n            const cell = map.cell(x, y);\n            const machine = cell.machineId;\n            if (!machine)\n                return false;\n            return map.activateMachineSync(machine, x, y, ctx);\n        }\n        return false;\n    }\n}\nEFFECT.installHandler('activateMachine', new ActivateMachineEffect());\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nimport { Depth, GameObject as ObjectFlags, } from '../gameObject/flags';\nimport * as Flags from './flags';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.effects = {};\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { object: 0, tile: 0, tileMech: 0 };\n        if (config.effects) {\n            Object.assign(this.effects, config.effects);\n        }\n        if (this.hasEffect('fire')) {\n            this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n        }\n    }\n    hasObjectFlag(flag) {\n        return !!(this.flags.object & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllObjectFlags(flag) {\n        return (this.flags.object & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.object & ObjectFlags.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.object & ObjectFlags.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.object & ObjectFlags.L_BLOCKS_EFFECTS);\n    }\n    hasEffect(name) {\n        return name in this.effects;\n    }\n    getName(arg) {\n        let opts = {};\n        if (arg === true || arg === false) {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription() {\n        return this.description || this.getName();\n    }\n    getFlavor() {\n        return this.flavor || this.getName();\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { effects: {}, flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = -1;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const effects = {};\n    Object.assign(effects, base.effects);\n    if (options.effects) {\n        Object.entries(options.effects).forEach(([key, value]) => {\n            if (value === null) {\n                delete effects[key];\n                return;\n            }\n            if (typeof value === 'string') {\n                effects[key] = value;\n                return;\n            }\n            effects[key] = Effect.make(value);\n        });\n    }\n    const flags = {\n        object: GWU.flag.from(ObjectFlags, base.flags.object, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        effects,\n        priority: priority != -1 ? priority : undefined,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n    };\n    const tile = new Tile(config);\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import * as Tile from './tile';\n// These are the minimal set of tiles to make the diggers work\nTile.install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: [30, 30, 30, 20, 0, 0, 0],\n    bg: [2, 2, 10, 0, 2, 2, 0],\n    priority: 10,\n    article: 'the',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: { tile: 'DOOR_OPEN' },\n        open: { tile: 'DOOR_OPEN_ALWAYS' },\n    },\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            tile: 'DOOR',\n            flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY',\n        },\n        enter: null,\n        open: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n});\nTile.install('UP_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'upward staircase',\n    article: 'an',\n    effects: {\n        player: { emit: 'UP_STAIRS' },\n    },\n});\nTile.install('DOWN_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'downward staircase',\n    article: 'a',\n    effects: {\n        player: { emit: 'DOWN_STAIRS' },\n    },\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'an impregnable wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: [5, 8, 20, 10, 0, 4, 15, true],\n    bg: [10, 15, 41, 6, 5, 5, 5, true],\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: [5, 8, 10, 10, 0, 4, 15, true],\n    bg: [10, 30, 30, 6, 0, 10, 10, true],\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    depth: 'SURFACE', // 'LIQUID'?\n});\nTile.install('BRIDGE', {\n    ch: '=',\n    fg: [100, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n});\n","import { Tile, TileMech } from './flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\nimport './tiles';\n","import * as GWU from 'gw-utils';\nexport { GameObject, Depth } from '../gameObject/flags';\nexport { Tile, TileMech } from '../tile/flags';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(0)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(1)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"KNOWN_TO_BE_TRAP_FREE\"] = Fl(2)] = \"KNOWN_TO_BE_TRAP_FREE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(11)] = \"IS_POWERED\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(12)] = \"IMPREGNABLE\";\n    // DARKENED = Fl(13), // magical blindness?\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(14)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"CELL_CHANGED\"] = Fl(15)] = \"CELL_CHANGED\";\n    // These are to help memory\n    Cell[Cell[\"HAS_SURFACE\"] = Fl(16)] = \"HAS_SURFACE\";\n    Cell[Cell[\"HAS_LIQUID\"] = Fl(17)] = \"HAS_LIQUID\";\n    Cell[Cell[\"HAS_GAS\"] = Fl(18)] = \"HAS_GAS\";\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(19)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(20)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(21)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(22)] = \"HAS_ITEM\";\n    Cell[Cell[\"IS_IN_PATH\"] = Fl(23)] = \"IS_IN_PATH\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(24)] = \"IS_CURSOR\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(25)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_TRAP_FREE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW | Cell.CELL_CHANGED] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import { Cell as Flags, GameObject as ObjectFlags, Tile as TileFlags, } from './flags';\nimport * as TILE from '../tile';\nimport * as Effect from '../effect';\nclass CellObjects {\n    constructor(cell) {\n        this.cell = cell;\n    }\n    forEach(cb) {\n        let object = this.cell._item;\n        while (object) {\n            cb(object);\n            object = object.next;\n        }\n        object = this.cell._actor;\n        while (object) {\n            cb(object);\n            object = object.next;\n        }\n    }\n    some(cb) {\n        let object = this.cell._item;\n        while (object) {\n            if (cb(object))\n                return true;\n            object = object.next;\n        }\n        object = this.cell._actor;\n        while (object) {\n            if (cb(object))\n                return true;\n            object = object.next;\n        }\n        return false;\n    }\n    reduce(cb, start) {\n        let object = this.cell._item;\n        while (object) {\n            if (start === undefined) {\n                start = object;\n            }\n            else {\n                start = cb(start, object);\n            }\n            object = object.next;\n        }\n        object = this.cell._actor;\n        while (object) {\n            if (start === undefined) {\n                start = object;\n            }\n            else {\n                start = cb(start, object);\n            }\n            object = object.next;\n        }\n        return start;\n    }\n}\nexport class Cell {\n    constructor(groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        // gasVolume: number = 0;\n        // liquidVolume: number = 0;\n        this._actor = null;\n        this._item = null;\n        this._objects = new CellObjects(this);\n        this.flags = { cell: 0 };\n        this.tiles = [TILE.tiles.NULL];\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles = other.tiles.slice();\n        this._actor = other._actor;\n        this._item = other._item;\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasObjectFlag(flag) {\n        return (this.tiles.some((t) => t && t.flags.object & flag) ||\n            this._objects.some((o) => !!(o.flags.object & flag)));\n    }\n    hasAllObjectFlags(flags) {\n        return (this.objectFlags() & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    objectFlags() {\n        return (this.tiles.reduce((out, t) => out | (t ? t.flags.object : 0), 0) |\n            this._objects.reduce((out, o) => out | o.flags.object, 0));\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    itemFlags() {\n        return this._objects.reduce((out, o) => out | o.itemFlags(), 0);\n    }\n    actorFlags() {\n        return this._objects.reduce((out, o) => out | o.actorFlags(), 0);\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags.cell |= Flags.NEEDS_REDRAW;\n        }\n        else {\n            this.flags.cell &= ~Flags.NEEDS_REDRAW;\n        }\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.object & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return (this.tiles.some((t) => t && t.blocksVision()) ||\n            this._objects.some((o) => o.blocksVision()));\n    }\n    blocksPathing() {\n        return (this.tiles.some((t) => t && t.blocksPathing()) ||\n            this._objects.some((o) => o.blocksPathing()));\n    }\n    blocksMove() {\n        return (this.tiles.some((t) => t && t.blocksMove()) ||\n            this._objects.some((o) => o.blocksMove()));\n    }\n    blocksEffects() {\n        return (this.tiles.some((t) => t && t.blocksEffects()) ||\n            this._objects.some((o) => o.blocksEffects()));\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isEmpty() {\n        return (this.tiles.every((t) => !t || t === TILE.tiles.NULL) &&\n            this._actor == null &&\n            this._item == null);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllObjectFlags(ObjectFlags.L_WALL_FLAGS);\n    }\n    isStairs() {\n        return this.hasTileFlag(TileFlags.T_HAS_STAIRS);\n    }\n    hasKey() {\n        return false;\n    }\n    // @returns - whether or not the change results in a change to the cell lighting.\n    setTile(tile) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        // const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        // if (current !== tile) {\n        //     this.gasVolume = 0;\n        //     this.liquidVolume = 0;\n        // }\n        // Check priority, etc...\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clear() {\n        this.tiles = [TILE.tiles.NULL];\n        this.needsRedraw = true;\n        this.flags.cell = 0;\n        this.chokeCount = 0;\n        this._actor = null;\n        this._item = null;\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    async activate(event, map, x, y, ctx = {}) {\n        ctx.cell = this;\n        let didSomething = false;\n        if (ctx.depth !== undefined) {\n            const tile = (ctx.tile = this.depthTile(ctx.depth));\n            if (tile && tile.effects) {\n                const ev = tile.effects[event];\n                didSomething = await this._fire(ev, map, x, y, ctx);\n            }\n        }\n        else {\n            // console.log('fire event - %s', event);\n            for (ctx.tile of this.tiles) {\n                if (!ctx.tile || !ctx.tile.effects)\n                    continue;\n                const ev = ctx.tile.effects[event];\n                // console.log(' - ', ev);\n                if (await this._fire(ev, map, x, y, ctx)) {\n                    didSomething = true;\n                    break;\n                }\n                // }\n            }\n        }\n        return didSomething;\n    }\n    activateSync(event, map, x, y, ctx = {}) {\n        ctx.cell = this;\n        let didSomething = false;\n        if (ctx.depth !== undefined) {\n            const tile = (ctx.tile = this.depthTile(ctx.depth));\n            if (tile && tile.effects) {\n                const ev = tile.effects[event];\n                didSomething = this._fireSync(ev, map, x, y, ctx);\n            }\n        }\n        else {\n            // console.log('fire event - %s', event);\n            for (ctx.tile of this.tiles) {\n                if (!ctx.tile || !ctx.tile.effects)\n                    continue;\n                const ev = ctx.tile.effects[event];\n                // console.log(' - ', ev);\n                if (this._fireSync(ev, map, x, y, ctx)) {\n                    didSomething = true;\n                    break;\n                }\n                // }\n            }\n        }\n        return didSomething;\n    }\n    async _fire(effect, map, x, y, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.effects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = await Effect.fire(effect, map, x, y, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    _fireSync(effect, map, x, y, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.effects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = Effect.fireSync(effect, map, x, y, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.HAS_ITEM);\n    }\n    get item() {\n        return this._item;\n    }\n    set item(val) {\n        this._item = val;\n        if (val) {\n            this.setCellFlag(Flags.HAS_ITEM);\n        }\n        else {\n            this.clearCellFlag(Flags.HAS_ITEM);\n        }\n        this.needsRedraw = true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.HAS_PLAYER);\n    }\n    get actor() {\n        return this._actor;\n    }\n    set actor(val) {\n        this._actor = val;\n        if (val) {\n            this.setCellFlag(Flags.HAS_ACTOR);\n        }\n        else {\n            this.clearCellFlag(Flags.HAS_ACTOR);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        var _a, _b, _c, _d;\n        if ((_b = (_a = this._actor) === null || _a === void 0 ? void 0 : _a.sprite) === null || _b === void 0 ? void 0 : _b.ch)\n            return this._actor.sprite.ch;\n        if ((_d = (_c = this._item) === null || _c === void 0 ? void 0 : _c.sprite) === null || _d === void 0 ? void 0 : _d.ch)\n            return this._item.sprite.ch;\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Tile from '../tile';\nimport * as Flags from './flags';\nimport { Depth } from '../gameObject/flags';\nexport class MapLayer {\n    constructor(map, name = 'layer') {\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    async tick(_dt) {\n        return false;\n    }\n}\nexport class ActorLayer extends MapLayer {\n    constructor(map, name = 'actor') {\n        super(map, name);\n    }\n    add(x, y, obj, _opts) {\n        const cell = this.map.cell(x, y);\n        const actor = obj;\n        if (actor.forbidsCell(cell))\n            return false;\n        if (!GWU.utils.addToChain(cell, 'actor', obj))\n            return false;\n        if (obj.isPlayer()) {\n            cell.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        obj.x = x;\n        obj.y = y;\n        return true;\n    }\n    remove(obj) {\n        const cell = this.map.cell(obj.x, obj.y);\n        if (!GWU.utils.removeFromChain(cell, 'actor', obj))\n            return false;\n        if (obj.isPlayer()) {\n            cell.clearCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        if (!cell.actor)\n            return;\n        dest.drawSprite(cell.actor.sprite);\n    }\n}\nexport class ItemLayer extends MapLayer {\n    constructor(map, name = 'item') {\n        super(map, name);\n    }\n    add(x, y, obj, _opts) {\n        const cell = this.map.cell(x, y);\n        const item = obj;\n        if (item.forbidsCell(cell))\n            return false;\n        if (!GWU.utils.addToChain(cell, 'item', obj))\n            return false;\n        obj.x = x;\n        obj.y = y;\n        return true;\n    }\n    remove(obj) {\n        const cell = this.map.cell(obj.x, obj.y);\n        if (!GWU.utils.removeFromChain(cell, 'item', obj))\n            return false;\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        if (!cell.item)\n            return;\n        dest.drawSprite(cell.item.sprite);\n    }\n}\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    set(x, y, tile, opts = {}) {\n        const cell = this.map.cell(x, y);\n        const current = cell.depthTile(tile.depth) || Tile.tiles.NULL;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (cell.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && cell.hasItem())\n            return false;\n        if (opts.blockedByActors && cell.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && cell.highestPriority() > tile.priority)\n            return false;\n        if (tile.depth > Depth.GROUND && tile.groundTile) {\n            const ground = cell.depthTile(Depth.GROUND);\n            if (!ground || ground === Tile.tiles.NULL) {\n                this.set(x, y, Tile.get(tile.groundTile));\n            }\n        }\n        if (!cell.setTile(tile))\n            return false;\n        if (opts.machine) {\n            cell.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            cell.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clear(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    async tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire, pressure plates and key-activated tiles.\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (!cell.hasCellFlag(Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM) &&\n                    cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)) {\n                    cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n                }\n                if (cell.hasEffect('noKey') && !cell.hasKey()) {\n                    await cell.activate('noKey', this.map, x, y);\n                }\n            }\n        }\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        const tile = cell.depthTile(this.depth);\n        if (tile && tile !== Tile.tiles.NULL) {\n            dest.drawSprite(tile.sprite);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Cell as CellFlags, Tile as TileFlags } from './flags';\nimport * as TILE from '../tile';\nexport class CellMemory {\n    constructor() {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.flags = {\n            cell: 0,\n            item: 0,\n            actor: 0,\n            tile: 0,\n            tileMech: 0,\n            object: 0,\n        };\n        this.blocks = {\n            vision: false,\n            effects: false,\n            move: false,\n            pathing: false,\n        };\n        this._tile = TILE.tiles.NULL;\n        this._item = null;\n        this._actor = null;\n        this._hasKey = false;\n        this.snapshot = new GWU.sprite.Mixer();\n    }\n    clear() {\n        this.snapshot.blackOut();\n        this._item = null;\n        this._actor = null;\n        this._tile = TILE.tiles.NULL;\n        this.flags.cell = 0;\n        this.flags.object = 0;\n        this.flags.tile = 0;\n        this.flags.tileMech = 0;\n        this.blocks.effects = false;\n        this.blocks.move = false;\n        this.blocks.pathing = false;\n        this.blocks.vision = false;\n        this._hasKey = false;\n        this.machineId = 0;\n        this.chokeCount = 0;\n    }\n    store(cell) {\n        this._item = null;\n        if (cell.hasItem()) {\n            this._item = cell.item;\n        }\n        this._actor = null;\n        if (cell.hasActor()) {\n            this._actor = cell.actor;\n        }\n        this._tile = cell.tile;\n        this.flags.cell = cell.cellFlags();\n        this.flags.tile = cell.tileFlags();\n        this.flags.tileMech = cell.tileMechFlags();\n        this.flags.object = cell.objectFlags();\n        this.flags.item = cell.itemFlags();\n        this.flags.actor = cell.actorFlags();\n        this.blocks.effects = cell.blocksEffects();\n        this.blocks.move = cell.blocksMove();\n        this.blocks.pathing = cell.blocksPathing();\n        this.blocks.vision = cell.blocksVision();\n        this._hasKey = cell.hasKey();\n        this.chokeCount = cell.chokeCount;\n        this.machineId = cell.machineId;\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.flags.tile & flags) == flags;\n    }\n    hasObjectFlag(flag) {\n        return !!(this.flags.object & flag);\n    }\n    hasAllObjectFlags(flags) {\n        return (this.flags.object & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    objectFlags() {\n        return this.flags.object;\n    }\n    tileFlags() {\n        return this.flags.tile;\n    }\n    tileMechFlags() {\n        return this.flags.tileMech;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    blocksVision() {\n        return this.blocks.vision;\n    }\n    blocksPathing() {\n        return this.blocks.pathing;\n    }\n    blocksMove() {\n        return this.blocks.move;\n    }\n    blocksEffects() {\n        return this.blocks.effects;\n    }\n    isWall() {\n        return this.blocksVision() && this.blocksMove();\n    }\n    isStairs() {\n        return this.hasTileFlag(TileFlags.T_HAS_STAIRS);\n    }\n    hasKey() {\n        return this._hasKey;\n    }\n    get tile() {\n        return this._tile;\n    }\n    hasTile(tile) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this._tile === tile;\n    }\n    hasItem() {\n        return !!this._item;\n    }\n    get item() {\n        return this._item;\n    }\n    hasActor() {\n        return !!this._actor;\n    }\n    hasPlayer() {\n        return !!(this.flags.cell & CellFlags.HAS_PLAYER);\n    }\n    get actor() {\n        return this._actor;\n    }\n    getDescription() {\n        throw new Error('Method not implemented.');\n    }\n    getFlavor() {\n        throw new Error('Method not implemented.');\n    }\n    getName(_opts) {\n        throw new Error('Method not implemented.');\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from './flags';\nimport { TileLayer } from './layers';\nimport * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.GameObject;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    async tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    await this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.utils.DIRS[d];\n                        await this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    async exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = Effect.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && GWU.random.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.utils.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasObjectFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            await cell.activate(event, this.map, x, y, {\n                force: true,\n            });\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from './flags';\nimport { TileLayer } from './layers';\nconst ObjectFlags = Flags.GameObject;\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.needsUpdate = false;\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    set(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.set(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.needsUpdate = true;\n        return true;\n    }\n    clear(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n    }\n    async tick(_dt) {\n        if (!this.needsUpdate)\n            return false;\n        this.needsUpdate = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.needsUpdate = true;\n            }\n            else {\n                this.clear(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasObjectFlag(ObjectFlags.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clear(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasObjectFlag(ObjectFlags.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n    putAppearance(dest, x, y) {\n        const volume = this.volume[x][y];\n        if (!volume)\n            return;\n        const cell = this.map.cell(x, y);\n        const tile = cell.depthTile(this.depth);\n        if (tile) {\n            const opacity = this.calcOpacity(volume);\n            dest.drawSprite(tile.sprite, opacity);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from './flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport { TileLayer, ActorLayer, ItemLayer } from './layers';\nimport { Depth } from '../gameObject/flags';\nimport { CellMemory } from './cellMemory';\nimport { FireLayer } from './fireLayer';\nimport { GasLayer } from './gasLayer';\nimport * as Effect from '../effect';\nexport class Map {\n    constructor(width, height, opts = {}) {\n        this.width = width;\n        this.height = height;\n        this.flags = { map: 0 };\n        this.layers = [];\n        this.cells = GWU.grid.make(width, height, () => new Cell());\n        this.memory = GWU.grid.make(width, height, () => new CellMemory());\n        this.light = new GWU.light.LightSystem(this, opts);\n        this.fov = new GWU.fov.FovSystem(this, opts);\n        this.properties = {};\n        this.initLayers();\n    }\n    cellInfo(x, y, useMemory = false) {\n        if (useMemory)\n            return this.memory[x][y];\n        return this.cell(x, y);\n    }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Depth.GROUND, new TileLayer(this, 'ground'));\n        this.addLayer(Depth.SURFACE, new FireLayer(this, 'surface'));\n        this.addLayer(Depth.GAS, new GasLayer(this, 'gas'));\n        this.addLayer(Depth.ITEM, new ItemLayer(this, 'item'));\n        this.addLayer(Depth.ACTOR, new ActorLayer(this, 'actor'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // DRAW\n    drawInto(dest, opts = {}) {\n        const buffer = dest instanceof GWU.canvas.Canvas ? dest.buffer : dest;\n        if (typeof opts === 'boolean')\n            opts = { force: opts };\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                this.getAppearanceAt(x, y, mixer);\n                buffer.drawSprite(x, y, mixer);\n            }\n        }\n    }\n    // items\n    itemAt(x, y) {\n        return this.cell(x, y).item;\n    }\n    eachItem(cb) {\n        this.cells.forEach((cell) => {\n            GWU.utils.eachChain(cell.item, cb);\n        });\n    }\n    addItem(x, y, item) {\n        const layer = this.layers[item.depth];\n        return layer.add(x, y, item);\n    }\n    removeItem(item) {\n        const layer = this.layers[item.depth];\n        return layer.remove(item);\n    }\n    moveItem(item, x, y) {\n        const layer = this.layers[item.depth];\n        if (!layer.remove(item))\n            return false;\n        return layer.add(x, y, item);\n    }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    actorAt(x, y) {\n        return this.cell(x, y).actor;\n    }\n    eachActor(cb) {\n        this.cells.forEach((cell) => {\n            GWU.utils.eachChain(cell.actor, cb);\n        });\n    }\n    addActor(x, y, item) {\n        const layer = this.layers[item.depth];\n        return layer.add(x, y, item);\n    }\n    removeActor(item) {\n        const layer = this.layers[item.depth];\n        return layer.remove(item);\n    }\n    moveActor(item, x, y) {\n        const layer = this.layers[item.depth];\n        if (!layer.remove(item))\n            return false;\n        return layer.add(x, y, item);\n    }\n    // Information\n    isVisible(x, y) {\n        return this.fov.isAnyKindOfVisible(x, y);\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        this.cells.dump(fmt || ((c) => c.dump()), log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cell(i, j);\n                cell.clear();\n                cell.setTile(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile, useMemory = false) {\n        return this.cellInfo(x, y, useMemory).hasTile(tile);\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof TileLayer))\n            return false;\n        return layer.set(x, y, tile, opts);\n    }\n    async tick(dt) {\n        let didSomething = await this.fireAll('tick');\n        for (let layer of this.layers) {\n            if (layer && (await layer.tick(dt))) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cells[x][y]);\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.flags.map = src.flags.map;\n        this.light.setAmbient(src.light.getAmbient());\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    async fire(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.activate(event, this, x, y, ctx);\n    }\n    fireSync(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.activateSync(event, this, x, y, ctx);\n    }\n    async fireAll(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.utils.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasObjectFlag(Flags.GameObject.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    GWU.random.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        await willFire.forEachAsync(async (w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    await cell.activate(event, this, x, y, {\n                        force: true,\n                        depth,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    fireAllSync(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.utils.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasObjectFlag(Flags.GameObject.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    GWU.random.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        willFire.forEach((w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    cell.activate(event, this, x, y, {\n                        force: true,\n                        depth,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    async activateMachine(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cells[x][y];\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        (await cell.activate('machine', this, x, y, ctx)) ||\n                            didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    activateMachineSync(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cells[x][y];\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        cell.activateSync('machine', this, x, y, ctx) ||\n                            didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    getAppearanceAt(x, y, dest) {\n        dest.blackOut();\n        const cell = this.cell(x, y);\n        const isVisible = this.fov.isAnyKindOfVisible(x, y);\n        if (cell.needsRedraw && isVisible) {\n            this.layers.forEach((layer) => layer.putAppearance(dest, x, y));\n            if (dest.dances) {\n                cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n            }\n            else {\n                cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n            }\n            dest.bake();\n            this.memory[x][y].putSnapshot(dest);\n            cell.needsRedraw = false;\n        }\n        else {\n            this.memory[x][y].getSnapshot(dest);\n        }\n        if (isVisible) {\n            const light = this.light.getLight(x, y);\n            dest.multiply(light);\n        }\n        else if (this.fov.isRevealed(x, y)) {\n            dest.scale(50);\n        }\n        else {\n            dest.blackOut();\n        }\n        if (cell.hasObjectFlag(Flags.GameObject.L_VISUALLY_DISTINCT)) {\n            GWU.color.separate(dest.fg, dest.bg);\n        }\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(_cb) {\n        // TODO !!\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    onCellRevealed(_x, _y) {\n        // if (DATA.automationActive) {\n        // if (cell.item) {\n        //     const theItem: GW.types.ItemType = cell.item;\n        //     if (\n        //         theItem.hasObjectFlag(ObjectFlags.L_INTERRUPT_WHEN_SEEN)\n        //     ) {\n        //         GW.message.add(\n        //             '§you§ §see§ ΩitemMessageColorΩ§item§∆.',\n        //             {\n        //                 item: theItem,\n        //                 actor: DATA.player,\n        //             }\n        //         );\n        //     }\n        // }\n        // if (\n        //     !(this.fov.isMagicMapped(x, y)) &&\n        //     this.site.hasObjectFlag(\n        //         x,\n        //         y,\n        //         ObjectFlags.L_INTERRUPT_WHEN_SEEN\n        //     )\n        // ) {\n        //     const tile = cell.tileWithLayerFlag(\n        //         ObjectFlags.L_INTERRUPT_WHEN_SEEN\n        //     );\n        //     if (tile) {\n        //         GW.message.add(\n        //             '§you§ §see§ ΩbackgroundMessageColorΩ§item§∆.',\n        //             {\n        //                 actor: DATA.player,\n        //                 item: tile.name,\n        //             }\n        //         );\n        //     }\n        // }\n    }\n    redrawCell(x, y, clearMemory) {\n        if (clearMemory) {\n            this.clearMemory(x, y);\n        }\n        this.cells[x][y].needsRedraw = true;\n    }\n    clearMemory(x, y) {\n        this.memory[x][y].clear();\n    }\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        this.memory[x][y].store(cell);\n    }\n}\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n    }\n    map.light.update();\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { GameObject as ObjectFlags } from '../gameObject/flags';\nimport { Cell as CellFlags } from './flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasObjectFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~CellFlags.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= CellFlags.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~CellFlags.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & CellFlags.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.utils.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.utils.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.utils.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.utils.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    CellFlags.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & CellFlags.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & CellFlags.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.utils.DIRS[dir][0];\n                        const newY = j + GWU.utils.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                CellFlags.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount = cellCount;\n                                            map.cell(i2, j2).flags.cell &= ~CellFlags.IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= CellFlags.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    let count = passMap[startX][startY] == 2 ? 5000 : 1;\n    if (map.cell(startX, startY).flags.cell & CellFlags.IS_IN_AREA_MACHINE) {\n        count = 10000;\n    }\n    results[startX][startY] = 1;\n    for (let dir = 0; dir < 4; dir++) {\n        const newX = startX + GWU.utils.DIRS[dir][0];\n        const newY = startY + GWU.utils.DIRS[dir][1];\n        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n            passMap[newX][newY] &&\n            !results[newX][newY]) {\n            count += floodFillCount(map, results, passMap, newX, newY);\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    map.eachCell(checkLoopiness);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasObjectFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~CellFlags.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= CellFlags.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(cell, x, y, map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    if (!cell || !(cell.flags.cell & CellFlags.IS_IN_LOOP)) {\n        return false;\n    }\n    // find an unloopy neighbor to start on\n    for (sdir = 0; sdir < 8; sdir++) {\n        newX = x + GWU.utils.CLOCK_DIRS[sdir][0];\n        newY = y + GWU.utils.CLOCK_DIRS[sdir][1];\n        if (!map.hasXY(newX, newY))\n            continue;\n        const cell = map.get(newX, newY);\n        if (!cell || !(cell.flags.cell & CellFlags.IS_IN_LOOP)) {\n            break;\n        }\n    }\n    if (sdir == 8) {\n        // no unloopy neighbors\n        return false; // leave cell loopy\n    }\n    // starting on this unloopy neighbor,\n    // work clockwise and count up:\n    // (a) the number of strings of loopy neighbors, and\n    // (b) the length of the longest such string.\n    numStrings = maxStringLength = currentStringLength = 0;\n    inString = false;\n    for (dir = sdir; dir < sdir + 8; dir++) {\n        newX = x + GWU.utils.CLOCK_DIRS[dir % 8][0];\n        newY = y + GWU.utils.CLOCK_DIRS[dir % 8][1];\n        if (!map.hasXY(newX, newY))\n            continue;\n        const newCell = map.get(newX, newY);\n        if (newCell && newCell.flags.cell & CellFlags.IS_IN_LOOP) {\n            currentStringLength++;\n            if (!inString) {\n                if (numStrings > 0) {\n                    return false; // more than one string here; leave loopy\n                }\n                numStrings++;\n                inString = true;\n            }\n        }\n        else if (inString) {\n            if (currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            currentStringLength = 0;\n            inString = false;\n        }\n    }\n    if (inString && currentStringLength > maxStringLength) {\n        maxStringLength = currentStringLength;\n    }\n    if (numStrings == 1 && maxStringLength <= 4) {\n        cell.flags.cell &= ~CellFlags.IS_IN_LOOP;\n        for (dir = 0; dir < 8; dir++) {\n            const newX = x + GWU.utils.CLOCK_DIRS[dir][0];\n            const newY = y + GWU.utils.CLOCK_DIRS[dir][1];\n            if (map.hasXY(newX, newY)) {\n                const newCell = map.cell(newX, newY);\n                checkLoopiness(newCell, newX, newY, map);\n            }\n        }\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & CellFlags.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & CellFlags.IS_IN_LOOP &&\n                    left.flags.cell & CellFlags.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & CellFlags.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.utils.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.utils.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            CellFlags.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~CellFlags.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport * as Flags from './flags';\nimport * as Tile from '../tile';\nimport * as Entity from '../gameObject';\nimport * as Effect from '../effect';\nimport { Actor } from '../actor';\nimport { Item } from '../item';\nexport class SpawnEffect {\n    make(src, dest) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (!src.tile)\n            return true; // no error\n        let config = src.tile;\n        if (typeof config === 'string') {\n            const parts = config.split(/[,|]/).map((p) => p.trim());\n            config = {\n                tile: parts[0],\n                grow: Number.parseInt(parts[1] || '0'),\n                decrement: Number.parseInt(parts[2] || '0'),\n            };\n        }\n        const info = {\n            grow: (_b = (_a = config.grow) !== null && _a !== void 0 ? _a : config.spread) !== null && _b !== void 0 ? _b : 0,\n            decrement: (_c = config.decrement) !== null && _c !== void 0 ? _c : 0,\n            flags: GWU.flag.from(Effect.Flags, config.flags),\n            volume: (_d = config.volume) !== null && _d !== void 0 ? _d : 0,\n            next: (_e = config.next) !== null && _e !== void 0 ? _e : null,\n        };\n        const id = (_f = config.tile) !== null && _f !== void 0 ? _f : config.id;\n        if (typeof id === 'string') {\n            info.tile = id;\n        }\n        else {\n            throw new Error('Invalid tile spawn config: ' + id);\n        }\n        if (!info.tile) {\n            throw new Error('Must have tile.');\n        }\n        const match = (_g = config.matchTile) !== null && _g !== void 0 ? _g : config.match;\n        if (typeof match === 'string') {\n            info.matchTile = match;\n        }\n        else if (match) {\n            throw new Error('Invalid tile spawn match tile: ' + config.matchTile);\n        }\n        dest.tile = info;\n        return true;\n    }\n    async fire(effect, map, x, y, ctx) {\n        let didSomething = false;\n        const spawned = this.fireSync(effect, map, x, y, ctx);\n        if (spawned) {\n            didSomething = true;\n            // await spawnMap.forEachAsync( (v, x, y) => {\n            //     if (!v) return;\n            //     await map.applyInstantEffects(x, y);\n            // });\n            // if (applyEffects) {\n            // if (PLAYER.xLoc == i && PLAYER.yLoc == j && !PLAYER.status.levitating && refresh) {\n            // \tflavorMessage(tileFlavor(PLAYER.xLoc, PLAYER.yLoc));\n            // }\n            // if (cell.actor || cell.item) {\n            // \tfor(let t of cell.tiles()) {\n            // \t\tawait t.applyInstantEffects(map, i, j, cell);\n            // \t\tif (Data.gameHasEnded) {\n            // \t\t\treturn true;\n            // \t\t}\n            // \t}\n            // }\n            // if (tile.flags & TileFlags.T_IS_FIRE) {\n            // \tif (cell.flags & CellFlags.HAS_ITEM) {\n            // \t\ttheItem = map.itemAt(i, j);\n            // \t\tif (theItem.flags & Flags.Item.ITEM_FLAMMABLE) {\n            // \t\t\tawait burnItem(theItem);\n            // \t\t}\n            // \t}\n            // }\n            // }\n        }\n        // GWU.grid.free(spawnMap);\n        return didSomething;\n    }\n    fireSync(effect, map, x, y, ctx) {\n        if (!effect.tile)\n            return false; // did nothing\n        const id = effect.tile.tile;\n        const tile = Tile.tiles[id] || null;\n        if (!tile) {\n            throw new Error('Failed to find tile for effect: ' + id);\n        }\n        const abortIfBlocking = !!(effect.flags & Effect.Flags.E_ABORT_IF_BLOCKS_MAP);\n        const isBlocking = !!(abortIfBlocking &&\n            !(effect.flags & Effect.Flags.E_PERMIT_BLOCKING) &&\n            (tile.blocksPathing() ||\n                effect.flags & Effect.Flags.E_TREAT_AS_BLOCKING));\n        let didSomething = false;\n        didSomething = computeSpawnMap(effect, map, x, y, ctx);\n        if (!didSomething) {\n            return false;\n        }\n        if (abortIfBlocking &&\n            isBlocking &&\n            this.mapDisruptedBy(map, effect.grid)) {\n            // GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (effect.flags & Effect.Flags.E_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, ctx.grid)) {\n                didSomething = true;\n            }\n        }\n        if (effect.flags & Effect.Flags.E_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, ctx.grid)) {\n                didSomething = true;\n            }\n        }\n        if (effect.flags & Effect.Flags.E_CLEAR_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (clearCells(map, ctx.grid, effect.flags)) {\n                didSomething = true;\n            }\n        }\n        const spawned = spawnTiles(effect.flags, ctx.grid, map, tile, effect.tile.volume, ctx.machine);\n        return spawned;\n    }\n    mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n        const walkableGrid = GWU.grid.alloc(map.width, map.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GWU.utils.forRect(map.width, map.height, (i, j) => {\n            const lakeX = i + blockingToMapX;\n            const lakeY = j + blockingToMapY;\n            if (blockingGrid.get(lakeX, lakeY)) {\n                if (map.cellInfo(i, j).isStairs()) {\n                    disrupts = true;\n                }\n            }\n            else if (!map.cellInfo(i, j).blocksMove()) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGWU.grid.dump();\n        GWU.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\nEffect.installHandler('tile', new SpawnEffect());\n// tick\n// Spawn\nexport function spawnTiles(flags, spawnMap, map, tile, volume = 0, machine) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = !!(flags & Effect.Flags.E_BLOCKED_BY_OTHER_LAYERS);\n    const superpriority = !!(flags & Effect.Flags.E_SUPERPRIORITY);\n    const blockedByActors = !!(flags & Effect.Flags.E_BLOCKED_BY_ACTORS);\n    const blockedByItems = !!(flags & Effect.Flags.E_BLOCKED_BY_ITEMS);\n    // const applyEffects = ctx.refreshCell;\n    volume = volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            // const isRoot = spawnMap[i][j] === 1;\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.hasTile(tile)) {\n                // If the new cell already contains the fill terrain,\n                // if (tile.depth == Entity.flags.Depth.GAS) {\n                //     spawnMap[i][j] = 1;\n                //     cell.gasVolume += volume;\n                // } else if (tile.depth == Entity.flags.Depth.LIQUID) {\n                //     spawnMap[i][j] = 1;\n                //     cell.liquidVolume += volume;\n                // }\n            }\n            else if (map.setTile(i, j, tile, {\n                volume,\n                superpriority,\n                blockedByOtherLayers,\n                blockedByActors,\n                blockedByItems,\n                machine,\n            })) {\n                // if the fill won't violate the priority of the most important terrain in this cell:\n                spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                // map.redrawCell(cell);\n                // if (volume && cell.gas) {\n                //     cell.volume += (feat.volume || 0);\n                // }\n                cell.flags.cell |= Flags.Cell.EVENT_FIRED_THIS_TURN;\n                if (flags & Effect.Flags.E_PROTECTED) {\n                    cell.flags.cell |= Flags.Cell.EVENT_PROTECTED;\n                }\n                accomplishedSomething = true;\n                // debug('- tile', i, j, 'tile=', tile.id);\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.setMapFlag(Flags.Map.MAP_CHANGED);\n    }\n    return accomplishedSomething;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.tile.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Effect.Flags.E_BUILD_IN_WALLS) {\n        if (!map.cellInfo(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Effect.Flags.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.utils.eachNeighbor(x, y, (i, j) => {\n            if (map.cellInfo(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Effect.Flags.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cellInfo(x, y).isWall())\n            return false; // or on wall\n        GWU.utils.eachNeighbor(x, y, (i, j) => {\n            if (map.cellInfo(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.tile.matchTile &&\n        !isStart &&\n        !cell.hasTile(effect.tile.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, map, x, y, ctx) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const config = effect.tile;\n    let startProb = config.grow || 0;\n    let probDec = config.decrement || 0;\n    const spawnMap = ctx.grid;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, x, y, true)) {\n        return false;\n    }\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.utils.DIRS[dir][0];\n                            y2 = j + GWU.utils.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                GWU.random.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\n// export function spreadCircle(\n//     this: any,\n//     ctx: Effect.EffectCtx,\n//     spawnMap: GWU.grid.NumGrid\n// ) {\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     let radius = 0;\n//     startProb = startProb || 100;\n//     if (startProb >= 100) {\n//         probDec = probDec || 100;\n//     }\n//     while (GW.random.chance(startProb)) {\n//         startProb -= probDec;\n//         ++radius;\n//     }\n//     // startProb = 100;\n//     // probDec = 0;\n//     spawnMap.updateCircle(x, y, radius, (_v, i, j) => {\n//         if (!cellIsOk(this, i, j, ctx)) return 0;\n//         // const dist = Math.floor(GWU.utils.distanceBetween(x, y, i, j));\n//         // const prob = startProb - dist * probDec;\n//         // if (!random.chance(prob)) return 0;\n//         return 1;\n//     });\n//     // spawnMap[x][y] = 1;\n//     // if (!isOk(flags, x, y, ctx)) {\n//     //     spawnMap[x][y] = 0;\n//     // }\n//     return true;\n// }\n// export function spreadLine(\n//     this: any,\n//     ctx: Effect.EffectCtx,\n//     spawnMap: GWU.grid.NumGrid\n// ) {\n//     let x2, y2;\n//     let madeChange;\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     if (startProb) {\n//         madeChange = true;\n//         if (startProb >= 100) {\n//             probDec = probDec || 100;\n//         }\n//         x2 = x;\n//         y2 = y;\n//         const dir = GWU.utils.DIRS[GW.random.number(4)];\n//         while (madeChange) {\n//             madeChange = false;\n//             x2 = x2 + dir[0];\n//             y2 = y2 + dir[1];\n//             if (\n//                 spawnMap.hasXY(x2, y2) &&\n//                 !spawnMap[x2][y2] &&\n//                 cellIsOk(this, x2, y2, ctx) &&\n//                 GW.random.chance(startProb)\n//             ) {\n//                 spawnMap[x2][y2] = 1;\n//                 madeChange = true;\n//                 startProb -= probDec;\n//             }\n//         }\n//     }\n//     if (!cellIsOk(this, x, y, ctx)) {\n//         spawnMap[x][y] = 0;\n//     }\n//     return true;\n// }\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Effect.Flags.E_CLEAR_CELL) === Effect.Flags.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Effect.Flags.E_CLEAR_GAS) {\n                cell.clearDepth(Entity.flags.Depth.GAS);\n            }\n            if (flags & Effect.Flags.E_CLEAR_LIQUID) {\n                cell.clearDepth(Entity.flags.Depth.LIQUID);\n            }\n            if (flags & Effect.Flags.E_CLEAR_SURFACE) {\n                cell.clearDepth(Entity.flags.Depth.SURFACE);\n            }\n            if (flags & Effect.Flags.E_CLEAR_GROUND) {\n                cell.clearDepth(Entity.flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let i = 0, j = 0;\n    let didSomething = false;\n    for (i = 0; i < map.width; i++) {\n        for (j = 0; j < map.height; j++) {\n            if (!blockingMap[i][j])\n                continue;\n            const cell = map.cell(i, j);\n            if (!cell.hasActor())\n                continue;\n            GWU.utils.eachChain(cell.actor, (obj) => {\n                if (!(obj instanceof Actor))\n                    return;\n                const monst = obj;\n                const loc = GWU.random.matchingLocNear(i, j, (x, y) => {\n                    if (!map.hasXY(x, y))\n                        return false;\n                    if (blockingMap[x][y])\n                        return false;\n                    const c = map.cell(x, y);\n                    return !monst.forbidsCell(c);\n                });\n                if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                    map.moveActor(monst, loc[0], loc[1]);\n                    // map.redrawXY(loc[0], loc[1]);\n                    didSomething = true;\n                }\n            });\n        }\n    }\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    blockingMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (!cell.hasItem())\n            return;\n        GWU.utils.eachChain(cell.item, (obj) => {\n            if (!(obj instanceof Item))\n                return;\n            const item = obj;\n            const loc = GWU.random.matchingLocNear(i, j, (x, y) => {\n                if (!map.hasXY(x, y))\n                    return false;\n                if (blockingMap[x][y])\n                    return false;\n                const dest = map.cell(x, y);\n                return !item.forbidsCell(dest);\n            });\n            if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                map.moveItem(item, loc[0], loc[1]);\n                // map.redrawXY(loc[0], loc[1]);\n                didSomething = true;\n            }\n        });\n    });\n    return didSomething;\n}\nclass ClearTileEffect {\n    make(src, dest) {\n        if (!src.clear)\n            return true;\n        let config = src.clear;\n        let layers = 0;\n        if (typeof config === 'string') {\n            config = config.split(/[,|]/).map((t) => t.trim());\n        }\n        if (config === true) {\n            layers = Entity.flags.Depth.ALL_LAYERS;\n        }\n        else if (typeof config === 'number') {\n            layers = config;\n        }\n        else if (Array.isArray(config)) {\n            layers = config.reduce((out, v) => {\n                if (typeof v === 'number')\n                    return out | v;\n                const depth = Entity.flags.Depth[v] ||\n                    0;\n                return out | depth;\n            }, 0);\n        }\n        else {\n            throw new Error('clear effect must have number or string config.');\n        }\n        dest.clear = layers;\n        return layers > 0;\n    }\n    fire(config, map, x, y, ctx) {\n        return this.fireSync(config, map, x, y, ctx);\n    }\n    fireSync(config, map, x, y, _ctx) {\n        if (!config.clear)\n            return false;\n        if (!map)\n            return false;\n        const cell = map.cell(x, y);\n        return cell.clearDepth(config.clear);\n    }\n}\nEffect.installHandler('clear', new ClearTileEffect());\n","import { Cell, Map, GameObject, Depth, Tile } from './flags';\nexport const flags = { Cell, Map, GameObject, Depth, Tile };\nexport * from './types';\nexport * from './cell';\nexport * from './map';\nexport * from './analyze';\nexport * from './effect';\nexport * from './cellMemory';\nexport * from './layers';\nexport * from './gasLayer';\nexport * from './fireLayer';\n"],"names":["Fl","GWU","flag","fl","GameObject","Depth","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","[object Object]","this","sprite","Sprite","depth","light","flags","object","next","x","y","hasObjectFlag","Flags.GameObject","Actor","super","actor","Flags.Depth","ACTOR","hasActorFlag","Flags.Actor","IS_PLAYER","_cell","Item","quantity","item","ITEM","Tile","TileMech","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","Effect","make","opts","_a","Error","fn","info","from","Flags","chance","id","Object","values","handlers","forEach","v","effect","effects","reset","E_FIRED","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","install","config","installHandler","handler","async","fire","map","ctx_","name","ctx","force","random","grid","alloc","width","height","didSomething","allHandlers","h","isVisible","E_NO_MARK_FIRED","E_NEXT_ALWAYS","data","gameHasEnded","nextInfo","E_NEXT_EVERYWHERE","forEachAsync","i","j","free","fireSync","MessageEffect","src","dest","message","fired","length","addAt","_map","_x","_y","_ctx","EmitEffect","emit","events","FnEffect","result","ActivateMachineEffect","activateMachine","machine","cell","machineId","activateMachineSync","e","entries","_b","_c","_d","index","dissipate","priority","groundTile","description","flavor","article","tile","tileMech","assign","hasEffect","Flags.Tile","T_IS_FLAMMABLE","ObjectFlags","blocksMove","hasTileFlag","T_PATHING_BLOCKER","arg","color","fg","toString","getName","options","_e","_f","base","extends","tiles","text","replace","search","Number","parseInt","substring","delta","undefined","key","value","Effect.make","Flags.TileMech","ch","bg","opacity","all","get","args","push","enter","open","tick","close","player","Cell","Map","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_TRAP_FREE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","NEEDS_REDRAW","CELL_CHANGED","CellObjects","cb","_item","_actor","start","chokeCount","_objects","TILE.tiles","NULL","TILE.get","setTile","other","slice","some","t","o","objectFlags","tileFlags","tileMechFlags","reduce","out","itemFlags","actorFlags","needsRedraw","Math","max","TILE.Tile","includes","highestPriorityTile","find","blocksVision","blocksPathing","blocksEffects","TILE.flags","T_BLOCKS_OTHER_LAYERS","every","hasAllObjectFlags","TileFlags","tileFlag","tileMechFlag","hasTileMechFlag","clearDepth","event","depthTile","ev","_fire","_fireSync","Effect.effects","Effect.fire","Effect.fireSync","hasCellFlag","val","setCellFlag","clearCellFlag","MapLayer","properties","_other","_dt","ActorLayer","obj","_opts","forbidsCell","utils","addToChain","isPlayer","Flags.Cell","removeFromChain","drawSprite","ItemLayer","TileLayer","current","Tile.tiles","superpriority","blocksLayer","blockedByItems","hasItem","blockedByActors","hasActor","blockedByOtherLayers","highestPriority","GROUND","ground","set","Tile.get","glowLightChanged","CAUGHT_FIRE_THIS_TURN","hasKey","activate","CellMemory","blocks","vision","move","pathing","_tile","_hasKey","snapshot","Mixer","blackOut","cellFlags","copy","CellFlags","TileMechFlags","FireLayer","exposeToFire","d","dir","DIRS","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","GAS","Effect.from","TM_EXPLOSIVE_PROMOTE","eachNeighbor","x0","y0","n","GasLayer","needsUpdate","volume","startingVolume","spread","update","clear","floor","min","total","count","highestVolume","startingTile","highestTile","updateCellVolume","calcOpacity","layers","cells","memory","LightSystem","fov","FovSystem","initLayers","useMemory","addLayer","SURFACE","layer","hasXY","buffer","canvas","Canvas","mixer","getAppearanceAt","eachChain","add","remove","hasPlayer","isAnyKindOfVisible","fmt","log","console","dump","c","boundary","isBoundaryXY","cellInfo","hasTile","dt","fireAll","constructor","l","setAmbient","getAmbient","activateSync","willFire","EVENT_FIRED_THIS_TURN","EVENT_PROTECTED","promoteChance","w","originX","originY","putAppearance","dances","COLORS_DANCE","bake","putSnapshot","getSnapshot","getLight","multiply","isRevealed","scale","L_VISUALLY_DISTINCT","separate","eachGlowLight","_cb","changed","isDark","clearMemory","store","fill","updateChokepoints","updateCounts","passMap","L_SECRETLY_PASSABLE","passableArcCount","oldX","CLOCK_DIRS","oldY","newX","newY","cellCount","floodFillCount","i2","j2","results","startX","startY","updateLoopiness","eachCell","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","newCell","fillInnerLoopGrid","up","left","designationSurvives","SpawnEffect","_g","parts","split","p","trim","grow","decrement","Effect.Flags","match","matchTile","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","isBlocking","E_PERMIT_BLOCKING","E_TREAT_AS_BLOCKING","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","spawnTiles","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","isStairs","first","floodFill","spawnMap","accomplishedSomething","E_BLOCKED_BY_OTHER_LAYERS","E_SUPERPRIORITY","E_PROTECTED","setMapFlag","Flags.Map","MAP_CHANGED","cellIsOk","isStart","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","ok","E_NO_TOUCH_WALLS","x2","y2","madeChange","startProb","probDec","clearAll","Entity.flags.Depth","LIQUID","blockingMap","monst","loc","matchingLocNear","moveActor","moveItem","ALL_LAYERS","Array","isArray","prefab","charToTile","isStringArray","len","line","updateChokeCounts"],"mappings":"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"}