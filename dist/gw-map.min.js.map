{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/flags/horde.js","../js/entity/key.js","../js/action/action.js","../js/action/actions.js","../js/entity/entity.js","../js/entity/kind.js","../js/actor/status.js","../js/actor/stat.js","../js/actor/actor.js","../js/effect/effect.js","../js/tile/tile.js","../js/tile/index.js","../js/map/cell.js","../js/item/item.js","../js/entity/message.js","../js/actor/pain.js","../js/ai/ai.js","../js/ai/wander.js","../js/ai/typical.js","../js/ai/utils.js","../js/actor/kind.js","../js/actor/make.js","../js/item/kind.js","../js/item/make.js","../js/actions/standStill.js","../js/fx/fx.js","../js/actions/bump.js","../js/actions/moveDir.js","../js/actions/idle.js","../js/actions/pickup.js","../js/actions/climb.js","../js/effects/fn.js","../js/effects/activateMachine.js","../js/effects/chance.js","../js/effects/clear.js","../js/effects/emit.js","../js/effects/feature.js","../js/effects/msg.js","../js/effects/nourish.js","../js/effects/spread.js","../js/effects/stat.js","../js/effects/tile.js","../js/layer/mapLayer.js","../js/layer/gasLayer.js","../js/layer/fireLayer.js","../js/layer/tileLayer.js","../js/draw/basic.js","../js/map/map.js","../js/map/analyze.js","../js/map/snapshot.js","../js/map/utils.js","../js/map/make.js","../js/horde/horde.js","../js/horde/make.js","../js/memory/index.js","../js/player/attribute.js","../js/player/skill.js","../js/player/scent.js","../js/player/player.js","../js/player/kind.js","../js/player/make.js","../js/game/viewport.js","../js/game/message.js","../js/game/flavor.js","../js/game/sidebar.js","../js/game/game.js","../js/tile/tiles.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_NO_SIDEBAR\"] = Fl(13)] = \"L_NO_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_ON_MAP\"] = Fl(17)] = \"L_ON_MAP\";\n    Entity[Entity[\"L_IN_SIDEBAR\"] = Fl(18)] = \"L_IN_SIDEBAR\";\n    Entity[Entity[\"L_FORMAL_NAME\"] = Fl(20)] = \"L_FORMAL_NAME\";\n    Entity[Entity[\"L_ALWAYS_PLURAL\"] = Fl(21)] = \"L_ALWAYS_PLURAL\";\n    Entity[Entity[\"DEFAULT_ACTOR\"] = 0] = \"DEFAULT_ACTOR\";\n    Entity[Entity[\"DEFAULT_ITEM\"] = 0] = \"DEFAULT_ITEM\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n    Actor[Actor[\"HAS_MEMORY\"] = Fl(1)] = \"HAS_MEMORY\";\n    Actor[Actor[\"USES_FOV\"] = Fl(2)] = \"USES_FOV\";\n    Actor[Actor[\"STABLE_COST_MAP\"] = Fl(3)] = \"STABLE_COST_MAP\";\n    Actor[Actor[\"IS_VISIBLE\"] = Fl(4)] = \"IS_VISIBLE\";\n    Actor[Actor[\"WAS_VISIBLE\"] = Fl(5)] = \"WAS_VISIBLE\";\n    Actor[Actor[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n    Item[Item[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_SHALLOW_WATER\"] = Fl(4)] = \"T_SHALLOW_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_LIST_IN_SIDEBAR\"] = Fl(22)] = \"T_LIST_IN_SIDEBAR\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n    Tile[Tile[\"T_ANY_LIQUID\"] = Tile.T_IS_DEEP_LIQUID | Tile.T_SHALLOW_WATER] = \"T_ANY_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(0)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(1)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"KNOWN_TO_BE_SAFE\"] = Fl(2)] = \"KNOWN_TO_BE_SAFE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(14)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"STABLE_SNAPSHOT\"] = Fl(15)] = \"STABLE_SNAPSHOT\";\n    // These are to speed checks\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(16)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(17)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(18)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(19)] = \"HAS_ITEM\";\n    Cell[Cell[\"HAS_FX\"] = Fl(20)] = \"HAS_FX\";\n    Cell[Cell[\"HAS_TICK_EFFECT\"] = Fl(22)] = \"HAS_TICK_EFFECT\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(23)] = \"IS_CURSOR\";\n    Cell[Cell[\"IS_HIGHLIGHTED\"] = Fl(24)] = \"IS_HIGHLIGHTED\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_SAFE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_NEEDS_REDRAW\"] = Fl(1)] = \"MAP_NEEDS_REDRAW\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_HAS_LIQUID\"] = Fl(5)] = \"MAP_HAS_LIQUID\";\n    Map[Map[\"MAP_HAS_GAS\"] = Fl(6)] = \"MAP_HAS_GAS\";\n    Map[Map[\"MAP_HAS_FIRE\"] = Fl(7)] = \"MAP_HAS_FIRE\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(10)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(11)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(12)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_SIDEBAR_TILES_CHANGED\"] = Fl(13)] = \"MAP_SIDEBAR_TILES_CHANGED\";\n    Map[Map[\"MAP_SIDEBAR_CHANGED\"] = Fl(14)] = \"MAP_SIDEBAR_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_IGNORE_FOV\"] = Fl(12)] = \"E_IGNORE_FOV\";\n    // E_SPREAD_CIRCLE = Fl(13), // Spread in a circle around the spot (using FOV), radius calculated using spread+decrement\n    // E_SPREAD_LINE = Fl(14), // Spread in a line in one random direction\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Horde;\n(function (Horde) {\n    Horde[Horde[\"HORDE_DIES_ON_LEADER_DEATH\"] = Fl(0)] = \"HORDE_DIES_ON_LEADER_DEATH\";\n    Horde[Horde[\"HORDE_IS_SUMMONED\"] = Fl(1)] = \"HORDE_IS_SUMMONED\";\n    Horde[Horde[\"HORDE_SUMMONED_AT_DISTANCE\"] = Fl(2)] = \"HORDE_SUMMONED_AT_DISTANCE\";\n    Horde[Horde[\"HORDE_NO_PERIODIC_SPAWN\"] = Fl(4)] = \"HORDE_NO_PERIODIC_SPAWN\";\n    Horde[Horde[\"HORDE_ALLIED_WITH_PLAYER\"] = Fl(5)] = \"HORDE_ALLIED_WITH_PLAYER\";\n    Horde[Horde[\"HORDE_NEVER_OOD\"] = Fl(15)] = \"HORDE_NEVER_OOD\";\n    // Move all these to tags?\n    // HORDE_LEADER_CAPTIVE = Fl(3), // the leader is in chains and the followers are guards\n    // HORDE_MACHINE_BOSS = Fl(6), // used in machines for a boss challenge\n    // HORDE_MACHINE_WATER_MONSTER = Fl(7), // used in machines where the room floods with shallow water\n    // HORDE_MACHINE_CAPTIVE = Fl(8), // powerful captive monsters without any captors\n    // HORDE_MACHINE_STATUE = Fl(9), // the kinds of monsters that make sense in a statue\n    // HORDE_MACHINE_TURRET = Fl(10), // turrets, for hiding in walls\n    // HORDE_MACHINE_MUD = Fl(11), // bog monsters, for hiding in mud\n    // HORDE_MACHINE_KENNEL = Fl(12), // monsters that can appear in cages in kennels\n    // HORDE_VAMPIRE_FODDER = Fl(13), // monsters that are prone to capture and farming by vampires\n    // HORDE_MACHINE_LEGENDARY_ALLY = Fl(14), // legendary allies\n    // HORDE_MACHINE_THIEF = Fl(16), // monsters that can be generated in the key thief area machines\n    // HORDE_MACHINE_GOBLIN_WARREN = Fl(17), // can spawn in goblin warrens\n    // HORDE_SACRIFICE_TARGET = Fl(18), // can be the target of an assassination challenge; leader will get scary light.\n    // HORDE_MACHINE_ONLY = HORDE_MACHINE_BOSS |\n    //     HORDE_MACHINE_WATER_MONSTER |\n    //     HORDE_MACHINE_CAPTIVE |\n    //     HORDE_MACHINE_STATUE |\n    //     HORDE_MACHINE_TURRET |\n    //     HORDE_MACHINE_MUD |\n    //     HORDE_MACHINE_KENNEL |\n    //     HORDE_VAMPIRE_FODDER |\n    //     HORDE_MACHINE_LEGENDARY_ALLY |\n    //     HORDE_MACHINE_THIEF |\n    //     HORDE_MACHINE_GOBLIN_WARREN |\n    //     HORDE_SACRIFICE_TARGET,\n})(Horde || (Horde = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","export class Action {\n    constructor(opts) {\n        this.actor = null; // actor doing the acting\n        this.item = null; // item being acted upon (if any/known)\n        this.x = 0;\n        this.y = 0;\n        this.target = null;\n        this.dir = null;\n        this.aware = false;\n        this.identified = false;\n        this.machine = 0;\n        this.try = false;\n        this.force = false;\n        this.good = false;\n        this.seen = false;\n        this.quiet = false;\n        // TODO - move to Game\n        // rng?: GWU.rng.Random;\n        // time = 0; // turn time (-1 means dead, 0 means no action, >0 means did something)\n        this.ok = false;\n        this.failed = false;\n        this.done = false;\n        this.logged = false; // message was logged\n        this.visible = false; // visible to player\n        this.data = {};\n        this.map = opts.map;\n        this.actor = opts.actor || null;\n        this.item = opts.item || null;\n        this.target = opts.target || null;\n        if (!this.map && this.actor) {\n            this.map = this.actor.map;\n        }\n        if (!this.map && this.item) {\n            this.map = this.item.map;\n        }\n        this.game = opts.game;\n        if (!this.game && this.map) {\n            this.game = this.map.game;\n        }\n        if (opts.x !== undefined) {\n            this.x = opts.x;\n            this.y = opts.y;\n        }\n        else if (this.actor) {\n            this.x = this.actor.x;\n            this.y = this.actor.y;\n        }\n        else if (this.item) {\n            this.x = this.item.x;\n            this.y = this.item.y;\n        }\n        this.originX = this.x;\n        this.originY = this.y;\n        this.key = !!opts.key;\n        if (opts.force)\n            this.force = true;\n        if (opts.aware)\n            this.aware = true;\n        if (opts.machine)\n            this.machine = opts.machine;\n    }\n    isSuccess() {\n        return this.ok;\n    }\n    isFailed() {\n        return this.failed;\n    }\n    didSomething() {\n        this.ok = true;\n    }\n    didNothing() { }\n    fail() {\n        this.failed = true;\n        this.done = true;\n    }\n    isDone() {\n        return this.done;\n    }\n    stop() {\n        this.done = true;\n    }\n    reset() {\n        this.done = false;\n        this.failed = false;\n        this.ok = false;\n    }\n}\n// export type ActionNext = () => boolean;\n// export type ActionFn = (req: ActionCtx, next: ActionNext) => boolean;\n// export type ActionAfterFn = (req: ActionCtx) => void;\n// export enum Priority {\n//     FIRST = 0,\n//     EARLY = 25,\n//     NORMAL = 50,\n//     LATE = 75,\n//     LAST = 100,\n// }\n// export interface Action {\n//     fn: ActionFn;\n//     priority: Priority;\n// }\n// interface ActionData {\n//     fns: Action[];\n//     afterFns: ActionAfterFn[];\n// }\n// export interface ActionObj {\n//     [key: string]: ActionFn | ActionFn[] | null | false;\n// }\n// export type ActionBase = ActionFn | ActionFn[];\n// export type ActionConfig = ActionBase | ActionObj;\n// // function isActionObj(arg: any): arg is ActionObj {\n// //     return typeof arg === 'object' && !Array.isArray(arg);\n// // }\n// export class ActionManager {\n//     ACTIONS: Record<string, ActionData> = {};\n//     has(name: string): boolean {\n//         return name in this.ACTIONS;\n//     }\n//     load(obj: ActionObj) {\n//         Object.entries(obj).forEach(([key, value]) => {\n//             if (!value) {\n//                 this.clear(key);\n//             } else {\n//                 this.use(key, value);\n//             }\n//         });\n//     }\n//     copy(other: ActionManager) {\n//         Object.entries(other.ACTIONS).forEach(([name, data]) => {\n//             this.ACTIONS[name] = {\n//                 fns: data.fns.slice(),\n//                 afterFns: data.afterFns.slice(),\n//             };\n//         });\n//     }\n//     clear(name: string) {\n//         delete this.ACTIONS[name];\n//     }\n//     use(name: string, fn: ActionBase): void;\n//     use(\n//         name: string,\n//         fn: ActionFn,\n//         afterFn?: ActionAfterFn,\n//         priority?: number | keyof typeof Priority\n//     ): void;\n//     use(\n//         name: string,\n//         fn: ActionFn,\n//         priority?: number | keyof typeof Priority\n//     ): void;\n//     use(\n//         name: string,\n//         fn: ActionBase,\n//         afterFn?: ActionAfterFn | number | keyof typeof Priority,\n//         priority?: number | keyof typeof Priority\n//     ): void {\n//         if (Array.isArray(fn)) {\n//             if (fn.length && !fn[0]) {\n//                 this.clear(name);\n//                 fn.shift();\n//             }\n//             fn = chain(...fn);\n//         }\n//         if (typeof afterFn !== 'function') {\n//             priority = afterFn;\n//             afterFn = undefined;\n//         }\n//         if (priority === undefined) priority = Priority.NORMAL;\n//         if (typeof priority === 'string') {\n//             priority = Priority[priority] || 50;\n//         }\n//         if (name.startsWith('!') || name.startsWith('^')) {\n//             name = name.substring(1);\n//             priority = Priority.FIRST;\n//         } else if (name.startsWith('-')) {\n//             name = name.substring(1);\n//             priority = Priority.EARLY;\n//         } else if (name.startsWith('+')) {\n//             name = name.substring(1);\n//             priority = Priority.LATE;\n//         } else if (name.startsWith('$')) {\n//             name = name.substring(1);\n//             priority = Priority.LAST;\n//         }\n//         if (!(name in this.ACTIONS)) {\n//             this.ACTIONS[name] = { fns: [], afterFns: [] };\n//         }\n//         const data = this.ACTIONS[name];\n//         const a = { fn, priority };\n//         data.fns.unshift(a); // should go before others with same priority\n//         data.fns.sort((a, b) => a.priority - b.priority);\n//         if (afterFn) {\n//             data.afterFns.push(afterFn);\n//         }\n//     }\n//     useAfter(name: string, fn: ActionAfterFn) {\n//         if (!(name in this.ACTIONS)) {\n//             this.ACTIONS[name] = { fns: [], afterFns: [] };\n//         }\n//         const data = this.ACTIONS[name];\n//         data.afterFns.push(fn);\n//     }\n//     trigger(action: string, req: ActionCtx, next?: ActionNext): boolean {\n//         const data = this.ACTIONS[action];\n//         if (data) {\n//             return this._trigger(req, data.fns, data.afterFns, next);\n//         }\n//         return true;\n//     }\n//     _trigger(\n//         req: ActionCtx,\n//         fns: Action[],\n//         afterFns: ActionAfterFn[] = [],\n//         next?: ActionNext\n//     ): boolean {\n//         let index = -1;\n//         function _next(): boolean {\n//             index += 1;\n//             if (index >= fns.length) {\n//                 return next ? next() : true;\n//             }\n//             const result = fns[index].fn(req, _next);\n//             return result;\n//         }\n//         const result = _next();\n//         afterFns.forEach((fn) => fn(req));\n//         return result;\n//     }\n// }\n// export function chain(...fns: ActionFn[]): ActionFn {\n//     return function (req: ActionCtx, next: ActionNext): boolean {\n//         let index = -1;\n//         function _next(): boolean {\n//             index += 1;\n//             if (index >= fns.length) {\n//                 return next();\n//             }\n//             return fns[index](req, _next);\n//         }\n//         return _next();\n//     };\n// }\n// export function each(...fns: ActionFn[]): ActionFn {\n//     return function (req: ActionCtx, next: ActionNext): boolean {\n//         for (let fn of fns) {\n//             fn(req, GWU.TRUE);\n//         }\n//         return next();\n//     };\n// }\n// export function make(opts?: ActionBase): ActionManager {\n// }\n/*\n    ActorKind\n        actions: Record<string,ActionFn[]>={};\n        use(action, fn, priority) {\n            // push\n            // sort\n        }\n        exec(action,req, res) {\n            // see exec\n        }\n*/\n/*\n\nfunction TRUE() { return true; }\n\ntype ActionCtx = any;\ntype ActionNext = () => boolean | boolean;\ntype ActionFn = (ctx: ActionCtx, next: ActionNext) => boolean | boolean;\n\ninterface ActionObj {\n  actions: Record<string, ActionFn[]>;\n}\n\n function actionObj(ev: string, ctx: ActionCtx, obj: ActionObj, next: ActionNext=TRUE): boolean {\n\n  const allActions = obj.actions;\n  if (!(ev in allActions)) return next();\n  const actions = allActions[ev];\n  \n  let index = -1;\n   function _next() : boolean {\n    ++index;\n    if (index >= actions.length) return next();\n    return actions[index](ctx, _next);\n  }\n\n  return _next();\n}\n\n// e.g. actionObj('test', {}, a, next);\n\n function actionObjs(ev: string, ctx: ActionCtx, objs: ActionObj[], next:ActionNext=TRUE): boolean {\n\n  let index = -1;\n   function _nextObj() {\n    ++index;\n    if (index >= objs.length) return next();\n    const obj = objs[index];\n    return actionObj(ev, ctx, obj, _nextObj);\n  }\n\n  return _nextObj();\n}\n\n// e.g. actionObjs('test', {}, a, b, c, next);\n\ntype ActionArg = ActionFn | { eg: string, obj: ActionObj };\ntype ChainList = [...ActionArg[], ActionNext] | ActionArg[];\n\n function actionChain(ctx: ActionCtx, ...args: ChainList) : boolean {\n\n\n\n  return true;\n}\n\n// map move might include something like...\n// e.g. actionChain({}, { ev: 'exit', obj: cell }, { ev: 'enter', obj: newCell }, next);\n// enter - covers bump/collide\n*/\n","import * as GWU from 'gw-utils';\nimport { Action } from './action';\nexport class Actions {\n    constructor(ctx) {\n        this._handlers = {};\n        this.onUnhandled = null;\n        this._ctx = ctx;\n    }\n    copy(other) {\n        Object.entries(other._handlers).forEach(([ev, fns]) => {\n            if (!fns)\n                return;\n            this._handlers[ev] = Array.isArray(fns) ? fns.slice() : fns;\n        });\n    }\n    has(ev) {\n        const events = this._handlers[ev];\n        if (!events)\n            return false;\n        return events.some((e) => e && !!e.fn);\n    }\n    on(ev, fn) {\n        if (Array.isArray(ev)) {\n            const cleanup = ev.map((e) => this.on(e, fn));\n            return () => {\n                cleanup.forEach((c) => c());\n            };\n        }\n        if (Array.isArray(fn)) {\n            const cleanup = fn.map((cb) => this.on(ev, cb));\n            return () => {\n                cleanup.forEach((c) => c());\n            };\n        }\n        let handlers = this._handlers[ev];\n        if (!handlers) {\n            handlers = this._handlers[ev] = [];\n        }\n        const info = { fn };\n        handlers.unshift(info);\n        return () => {\n            const events = this._handlers[ev];\n            if (Array.isArray(events)) {\n                GWU.arrayNullify(events, info);\n            }\n        };\n    }\n    load(obj) {\n        Object.entries(obj).forEach(([ev, cfg]) => {\n            this.on(ev, cfg);\n        });\n    }\n    once(ev, fn) {\n        if (Array.isArray(ev)) {\n            const cleanup = ev.map((e) => this.once(e, fn));\n            return () => {\n                cleanup.forEach((c) => c());\n            };\n        }\n        if (Array.isArray(fn)) {\n            const cleanup = fn.map((cb) => this.on(ev, cb));\n            return () => {\n                cleanup.forEach((c) => c());\n            };\n        }\n        let handlers = this._handlers[ev];\n        if (!handlers) {\n            handlers = this._handlers[ev] = [];\n        }\n        const info = { fn, once: true };\n        handlers.unshift(info);\n        return () => {\n            const events = this._handlers[ev];\n            if (Array.isArray(events)) {\n                GWU.arrayNullify(events, info);\n            }\n        };\n    }\n    off(ev, cb) {\n        if (Array.isArray(ev)) {\n            ev.forEach((e) => this.off(e, cb));\n            return;\n        }\n        const events = this._handlers[ev];\n        if (!events)\n            return;\n        if (cb) {\n            const current = events.findIndex((i) => i && i.fn === cb);\n            if (current > -1) {\n                events[current] = null;\n            }\n        }\n        else {\n            for (let i = 0; i < events.length; ++i) {\n                events[i] = null;\n            }\n        }\n    }\n    trigger(ev, action) {\n        if (!action)\n            throw new Error('Need Action parameter.');\n        if (Array.isArray(ev)) {\n            let didSomething = false;\n            for (let name of ev) {\n                didSomething = this.trigger(name, action) || didSomething;\n                if (action.isDone())\n                    return didSomething;\n            }\n            return didSomething;\n        }\n        const handlers = this._handlers[ev];\n        if (!handlers || handlers.length == 0) {\n            return this._unhandled(ev, action);\n        }\n        for (let i = 0; i < handlers.length; ++i) {\n            const info = handlers[i];\n            if (info) {\n                if (info.fn) {\n                    // console.log('info.fn', info.fn);\n                    info.fn.call(this._ctx, action);\n                }\n                if (info.once) {\n                    handlers[i] = null;\n                }\n            }\n            if (action.isDone())\n                break;\n        }\n        this._handlers[ev] = handlers.filter((i) => i);\n        return true;\n    }\n    _unhandled(ev, action) {\n        if (!this.onUnhandled)\n            return false;\n        this.onUnhandled(ev, action);\n        return true;\n    }\n    clear() {\n        this._handlers = {};\n        this.onUnhandled = null;\n    }\n    restart() {\n        Object.keys(this._handlers).forEach((ev) => {\n            this._handlers[ev] = this._handlers[ev].filter((i) => i && !i.once);\n        });\n        // this.onUnhandled = null;\n    }\n}\nconst global = new Actions();\nexport function install(ev, fn) {\n    fn.seen = false;\n    global.on(ev, fn);\n}\nexport function doAction(ev, action = {}) {\n    if (!(action instanceof Action)) {\n        action = new Action(action);\n    }\n    if (action.actor) {\n        if (!action.actor.canDoAction(ev)) {\n            return action.fail();\n        }\n    }\n    if (action.item) {\n        if (!action.item.canDoAction(ev)) {\n            return action.fail();\n        }\n    }\n    action.map.trigger(ev, action);\n    if (action.isDone())\n        return;\n    if (action.item) {\n        action.item.trigger(ev, action);\n        if (action.isDone())\n            return;\n    }\n    action.actor && action.actor.trigger(ev, action);\n    if (action.isDone())\n        return;\n    action.game.trigger(ev, action);\n    if (action.isDone())\n        return;\n    global.trigger(ev, action);\n}\nexport function defaultAction(ev, _action) {\n    // if we get here then there was no action installed, this is a problem\n    throw new Error('Unhandled action - ' + ev);\n}\nglobal.onUnhandled = defaultAction;\n","import * as Flags from '../flags/entity';\nimport * as ACTION from '../action';\nlet lastId = 0;\nexport class Entity {\n    // lastSeen: GWU.xy.Loc = [-1, -1];\n    constructor(kind) {\n        this._map = null;\n        this.key = null;\n        this.machineHome = 0;\n        this.changed = true;\n        this.actions = new ACTION.Actions(this);\n        this._actions = {};\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n        this.id = '' + ++lastId;\n    }\n    get map() {\n        return this._map;\n    }\n    isPlural() {\n        return this.hasEntityFlag(Flags.Entity.L_ALWAYS_PLURAL);\n    }\n    isOnMap() {\n        // return this.hasEntityFlag(Flags.Entity.L_ON_MAP);\n        return !!this._map;\n    }\n    addToMap(map, x, y) {\n        this.x = x;\n        this.y = y;\n        this.setEntityFlag(Flags.Entity.L_ON_MAP);\n        if (this._map === map) {\n            return false;\n        }\n        this._map = map;\n        this.kind.addToMap(this, map);\n        return true;\n    }\n    removeFromMap() {\n        this.clearEntityFlag(Flags.Entity.L_ON_MAP);\n        this.kind.removeFromMap(this);\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    isAt(x, y) {\n        return this.x === x && this.y === y;\n    }\n    clone() {\n        const other = new this.constructor(this.kind);\n        other.copy(this);\n        return other;\n    }\n    copy(other) {\n        this.depth = other.depth;\n        this.light = other.light;\n        Object.assign(this.flags, other.flags);\n        this.next = other.next;\n        this.x = other.x;\n        this.y = other.y;\n        this.kind = other.kind;\n        this.id = other.id;\n    }\n    canBeSeen() {\n        return this.kind.canBeSeen(this);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    setEntityFlag(flag) {\n        this.flags.entity |= flag;\n    }\n    clearEntityFlag(flag) {\n        this.flags.entity &= ~flag;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isKey(x, y) {\n        return this.key && this.key.matches(x, y);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(cell, this);\n    }\n    avoidsCell(cell) {\n        return this.kind.avoidsCell(cell, this);\n    }\n    getName(opts) {\n        return this.kind.getName(this, opts);\n    }\n    getDescription(opts) {\n        return this.kind.getDescription(this, opts);\n    }\n    getFlavor(opts) {\n        return this.kind.getFlavor(this, opts);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n    drawSidebar(buffer, bounds) {\n        return this.kind.drawSidebar(this, buffer, bounds);\n    }\n    drawInto(dest, _observer) {\n        dest.drawSprite(this.sprite);\n    }\n    canDoAction(action) {\n        const v = this._actions[action];\n        if (v !== undefined)\n            return v;\n        return this.kind.canDoAction(action);\n    }\n    hasAction(action) {\n        return this.actions.has(action) || this.kind.actions.has(action);\n    }\n    on(action, fn) {\n        this.actions.on(action, fn);\n    }\n    once(action, fn) {\n        this.actions.once(action, fn);\n    }\n    off(action, fn) {\n        this.actions.off(action, fn);\n    }\n    trigger(name, action = {}) {\n        if (!(action instanceof ACTION.Action)) {\n            action = new ACTION.Action(action);\n        }\n        if (action.isDone())\n            return;\n        this.actions.trigger(name, action);\n        if (action.isDone())\n            return;\n        this.kind.trigger(name, action);\n    }\n    toString() {\n        return `${this.kind.id}-${this.id} @ ${this.x},${this.y}`;\n    }\n}\nEntity.default = {\n    sidebarFg: 'purple',\n};\n","import * as GWU from 'gw-utils';\nimport { Entity } from './entity';\nimport * as Flags from '../flags';\nimport * as ACTION from '../action';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.requireTileFlags = 0;\n        this.forbidTileFlags = 0;\n        this.avoidTileFlags = 0;\n        this.requireTileTags = [];\n        this.forbidTileTags = [];\n        this.avoidTileTags = [];\n        this.actions = new ACTION.Actions(this);\n        this._actions = {};\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config.sprite ? config.sprite : config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        if (config.requireTileFlags) {\n            this.requireTileFlags = GWU.flag.from(Flags.Tile, config.requireTileFlags);\n        }\n        if (config.avoidTileFlags) {\n            this.avoidTileFlags = GWU.flag.from(Flags.Tile, config.avoidTileFlags);\n        }\n        if (config.forbidTileFlags) {\n            this.forbidTileFlags = GWU.flag.from(Flags.Tile, config.forbidTileFlags);\n        }\n        if (config.requireTileTags) {\n            if (typeof config.requireTileTags === 'string') {\n                config.requireTileTags = config.requireTileTags.split(/[,|]/g);\n            }\n            this.requireTileTags = config.requireTileTags.map((t) => t.trim());\n        }\n        if (config.avoidTileTags) {\n            if (typeof config.avoidTileTags === 'string') {\n                config.avoidTileTags = config.avoidTileTags.split(/[,|]/g);\n            }\n            this.avoidTileTags = config.avoidTileTags.map((t) => t.trim());\n        }\n        if (config.forbidTileTags) {\n            if (typeof config.forbidTileTags === 'string') {\n                config.forbidTileTags = config.forbidTileTags.split(/[,|]/g);\n            }\n            this.forbidTileTags = config.forbidTileTags.map((t) => t.trim());\n        }\n        if (config.drawSidebar) {\n            this.drawSidebar = config.drawSidebar;\n        }\n        this.sidebarFg = GWU.color.from(config.sidebarFg || Entity.default.sidebarFg);\n        if (config.actions) {\n            Object.entries(config.actions).forEach(([name, value]) => this.on(name, value));\n        }\n    }\n    make(opts) {\n        const entity = new Entity(this);\n        this.init(entity, opts);\n        return entity;\n    }\n    init(entity, opts = {}) {\n        if (opts.machineHome) {\n            entity.machineHome = opts.machineHome;\n        }\n    }\n    addToMap(_entity, _map) { }\n    removeFromMap(_entity) { }\n    canBeSeen(_entity) {\n        return true;\n    }\n    forbidsCell(cell, _entity) {\n        if (this.requireTileFlags &&\n            !cell.hasAllTileFlags(this.requireTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.forbidTileFlags &&\n            cell.hasTileFlag(this.forbidTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.requireTileTags.length &&\n            !cell.hasAllTileTags(this.requireTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.forbidTileTags.length &&\n            cell.hasAnyTileTag(this.forbidTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        return false;\n    }\n    avoidsCell(cell, entity) {\n        if (this.forbidsCell(cell, entity))\n            return true;\n        if (this.avoidTileFlags &&\n            cell.hasTileFlag(this.avoidTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.avoidTileTags.length &&\n            cell.hasAnyTileTag(this.avoidTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        return false;\n    }\n    getName(_entity, _opts) {\n        return this.name;\n    }\n    getDescription(_entity, _opts) {\n        return this.description;\n    }\n    getFlavor(_entity, _opts) {\n        return this.flavor;\n    }\n    getVerb(_entity, verb) {\n        return verb;\n    }\n    drawSidebar(entity, buffer, bounds) {\n        if (!entity.map)\n            return 0;\n        if (entity.isDestroyed)\n            return 0;\n        const mixer = new GWU.sprite.Mixer();\n        entity.map.getAppearanceAt(entity.x, entity.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, entity.getName(), this.sidebarFg);\n        return 1;\n    }\n    canDoAction(action) {\n        const v = this._actions[action];\n        if (v !== undefined)\n            return v;\n        return true; // by default you can do everything!\n    }\n    on(action, fn) {\n        if (Array.isArray(action)) {\n            action.forEach((a) => this.on(a, fn));\n            return;\n        }\n        if (fn === true) {\n            this._actions[action] = true;\n        }\n        else if (fn === false) {\n            this._actions[action] = false;\n        }\n        else {\n            this.actions.on(action, fn);\n            this._actions[action] = true;\n        }\n    }\n    off(action) {\n        if (Array.isArray(action)) {\n            action.forEach((a) => this.off(a));\n            return;\n        }\n        this._actions[action] = false;\n    }\n    trigger(name, action = {}) {\n        if (!(action instanceof ACTION.Action)) {\n            action = new ACTION.Action(action);\n        }\n        if (action.isDone())\n            return;\n        this.actions.trigger(name, action);\n    }\n}\nexport function make(opts, makeOpts = {}) {\n    const kind = new EntityKind(opts);\n    return kind.make(makeOpts);\n}\n","import * as GWU from 'gw-utils';\nexport class Status {\n    constructor() {\n        this._set = {};\n        this._time = {};\n        this._count = {};\n        this._done = {};\n        this._value = {};\n        this.changed = null;\n    }\n    clear(name) {\n        this.clearTime(name);\n        this.clearCount(name);\n        this.setOff(name);\n        return this._update(name);\n    }\n    get(name) {\n        return this._value[name] || false;\n    }\n    has(name) {\n        return this._value[name] || false;\n    }\n    _addDone(name, done) {\n        if (done) {\n            if (!this._done[name]) {\n                this._done[name] = done;\n            }\n        }\n    }\n    /**\n     * Sets the count for a status variable.\n     * If setting the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} count The count to set.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not setting the count turned the status on.\n     */\n    setCount(name, count, done) {\n        const status = this;\n        status._count[name] = Math.max(count, status._count[name] || 0);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Increments the count for the status by the given amount (1=default)\n     * If incrementing the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} [count=1] The count to incrmeent.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not incrementing the count turned the status on.\n     */\n    increment(name, count = 1, done) {\n        if (typeof count == 'function') {\n            done = count;\n            count = 1;\n        }\n        const status = this;\n        status._count[name] = (status._count[name] || 0) + count;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Decrements the count for the status by the given amount (1=default)\n     * If decrementing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @param {number} [count=1] The count to decrement.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    decrement(name, count = 1) {\n        const status = this;\n        status._count[name] = Math.max(0, (status._count[name] || 0) - count);\n        return this._update(name);\n    }\n    /**\n     * Clears all counts from the given status.\n     * If clearing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    clearCount(name) {\n        const status = this;\n        status._count[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Turns on the given status.\n     * @param {string} name The status to adjust.\n     * @param {function} [done] The function to call when the status is turned off.\n     * @returns {boolean} True if this turns on the status. (It could be on because of a time or count).\n     */\n    setOn(name, done) {\n        const status = this;\n        status._set[name] = true;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Turns off the given status.\n     *\n     * @param {string} name The status to adjust.\n     * @returns {boolean} True if this turns off the status. (It could be on because of a time or count).\n     */\n    setOff(name) {\n        const status = this;\n        status._set[name] = false;\n        return this._update(name);\n    }\n    /**\n     * Sets the time for a status variable.\n     * If setting the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to set.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not setting the time turned the status on.\n     */\n    setTime(name, value, done) {\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        const current = status._time[name] || 0;\n        status._time[name] = Math.max(value, current);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Adds to the time for a status variable.\n     * If adding to the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to add.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not adding the time turned the status on.\n     */\n    addTime(name, value = 1, done) {\n        if (typeof value == 'function') {\n            done = value;\n            value = 1;\n        }\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        status._time[name] = (status._time[name] || 0) + value;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Removes time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to remove.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    removeTime(name, value = 1) {\n        const status = this;\n        value = GWU.range.make(value).value();\n        status._time[name] = Math.max(0, (status._time[name] || 0) - value);\n        return this._update(name);\n    }\n    /**\n     * Removes all time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    clearTime(name) {\n        const status = this;\n        status._time[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Removes time for all status variables that have time.\n     * If removing the time turns off any status (it was on),\n     * then this function returns an object with all of those statuses as keys and false as the values.  Otherwise, false.\n     * @param {Status|object} source The object to set the status on.  If object.status is set then that is where the values are updated.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean|object} false or an object with the names of the statuses that were cleared as keys and false as the values.\n     */\n    decayAllTimes(delta = 1) {\n        const status = this;\n        const cleared = {};\n        let noticed = false;\n        for (let name in status._time) {\n            if (this.removeTime(name, delta)) {\n                noticed = true;\n                cleared[name] = false;\n            }\n        }\n        return noticed ? cleared : false;\n    }\n    /**\n     * Updates the value of the status and returns whether or not this change\n     * turned the status on or off (true = change, false = no change)\n     * @param {string} name The name of the status to update\n     * @returns {boolean} True if the value was turned on or off, False otherwise.\n     */\n    _update(name) {\n        const status = this;\n        const rec = this._value;\n        let was = rec[name];\n        let value = (rec[name] =\n            status._set[name] ||\n                status._time[name] > 0 ||\n                status._count[name] > 0 ||\n                false);\n        const doneFn = this._done[name];\n        if (!value && doneFn) {\n            doneFn(this, name);\n            status._done[name] = null;\n        }\n        if (was && !value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: false');\n            return true;\n        }\n        else if (!was && value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: true');\n            return true;\n        }\n        return false;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Stats {\n    constructor(opts = {}) {\n        this._max = {};\n        this._rate = {};\n        this._value = {};\n        this.init(opts);\n    }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    getPct(name) {\n        const max = this.max(name);\n        return max ? Math.round((100 * this.get(name)) / max) : 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    regen(name) {\n        return this._rate[name] || null;\n    }\n    init(opts) {\n        for (let name in opts) {\n            this.set(name, opts[name]);\n        }\n    }\n    set(name, v, max) {\n        if (typeof v !== 'number') {\n            const r = GWU.range.make(v);\n            v = r.value();\n        }\n        this._value[name] = v;\n        this._max[name] = max || v;\n    }\n    gain(name, amount, allowOver = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        let v = this._value[name] + amount;\n        if (!allowOver) {\n            v = Math.min(v, this._max[name]);\n        }\n        this._value[name] = v;\n    }\n    drain(name, amount) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._value[name] = Math.max(0, this._value[name] - amount);\n    }\n    raiseMax(name, amount, raiseValue = true) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] += amount;\n        if (raiseValue) {\n            this.gain(name, amount);\n        }\n    }\n    reduceMax(name, amount, lowerValue = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] = Math.max(0, this._max[name] - amount);\n        if (lowerValue) {\n            this.drain(name, amount);\n        }\n    }\n    setRegen(name, turns, count = 1) {\n        const r = (this._rate[name] = this._rate[name] || { elapsed: 0 });\n        r.turns = turns;\n        r.count = count;\n    }\n    regenAll() {\n        for (let name in this._max) {\n            const r = this._rate[name];\n            r.elapsed += 1;\n            if (r.elapsed >= r.turns) {\n                this.gain(name, r.count);\n                r.elapsed -= r.turns;\n            }\n        }\n    }\n    restore(name, value) {\n        if (value === undefined)\n            value = this._max[name];\n        this._value[name] = value;\n    }\n    adjust(name, type, amount) {\n        amount = GWU.range.from(amount);\n        const v = amount.value();\n        const c = this.get(name);\n        if (type === 'inc') {\n            this.gain(name, amount);\n        }\n        else if (type === 'dec') {\n            this.drain(name, amount);\n        }\n        else if (type === 'set') {\n            this.set(name, amount);\n        }\n        else if (type === 'min') {\n            const v = amount.value();\n            if (this.get(name) < v) {\n                this.set(name, v);\n            }\n        }\n        else if (type === 'max') {\n            if (this.get(name) > v) {\n                this.set(name, v);\n            }\n        }\n        else {\n            throw new Error('Invalid stat adjust type: ' + type);\n        }\n        return c !== this.get(name);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity/entity';\nimport * as Flags from '../flags';\nimport { Status } from './status';\nimport { Stats } from './stat';\nimport * as ACTION from '../action';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.ai = {};\n        this._action = 'idle';\n        this._turnTime = 0;\n        this.leader = null;\n        this.items = null; // inventory\n        this.visionDistance = 99;\n        this.data = {};\n        this._costMap = null;\n        this._goalMap = null;\n        this._mapToMe = null;\n        this.next = null; // TODO - can we get rid of this?\n        // @ts-ignore - initialized in Entity\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n        this.kind = kind;\n        this.stats = new Stats();\n        this.status = new Status();\n    }\n    setData(key, value) {\n        this.data[key] = value;\n        this.changed = true;\n    }\n    copy(other) {\n        super.copy(other);\n        this.leader = other.leader;\n        this.items = other.items;\n        this.visionDistance = other.visionDistance;\n    }\n    destroy() {\n        this.setEntityFlag(Flags.Entity.L_DESTROYED);\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n        if (this._mapToMe) {\n            GWU.grid.free(this._mapToMe);\n            this._mapToMe = null;\n        }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    setActorFlag(flag) {\n        this.flags.actor |= flag;\n    }\n    clearActorFlag(flag) {\n        this.flags.actor &= ~flag;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    isDead() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n    /////////////// VISIBILITY\n    becameVisible() {\n        return (this.hasActorFlag(Flags.Actor.IS_VISIBLE) &&\n            !this.hasActorFlag(Flags.Actor.WAS_VISIBLE));\n    }\n    canSee(x, y) {\n        if (x instanceof Entity.Entity) {\n            return this.canSee(x.x, x.y) && this.kind.isAbleToSee(this, x);\n        }\n        else if (this.map) {\n            if (this.isPlayer()) {\n                return this.map.fov.isDirectlyVisible(x, y);\n            }\n            if (GWU.xy.distanceBetween(this.x, this.y, x, y) >\n                this.visionDistance) {\n                return false;\n            }\n            return GWU.xy.forLineBetween(this.x, this.y, x, y, (i, j) => {\n                if (this.map.cell(i, j).blocksVision())\n                    return false;\n            });\n        }\n        else {\n            return false; // need a map or an fov\n        }\n    }\n    canSeeOrSense(x, y) {\n        if (x instanceof Entity.Entity) {\n            return (this.canSeeOrSense(x.x, x.y) &&\n                (this.kind.isAbleToSee(this, x) ||\n                    this.kind.isAbleToSense(this, x)));\n        }\n        if (this.map && this.isPlayer()) {\n            return this.map.fov.isAnyKindOfVisible(x, y);\n        }\n        return this.canSee(x, y);\n    }\n    isAbleToSee(entity) {\n        return this.kind.isAbleToSee(this, entity);\n    }\n    isAbleToSense(entity) {\n        return this.kind.isAbleToSense(this, entity);\n    }\n    ////////////////// ACTOR\n    setAction(name) {\n        if (!this.canDoAction(name)) {\n            throw new Error('Actor cannot do action - ' + name);\n        }\n        this._action = name;\n    }\n    clearAction() {\n        this._action = 'idle';\n    }\n    act(game) {\n        let startedVisible = false;\n        if (game.player.canSee(this)) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n            startedVisible = true;\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n        if (this.becameVisible()) {\n            game.player.interrupt(this);\n        }\n        ACTION.doAction(this._action, { game, actor: this, map: this.map });\n        // let r = 0;\n        // if (this.ai && this.ai.fn) {\n        //     r = this.ai.fn(game, this);\n        // }\n        // if (r == 0 && this.kind.ai.fn) {\n        //     r = this.kind.ai.fn(game, this);\n        // }\n        // if (r) {\n        //     // did something\n        if (startedVisible || game.player.canSee(this)) {\n        }\n        //     return r;\n        // }\n        // // idle - always\n        return this._turnTime;\n    }\n    moveSpeed() {\n        return this.kind.moveSpeed;\n    }\n    startTurn() {\n        this._turnTime = 0;\n        if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n            this.setActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        const map = this.map;\n        const isVisible = map && map.fov.isAnyKindOfVisible(this.x, this.y);\n        if (isVisible) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n    }\n    endTurn(pct = 100) {\n        if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n            this.setActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        const map = this.map;\n        const isVisible = map && map.fov.isAnyKindOfVisible(this.x, this.y);\n        if (isVisible) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n            if (!this.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR) &&\n                !this.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n                map.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n            }\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n            if (map &&\n                !this.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR) &&\n                this.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n                map.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n            }\n        }\n        this._turnTime = Math.max(this._turnTime, Math.floor((pct * this.moveSpeed()) / 100));\n    }\n    ///////\n    willAttack(_other) {\n        return true;\n    }\n    canPass(_other) {\n        return false;\n    }\n    ////////////////// INVENTORY\n    avoidsItem(_item) {\n        return false;\n    }\n    canAddItem(_item) {\n        return false;\n    }\n    addItem(_item) { }\n    pickupItem(item, opts) {\n        return this.kind.pickupItem(this, item, opts);\n    }\n    dropItem(item, opts) {\n        return this.kind.dropItem(this, item, opts);\n    }\n    // PATHFINDING\n    addToMap(map, x, y) {\n        const mapChanged = super.addToMap(map, x, y);\n        if (mapChanged) {\n            this.clearActorFlag(Flags.Actor.STABLE_COST_MAP);\n        }\n        return mapChanged;\n    }\n    removeFromMap() {\n        super.removeFromMap();\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n        if (this._mapToMe) {\n            GWU.grid.free(this._mapToMe);\n            this._mapToMe = null;\n        }\n    }\n    /*\n    Calculates and returns the actor's move cost map.\n    Used in pathfinding.\n    */\n    costMap() {\n        if (!this.map) {\n            throw new Error('Actor must have map to calculate costMap.');\n        }\n        const staleMap = !this.hasActorFlag(Flags.Actor.STABLE_COST_MAP);\n        if (staleMap && this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (!this._costMap) {\n            this._costMap = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        else if (!staleMap) {\n            return this._costMap;\n        }\n        const kind = this.kind;\n        const map = this.map;\n        this._costMap.update((_v, x, y) => {\n            const cell = map.cell(x, y);\n            return kind.cellCost(cell, this);\n        });\n        this.setActorFlag(Flags.Actor.STABLE_COST_MAP);\n        /*\n\n            if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n            && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))\n            {\n                playerCostMap[i][j] = monsterCostMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_SACRED)) {\n                    playerCostMap[i][j] = 1;\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_LAVA_INSTA_DEATH)) {\n        monsterCostMap[i][j] = PDS_FORBIDDEN;\n        if (player.status[STATUS_LEVITATING] || !player.status[STATUS_IMMUNE_TO_FIRE]) {\n            playerCostMap[i][j] = 1;\n        } else {\n            playerCostMap[i][j] = PDS_FORBIDDEN;\n        }\n            } else {\n                if (pmap[i][j].flags & HAS_MONSTER) {\n                    monst = monsterAtLoc(i, j);\n                    if ((monst.creatureState == MONSTER_SLEEPING\n                         || monst.turnsSpentStationary > 2\n             || (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)\n                         || monst.creatureState == MONSTER_ALLY)\n                        && monst.creatureState != MONSTER_FLEEING)\n                    {\n                        playerCostMap[i][j] = 1;\n                        monsterCostMap[i][j] = PDS_FORBIDDEN;\n                        continue;\n                    }\n                }\n\n                if (cellHasTerrainFlag(i, j, (T_AUTO_DESCENT | T_IS_DF_TRAP))) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, T_IS_FIRE)) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_IMMUNE_TO_FIRE]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, (T_IS_DEEP_WATER | T_SPONTANEOUSLY_IGNITES))) {\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = 5;\n          }\n                    monsterCostMap[i][j] = 5;\n        } else if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n                   && cellHasTMFlag(i, j, TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)\n                   && !(pmap[i][j].flags & IN_FIELD_OF_VIEW))\n             {\n            // Secret door that the player can't currently see\n            playerCostMap[i][j] = 100;\n            monsterCostMap[i][j] = 1;\n                } else {\n                    playerCostMap[i][j] = monsterCostMap[i][j] = 1;\n                }\n            }\n        }\n    }\n        */\n        return this._costMap;\n    }\n    get goalMap() {\n        return this._goalMap;\n    }\n    hasGoal() {\n        return !!this._goalMap;\n    }\n    setGoal(x, y) {\n        const map = this._map;\n        if (!map)\n            throw new Error('No map to set goal with!');\n        if (!this._goalMap) {\n            this._goalMap = GWU.grid.alloc(map.width, map.height);\n        }\n        const goalMap = this._goalMap;\n        GWU.path.calculateDistances(goalMap, x, y, this.costMap());\n        return this._goalMap;\n    }\n    clearGoal() {\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n    }\n    mapToMe() {\n        if (!this.map)\n            throw new Error('No map!');\n        if (!this._mapToMe) {\n            this._mapToMe = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        if (this._mapToMe.x !== this.x || this._mapToMe.y !== this.y) {\n            GWU.path.calculateDistances(this._mapToMe, this.x, this.y, this.costMap());\n        }\n        return this._mapToMe;\n    }\n}\nActor.default = {\n    sidebarFg: 'purple',\n};\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nexport const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id.toLowerCase()] = handler;\n}\nexport function make(id, config) {\n    if (!id)\n        return GWU.NOOP;\n    if (typeof id === 'string') {\n        if (!id.length)\n            throw new Error('Cannot create effect from empty string.');\n        if (!config) {\n            const parts = id.split(':');\n            id = parts.shift().toLowerCase();\n            config = parts;\n        }\n        const handler = handlers[id];\n        if (!handler)\n            throw new Error('Failed to find effect - ' + id);\n        return handler(config || {});\n    }\n    let steps;\n    if (Array.isArray(id)) {\n        steps = id\n            .map((config) => make(config))\n            .filter((a) => a !== null);\n    }\n    else if (typeof id === 'function') {\n        return id;\n    }\n    else {\n        steps = Object.entries(id)\n            .map(([key, config]) => make(key, config))\n            .filter((a) => a !== null);\n    }\n    if (steps.length === 1) {\n        return steps[0];\n    }\n    return (a) => {\n        const x = a.x;\n        const y = a.y;\n        for (let step of steps) {\n            a.x = x;\n            a.y = y;\n            step && step(a);\n            if (a.isDone())\n                return;\n        }\n    };\n}\nexport function makeArray(cfg) {\n    if (!cfg)\n        return [];\n    if (Array.isArray(cfg)) {\n        return cfg\n            .map((c) => make(c))\n            .filter((fn) => fn !== null);\n    }\n    if (typeof cfg === 'string') {\n        if (!cfg.length)\n            throw new Error('Cannot create effect from empty string.');\n        const parts = cfg.split(':');\n        cfg = parts.shift().toLowerCase();\n        const handler = handlers[cfg];\n        if (!handler)\n            return [];\n        return [handler(parts)];\n    }\n    else if (typeof cfg === 'function') {\n        return [cfg];\n    }\n    const steps = Object.entries(cfg).map(([key, config]) => make(key, config));\n    return steps.filter((s) => s !== null);\n}\nexport function trigger(effect, map, x, y, opts) {\n    const cfg = Object.assign({ map, x, y }, opts);\n    const action = new ACTION.Action(cfg);\n    const fn = handlers[effect];\n    if (!fn)\n        return;\n    fn(action);\n}\n/*\n\n/////////////////////////\n// TYPES\n\nexport type MakeEffectFn = (config: any) => Effect;\n\nexport const effectTypes: Record<string, MakeEffectFn> = {};\n\nexport function installType(id: string, type: MakeEffectFn) {\n    effectTypes[id] = type;\n}\n\n//////////////////////////\n// EFFECT\n\nexport interface Effect {\n    chance: number; //  100 * 100 =  100%\n    seen: boolean;\n    effects: EffectFn[];\n    next: Effect | null;\n\n    trigger(loc: MapXY, ctx?: EffectCtx): boolean;\n    // clone(): this;\n}\n\n//////////////////////////\n// MAKE\n\nexport interface EffectConfig {\n    chance?: number | string;\n    type?: string; // basic | bolt | beam | ball | burst | adjacent | spread\n\n    effects: string | EffectFn | (string | EffectFn)[] | Record<string, any>;\n    good?: boolean;\n    flags?: GWU.flag.FlagBase;\n\n    next?: EffectBase;\n\n    [key: string]: any;\n}\n\nexport type EffectBase =\n    | string\n    | EffectFn\n    | (string | EffectFn)[]\n    | EffectConfig\n    | Record<string, any>;\n\n*/\n// export class Effect {\n//     id = '';\n//     chance = 100 * 100; // 100%\n//     type: string; // self | bolt | beam | ball | burst | adjacent | spread\n//     aim: string; // actor | item | cell\n//     bolt: string | GWU.sprite.SpriteData | null = null;\n//     beam = false;\n//     range = 0;\n//     ball: string | GWU.sprite.SpriteData | null = null;\n//     radius = 0;\n//     center = false;\n//     effects: EffectFn[];\n//     good = false;\n//     seen = false;\n//     next: Effect | null = null;\n//     constructor(config: EffectConfig) {\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         this.aim = config.aim || 'actor';\n//         if (typeof config.chance === 'string') {\n//             // '20%' becomes 2000\n//             config.chance = Math.floor(Number.parseFloat(config.chance) * 100);\n//         }\n//         this.chance = config.chance || 100 * 100;\n//         const type = config.type || 'basic';\n//         const parts = type.split(':');\n//         if (type.startsWith('bolt') || type.startsWith('beam')) {\n//             // bolt:range:sprite\n//             this.type = parts[0];\n//             this.range = parts[1] ? Number.parseInt(parts[1]) : 99;\n//             this.bolt = parts[1] || 'missile';\n//             this.beam = type.startsWith('beam');\n//         } else if (\n//             type.startsWith('ball') ||\n//             type.startsWith('burst') ||\n//             type.startsWith('aura')\n//         ) {\n//             this.type = parts[0];\n//             this.radius = parts[1] ? Number.parseInt(parts[1]) : 2;\n//             this.range = parts[2] ? Number.parseInt(parts[2]) : 99;\n//             this.ball = parts[3] || 'explosion';\n//             this.center = !type.startsWith('aura');\n//         } else {\n//             this.type = 'basic';\n//         }\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         if (Array.isArray(config.effects)) {\n//             this.effects = config.effects.map((e) => {\n//                 if (typeof e === 'function') return e;\n//                 return effectFnFromString(e);\n//             });\n//         } else {\n//             this.effects = [];\n//             Object.entries(config.effects).forEach(([key, value]) => {\n//                 const handler = handlers[key.toLowerCase()];\n//                 if (handler) {\n//                     this.effects.push(handler(value));\n//                 } else if (typeof value === 'function') {\n//                     this.effects.push(value);\n//                 } else {\n//                     throw new Error('Unknown effect: ' + key);\n//                 }\n//             });\n//         }\n//         if (this.effects.length === 0) throw new Error('No effects!');\n//     }\n//     clone(): this {\n//         const other = new (this.constructor as new (\n//             config: EffectConfig\n//         ) => this)(this as EffectConfig);\n//         return other;\n//     }\n//     fire(map: Map.MapType, x: number, y: number, ctx: EffectCtx = {}): boolean {\n//         let didSomething = false;\n//         ctx.good = this.good;\n//         ctx.seen = this.seen;\n//         if (!this.chance || map.rng.chance(this.chance, 10000)) {\n//             // fire\n//             for (let effect of this.effects) {\n//                 if (GWU.data.gameHasEnded) break;\n//                 if (effect(map, x, y, ctx)) {\n//                     didSomething = true;\n//                 } else {\n//                     break;\n//                 }\n//             }\n//         }\n//         if (ctx.aware && didSomething) {\n//             this.seen = true;\n//         }\n//         this.good = ctx.good;\n//         return didSomething;\n//     }\n//     reset() {\n//         this.seen = false;\n//     }\n// }\n// export function effectFnFromString(e: string): EffectFn {\n//     const parts = e.split(':');\n//     if (parts.length === 0) throw new Error('Invalid effect string.');\n//     // @ts-ignore\n//     const name = parts.shift().toLowerCase();\n//     const handler = handlers[name] || null;\n//     if (!handler) {\n//         throw new Error('Failed to find effect handler: ' + name);\n//     }\n//     return handler(parts);\n// }\n/*\nexport function make(opts: EffectBase): Effect {\n    if (!opts) throw new Error('opts required to make effect.');\n    let config = {} as EffectConfig;\n\n    if (typeof opts === 'string') {\n        // Special case\n        if (opts.toLowerCase().startsWith('spread:')) {\n            const endPos = opts.indexOf(':', 8);\n            const tile = opts.substring(8, endPos);\n            config = {\n                type: 'spread:' + opts.substring(endPos),\n                effects: ['tile:' + tile],\n            };\n        } else {\n            config = { type: 'basic', effects: [opts] };\n        }\n    } else if (typeof opts === 'function') {\n        config = { type: 'basic', effects: [opts] };\n    } else if (Array.isArray(opts)) {\n        config = { type: 'basic', effects: opts };\n    } else {\n        // @ts-ignore\n        if (opts.effect) {\n            // @ts-ignore\n            opts.effects = [opts.effect];\n            delete opts.effect;\n        }\n\n        // object only\n        if (opts.effects) {\n            Object.assign(config, opts);\n            if (typeof config.effects === 'string') {\n                config.effects = [opts.effects];\n            } else if (typeof config.effects === 'function') {\n                config.effects = [opts.effects];\n            }\n        } else {\n            config.effects = {} as Record<string, any>;\n            Object.entries(opts).forEach(([key, value]) => {\n                const handler = handlers[key.toLowerCase()];\n                if (handler !== undefined) {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                } else if (typeof value === 'function') {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                } else {\n                    // @ts-ignore\n                    config[key] = value;\n                }\n            });\n        }\n    }\n\n    config.type = config.type || 'basic';\n\n    if (typeof config.type !== 'string')\n        throw new Error('Invalid effect type: ' + JSON.stringify(config.type));\n\n    const typeParts = config.type.split(':').map((t) => t.trim());\n    const typeName = typeParts.shift()!;\n\n    const makeFn = effectTypes[typeName.toLowerCase()];\n    if (!makeFn) throw new Error('Invalid effect type: ' + typeName);\n\n    const effect = makeFn(config);\n\n    if (Array.isArray(config.effects)) {\n        config.effects.forEach((e: string | EffectFn) => {\n            if (typeof e === 'function') {\n                effect.effects.push(e);\n            } else {\n                const parts = e.split(':').map((t: string) => t.trim());\n\n                if (parts.length === 1) {\n                    const effect = installedEffects[parts[0]];\n                    if (!effect)\n                        throw new Error(\n                            'Failed to find effect with id: ' + parts[0]\n                        );\n                    effect.effects.push(effect.trigger.bind(effect));\n                } else {\n                    const handler = handlers[parts[0].toLowerCase()];\n                    if (!handler)\n                        throw new Error('Unknown effect: ' + parts[0]);\n                    parts.shift();\n                    effect.effects.push(handler(parts));\n                }\n            }\n        });\n    } else {\n        Object.entries(config.effects).forEach(([key, value]) => {\n            const handler = handlers[key.toLowerCase()];\n            if (!handler)\n                throw new Error('Failed to find handler type: ' + key);\n\n            effect.effects.push(handler(value));\n        });\n    }\n\n    if (config.next) {\n        effect.next = make(config.next);\n    }\n\n    return effect;\n}\n\nexport function from(opts: EffectBase): Effect {\n    if (!opts) throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'object' && 'trigger' in opts) {\n        return opts as Effect;\n    }\n\n    if (typeof opts === 'string') {\n        const effect = installedEffects[opts];\n        if (effect) return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\n*/\n//////////////////////////////\n// INSTALL\nexport const installed = {};\nexport function install(id, config) {\n    const effect = make(config);\n    if (!effect)\n        throw new Error('Failed to make effect.');\n    installed[id] = effect;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function resetAll() {\n    Object.values(installed).forEach((e) => (e.seen = false));\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as ACTION from '../action';\nimport * as EFFECT from '../effect';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.actions = new ACTION.Actions(this);\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.tags = [];\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.actions) {\n            Object.entries(config.actions).forEach(([ev, fn]) => {\n                this.on(ev, fn);\n            });\n        }\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                config.tags\n                    .split(/[,|]/)\n                    .map((t) => t.trim())\n                    .forEach((t) => {\n                    this.tags.push(t);\n                });\n            }\n            else {\n                this.tags = config.tags.slice().map((t) => t.trim());\n            }\n        }\n    }\n    hasTag(tag) {\n        return this.tags.includes(tag);\n    }\n    hasAnyTag(tags) {\n        return GWU.arraysIntersect(this.tags, tags);\n    }\n    hasAllTags(tags) {\n        return tags.every((t) => this.tags.includes(t));\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    // ACTIONS\n    hasAction(name) {\n        return this.actions.has(name);\n    }\n    on(name, fn) {\n        if (!fn) {\n            this.actions.off(name);\n            if (name === 'fire') {\n                this.flags.tile &= ~Flags.Tile.T_IS_FLAMMABLE;\n            }\n            return;\n        }\n        if (typeof fn === 'string') {\n            const effect = EFFECT.make(fn);\n            if (effect === null)\n                throw new Error('Failed to make effect: ' + fn);\n            fn = effect;\n        }\n        if (Array.isArray(fn)) {\n            fn.reverse().forEach((cb) => this.on(name, cb));\n        }\n        else if (typeof fn === 'object') {\n            Object.entries(fn)\n                .reverse()\n                .forEach(([key, value]) => {\n                const effect = EFFECT.make(key, value);\n                effect && this.on(name, effect);\n            });\n        }\n        else {\n            this.actions.on(name, fn);\n            if (name === 'fire') {\n                this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n            }\n        }\n    }\n    trigger(name, action = {}) {\n        if (!(action instanceof ACTION.Action)) {\n            action = new ACTION.Action(action);\n        }\n        if (!action.map)\n            throw new Error('Need action with a map.');\n        this.actions.trigger(name, action);\n    }\n    // INFO\n    isNull() {\n        return this === NULL;\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isDoor() {\n        return this.hasTileFlag(Flags.Tile.T_IS_DOOR);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isDiggable() {\n        return this.isNull() || this.isWall();\n    }\n    getName(arg) {\n        let opts = {};\n        if (typeof arg === 'boolean') {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription(opts) {\n        return this.description || this.getName(opts);\n    }\n    getFlavor(opts) {\n        return this.flavor || this.getName(opts);\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n        tags: options.tags || null,\n    };\n    const tile = new Tile(config);\n    if (base && base.actions) {\n        tile.actions.copy(base.actions);\n    }\n    if (options.actions) {\n        Object.entries(options.actions).forEach(([key, value]) => {\n            tile.on(key, value);\n        });\n    }\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string') {\n        const t = tiles[id];\n        if (t)\n            return t;\n        throw new Error('Failed to find tile with id - ' + id);\n    }\n    const t = all[id];\n    if (t)\n        return t;\n    throw new Error('Failed to find tile with index - ' + id);\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n// These are the minimal set of tiles to make the diggers work\nexport const NULL = install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\n// import './tiles';\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as ACTION from '../action';\nGWU.color.install('cellStatusName', 'light_blue');\nexport const NEVER_SEEN = {\n    tiles: [TILE.NULL],\n    item: null,\n    actor: null,\n    flags: {\n        cell: 0,\n        entity: TILE.NULL.flags.entity,\n        tile: TILE.NULL.flags.tile,\n        tileMech: TILE.NULL.flags.tileMech,\n    },\n};\nexport class Cell {\n    constructor(map, x, y, groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.x = -1;\n        this.y = -1;\n        // toFire: Partial<Effect.EffectCtx>[] = [];\n        this.memory = null;\n        this.volume = 0;\n        // this._entities = new CellEntities(this);\n        this.flags = { cell: Flags.Cell.NEEDS_REDRAW };\n        this.tiles = [TILE.tiles.NULL];\n        this.map = map;\n        this.x = x;\n        this.y = y;\n        this.snapshot = GWU.sprite.makeMixer();\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n        this.memory = NEVER_SEEN;\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get hasStableSnapshot() {\n        return this.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    }\n    get hasStableMemory() {\n        return this.hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    storeMemory() {\n        var _a;\n        this.setCellFlag(Flags.Cell.STABLE_MEMORY);\n        // store memory\n        this.memory = {\n            flags: {\n                cell: this.flags.cell,\n                entity: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.entity) || 0), 0),\n                tile: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.tile) || 0), 0),\n                tileMech: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.tileMech) || 0), 0),\n            },\n            tiles: this.tiles.slice(),\n            item: ((_a = this.item) === null || _a === void 0 ? void 0 : _a.clone()) || null,\n            actor: null,\n        };\n        if (this.hasItem()) {\n            const item = this.item;\n            if (item) {\n                this.memory.flags.entity |= item.flags.entity;\n            }\n        }\n        if (this.hasActor()) {\n            const actor = this.actor;\n            if (actor) {\n                this.memory.flags.entity |= actor.flags.entity;\n            }\n            this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n    }\n    clearMemory() {\n        this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT | Flags.Cell.STABLE_MEMORY);\n        this.memory = null;\n        this.needsRedraw = true;\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this.machineId = other.machineId;\n        // this._actor = other.actor;\n        // this._item = other.item;\n        this.memory = other.memory;\n        this.volume = other.volume;\n        this.map = other.map;\n        this.x = other.x;\n        this.y = other.y;\n        other.getSnapshot(this.snapshot);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag, checkEntities = false) {\n        var _a, _b;\n        if (this.tiles.some((t) => t && t.flags.entity & flag))\n            return true;\n        if (!checkEntities)\n            return false;\n        if (this.hasItem()) {\n            if ((_a = this.item) === null || _a === void 0 ? void 0 : _a.hasEntityFlag(flag))\n                return true;\n        }\n        if (this.hasActor()) {\n            if ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.hasEntityFlag(flag))\n                return true;\n        }\n        return false;\n    }\n    hasAllEntityFlags(flags, checkEntities = false) {\n        return (this.entityFlags(checkEntities) & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    hasTileTag(tag) {\n        return this.tiles.some((tile) => tile && tile.hasTag(tag));\n    }\n    hasAllTileTags(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAllTags(tags);\n        });\n    }\n    hasAnyTileTag(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAnyTag(tags);\n        });\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags(withEntities = false) {\n        var _a, _b;\n        let flag = this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0);\n        if (withEntities) {\n            if (this.hasItem()) {\n                flag |= ((_a = this.item) === null || _a === void 0 ? void 0 : _a.flags.entity) || 0;\n            }\n            if (this.hasActor()) {\n                flag |= ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.flags.entity) || 0;\n            }\n        }\n        return flag;\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            if (!this.memory) {\n                this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n                this.flags.cell &= ~Flags.Cell.STABLE_SNAPSHOT;\n                this.map.needsRedraw = true;\n            }\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return this.tiles.some((t) => t && t.blocksVision());\n    }\n    blocksPathing() {\n        return (this.tiles.some((t) => t && t.blocksPathing()) &&\n            !this.tiles.some((t) => t && t.hasTileFlag(Flags.Tile.T_BRIDGE)));\n    }\n    blocksMove() {\n        return this.tiles.some((t) => t && t.blocksMove());\n    }\n    blocksEffects() {\n        return this.tiles.some((t) => t && t.blocksEffects());\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isNull() {\n        return this.tiles.every((t) => !t || t === TILE.tiles.NULL);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isDoor() {\n        return this.hasTileFlag(Flags.Tile.T_IS_DOOR);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    // hasKey(): boolean {\n    //     return this._entities.some(\n    //         (e) => !!e.key && e.key.matches(this.x, this.y)\n    //     );\n    // }\n    hasLiquid() {\n        return this.hasTileFlag(Flags.Tile.T_ANY_LIQUID);\n    }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile, opts = {}) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile) {\n            if (opts.volume) {\n                this.volume += opts.volume;\n            }\n            return false;\n        }\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (this.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && this.hasItem())\n            return false;\n        if (opts.blockedByActors && this.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && this.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const currentGround = this.depthTile(Flags.Depth.GROUND);\n            const wantGround = TILE.get(tile.groundTile);\n            if (currentGround !== wantGround) {\n                if (!this.setTile(wantGround, opts)) {\n                    return false;\n                }\n            }\n        }\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            this.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            this.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (current.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR) !==\n            tile.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n            this.map.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            this.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            this.map.setMapFlag(Flags.Map.MAP_HAS_FIRE);\n        }\n        this.volume = opts.volume || 0;\n        if (tile.depth === Flags.Depth.GAS) {\n            this.map.setMapFlag(Flags.Map.MAP_HAS_GAS);\n        }\n        if (tile.depth === Flags.Depth.LIQUID) {\n            this.map.setMapFlag(Flags.Map.MAP_HAS_LIQUID);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.needsRedraw = true;\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.volume = 0;\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.snapshot.blackOut();\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            if (depth === Flags.Depth.GAS) {\n                this.volume = 0;\n            }\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    tileWithAction(name) {\n        return this.tiles.find((t) => t === null || t === void 0 ? void 0 : t.hasAction(name)) || null;\n    }\n    trigger(action, ctx = {}) {\n        if (!(ctx instanceof ACTION.Action)) {\n            ctx = new ACTION.Action(ctx);\n        }\n        ctx.x = this.x;\n        ctx.y = this.y;\n        ctx.map = this.map;\n        this.tiles.forEach((t) => t && t.trigger(action, ctx));\n    }\n    hasAction(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasAction(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    get item() {\n        return this.map.itemAt(this.x, this.y);\n    }\n    canAddItem(_item) {\n        return true;\n    }\n    canRemoveItem(_item) {\n        return true;\n    }\n    _addItem(_item) {\n        this.setCellFlag(Flags.Cell.HAS_ITEM);\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeItem(item) {\n        let hasItems = false;\n        let foundIndex = -1;\n        this.map.items.forEach((obj, index) => {\n            if (obj === item) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasItems = true;\n            }\n        });\n        if (!hasItems) {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this.map.actorAt(this.x, this.y);\n    }\n    canAddActor(_actor) {\n        return !this.hasActor();\n    }\n    canRemoveActor(_actor) {\n        return true;\n    }\n    _addActor(actor) {\n        this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        if (actor.isPlayer()) {\n            this.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeActor(actor) {\n        let hasActor = false;\n        let foundIndex = -1;\n        this.map.actors.forEach((obj, index) => {\n            if (obj === actor) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasActor = true;\n            }\n        });\n        if (!hasActor) {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.HAS_PLAYER);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    hasFx() {\n        return !!(this.flags.cell & Flags.Cell.HAS_FX);\n    }\n    get fx() {\n        return this.map.fxAt(this.x, this.y);\n    }\n    _addFx(_fx) {\n        this.setCellFlag(Flags.Cell.HAS_FX);\n        this.needsRedraw = true;\n    }\n    _removeFx(_fx) {\n        if (!this.fx) {\n            this.clearCellFlag(Flags.Cell.HAS_FX);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        if (this.hasActor()) {\n            const actor = this.map.actorAt(this.x, this.y);\n            if (actor && actor.sprite.ch)\n                return actor.sprite.ch;\n        }\n        if (this.hasItem()) {\n            const item = this.map.itemAt(this.x, this.y);\n            if (item && item.sprite.ch)\n                return item.sprite.ch;\n        }\n        if (this.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return '=';\n        }\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n    drawSidebar(buffer, bounds) {\n        const mixer = new GWU.sprite.Mixer();\n        this.map.getAppearanceAt(this.x, this.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, this.getName(), 'cellStatusName');\n        return 1;\n    }\n    toString() {\n        return `Cell @ ${this.x},${this.y}`;\n    }\n}\n","import { Entity } from '../entity/entity';\nimport { Depth } from '../flags';\nexport class Item extends Entity {\n    constructor(kind) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore - initialized in constructor\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n    }\n    isPlural() {\n        if (this.quantity > 1)\n            return true;\n        return super.isPlural();\n    }\n    copy(other) {\n        super.copy(other);\n        this.quantity = other.quantity;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n    // getAction(name: string): ACTION.ItemActionBase | undefined {\n    //     const action = this.kind.actions[name];\n    //     return action;\n    // }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n}\nItem.default = {\n    sidebarFg: 'gold',\n};\n","import * as GWU from 'gw-utils';\nimport { Actor } from '../actor/actor';\nimport { Cell } from '../map/cell';\nimport { Item } from '../item/item';\nimport * as Flags from '../flags';\nexport function messageYou(name, view, args) {\n    const field = args[0] || 'actor';\n    const actor = this.get(view, field);\n    if (actor && actor instanceof Actor) {\n        if (actor.isPlayer()) {\n            return 'you';\n        }\n        else {\n            return 'the ' + actor.getName();\n        }\n    }\n    return actor || name;\n}\nGWU.text.addHelper('you', messageYou);\nexport function messageThe(name, view, args) {\n    const value = args[0]\n        ? this.get(view, args[0])\n        : view.item || view.cell || view.target || view.actor;\n    if (value) {\n        if (value instanceof Cell) {\n            return value.getFlavor();\n        }\n        else if (value instanceof Actor) {\n            if (value.isPlayer()) {\n                return 'you';\n            }\n            else {\n                return 'the ' + value.getName();\n            }\n        }\n        else if (value instanceof Item) {\n            return 'the ' + value.getName();\n        }\n    }\n    return name;\n}\nGWU.text.addHelper('the', messageThe);\nexport function messageA(name, view, args) {\n    const value = args[0]\n        ? this.get(view, args[0])\n        : view.item || view.cell || view.target || view.actor;\n    if (value) {\n        if (value instanceof Cell) {\n            return value.getFlavor();\n        }\n        else if (value instanceof Actor) {\n            if (value.isPlayer()) {\n                return 'you';\n            }\n            else if (value.hasEntityFlag(Flags.Entity.L_FORMAL_NAME)) {\n                return value.getName();\n            }\n        }\n        if ('getName' in value) {\n            const name = value.getName();\n            const char = GWU.text.firstChar(name);\n            const ana = /[aeiouy]/i.exec(char) ? 'an ' : 'a ';\n            return ana + name;\n        }\n    }\n    return name;\n}\nGWU.text.addHelper('a', messageA);\nGWU.text.addHelper('an', messageA);\nexport function messageVerb(_name, view, args) {\n    const verb = args[0] || 'verb';\n    const value = args[1]\n        ? this.get(view, args[1])\n        : view.actor || view.target || view.item || view.cell;\n    let plural = false;\n    if (value) {\n        if (value instanceof Cell) {\n            plural = false;\n        }\n        else if (value instanceof Actor) {\n            plural = value.isPlural();\n        }\n        else if (value instanceof Item) {\n            plural = value.isPlural();\n        }\n    }\n    return plural ? GWU.text.toPluralVerb(verb) : GWU.text.toSingularVerb(verb);\n}\nGWU.text.addHelper('verb', messageVerb);\n","import * as GWU from 'gw-utils';\nexport class PainMessages {\n    constructor(msgs = []) {\n        this._msgs = [];\n        msgs.forEach((m) => this.add(m));\n    }\n    add(msg) {\n        this._msgs.push(msg);\n        return this;\n    }\n    get(pct, singular = true) {\n        const index = GWU.clamp(Math.floor(pct * this._msgs.length), 0, this._msgs.length - 1);\n        const msg = this._msgs[index];\n        return this._format(msg, singular);\n    }\n    _format(msg, singular = true) {\n        return msg.replace(/\\[(\\w+)\\|?(\\w*)\\]/g, singular ? '$1' : '$2');\n    }\n}\nexport const painMessages = {};\nexport function installPain(id, pain) {\n    if (Array.isArray(pain)) {\n        pain = new PainMessages(pain);\n    }\n    painMessages[id] = pain;\n}\nexport function getPain(id) {\n    const m = painMessages[id];\n    if (!m)\n        throw new Error('No such pain message index: ' + id);\n    return m;\n}\n","// AI functions\n// actor is current actor\n// returns time until next turn for this actor\n// < 0 means do not requeue\nexport const ais = {};\nexport function install(name, fn) {\n    ais[name] = fn;\n}\nexport function make(opts) {\n    if (typeof opts === 'string') {\n        opts = { fn: opts };\n    }\n    if (typeof opts === 'function') {\n        opts = { fn: opts };\n    }\n    if (typeof opts.fn === 'string') {\n        opts.fn = ais[opts.fn];\n    }\n    if (!opts.fn) {\n        opts.fn = ais.default;\n    }\n    return opts;\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as ACTION from '../action';\nexport function wander(action) {\n    const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor required.');\n    // Do we have a wander target?\n    let goalMap = actor.goalMap;\n    if (!goalMap) {\n        //      pick new wander target\n        const costMap = actor.costMap();\n        const loc = GWU.random.matchingLoc(costMap.width, costMap.height, (x, y) => {\n            return costMap[x][y] > 0 && costMap[x][y] !== GWU.path.NO_PATH;\n        });\n        if (!loc || loc[0] < 0 || loc[1] < 0) {\n            console.log('No wander location found!');\n            return action.didNothing();\n        }\n        //      build distance map to target\n        goalMap = actor.setGoal(loc[0], loc[1]);\n    }\n    // take the next step to the target\n    const step = GWU.path.nextStep(goalMap, actor.x, actor.y, (x, y) => {\n        if (!map.hasActor(x, y))\n            return false;\n        const other = map.actorAt(x, y);\n        if (!other) {\n            console.log(`Cell @ ${x},${y} has actor flag, but no actor.`);\n            map.cell(x, y).clearCellFlag(Flags.Cell.HAS_ACTOR);\n            return false;\n        }\n        return !actor.canPass(other);\n    });\n    if (!step) {\n        actor.clearGoal();\n        return action.didNothing();\n    }\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        return action.didNothing();\n    }\n    action.dir = step;\n    return ACTION.doAction('moveDir', action);\n}\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nimport * as AI from './ai';\nimport { wander } from './wander';\n/*\nhttp://roguebasin.com/index.php/Roguelike_Intelligence_-_Stateless_AIs\n-- Typical AI\n*/\nexport function typical(action) {\n    // const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor required.');\n    if (actor.isDead())\n        return action.didNothing();\n    const target = action.game.player;\n    const tryAttack = actor.canSee(target) && actor.willAttack(target);\n    if (tryAttack) {\n        const damagePct = 100 - actor.stats.getPct('health');\n        const morale = actor.stats.get('morale');\n        const chargeChance = 100;\n        const retreatChance = 0;\n        actor.ai.lastSawPlayer = [target.x, target.y];\n        actor.clearGoal();\n        console.log('SAW YOU!', actor.id, target.x, target.y);\n        if (damagePct > morale) {\n            if (canRunAwayFrom(action)) {\n                runAwayFrom(action);\n            }\n            else if (canAttack(action)) {\n                attack(action);\n            }\n            return;\n        }\n        if (tooFarFrom(action) && canAttack(action) && canMoveToward(action)) {\n            if (GWU.random.chance(chargeChance)) {\n                moveToward(action);\n            }\n            else {\n                attack(action);\n            }\n            return;\n        }\n        if (tooCloseTo(action) &&\n            canAttack(action) &&\n            canMoveAwayFrom(action)) {\n            if (GWU.random.chance(retreatChance)) {\n                moveAwayFrom(action);\n            }\n            else {\n                attack(action);\n            }\n            return;\n        }\n        if (canAttack(action)) {\n            attack(action);\n            return;\n        }\n        if (tooFarFrom(action) && canMoveToward(action)) {\n            moveToward(action);\n            return;\n        }\n        if (tooCloseTo(action) && canMoveAwayFrom(action)) {\n            moveAwayFrom(action);\n            return;\n        }\n    }\n    // TODO - Use scent, menory, other teammates info, ...\n    else if (actor.ai.lastSawPlayer) {\n        if (!actor.hasGoal()) {\n            const loc = actor.ai.lastSawPlayer;\n            actor.setGoal(loc[0], loc[1]);\n        }\n        console.log('CHASING YOU!', actor.id, actor.goalMap.x, actor.goalMap.y);\n        moveTowardGoal(action);\n        if (action.isSuccess()) {\n            return;\n        }\n        actor.ai.lastSawPlayer = null; // no longer\n        actor.clearGoal();\n    }\n    // check if they noticed the player scent\n    if (target.scent) {\n        action.dir = target.scent.nextDir(actor.x, actor.y);\n        if (action.dir) {\n            console.log('tracking scent', actor.id, action.dir);\n            ACTION.doAction('moveDir', action);\n            if (action.isDone())\n                return;\n        }\n    }\n    const wanderOpt = GWU.object.firstOpt('wander', actor.ai, actor.kind.ai, false);\n    if (wanderOpt) {\n        if (actor.goalMap || // we have a current goal\n            typeof wanderOpt !== 'number' || // wander: true\n            GWU.random.chance(wanderOpt) // chance\n        ) {\n            wander(action);\n            if (action.isSuccess())\n                return;\n        }\n        else {\n            ACTION.doAction('idle', action);\n            if (action.isSuccess()) {\n                return;\n            }\n        }\n    }\n    return ACTION.doAction('standStill', action);\n}\nAI.install('typical', typical);\nAI.install('default', typical);\nexport function canMoveToward(action) {\n    // can move?\n    const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor required.');\n    const target = action.target;\n    if (!target)\n        throw new Error('No target.');\n    let x = target.x;\n    let y = target.y;\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = actor.costMap();\n    GWU.path.calculateDistances(distanceMap, x, y, costMap);\n    const canMoveDiagonal = false;\n    // look for distance > current around me\n    let center = distanceMap[actor.x][actor.y];\n    let count = 0;\n    GWU.xy.eachNeighbor(actor.x, actor.y, (x, y) => {\n        if (distanceMap[x][y] < center) {\n            ++count;\n        }\n    }, canMoveDiagonal);\n    GWU.grid.free(distanceMap);\n    return count > 0;\n}\nexport function moveToward(action) {\n    // pathfinding?\n    const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor required.');\n    const target = action.target;\n    if (!target)\n        throw new Error('No target.');\n    let x = target.x;\n    let y = target.y;\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = actor.costMap();\n    GWU.path.calculateDistances(distanceMap, x, y, costMap);\n    const step = GWU.path.nextStep(distanceMap, actor.x, actor.y, (x, y) => {\n        const cell = map.cell(x, y);\n        if (!cell)\n            return true;\n        if (cell.hasActor() && cell.actor !== action.target)\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    });\n    GWU.grid.free(distanceMap);\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        return ACTION.doAction('standStill', action);\n    }\n    action.dir = step;\n    return ACTION.doAction('moveDir', action);\n}\nexport function canMoveAwayFrom(_action) {\n    // can move?\n    // const distanceMap = ctx.distanceMap;\n    // const canMoveDiagonal = false;\n    // // look for distance > current around me\n    // let center = distanceMap[actor.x][actor.y];\n    // let count = 0;\n    // GWU.xy.eachNeighbor(\n    //     actor.x,\n    //     actor.y,\n    //     (x, y) => {\n    //         const d = distanceMap[x][y];\n    //         if (d >= GWU.path.NO_PATH) return;\n    //         if (distanceMap[x][y] > center) {\n    //             ++count;\n    //         }\n    //     },\n    //     canMoveDiagonal\n    // );\n    // return ctx.done(count > 0);\n    return false;\n}\nexport function moveAwayFrom(action) {\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Need actor.');\n    // safety/strategy?\n    // always move using safety map?\n    actor.endTurn();\n    return action.didSomething();\n}\nexport function canRunAwayFrom(_action) {\n    // can move?\n    return false;\n}\nexport function runAwayFrom(action) {\n    // move toward loop if away from player\n    if (!action.actor)\n        throw new Error('Need actor.');\n    action.actor.endTurn();\n    return action.didSomething();\n}\nexport function canAttack(action) {\n    // has attack?\n    // attack affects player?\n    // cooldown?\n    const actor = action.actor;\n    const target = action.target;\n    if (!actor || !target)\n        return false;\n    return GWU.xy.distanceFromTo(actor, target) <= 1;\n}\nexport function attack(action) {\n    const actor = action.actor;\n    const target = action.target;\n    if (!actor || !target)\n        throw new Error('Actor and Target required to attack.');\n    console.log('attack!', actor.id, target.id);\n    return ACTION.doAction('attack', action);\n}\nexport function tooFarFrom(action) {\n    // diagonal?\n    const actor = action.actor;\n    const target = action.target;\n    if (!actor || !target)\n        return true;\n    return GWU.xy.distanceFromTo(actor, target) > 1;\n}\nexport function tooCloseTo(action) {\n    const actor = action.actor;\n    const target = action.target;\n    if (!actor || !target)\n        return true;\n    return GWU.xy.distanceFromTo(actor, target) < 1;\n}\n// TODO - make an action\nexport function moveTowardGoal(action) {\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Need actor.');\n    if (!actor.hasGoal())\n        return action.didNothing();\n    const nextStep = GWU.path.nextStep(actor.goalMap, actor.x, actor.y, (x, y) => {\n        return actor.map.hasActor(x, y);\n    });\n    if (!nextStep) {\n        actor.clearGoal();\n        return action.didNothing();\n    }\n    action.dir = nextStep;\n    return ACTION.doAction('moveDir', action);\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nexport function fillSafetyMap(safetyMap, actor, target) {\n    const costGrid = GWU.grid.alloc(actor.costMap());\n    GWU.path.calculateDistances(safetyMap, target.x, target.y, costGrid, true);\n    safetyMap.update((v) => v * -1); // Can set factor to be < -1 e.g. -1.2\n    actor.map.actors.forEach((a) => {\n        if (a.willAttack(actor)) {\n            costGrid[a.x][a.y] = GWU.path.FORBIDDEN; // This is why we allocate a copy\n        }\n    });\n    actor.map.eachCell((c, x, y) => {\n        if (c.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n            safetyMap[x][y] -= GWU.path.AVOIDED; // loop cells are extra good\n        }\n    });\n    GWU.path.rescan(safetyMap, costGrid, true);\n    safetyMap.update((v) => (v <= -30000 ? 30000 : v));\n    GWU.grid.free(costGrid);\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Actor } from './actor';\nimport * as AI from '../ai';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n        this.flags = {\n            actor: Flags.Actor.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.vision = {};\n        this.bump = ['attack'];\n        this.moveSpeed = 100;\n        if (opts.flags) {\n            this.flags.actor = GWU.flag.from(Flags.Actor, this.flags.actor, opts.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, opts.flags);\n        }\n        if (opts.vision) {\n            this.vision.normal = opts.vision;\n        }\n        this.stats = Object.assign({ health: 1, morale: 100 }, opts.stats);\n        if (opts.moveSpeed) {\n            this.moveSpeed = opts.moveSpeed;\n        }\n        this.ai = AI.make(opts.ai || 'default');\n        if (opts.bump) {\n            if (typeof opts.bump === 'string') {\n                opts.bump = opts.bump.split(/[|,]/g).map((t) => t.trim());\n            }\n            if (typeof opts.bump === 'function') {\n                opts.bump = [opts.bump];\n            }\n            if (Array.isArray(opts.bump)) {\n                this.bump = opts.bump.slice();\n            }\n        }\n        if (opts.waterOnly) {\n            this.forbidTileFlags =\n                this.forbidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            this.avoidTileFlags =\n                this.avoidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            this.requireTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n        }\n        else if (opts.lavaOnly) {\n            this.forbidTileFlags = this.forbidTileFlags & ~Flags.Tile.T_LAVA;\n            this.avoidTileFlags = this.avoidTileFlags & ~Flags.Tile.T_LAVA;\n            this.requireTileFlags |= Flags.Tile.T_LAVA;\n        }\n        else {\n            if (opts.swim) {\n                this.avoidTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n            else {\n                this.forbidTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n            if (opts.fly) {\n                this.forbidTileFlags =\n                    this.forbidTileFlags & ~Flags.Tile.T_LAVA;\n                this.avoidTileFlags = this.avoidTileFlags & ~Flags.Tile.T_LAVA;\n                this.requireTileFlags =\n                    this.requireTileFlags & ~Flags.Tile.T_LAVA;\n                this.forbidTileFlags =\n                    this.forbidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n                this.avoidTileFlags =\n                    this.avoidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n                this.requireTileFlags =\n                    this.requireTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n        }\n        this.sidebarFg = GWU.color.from(opts.sidebarFg || Actor.default.sidebarFg);\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n        Object.assign(actor.flags, this.flags);\n        // if (options.fov) {\n        //     actor.fov = options.fov;\n        // }\n        // if (options.memory) {\n        //     actor.memory = options.memory;\n        // }\n        if (this.vision.normal) {\n            actor.visionDistance = this.vision.normal;\n        }\n        actor.stats.init(this.stats);\n    }\n    addToMap(actor, map) {\n        super.addToMap(actor, map);\n        // if (this.hasActorFlag(Flags.Actor.HAS_MEMORY)) {\n        //     actor.memory = Memory.get(actor, map);\n        // }\n        // if (this.hasActorFlag(Flags.Actor.USES_FOV)) {\n        //     actor.fov = new GWU.fov.FovSystem(map);\n        //     actor.fov.follow = actor;\n        //     if (actor.memory) {\n        //         actor.fov.callback = actor.memory;\n        //     }\n        // }\n    }\n    removeFromMap(actor) {\n        super.removeFromMap(actor);\n        // if (actor._map && actor.memory) {\n        //     Memory.store(actor, actor._map, actor.memory);\n        // }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    canSeeEntity(_actor, _entity) {\n        return true;\n    }\n    isAbleToSee(_actor, _entity) {\n        return true;\n    }\n    isAbleToSense(_actor, _entity) {\n        return true;\n    }\n    forbidsCell(cell, actor) {\n        if (super.forbidsCell(cell, actor)) {\n            return true;\n        }\n        if (cell.blocksMove())\n            return true;\n        return false;\n    }\n    avoidsCell(cell, actor) {\n        if (super.avoidsCell(cell, actor))\n            return true;\n        if (cell.blocksPathing())\n            return true;\n        return false;\n    }\n    getFlavor(actor, opts) {\n        const flavor = actor.isPlayer() ? 'yourself' : this.flavor;\n        if (opts && opts.action) {\n            return flavor + ' standing';\n        }\n        return flavor;\n    }\n    pickupItem(actor, item, _opts) {\n        if (!GWU.list.push(actor, 'items', item))\n            return false;\n        // TODO - Pickup effects\n        return true;\n    }\n    dropItem(actor, item, _opts) {\n        if (!GWU.list.remove(actor, 'items', item))\n            return false;\n        // TODO - Drop effects\n        return true;\n    }\n    cellCost(cell, actor) {\n        if (this.forbidsCell(cell, actor)) {\n            return cell.hasEntityFlag(Flags.Entity.L_BLOCKS_DIAGONAL)\n                ? GWU.path.OBSTRUCTION\n                : GWU.path.FORBIDDEN;\n        }\n        else if (this.avoidsCell(cell, actor)) {\n            return GWU.path.AVOIDED;\n        }\n        return GWU.path.OK;\n    }\n    drawSidebar(actor, buffer, bounds) {\n        let count = super.drawSidebar(actor, buffer, bounds);\n        if (actor.map.hasTileFlag(actor.x, actor.y, Flags.Tile.T_DEEP_WATER) &&\n            !actor.map.hasTileFlag(actor.x, actor.y, Flags.Tile.T_BRIDGE)) {\n            buffer.drawText(bounds.x + 3, bounds.y + count++, 'Swimming', '#66F');\n        }\n        return count;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ActorKind } from './kind';\nexport function make(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ActorKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ActorKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ActorKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ActorKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Item } from './item';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n        this.flags = {\n            item: Flags.Item.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.bump = [];\n        if (config.flags) {\n            this.flags.item = GWU.flag.from(Flags.Item, this.flags.item, config.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, config.flags);\n        }\n        if (config.bump) {\n            if (typeof config.bump === 'string' ||\n                typeof config.bump === 'function') {\n                config.bump = [config.bump];\n            }\n            if (Array.isArray(config.bump)) {\n                this.bump = config.bump.slice();\n            }\n        }\n        this.avoidTileFlags |= Flags.Tile.T_DEEP_WATER;\n        this.forbidTileFlags |= Flags.Tile.T_LAVA | Flags.Tile.T_AUTO_DESCENT;\n        this.sidebarFg = GWU.color.from(config.sidebarFg || Item.default.sidebarFg);\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n    init(item, options = {}) {\n        super.init(item, options);\n        Object.assign(item.flags, this.flags);\n        item.quantity = options.quantity || 1;\n    }\n    avoidsCell(cell, item) {\n        if (cell.isDoor() || cell.isStairs())\n            return true;\n        return super.avoidsCell(cell, item);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ItemKind } from './kind';\nexport function make(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        kind.id = id;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import * as ACTION from '../action';\nexport function standStill(action) {\n    if (action.actor) {\n        action.actor.endTurn();\n        action.didSomething();\n    }\n}\nACTION.install('standStill', standStill);\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nexport function flashSprite(map, x, y, sprite, duration = 100, count = 1) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ visible: true })\n        .to({ visible: false })\n        .repeat(count)\n        .repeatDelay(duration)\n        .duration(duration)\n        .onUpdate((obj) => {\n        if (obj.visible) {\n            map.addFx(x, y, entity);\n        }\n        else {\n            map.removeFx(entity);\n        }\n    });\n    return tween;\n}\nGWU.sprite.install('bump', 'white', 50);\nexport function hit(map, target, sprite, duration) {\n    sprite = sprite || 'hit';\n    duration = duration || 200;\n    return flashSprite(map, target.x, target.y, sprite, duration, 1);\n}\nGWU.sprite.install('hit', 'red', 50);\nexport function miss(map, target, sprite, duration) {\n    sprite = sprite || 'miss';\n    duration = duration || 200;\n    return flashSprite(map, target.x, target.y, sprite, duration, 1);\n}\nGWU.sprite.install('miss', 'green', 50);\nexport function fadeInOut(map, x, y, sprite, duration = 100) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite).clone();\n    }\n    else {\n        sprite = GWU.sprite.make(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ opacity: 0 })\n        .to({ opacity: 100 })\n        .repeat(2)\n        .yoyo(true)\n        .duration(Math.floor(duration / 2))\n        .onUpdate((obj) => {\n        entity.sprite.opacity = obj.opacity;\n        map.cell(x, y).needsRedraw = true; // we changed the sprite so redraw\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n    });\n    // realTime\n    return tween;\n}\nexport function moveSprite(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    const from = { x: GWU.xy.x(source), y: GWU.xy.y(source) };\n    map.addFx(from.x, from.y, entity);\n    let duration = opts.duration ||\n        Math.ceil(16 * (GWU.xy.maxAxisFromTo(source, target) / (opts.speed || 8)));\n    if (GWU.xy.isLoc(target)) {\n        target = { x: target[0], y: target[1] };\n    }\n    const tween = GWU.tween\n        .make(from)\n        .to(target)\n        .duration(duration)\n        .onUpdate((vals) => {\n        // tweens dont update every step, so...\n        // draw line from current pos to vals pos\n        // check each step for blocking...\n        // end at either vals or last blocking spot\n        const dest = { x: entity.x, y: entity.y };\n        const ok = GWU.xy.forLineBetween(dest.x, dest.y, vals.x, vals.y, (x, y) => {\n            if (opts.stepFn) {\n                if (opts.stepFn(x, y)) {\n                    if (!opts.stopBeforeWalls) {\n                        dest.x = x;\n                        dest.y = y;\n                    }\n                    return false;\n                }\n            }\n            else if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (!opts.stopBeforeWalls) {\n                    dest.x = x;\n                    dest.y = y;\n                }\n                return false;\n            }\n            dest.x = x;\n            dest.y = y;\n        });\n        map.moveFx(entity, dest.x, dest.y);\n        if (!ok) {\n            tween.stop();\n        }\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n        return entity;\n    });\n    return tween;\n}\nexport function bolt(map, source, target, sprite, opts = {}) {\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport function projectile(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    if (sprite.ch && sprite.ch.length == 4) {\n        const dir = GWU.xy.dirFromTo(source, target);\n        let index = 0;\n        if (dir[0] && dir[1]) {\n            index = 2;\n            if (dir[0] != dir[1]) {\n                // remember up is -y\n                index = 3;\n            }\n        }\n        else if (dir[0]) {\n            index = 1;\n        }\n        const ch = sprite.ch[index];\n        sprite = GWU.sprite.make(ch, sprite.fg, sprite.bg);\n    }\n    else if (sprite.ch && sprite.ch.length !== 1) {\n        throw new Error('projectile requires 4 chars - vert,horiz,diag-left,diag-right (e.g: \"|-\\\\/\")');\n    }\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport function beam(map, from, to, sprite, opts = {}) {\n    opts.fade = opts.fade || 100;\n    if (opts.stopAtWalls === undefined)\n        opts.stopAtWalls = true;\n    const line = [];\n    GWU.xy.forLineFromTo(from, to, (x, y) => {\n        if (!map.hasXY(x, y))\n            return false;\n        if (opts.stepFn && opts.stepFn(x, y))\n            return false;\n        if (opts.stopAtWalls || opts.stopBeforeWalls) {\n            if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (opts.stopBeforeWalls)\n                    return false;\n                line.push([x, y]);\n                return false;\n            }\n        }\n        line.push([x, y]);\n        return true;\n    });\n    const duration = opts.duration || Math.ceil(16 * (line.length / (opts.speed || 8)));\n    let lastIndex = -1;\n    const tween = GWU.tween\n        .make({ index: 0 })\n        .to({ index: line.length - 1 })\n        .duration(duration)\n        .onUpdate((vals) => {\n        while (lastIndex < vals.index) {\n            ++lastIndex;\n            const loc = line[lastIndex] || [-1, -1];\n            tween.addChild(fadeInOut(map, loc[0], loc[1], sprite, opts.fade));\n        }\n    });\n    return tween;\n}\nfunction isInShape(shape, cx, cy, allowCenter, x, y) {\n    const sx = Math.abs(x - cx);\n    const sy = Math.abs(y - cy);\n    if (sx == 0 && sy == 0 && !allowCenter)\n        return false;\n    switch (shape) {\n        case '+':\n            return sx == 0 || sy == 0;\n        case 'x':\n        case 'X':\n            return sx == sy;\n        case '*':\n            return sx == 0 || sy == 0 || sx == sy;\n        default:\n            return true;\n    }\n}\nfunction checkExplosionOpts(opts) {\n    opts.speed = opts.speed || 2;\n    opts.fade = opts.fade || 100;\n    opts.shape = opts.shape || 'o';\n    if (opts.center === undefined) {\n        opts.center = true;\n    }\n}\nexport function explosion(map, x, y, radius, sprite, opts = {}) {\n    checkExplosionOpts(opts);\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const grid = GWU.grid.alloc(map.width, map.height);\n    const fov = new GWU.fov.FOV({\n        isBlocked(x, y) {\n            return map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE);\n        },\n        hasXY(x, y) {\n            return map.hasXY(x, y);\n        },\n    });\n    fov.calculate(x, y, radius, (x1, y1) => {\n        grid[x1][y1] = 1;\n    });\n    const duration = opts.duration || 32 * (radius / opts.speed);\n    const tween = GWU.tween\n        .make({ r: 0 })\n        .to({ r: radius })\n        .duration(duration)\n        .onUpdate((vals) => {\n        const minX = Math.max(0, x - vals.r);\n        const minY = Math.max(0, y - vals.r);\n        const maxX = Math.min(map.width - 1, x + vals.r);\n        const maxY = Math.min(map.height - 1, y + vals.r);\n        for (let x1 = minX; x1 <= maxX; ++x1) {\n            for (let y1 = minY; y1 <= maxY; ++y1) {\n                if (grid[x1][y1] &&\n                    GWU.xy.distanceBetween(x, y, x1, y1) <= vals.r) {\n                    grid[x1][y1] = 0;\n                    if (isInShape(opts.shape, x, y, opts.center, x1, y1)) {\n                        tween.addChild(fadeInOut(map, x1, y1, sprite, opts.fade));\n                    }\n                }\n            }\n        }\n    })\n        .onFinish(() => {\n        GWU.grid.free(grid);\n    });\n    return tween;\n}\n","import * as ACTION from '../action';\n// import * as ACTOR from '../actor';\n// BUMP\n//\n// prefixes:\n// @ : only for player\n// + : only for ally\n// - : only for opposed\n// = : only for same kind\n// $ : use my action (if used with one of the above, this comes last)\n//\nexport function bump(action) {\n    const other = action.target;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor is required for bump.');\n    if (other) {\n        const bumpActions = other.getBumpActions();\n        for (let actionName of bumpActions) {\n            if (typeof actionName === 'string') {\n                if (actionName.startsWith('@')) {\n                    if (!actor.isPlayer())\n                        continue;\n                    actionName = actionName.substring(1);\n                    // } else if (actionName.startsWith('+')) {\n                    //     if (!actor.isAllyWith(other)) continue;\n                    //     actionName = actionName.substring(1);\n                    // } else if (actionName.startsWith('-')) {\n                    //     if (actor.isAllyWith(other)) continue;\n                    //     actionName = actionName.substring(1);\n                }\n                else if (actionName.startsWith('=')) {\n                    if (actor.kind !== other.kind)\n                        continue;\n                    actionName = actionName.substring(1);\n                }\n                if (actionName.startsWith('$')) {\n                    const selfName = actionName.substring(1);\n                    if (!other.canDoAction(selfName))\n                        throw new Error('Invalid bump choice - ' + actionName);\n                    other.trigger(selfName, action);\n                    if (action.isDone())\n                        return;\n                    // let selfAction: ACTOR.ActorActionResult =\n                    //     other.getAction(selfName);\n                    // if (selfAction === false) {\n                    //     throw new Error(\n                    //         'Cannot have bump action for self action that actor cannot do: ' +\n                    //             action\n                    //     );\n                    // }\n                    // const ctx2 = Object.assign({}, ctx, { actor });\n                    // const result = selfAction(game, other, ctx2);\n                    // if (result) return result;\n                }\n                else {\n                    ACTION.doAction(actionName, action);\n                    if (action.isDone())\n                        return;\n                    // const config = actor.getAction(actionName);\n                    // if (config === false) {\n                    //     throw new Error(\n                    //         'Cannot configure actor with bump action they cannot do: ' +\n                    //             action\n                    //     );\n                    // } else {\n                    //     action = config;\n                    // }\n                    // const result = action(game, actor, ctx);\n                    // if (result) return result;\n                }\n            }\n            else {\n                actionName(action);\n                if (action.isDone())\n                    return;\n            }\n        }\n    }\n    const item = action.item;\n    if (item) {\n        // TODO - Item Actions\n    }\n}\nACTION.install('bump', bump);\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nimport * as FX from '../fx';\nimport * as Flags from '../flags';\nimport { bump } from './bump';\nimport { standStill } from './standStill';\nexport function moveDir(action) {\n    //\n    const step = action.dir;\n    if (!step)\n        throw new Error('moveDir called with no direction!');\n    const actor = action.actor;\n    const map = action.map;\n    // const game = action.game;\n    if (!actor)\n        throw new Error('moveDir requires actor!');\n    const newX = actor.x + step[0];\n    const newY = actor.y + step[1];\n    const currentCell = map.cell(actor.x, actor.y);\n    const newCell = map.cell(newX, newY);\n    // actor, map/cell/tiles, game, global\n    // - give them all a chance to handle this\n    // if (action.defaultPrevented) return;\n    if (actor.forbidsCell(newCell)) {\n        if (action.try)\n            return action.didNothing();\n        if (actor.isPlayer()) {\n            FX.hit(map, newCell, 'hit', 100);\n            GWU.message.addAt(newCell.x, newCell.y, '{{you}} {{verb bump~}} into {{a cell}}.', { actor, cell: newCell });\n        }\n        actor.clearGoal();\n        actor.endTurn();\n        return action.didSomething();\n    }\n    if (newCell.blocksMove()) {\n        if (action.try)\n            return action.didNothing();\n        FX.hit(map, newCell, 'hit', 100);\n        actor.clearGoal();\n        actor.endTurn();\n        return action.didSomething();\n    }\n    // can we leave?\n    if (!currentCell.canRemoveActor(actor)) {\n        if (action.try)\n            return action.didNothing();\n        // canActorLeave must add appropriate message\n        actor.endTurn();\n        return action.didSomething();\n    }\n    // is there an actor there?\n    if (newCell.hasActor() || newCell.hasItem()) {\n        if (action.try)\n            return action.didNothing();\n        action.target = newCell.actor;\n        action.item = newCell.item;\n        return bump(action);\n    }\n    // can we enter?\n    if (!newCell.canAddActor(actor)) {\n        if (action.try)\n            return action.didNothing();\n        actor.endTurn();\n        return action.didSomething();\n    }\n    if (!map.moveActor(actor, newX, newY)) {\n        return standStill(action);\n    }\n    let rate = 100;\n    if (newCell.hasTileFlag(Flags.Tile.T_DEEP_WATER)) {\n        rate = 150;\n    }\n    actor.endTurn(rate);\n    return action.didSomething();\n}\nACTION.install('moveDir', moveDir);\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nimport { moveDir } from './moveDir';\nexport function idle(action) {\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Action requires an actor.');\n    if (GWU.random.chance(50)) {\n        // stand still\n        actor.endTurn();\n        return action.didSomething();\n    }\n    // try to step in a random direction\n    const dirIndex = GWU.random.number(4);\n    action.dir = GWU.xy.DIRS[dirIndex];\n    return moveDir(action);\n}\nACTION.install('idle', idle);\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nexport function pickup(action) {\n    const map = action.map;\n    if (!map)\n        throw new Error('Map is required!');\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor is required.');\n    const item = map.itemAt(action.x, action.y);\n    if (!item) {\n        if (!action.quiet) {\n            GWU.message.addAt(action.x, action.y, 'Nothing to pickup.');\n        }\n        return action.didNothing();\n    }\n    if (actor.avoidsItem(item))\n        return action.didNothing();\n    if (item.canDoAction('pickup') === false) {\n        if (!action.quiet) {\n            GWU.message.addAt(actor.x, actor.y, '{{you}} cannot pickup {{the item}}.', {\n                actor,\n                item,\n            });\n        }\n        return action.didNothing();\n    }\n    // logs error messages\n    if (!actor.canAddItem(item)) {\n        return action.didNothing();\n    }\n    if (!map.removeItem(item)) {\n        return action.didNothing();\n    }\n    actor.addItem(item);\n    if (!action.quiet) {\n        GWU.message.addAt(actor.x, actor.y, '{{you}} {{verb pick[s]}} up {{an item}}.', {\n            actor,\n            item,\n        });\n    }\n    actor.endTurn();\n    action.didSomething();\n}\nACTION.install('pickup', pickup);\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nimport * as Flags from '../flags';\nexport function climb(action) {\n    const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor is required.');\n    const x = action.x;\n    const y = action.y;\n    if (map.hasTileFlag(x, y, Flags.Tile.T_UP_STAIRS)) {\n        GWU.message.addAt(x, y, '{{you}} {{verb climb[s]}}.', { actor });\n        action.game.startNewMap({ up: true });\n        actor.endTurn();\n        return action.didSomething();\n    }\n    GWU.message.addAt(x, y, 'Nothing to climb.');\n    actor.endTurn(50); // half turn??\n    return action.didSomething();\n}\nACTION.install('climb', climb);\n","import { installHandler } from '../effect';\nexport function fn(cfg) {\n    if (typeof cfg === 'function')\n        return cfg;\n    return (a) => {\n        for (let fn of cfg) {\n            fn(a);\n            if (a.isDone())\n                return;\n        }\n    };\n}\ninstallHandler('fn', fn);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// ActivateMachine\nexport function activateMachine() {\n    return activateMachineAction.bind(undefined);\n}\nexport function activateMachineAction(action) {\n    const map = action.map;\n    const cell = map.cell(action.x, action.y);\n    const machine = cell.machineId;\n    if (!machine)\n        return action.didNothing();\n    action.originX = action.x;\n    action.originY = action.y;\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.machineId !== machine)\n                continue;\n            cell.trigger('machine', action); // will set didSomething or didNothing\n        }\n    }\n}\ninstallHandler('activateMachine', activateMachine);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// chance\nexport function chance(opts) {\n    if (Array.isArray(opts)) {\n        opts = opts[0];\n    }\n    if (typeof opts === 'object') {\n        opts = opts.chance;\n    }\n    if (typeof opts === 'string') {\n        if (opts.endsWith('%')) {\n            opts = Number.parseFloat(opts) * 100;\n        }\n        else {\n            opts = Number.parseInt(opts || '10000');\n        }\n    }\n    if (typeof opts !== 'number') {\n        throw new Error('Chance effect config must be number or string that can be a number.');\n    }\n    return chanceAction.bind(undefined, opts);\n}\nexport function chanceAction(cfg, action) {\n    const map = action.map;\n    if (!map.rng.chance(cfg, 10000)) {\n        return action.stop();\n    }\n}\ninstallHandler('chance', chance);\n","import * as Flags from '../flags';\nimport { installHandler } from '../effect';\nexport function clear(config) {\n    let layers = 0;\n    if (!config) {\n        layers = Flags.Depth.ALL_LAYERS;\n    }\n    else if (typeof config === 'number') {\n        layers = config;\n    }\n    else if (typeof config === 'string') {\n        const parts = config.split(/[,|]/g);\n        layers = parts.reduce((out, v) => {\n            if (typeof v === 'number')\n                return out | v;\n            const depth = Flags.Depth[v] || 0;\n            return out | depth;\n        }, 0);\n    }\n    else {\n        throw new Error('Invalid config for clear effect: ' + JSON.stringify(config));\n    }\n    return clearAction.bind(undefined, layers);\n}\nexport function clearAction(layers, action) {\n    if (!layers)\n        return action.didNothing();\n    const cell = action.map.cell(action.x, action.y);\n    if (cell.clearDepth(layers)) {\n        action.didSomething();\n    }\n    else {\n        action.didNothing();\n    }\n}\ninstallHandler('clear', clear);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// EMIT\nexport function emit(config) {\n    if (Array.isArray(config))\n        config = config[0];\n    if (typeof config !== 'string')\n        throw new Error('Invalid EMIT handler config - ' + config);\n    return emitAction.bind(undefined, config);\n}\nexport function emitAction(id, action) {\n    action.actor && action.actor.trigger(id, action);\n    if (action.isDone())\n        return;\n    action.item && action.item.trigger(id, action);\n    if (action.isDone())\n        return;\n    action.map.trigger(id, action);\n    if (action.isDone())\n        return;\n    action.game.trigger(id, action);\n}\ninstallHandler('emit', emit);\n","import * as Effect from '../effect';\nexport function feature(id) {\n    if (Array.isArray(id))\n        id = id[0];\n    if (id && typeof id !== 'string') {\n        id = id.id;\n    }\n    if (!id || !id.length)\n        throw new Error('Feature effect needs ID');\n    return featureAction.bind(undefined, id);\n}\nexport function featureAction(id, action) {\n    const feat = Effect.installed[id];\n    if (!feat) {\n        throw new Error('Failed to find feature: ' + id);\n    }\n    return feat(action);\n}\nEffect.installHandler('feature', feature);\nEffect.installHandler('effect', feature);\nEffect.installHandler('id', feature);\n","import * as GWU from 'gw-utils';\nimport { installHandler } from '../effect';\n//////////////////////////////////////////////\n// MESSAGE\nexport function msg(src) {\n    if (Array.isArray(src))\n        src = src[0];\n    if (typeof src !== 'string') {\n        throw new Error('Need message for message effect.');\n    }\n    const info = {\n        msg: src,\n    };\n    return messageAction.bind(undefined, info);\n}\nexport function messageAction(info, action) {\n    const seen = action.seen;\n    const msg = info.msg;\n    if (msg &&\n        msg.length &&\n        action.aware &&\n        !seen\n    // && map.isVisible(x, y)\n    ) {\n        GWU.message.addAt(action.x, action.y, msg, action);\n        return action.didSomething();\n    }\n    return action.didNothing();\n}\ninstallHandler('msg', msg);\n","import * as GWU from 'gw-utils';\nimport * as EFFECT from '../effect';\nexport function nourish(opts) {\n    if (!opts)\n        throw new Error('Invalid Nourish config.');\n    let info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.type = opts[0] || 'inc';\n        info.amount = GWU.range.make(opts[1] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(opts.amount || 1);\n    }\n    else {\n        throw new Error('Invalid Nourish config: ' + JSON.stringify(opts));\n    }\n    return nourishAction.bind(undefined, info);\n}\nexport function nourishAction(config, action) {\n    if (!config.amount)\n        return action.didNothing();\n    // who am I nourishing?\n    const map = action.map;\n    const actor = map.actorAt(action.x, action.y);\n    if (!actor) {\n        return action.didNothing();\n    }\n    const stats = actor.stats;\n    const c = stats.get('food');\n    if (!stats.adjust('food', config.type, config.amount))\n        return action.didNothing();\n    const n = stats.get('food');\n    if (n < c && n / stats.max('food') < 0.1) {\n        GWU.message.addAt(actor.x, actor.y, nourishAction.default.pukeMsg, {\n            actor,\n        });\n    }\n    return action.didSomething();\n}\nnourishAction.default = {\n    pukeMsg: '%you vomit.',\n};\nEFFECT.installHandler('nourish', nourish);\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as EFFECT from '../effect';\nexport function spread(...args) {\n    let config = {};\n    if (!args.length) {\n        throw new Error('Must have config to create spread.');\n    }\n    if (args.length === 1) {\n        if (typeof args[0] === 'string') {\n            args = args[0].split(':').map((t) => t.trim());\n        }\n        else if (Array.isArray(args[0])) {\n            args = args[0];\n        }\n        else {\n            Object.assign(config, args[0]);\n            args = [config];\n        }\n    }\n    if (args.length >= 3) {\n        Object.assign(config, args[3] || {});\n        config.grow = Number.parseInt(args[0]);\n        config.decrement = Number.parseInt(args[1]);\n        config.actions = args[2];\n    }\n    else if (args.length === 2) {\n        throw new Error('Must have actions to run for spread.');\n    }\n    if (typeof config.grow !== 'number')\n        config.grow = Number.parseInt(config.grow || 0);\n    if (typeof config.decrement !== 'number')\n        config.decrement = Number.parseInt(config.decrement || 100);\n    config.flags = GWU.flag.from(Flags.Effect, config.flags || 0);\n    config.matchTile = config.matchTile || '';\n    const action = EFFECT.makeArray(config.actions);\n    if (!action)\n        throw new Error('Failed to make action for spread.');\n    config.actions = action;\n    const fn = spreadAction.bind(config);\n    fn.config = config;\n    return fn;\n}\nEFFECT.installHandler('spread', spread);\nexport function spreadAction(action) {\n    const abortIfBlocking = !!(this.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n    const map = action.map;\n    const spawnMap = GWU.grid.alloc(map.width, map.height);\n    if (!computeSpawnMap(this, action, spawnMap)) {\n        GWU.grid.free(spawnMap);\n        return action.didNothing();\n    }\n    if (abortIfBlocking && mapDisruptedBy(map, spawnMap)) {\n        GWU.grid.free(spawnMap);\n        return action.didNothing();\n    }\n    if (this.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n        // first, evacuate creatures, so that they do not re-trigger the tile.\n        if (evacuateCreatures(map, spawnMap)) {\n            action.didSomething();\n        }\n    }\n    if (this.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n        // first, evacuate items, so that they do not re-trigger the tile.\n        if (evacuateItems(map, spawnMap)) {\n            action.didSomething();\n        }\n    }\n    if (this.flags & Flags.Effect.E_CLEAR_CELL) {\n        // first, clear other tiles (not base/ground)\n        if (clearCells(map, spawnMap, this.flags)) {\n            action.didSomething();\n        }\n    }\n    spawnMap.update((v) => {\n        if (!v)\n            return 0;\n        return 1;\n    });\n    let didSomething = action.isSuccess();\n    this.actions.forEach((fn, i) => {\n        spawnMap.forEach((v, x, y) => {\n            if (v !== i + 1)\n                return;\n            action.reset();\n            action.x = x;\n            action.y = y;\n            fn(action);\n            if (action.isSuccess()) {\n                didSomething = true;\n                spawnMap[x][y] += 1;\n            }\n        });\n    });\n    if (didSomething) {\n        action.didSomething();\n    }\n    GWU.grid.free(spawnMap);\n}\nexport function mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(map.width, map.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (map.cell(i, j).isStairs()) {\n                disrupts = true;\n            }\n        }\n        else if (!map.cell(i, j).blocksMove()) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGWU.grid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cell(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cell(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.matchTile && !isStart && !cell.hasTile(effect.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, loc, spawnMap) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const map = loc.map;\n    let startProb = effect.grow || 0;\n    let probDec = effect.decrement || 0;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, loc.x, loc.y, true)) {\n        return false;\n    }\n    spawnMap[loc.x][loc.y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap[a.x][a.y])\n            return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const c = map.cell(x, y);\n            return !a.forbidsCell(c);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeActor(a);\n            map.addActor(loc[0], loc[1], a);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap[i.x][i.y])\n            return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const dest = map.cell(x, y);\n            return !i.forbidsCell(dest);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(i);\n            map.addItem(loc[0], loc[1], i);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nexport function stat(opts) {\n    if (!opts)\n        throw new Error('Invalid Stat config.');\n    const info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.stat = opts[0];\n        info.type = opts[1] || 'inc';\n        info.amount = GWU.range.make(opts[2] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.stat = opts.stat;\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(info.amount || 1);\n    }\n    else {\n        throw new Error('Invalid stat effect configuration: ' + JSON.stringify(opts));\n    }\n    return statAction.bind(undefined, info);\n}\nexport function statAction(config, action) {\n    if (!config.amount)\n        return action.didNothing();\n    // who am I nourishing?\n    const actor = action.actor || action.map.actorAt(action.x, action.y);\n    if (!actor) {\n        return action.didNothing();\n    }\n    // sustain?\n    const stats = actor.stats;\n    if (!stats.adjust(config.stat, config.type, config.amount))\n        return action.didNothing();\n    return action.didSomething();\n}\nEffect.installHandler('stat', stat);\n","import { installHandler } from '../effect';\nimport * as Flags from '../flags';\nexport function tile(src) {\n    if (!src)\n        throw new Error('Tile effect needs configuration.');\n    if (typeof src === 'string') {\n        src = { id: src };\n    }\n    else if (Array.isArray(src)) {\n        src = { id: src[0] };\n    }\n    else if (!src.id) {\n        throw new Error('Tile effect needs configuration with id.');\n    }\n    const opts = src;\n    if (opts.id.includes('!')) {\n        opts.superpriority = true;\n    }\n    if (opts.id.includes('~')) {\n        opts.blockedByActors = true;\n        opts.blockedByItems = true;\n    }\n    if (opts.id.includes('+')) {\n        opts.protected = true;\n    }\n    opts.id = opts.id.replace(/[!~+]*/g, '');\n    return tileAction.bind(undefined, opts);\n}\nexport function tileAction(cfg, action) {\n    const map = action.map;\n    cfg.machine = action.machine || 0;\n    if (map.setTile(action.x, action.y, cfg.id, cfg)) {\n        if (cfg.protected) {\n            map.setCellFlag(action.x, action.y, Flags.Cell.EVENT_PROTECTED);\n        }\n        action.didSomething();\n    }\n}\ninstallHandler('tile', tile);\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile, _opts) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nexport function gas(map) {\n    const cleanup = [];\n    map.data.gas = true;\n    cleanup.push(map.on('tick', () => {\n        gasTick(map);\n    }));\n    cleanup.push(map.on('copy', (src) => {\n        if (!src.data.gas) {\n            // remove gas\n            cleanup.forEach((c) => c());\n        }\n    }));\n    cleanup.push(map.on('assign', (dest) => {\n        if (!dest.data.gas) {\n            // install gas\n            gas(dest);\n        }\n    }));\n}\nfunction gasTick(map) {\n    if (!map.hasMapFlag(Flags.Map.MAP_HAS_GAS))\n        return;\n    const updatedVolumes = GWU.grid.alloc(map.width, map.height);\n    // dissipate the gas...\n    dissipateGas(map, updatedVolumes);\n    // spread the gas...\n    spreadGas(map, updatedVolumes);\n    GWU.grid.free(updatedVolumes);\n}\nfunction dissipateGas(map, volume) {\n    map.cells.forEach((cell, x, y) => {\n        if (!cell.volume) {\n            volume[x][y] = 0;\n        }\n        else {\n            let v = cell.volume;\n            const tile = cell.depthTile(Flags.Depth.GAS);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (!v) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            else {\n                cell.volume = v;\n            }\n            volume[x][y] = v;\n        }\n    });\n}\n// function calcOpacity(volume: number): number {\n//     return Math.floor(Math.min(volume, 10) * 10);\n// }\nfunction updateCellVolume(map, x, y, startingVolume) {\n    let total = 0;\n    let count = 0;\n    let highestVolume = 0;\n    const cell = map.cell(x, y);\n    let startingTile = cell.depthTile(Flags.Depth.GAS);\n    let highestTile = startingTile;\n    if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n        startingVolume[x][y] = 0;\n        cell.volume = 0;\n        return;\n    }\n    for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n        for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n            const v = startingVolume[i][j];\n            if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                ++count;\n                if (v > highestVolume) {\n                    highestVolume = v;\n                    highestTile = map.cell(i, j).depthTile(Flags.Depth.GAS);\n                }\n            }\n            total += v;\n        }\n    }\n    const v = Math.floor((total * 10) / count) / 10;\n    // startingVolume[x][y] = v;\n    if (v > 0 && highestTile) {\n        if (!startingTile || startingTile !== highestTile) {\n            cell.setTile(highestTile, { volume: v });\n        }\n        else {\n            cell.volume = v;\n        }\n    }\n    if (v > 0) {\n        cell.needsRedraw = true;\n    }\n}\nfunction spreadGas(map, startingVolume) {\n    for (let x = 0; x < startingVolume.width; ++x) {\n        for (let y = 0; y < startingVolume.height; ++y) {\n            updateCellVolume(map, x, y, startingVolume);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport function fire(map) {\n    map.data.fire = true;\n    const cancelFns = [];\n    cancelFns.push(map.on('tick', () => {\n        fireTick(map);\n    }));\n    cancelFns.push(map.on('assign', (dest) => {\n        if (!dest.data.fire) {\n            fire(dest);\n        }\n    }));\n    // Not sure if we should do this, but...\n    cancelFns.push(map.on('copy', (src) => {\n        if (!src.data.fire) {\n            cancelFns.forEach((c) => c());\n        }\n    }));\n}\nfunction fireTick(map) {\n    // Run any tick effects\n    if (!map.hasMapFlag(Flags.Map.MAP_HAS_FIRE))\n        return;\n    map.clearMapFlag(Flags.Map.MAP_HAS_FIRE);\n    // Bookkeeping for fire\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n        }\n    }\n    // now spread the fire...\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                exposeToFire(map, x, y, false);\n                for (let d = 0; d < 4; ++d) {\n                    const dir = GWU.xy.DIRS[d];\n                    exposeToFire(map, x + dir[0], y + dir[1]);\n                }\n            }\n        }\n    }\n    if (map.someCell((c) => c.hasTileFlag(Flags.Tile.T_IS_FIRE))) {\n        map.setMapFlag(Flags.Map.MAP_HAS_FIRE);\n    }\n}\nfunction exposeToFire(map, x, y, alwaysIgnite = false) {\n    let firePriority = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n    let explosivePromotion = false;\n    const cell = map.cell(x, y);\n    if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n        return false;\n    }\n    cell.eachTile((tile) => {\n        // Pick the extinguishing layer with the best priority.\n        if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n            tile.priority > bestExtinguishingPriority) {\n            bestExtinguishingPriority = tile.priority;\n        }\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n            tile.priority > firePriority) {\n            firePriority = tile.priority;\n        }\n    });\n    // didNothing\n    if (bestExtinguishingPriority >= firePriority && !alwaysIgnite)\n        return false;\n    // Count explosive neighbors.\n    if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n        GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n            const n = map.cell(x0, y0);\n            if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                ++explosiveNeighborCount;\n            }\n        });\n        if (explosiveNeighborCount >= 8) {\n            explosivePromotion = true;\n        }\n    }\n    let event = 'fire';\n    if (explosivePromotion && cell.hasAction('explode')) {\n        event = 'explode';\n    }\n    // cell.eachTile( (tile) => {\n    //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n    //         if (tile.depth === Depth.GAS) {\n    //             cell.gasVolume = 0;\n    //         } else if (tile.depth === Depth.LIQUID) {\n    //             cell.liquidVolume = 0;\n    //         }\n    //     }\n    // });\n    cell.trigger(event, {\n        force: true,\n    });\n    // cell.needsRedraw = true;\n    return true;\n}\n","import { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts) {\n        const cell = this.map.cell(x, y);\n        return cell.setTile(tile, opts);\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // // Bookkeeping for fire, pressure plates and key-activated tiles.\n        // for (let x = 0; x < this.map.width; ++x) {\n        //     for (let y = 0; y < this.map.height; ++y) {\n        //         const cell = this.map.cell(x, y);\n        //         if (\n        //             !cell.hasCellFlag(\n        //                 Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM\n        //             ) &&\n        //             cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)\n        //         ) {\n        //             cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n        //         }\n        //     }\n        // }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nconst highlightColor = GWU.color.install('highlight', [100, 100, 0]);\nexport class BasicDrawer {\n    constructor() {\n        this.scent = false;\n    }\n    drawInto(dest, map, opts = {}) {\n        const offsetX = opts.offsetX || 0;\n        const offsetY = opts.offsetY || 0;\n        map.clearMapFlag(Flags.Map.MAP_DANCES);\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < dest.width; ++x) {\n            for (let y = 0; y < dest.height; ++y) {\n                if (map.hasXY(x + offsetX, y + offsetY)) {\n                    const cell = map.cell(x + offsetX, y + offsetY);\n                    this.drawCell(mixer, map, cell, map.fov);\n                    dest.draw(x, y, mixer.ch || ' ', mixer.fg, mixer.bg);\n                }\n            }\n        }\n    }\n    drawCell(dest, map, cell, fov) {\n        dest.blackOut();\n        // const isVisible = fov ? fov.isAnyKindOfVisible(cell.x, cell.y) : true;\n        const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (cell.needsRedraw || needSnapshot) {\n            this.getAppearance(dest, map, cell);\n            cell.putSnapshot(dest);\n            cell.needsRedraw = false;\n            cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n        else {\n            cell.getSnapshot(dest);\n            if (cell.hasCellFlag(Flags.Cell.COLORS_DANCE)) {\n                map.setMapFlag(Flags.Map.MAP_DANCES);\n            }\n        }\n        this.applyLight(dest, cell, fov);\n        let separate = false;\n        if (cell.memory) {\n            separate = !!((cell.memory.flags.entity & Flags.Entity.L_VISUALLY_DISTINCT)\n            // Flags.Entity.L_LIST_IN_SIDEBAR)\n            );\n        }\n        else {\n            separate = cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT, \n            // Flags.Entity.L_LIST_IN_SIDEBAR,\n            true);\n        }\n        if (cell.hasCellFlag(Flags.Cell.IS_CURSOR)) {\n            dest.bg = highlightColor;\n            dest.fg = dest.bg.inverse();\n            separate = true;\n        }\n        else if (cell.hasCellFlag(Flags.Cell.IS_HIGHLIGHTED)) {\n            dest.bg = highlightColor.mix(dest.bg, 35);\n            dest.fg = dest.bg.inverse();\n            separate = true;\n        }\n        if (this.scent && map.player) {\n            const s = GWU.clamp(map.player.scent.get(cell.x, cell.y) * 5, 0, 50);\n            if (s) {\n                const c = GWU.color.colors.red;\n                dest.mix(c, 0, s);\n            }\n        }\n        if (separate) {\n            [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n        }\n        return true;\n    }\n    // getCellAppearance(cell: CellType, dest: GWU.sprite.Mixer) {\n    //     dest.blackOut();\n    //     const isVisible = true; // this.fov.isAnyKindOfVisible(x, y);\n    //     const isRevealed = true; // this.fov.isRevealed(x, y);\n    //     const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     if (needSnapshot || (cell.needsRedraw && isVisible)) {\n    //         this.layers.forEach((layer) => layer.putAppearance(dest, cell));\n    //         if (dest.dances) {\n    //             cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n    //         } else {\n    //             cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n    //         }\n    //         dest.bake();\n    //         cell.putSnapshot(dest);\n    //         cell.needsRedraw = false;\n    //         cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     } else {\n    //         cell.getSnapshot(dest);\n    //     }\n    //     if (isVisible) {\n    //         const light = this.light.getLight(cell.x, cell.y);\n    //         dest.multiply(light);\n    //     } else if (isRevealed) {\n    //         dest.scale(50);\n    //     } else {\n    //         dest.blackOut();\n    //     }\n    //     if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n    //         [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n    //     }\n    // }\n    getAppearance(dest, map, cell) {\n        let tiles = cell.tiles;\n        let actor = null;\n        let item = null;\n        if (cell.memory) {\n            tiles = cell.memory.tiles;\n            item = cell.memory.item;\n        }\n        else {\n            actor = cell.hasActor() ? cell.actor : null;\n            item = cell.hasItem() ? cell.item : null;\n        }\n        const ground = tiles[Flags.Depth.GROUND];\n        const surface = tiles[Flags.Depth.SURFACE];\n        const liquid = tiles[Flags.Depth.LIQUID];\n        const gas = tiles[Flags.Depth.GAS]; // How to get volume!?!?!?!\n        dest.drawSprite(ground.sprite);\n        if (surface) {\n            dest.drawSprite(surface.sprite);\n        }\n        if (liquid) {\n            dest.drawSprite(liquid.sprite);\n        }\n        if (item) {\n            item.drawInto(dest);\n        }\n        if (actor) {\n            actor.drawInto(dest);\n        }\n        if (gas) {\n            const opacity = GWU.rng.cosmetic.number(50) + 25;\n            dest.drawSprite(gas.sprite, opacity);\n        }\n        if (cell.hasFx()) {\n            const fx = map.fxAt(cell.x, cell.y);\n            if (fx)\n                dest.drawSprite(fx.sprite);\n        }\n        if (dest.dances) {\n            cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n            map.setMapFlag(Flags.Map.MAP_DANCES);\n        }\n        else {\n            cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n        }\n        dest.bake(true); // apply dancing\n    }\n    applyLight(dest, cell, fov) {\n        const isVisible = !fov || fov.isAnyKindOfVisible(cell.x, cell.y);\n        const isRevealed = !fov || fov.isRevealed(cell.x, cell.y);\n        const light = cell.map.light.getLight(cell.x, cell.y);\n        dest.multiply(light);\n        // TODO - is Clairy\n        // TODO - is Telepathy\n        if (fov && fov.isCursor(cell.x, cell.y)) {\n            dest.invert();\n        }\n        else if (!isVisible) {\n            if (cell.hasEntityFlag(Flags.Entity.L_BRIGHT_MEMORY)) {\n            }\n            else if (isRevealed) {\n                dest.scale(70);\n            }\n            else {\n                dest.blackOut();\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport { Tile } from '../tile';\nimport { BasicDrawer } from '../draw/basic';\nimport * as ACTION from '../action';\n// export interface MapEvents extends GWU.events.Events {\n//     // add or remove actor\n//     actor: (map: Map, actor: Actor, isNew: boolean) => void;\n//     // add or remove item\n//     item: (map: Map, item: Item, isNew: boolean) => void;\n//     // add or remove fx\n//     fx: (map: Map, fx: Entity, isNew: boolean) => void;\n//     // change cell tiles\n//     cell: (map: Map, cell: Cell) => void;\n// }\nexport class Map {\n    constructor(width, height, opts = {}) {\n        this.locations = {};\n        // _memory: GWU.grid.Grid<CellMemory>;\n        // machineCount = 0;\n        // _seed = 0;\n        this.rng = GWU.rng.random;\n        this.id = 0;\n        this.actors = [];\n        this.items = [];\n        this.fx = [];\n        this.player = null;\n        this._tweens = new GWU.app.Tweens();\n        // actions = new ACTION.Actions(this);\n        this.events = new GWU.app.Events(this);\n        this.flags = { map: 0 };\n        // this.layers = [];\n        this.data = { seed: 0, machineCount: 0 };\n        if (opts.id) {\n            this.data.id = opts.id;\n        }\n        this.drawer = opts.drawer || new BasicDrawer();\n        this.cells = GWU.grid.make(width, height, (x, y) => new Cell(this, x, y));\n        // this._memory = GWU.grid.make(\n        //     width,\n        //     height,\n        //     (x, y) => new CellMemory(this, x, y)\n        // );\n        if (opts.seed) {\n            this.data.seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        if (opts.fov === undefined) {\n            opts.alwaysVisible = true;\n        }\n        else if (opts.fov === false) {\n            opts.visible = true;\n        }\n        opts.callback = this.onFovChange.bind(this);\n        this.fov = new GWU.fov.FovSystem(this, opts);\n        // this.initLayers();\n        if (opts.player) {\n            this.setPlayer(opts.player);\n        }\n        if (opts.actions) {\n            this.events.load(opts.actions);\n        }\n    }\n    get seed() {\n        return this.data.seed;\n    }\n    set seed(v) {\n        this.data.seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    get width() {\n        return this.cells.width;\n    }\n    get height() {\n        return this.cells.height;\n    }\n    // memory(x: number, y: number): CellMemory {\n    //     return this._memory[x][y];\n    // }\n    // knowledge(x: number, y: number): CellInfoType {\n    //     if (this.fov.isAnyKindOfVisible(x, y)) return this.cell(x,y);\n    //     return this._memory[x][y];\n    // }\n    // LAYERS\n    // initLayers() {\n    //     this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n    //     this.addLayer(\n    //         Flags.Depth.SURFACE,\n    //         new Layer.FireLayer(this, 'surface')\n    //     );\n    //     this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n    // }\n    // addLayer(depth: number | keyof typeof Flags.Depth, layer: LayerType) {\n    //     if (typeof depth !== 'number') {\n    //         depth = Flags.Depth[depth as keyof typeof Flags.Depth];\n    //     }\n    //     layer.depth = depth;\n    //     this.layers[depth] = layer;\n    // }\n    // removeLayer(depth: number | keyof typeof Flags.Depth) {\n    //     if (typeof depth !== 'number') {\n    //         depth = Flags.Depth[depth as keyof typeof Flags.Depth];\n    //     }\n    //     if (!depth) throw new Error('Cannot remove layer with depth=0.');\n    //     delete this.layers[depth];\n    // }\n    // getLayer(depth: number | keyof typeof Flags.Depth): LayerType | null {\n    //     if (typeof depth !== 'number') {\n    //         depth = Flags.Depth[depth as keyof typeof Flags.Depth];\n    //     }\n    //     return this.layers[depth] || null;\n    // }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    someCell(cb) {\n        return this.cells.some((c, x, y) => cb(c, x, y, this));\n    }\n    // items\n    hasItem(x, y) {\n        return this.cell(x, y).hasItem();\n    }\n    itemAt(x, y) {\n        return this.items.find((i) => i.isAt(x, y)) || null;\n    }\n    eachItem(cb) {\n        this.items.forEach(cb);\n    }\n    addItem(x, y, item, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        // if (!cell.canAddItem(item)) return false;\n        if (cell._addItem(item)) {\n            const index = this.items.indexOf(item);\n            if (index < 0) {\n                this.items.push(item);\n            }\n            item.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddItemEffects(item, cell);\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddItemEffects(item, cell) {\n        if (item.key &&\n            item.key.matches(cell.x, cell.y) &&\n            cell.hasAction('key')) {\n            cell.trigger('key', { map: this, key: true, item });\n        }\n        else if (cell.hasAction('place')) {\n            cell.trigger('place', { map: this, item });\n        }\n    }\n    addItemNear(x, y, item, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasItem())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (item.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addItem(loc[0], loc[1], item, fireEffects);\n    }\n    removeItem(item, fireEffects = false) {\n        const cell = this.cell(item.x, item.y);\n        // if (!cell.canRemoveItem(item)) return false;\n        if (cell._removeItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, cell);\n            }\n            GWU.arrayDelete(this.items, item);\n            item.removeFromMap();\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveItemEffects(item, cell) {\n        if (item.isKey(cell.x, cell.y) && cell.hasAction('no_key')) {\n            cell.trigger('no_key', {\n                map: this,\n                key: true,\n                item,\n            });\n        }\n        else if (cell.hasAction('remove')) {\n            cell.trigger('remove', { map: this, key: true, item });\n        }\n    }\n    moveItem(item, x, y, fireEffects = false) {\n        if (item.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this.cell(item.x, item.y);\n        const newCell = this.cell(x, y);\n        // if (!currentCell.canRemoveItem(item)) return false;\n        // if (!newCell.canAddItem(item)) return false;\n        currentCell._removeItem(item);\n        if (newCell._addItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, currentCell);\n                this._fireAddItemEffects(item, newCell);\n            }\n            item.addToMap(this, x, y);\n        }\n        return true;\n    }\n    //  moveItem(item: Item, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = item.x;\n    //     const oldY = item.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[item.depth] as Layer.ItemLayer;\n    //     if (!( layer.removeItem(item))) return false;\n    //     if (!( this.addItem(x, y, item))) {\n    //         layer.forceItem(item.x, item.y, item);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (item.lastSeen) {\n    //     //         this._memory[item.lastSeen.x][item.lastSeen.y].removeItem(item);\n    //     //         this.clearCellFlag(\n    //     //             item.lastSeen.x,\n    //     //             item.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         item.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.item = item;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     item.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    setPlayer(player) {\n        this.player = player;\n    }\n    actorAt(x, y) {\n        return this.actors.find((a) => a.isAt(x, y)) || null;\n    }\n    eachActor(cb) {\n        this.actors.forEach(cb);\n    }\n    addActor(x, y, actor, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (!cell.canAddActor(actor))\n            return false;\n        if (cell._addActor(actor)) {\n            const index = this.actors.indexOf(actor);\n            if (index < 0) {\n                this.actors.push(actor);\n            }\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddActorEffects(actor, cell);\n            }\n            if (index < 0) {\n                this.trigger('enter', { map: this, actor });\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddActorEffects(actor, cell) {\n        if (actor.isKey(cell.x, cell.y) && cell.hasAction('key')) {\n            cell.trigger('key', { map: this, key: true, actor });\n        }\n        else if (actor.isPlayer() && cell.hasAction('player-enter')) {\n            cell.trigger('player-enter', {\n                map: this,\n                actor,\n            });\n        }\n        else if (cell.hasAction('enter')) {\n            cell.trigger('enter', { map: this, actor });\n        }\n    }\n    addActorNear(x, y, actor, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasActor())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addActor(loc[0], loc[1], actor, fireEffects);\n    }\n    removeActor(actor, fireEffects = false) {\n        const cell = this.cell(actor.x, actor.y);\n        if (!cell.canRemoveActor(actor))\n            return false;\n        if (cell._removeActor(actor)) {\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, cell);\n            }\n            actor.removeFromMap();\n            GWU.arrayDelete(this.actors, actor);\n            this.trigger('exit', { map: this, actor });\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveActorEffects(actor, cell) {\n        if (actor.isKey(actor.x, actor.y) && cell.hasAction('no_key')) {\n            cell.trigger('no_key', { map: this, key: true, actor });\n        }\n        else if (actor.isPlayer() && cell.hasAction('player-exit')) {\n            cell.trigger('player-exit', { map: this, actor });\n        }\n        else if (cell.hasAction('exit')) {\n            cell.trigger('exit', { map: this, actor });\n        }\n    }\n    moveActor(actor, x, y, fireEffects = false) {\n        if (actor.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this.cell(actor.x, actor.y);\n        const newCell = this.cell(x, y);\n        // if (!currentCell.canRemoveActor(actor)) return false;\n        // if (!newCell.canAddActor(actor)) return false;\n        currentCell._removeActor(actor);\n        if (newCell._addActor(actor)) {\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, currentCell);\n                this._fireAddActorEffects(actor, newCell);\n            }\n        }\n        return true;\n    }\n    //  moveActor(actor: Actor, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = actor.x;\n    //     const oldY = actor.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[actor.depth] as Layer.ActorLayer;\n    //     if (!( layer.removeActor(actor))) return false;\n    //     if (!( layer.addActor(x, y, actor))) {\n    //         layer.forceActor(actor.x, actor.y, actor);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (actor.lastSeen) {\n    //     //         this._memory[actor.lastSeen.x][actor.lastSeen.y].removeActor(\n    //     //             actor\n    //     //         );\n    //     //         this.clearCellFlag(\n    //     //             actor.lastSeen.x,\n    //     //             actor.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         actor.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.actor = actor;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     actor.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    fxAt(x, y) {\n        return this.fx.find((i) => i.isAt(x, y)) || null;\n    }\n    eachFx(cb) {\n        this.fx.forEach(cb);\n    }\n    addFx(x, y, fx) {\n        const cell = this.get(x, y);\n        if (!cell)\n            return false;\n        fx.x = x;\n        fx.y = y;\n        cell._addFx(fx);\n        this.fx.push(fx);\n        // this.events.emit('fx', this, fx, true);\n        return true;\n    }\n    moveFx(fx, x, y) {\n        const current = this.get(fx.x, fx.y);\n        const updated = this.get(x, y);\n        if (!updated)\n            return false;\n        current._removeFx(fx);\n        fx.x = x;\n        fx.y = y;\n        updated._addFx(fx);\n        return true;\n    }\n    removeFx(fx) {\n        const cell = this.get(fx.x, fx.y);\n        GWU.arrayDelete(this.fx, fx);\n        if (cell) {\n            cell._removeFx(fx);\n        }\n        // this.events.emit('fx', this, fx, false);\n        return true;\n    }\n    // Information\n    // isVisible(x: number, y: number): boolean {\n    //     return this.fov.isAnyKindOfVisible(x, y);\n    // }\n    hasKey(x, y) {\n        const actor = this.actorAt(x, y);\n        if (actor && actor.isKey(x, y))\n            return true;\n        const item = this.itemAt(x, y);\n        if (item && item.isKey(x, y))\n            return true;\n        return false;\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        const getCh = (cell) => {\n            return cell.dump();\n        };\n        this.cells.dump(fmt || getCh, log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    get needsRedraw() {\n        return this.hasMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v)\n            this.setMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n        else\n            this.clearMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).hasCellFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    hasEntityFlag(x, y, flag) {\n        return this.cell(x, y).hasEntityFlag(flag);\n    }\n    hasTileFlag(x, y, flag) {\n        return this.cell(x, y).hasTileFlag(flag);\n    }\n    highlightPath(path, markCursor = true) {\n        this.clearPath();\n        path.forEach((loc) => {\n            this.setCellFlag(loc[0], loc[1], Flags.Cell.IS_HIGHLIGHTED);\n        });\n        if (markCursor && path[0]) {\n            const loc = path[0];\n            this.setCellFlag(loc[0], loc[1], Flags.Cell.IS_CURSOR);\n        }\n        this.needsRedraw = true;\n    }\n    highlightCell(x, y, markCursor = false) {\n        this.setCellFlag(x, y, markCursor ? Flags.Cell.IS_CURSOR : Flags.Cell.IS_HIGHLIGHTED);\n        this.needsRedraw = true;\n    }\n    clearPath() {\n        this.cells.forEach((c) => c.clearCellFlag(Flags.Cell.IS_CURSOR | Flags.Cell.IS_HIGHLIGHTED));\n        this.needsRedraw = true;\n    }\n    showCursor(x, y) {\n        this.clearCursor();\n        this.cell(x, y).setCellFlag(Flags.Cell.IS_CURSOR);\n        this.needsRedraw = true;\n    }\n    clearCursor() {\n        this.cells.forEach((c) => c.clearCellFlag(Flags.Cell.IS_CURSOR));\n        this.needsRedraw = true;\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        // this.fov.needsUpdate = true;\n        // this.layers.forEach((l) => l.clear());\n        this.cells.forEach((c) => {\n            c.clear();\n            this.events.trigger('changed', c);\n        });\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n        this.events.trigger('changed', cell);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cells[i][j];\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n                this.events.trigger('changed', cell);\n            }\n        }\n    }\n    hasTile(x, y, tile\n    // useMemory = false\n    ) {\n        return this.cell(x, y).hasTile(tile);\n        // if (!useMemory) return this.cell(x, y).hasTile(tile);\n        // return this.memory(x, y).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof Tile)) {\n            const name = tile;\n            tile = TILE.get(name);\n            if (!tile)\n                throw new Error('Failed to find tile: ' + name);\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        // const depth = tile.depth || 0;\n        // const layer = this.layers[depth] || this.layers[0];\n        // if (!(layer instanceof Layer.TileLayer)) return false;\n        const cell = this.cell(x, y);\n        if (cell.setTile(tile, opts)) {\n            this.events.trigger('changed', cell, opts);\n            return true;\n        }\n        return false;\n    }\n    // clearTiles(x: number, y: number, tile?: TileBase) {\n    //     const cell = this.cell(x, y);\n    //     cell.clearTiles(tile);\n    // }\n    tick(dt) {\n        let didSomething = this._tweens.length > 0;\n        this._tweens.update(dt);\n        if (this.triggerAll('tick')) {\n            didSomething = true;\n        }\n        // for (let layer of this.layers) {\n        //     if (layer && layer.tick(dt)) {\n        //         didSomething = true;\n        //     }\n        // }\n        this.events.trigger('tick', dt);\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cell(x, y));\n        });\n        // this.layers.forEach((l, depth) => {\n        //     l.copy(src.layers[depth]);\n        // });\n        this.actors = src.actors.slice();\n        this.items = src.items.slice();\n        this.flags.map = src.flags.map;\n        // this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        this.data = Object.assign({}, src.data);\n        src.events.trigger('assign', this);\n        this.events.trigger('copy', src);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    hasAction(action) {\n        return this.events.has(action);\n    }\n    on(action, fn) {\n        return this.events.on(action, fn);\n    }\n    once(action, fn) {\n        return this.events.once(action, fn);\n    }\n    off(action, fn) {\n        this.events.off(action, fn);\n    }\n    trigger(ev, action = {}) {\n        if (!(action instanceof ACTION.Action)) {\n            action = new ACTION.Action(action);\n        }\n        this.events.trigger(ev, action);\n        if (action.isDone())\n            return;\n        if (action.x !== undefined && action.y !== undefined) {\n            const cell = this.cell(action.x, action.y);\n            cell.trigger(ev, action);\n        }\n    }\n    triggerAll(name, action = {}) {\n        if (!(action instanceof ACTION.Action)) {\n            action = new ACTION.Action(action);\n        }\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        action.map = this;\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                if (!tile.hasAction(name))\n                    return;\n                // const ev = tile.effects[event];\n                // if (!ev) return;\n                const effect = { chance: 0 }; // DELETE\n                // const effect = Effect.from(ev);\n                // if (!effect) return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        action.force = true;\n        willFire.forEach((w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    cell.trigger(name, action);\n                    if (action.isSuccess()) {\n                        didSomething = true;\n                    }\n                    action.reset();\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    // DRAW\n    drawInto(dest, opts) {\n        this.drawer.drawInto(dest, this, opts);\n    }\n    getAppearanceAt(x, y, dest) {\n        const cell = this.cell(x, y);\n        return this.drawer.drawCell(dest, this, cell);\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            // cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(cb) {\n        // TODO - Clairy, Telepathy, Detect, etc...\n        if (this.player) {\n            cb(this.player.x, this.player.y, this.player.visionDistance, GWU.fov.FovFlags.PLAYER);\n        }\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    // redrawCell(x: number, y: number): void {\n    //     // if (clearMemory) {\n    //     //     this.clearMemory(x, y);\n    //     // }\n    //     this.cell(x, y).needsRedraw = true;\n    // }\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        cell.storeMemory();\n        if (cell.hasActor() &&\n            cell.actor.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n    }\n    makeVisible(x, y) {\n        const cell = this.cell(x, y);\n        cell.clearMemory();\n        if (cell.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED |\n                Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n        else if (cell.hasActor() &&\n            !cell.actor.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n        else if (cell.hasItem() &&\n            !cell.item.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n    }\n    onFovChange(x, y, isVisible) {\n        if (!isVisible) {\n            this.storeMemory(x, y);\n        }\n        else {\n            this.makeVisible(x, y);\n        }\n    }\n    // Animator\n    addAnimation(a) {\n        this._tweens.add(a);\n    }\n    removeAnimation(a) {\n        this._tweens.remove(a);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount =\n                                                cellCount;\n                                            map.cell(i2, j2).flags.cell &=\n                                                ~Flags.Cell.IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        // layerVersion: number[] = [];\n        this.lightVersion = 0;\n        // fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        // this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        // if (this.map.fov.changed) {\n        //     this.fovVersion = this.version;\n        //     this.map.fov.changed = false;\n        // }\n        // if (snap.version !== this.fovVersion) {\n        //     snap.map.fov.copy(this.map.fov);\n        // }\n        // layers\n        // this.map.layers.forEach((layer, index) => {\n        //     const snapLayer = snap.map.layers[index];\n        //     if (layer.changed) {\n        //         this.layerVersion[index] = this.version;\n        //     }\n        //     if (this.layerVersion[index] !== snap.version) {\n        //         snapLayer.copy(layer);\n        //     }\n        // });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        // if (snap.version < this.fovVersion || this.map.fov.changed) {\n        //     this.map.fov.copy(snap.map.fov);\n        //     this.fovVersion = snap.version;\n        // }\n        // layers\n        // this.layerVersion.forEach((v, index) => {\n        //     if (v < snap.version) return;\n        //     const destLayer = this.map.layers[index];\n        //     if (v > snap.version || destLayer.changed) {\n        //         const srcLayer = snap.map.layers[index];\n        //         destLayer.copy(srcLayer);\n        //         this.layerVersion[index] = snap.version;\n        //     }\n        // });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function isHallway(map, x, y) {\n    return (GWU.xy.arcCount(x, y, (i, j) => {\n        return map.cell(i, j).isPassable();\n    }) > 1);\n}\nexport function replaceTile(map, find, replace) {\n    let count = 0;\n    map.eachCell((c) => {\n        if (!c.hasTile(find))\n            return;\n        if (c.setTile(replace)) {\n            ++count;\n        }\n    });\n    return count;\n}\nexport function getCellPathCost(map, x, y) {\n    const cell = map.cell(x, y);\n    if (cell.blocksMove())\n        return GWU.path.OBSTRUCTION;\n    if (cell.blocksPathing())\n        return GWU.path.FORBIDDEN;\n    if (cell.hasActor())\n        return 10;\n    return 1;\n}\nexport function fillCostMap(map, costMap) {\n    costMap.update((_v, x, y) => getCellPathCost(map, x, y));\n}\nexport function getPathBetween(map, x0, y0, x1, y1, options = {}) {\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = GWU.grid.alloc(map.width, map.height);\n    fillCostMap(map, costMap);\n    GWU.path.calculateDistances(distanceMap, x1, y1, costMap, options.eightWays, GWU.xy.straightDistanceBetween(x0, y0, x1, y1) + 1);\n    const path = GWU.path.getPath(distanceMap, x0, y0, (x, y) => map.cell(x, y).blocksMove(), options.eightWays);\n    if (path) {\n        path.push([x1, y1]);\n    }\n    GWU.grid.free(costMap);\n    GWU.grid.free(distanceMap);\n    return path;\n}\n","import { Map } from './map';\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile === undefined) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === undefined) {\n        opts.boundary = 'WALL';\n    }\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n        map.light.update();\n    }\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    // // In case we reveal the map or make it all visible we need our memory set correctly\n    // map.cells.forEach((_c, x, y) => {\n    //     if (map.fov.isRevealed(x, y)) {\n    //         map.storeMemory(x, y, true); // with snapshot\n    //     }\n    // });\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Horde as Flags } from '../flags/horde';\nimport * as Map from '../map';\nimport * as Actor from '../actor';\nexport class Horde {\n    // requiredTile: string | null = null;\n    constructor(config) {\n        this.tags = [];\n        this.members = {};\n        // blueprintId: string | null = null;\n        this.flags = { horde: 0 };\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        this.leader = config.leader;\n        if (config.members) {\n            Object.entries(config.members).forEach(([id, range]) => {\n                this.members[id] = GWU.range.make(range);\n            });\n        }\n        this.frequency = GWU.frequency.make(config.frequency || 100);\n        // this.blueprintId = config.blueprintId || null;\n        this.flags.horde = GWU.flag.from(Flags, config.flags);\n        // if (config.requiredTile) this.requiredTile = config.requiredTile;\n    }\n    spawn(map, x = -1, y = -1, opts = {}) {\n        var _a;\n        opts.canSpawn = opts.canSpawn || GWU.TRUE;\n        opts.rng = opts.rng || map.rng;\n        opts.machine = (_a = opts.machine) !== null && _a !== void 0 ? _a : 0;\n        const leader = this._spawnLeader(map, x, y, opts);\n        if (!leader)\n            return null;\n        this._spawnMembers(leader, map, opts);\n        return leader;\n    }\n    _spawnLeader(map, x, y, opts) {\n        const leaderKind = Actor.get(this.leader);\n        if (!leaderKind) {\n            throw new Error('Failed to find leader kind = ' + this.leader);\n        }\n        if (x >= 0 && y >= 0) {\n            if (leaderKind.avoidsCell(map.cell(x, y)))\n                return null;\n        }\n        const leader = Actor.make(leaderKind, { machineHome: opts.machine });\n        if (!leader)\n            throw new Error('Failed to make horde leader - ' + this.leader);\n        if (x < 0 || y < 0) {\n            [x, y] = this._pickLeaderLoc(leader, map, opts) || [-1, -1];\n            if (x < 0 || y < 0) {\n                return null;\n            }\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addLeader(leader, map, x, y, opts)) {\n            return null;\n        }\n        return leader;\n    }\n    _addLeader(leader, map, x, y, _opts) {\n        return map.addActor(x, y, leader);\n    }\n    _addMember(member, map, x, y, leader, _opts) {\n        member.leader = leader;\n        return map.addActor(x, y, member);\n    }\n    _spawnMembers(leader, map, opts) {\n        const entries = Object.entries(this.members);\n        if (entries.length == 0)\n            return 0;\n        let count = 0;\n        entries.forEach(([kindId, countRange]) => {\n            const count = countRange.value(opts.rng);\n            for (let i = 0; i < count; ++i) {\n                this._spawnMember(kindId, map, leader, opts);\n            }\n        });\n        return count;\n    }\n    _spawnMember(kindId, map, leader, opts) {\n        const kind = Actor.get(kindId);\n        if (!kind) {\n            throw new Error('Failed to find member kind = ' + kindId);\n        }\n        const member = Actor.make(kind, { machineHome: opts.machine });\n        if (!member)\n            throw new Error('Failed to make horde member - ' + kindId);\n        const [x, y] = this._pickMemberLoc(member, map, leader, opts) || [\n            -1, -1,\n        ];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addMember(member, map, x, y, leader, opts)) {\n            return null;\n        }\n        return member;\n    }\n    _pickLeaderLoc(leader, map, opts) {\n        let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            if (!opts.canSpawn(x, y))\n                return false;\n            if (leader.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n    _pickMemberLoc(actor, map, leader, opts) {\n        let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Horde } from './horde';\nimport { Horde as Flags } from '../flags/horde';\nexport const hordes = {};\nexport function install(id, horde) {\n    if (typeof horde === 'string') {\n        horde = { leader: horde };\n    }\n    if (!(horde instanceof Horde)) {\n        horde = new Horde(horde);\n    }\n    hordes[id] = horde;\n    return horde;\n}\nexport function installAll(hordes) {\n    Object.entries(hordes).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function from(id) {\n    if (id instanceof Horde) {\n        return id;\n    }\n    if (typeof id === 'string') {\n        return hordes[id];\n    }\n    return new Horde(id);\n}\nexport function random(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n        flags: 0,\n        forbidFlags: 0,\n        depth: 0,\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    const rng = opts.rng || GWU.rng.random;\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    if (opts.flags) {\n        if (typeof opts.flags === 'string') {\n            opts.flags\n                .split(/[,|]/)\n                .map((t) => t.trim())\n                .forEach((flag) => {\n                if (flag.startsWith('!')) {\n                    const key = flag.substring(1);\n                    match.forbidFlags |= Flags[key];\n                }\n                else {\n                    match.flags |= Flags[flag];\n                }\n            });\n        }\n    }\n    if (opts.forbidFlags) {\n        match.forbidFlags = GWU.flag.from(Flags, opts.forbidFlags);\n    }\n    if (opts.depth) {\n        match.depth = opts.depth;\n    }\n    if (match.depth && opts.oodChance) {\n        while (rng.chance(opts.oodChance)) {\n            match.depth += 1;\n        }\n        match.forbidFlags |= Flags.HORDE_NEVER_OOD;\n    }\n    const matches = Object.values(hordes).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        if (match.flags && !(k.flags.horde & match.flags)) {\n            return false;\n        }\n        if (match.forbidFlags && k.flags.horde & match.forbidFlags) {\n            return false;\n        }\n        return true;\n    });\n    if (match.depth) {\n        return rng.item(matches) || null;\n    }\n    const depth = match.depth;\n    const weights = matches.map((h) => h.frequency(depth));\n    const index = rng.weighted(weights);\n    if (index < 0)\n        return null;\n    return matches[index];\n}\n","// export * from './memory';\n// export * from './system';\nexport const empty = {};\n","/*\n    Attributes\n    ========================\n\n    To configure attributes, set the defaults:\n\n    Attribute.install(')\n\n    const attr = new Attributes(10);\n\n    attr.set('str', 10);\n    attr.set('dex', 10);\n    ...\n    attr.set('chr', 10);\n\n    // to get the current value\n    attr.get('str');\n\n    // To raise an attribute permanently\n    attr.gain('chr', 1);\n\n    // To raise an attribute temporarily\n    attr.gain('chr', 1, false);\n\n    // To lower an attribute permanently\n    attr.drain('chr', 1, true);\n\n    // to lower an attribute temporarily\n    attr.drain('chr', 1);\n\n    // to restore (remove) all temporary changes\n    attr.restore();\n\n    // to add a temporary change that can be removed by itself\n    attr.addBonus('str', 1);\n\n    // to remove the bonus\n    attr.clearBonus('str', 1);\n\n    // adjustments (bonuses) are also possible via:\n    attr.adjust('str', { bonus: 1 });\n\n    // But adjustments can also set the\n    attr.adjust('str', { fixed: 14 });      // temporarily sets base\n    attr.adjust('str', { base: 21 });       // resets the base\n    attr.adjust('str', { restore: true });  // removes all bonuses/penalties\n    attr.adjust('str', { min: 10 });        // limits value\n    attr.adjust('str', { max: 30 });        // limits value\n    attr.adjust('str', { sustain: true });  // turns off lowering values\n*/\nexport class Attributes {\n    constructor(baseValues) {\n        this._base = {};\n        this._max = {};\n        this._bonus = {};\n        this._sustain = {};\n        this._value = {};\n        this.changed = null;\n        this.init(baseValues);\n    }\n    init(baseValues) {\n        for (let k in attributes) {\n            const v = typeof baseValues === 'number' ? baseValues : attributes[k];\n            this.set(k, v);\n        }\n        if (typeof baseValues !== 'number') {\n            for (let k in baseValues) {\n                this.set(k, baseValues[k]);\n            }\n        }\n    }\n    forEach(fn) {\n        Object.keys(attributes).forEach((k) => fn(this.get(k)));\n    }\n    // modifier(name: string) {\n    //     return Math.floor((this.get(name) - 10) / 2);\n    // }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    set(name, value = 0) {\n        this._value[name] = value;\n        this._base[name] = value;\n        this._max[name] = value;\n        this._bonus[name] = [];\n        return value;\n    }\n    base(name) {\n        return this._base[name] || 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    sustain(name) {\n        return this._sustain[name] || false;\n    }\n    gain(name, delta, raiseMax = true) {\n        if (delta < 0 && this._sustain[name])\n            return 0;\n        this._base[name] += delta;\n        if (raiseMax && this._base[name] > this._max[name]) {\n            this._max[name] = this._base[name];\n        }\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    drain(name, loss, lowerMax = false) {\n        if (loss < 0)\n            loss = -loss;\n        const changed = this.gain(name, -loss, false);\n        if (changed && lowerMax) {\n            this._max[name] = this._base[name];\n        }\n        return changed;\n    }\n    restore(name) {\n        this._base[name] = this._max[name];\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    addBonus(name, bonus) {\n        return this._addBonus(name, { bonus });\n    }\n    _addBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        if (this._value[name] === undefined) {\n            this.set(name, 0);\n        }\n        this._bonus[name].push(bonus);\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    clearBonus(name, bonus) {\n        return this._clearBonus(name, { bonus });\n    }\n    _clearBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        let arr = this._bonus[name] || [];\n        let key = JSON.stringify(bonus);\n        let index = arr.findIndex((o) => {\n            return JSON.stringify(o) == key;\n        });\n        if (index > -1) {\n            arr.splice(index, 1);\n            let old = this.get(name);\n            return this._calcValue(name) - old;\n        }\n        return 0;\n    }\n    _calcValue(name) {\n        let allAdjustments = {};\n        this._bonus[name].forEach((adj) => this._applyAdjustment(allAdjustments, adj));\n        this._sustain[name] = allAdjustments.sustain || false;\n        let value = this._base[name] || 0;\n        if (allAdjustments.fixed !== undefined) {\n            value = allAdjustments.fixed;\n        }\n        else {\n            value += allAdjustments.bonus || 0;\n            if (allAdjustments.min !== undefined) {\n                value = Math.max(allAdjustments.min, value);\n            }\n            if (allAdjustments.max !== undefined) {\n                value = Math.min(allAdjustments.max, value);\n            }\n        }\n        return (this._value[name] = value);\n    }\n    adjust(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.gain(name, adj.base);\n        }\n        else if (adj.restore) {\n            delta = this.restore(name);\n            if (delta == 0)\n                delta = undefined;\n        }\n        else {\n            delta = this._addBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    clearAdjustment(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.drain(name, adj.base, true);\n        }\n        else if (adj.restore) {\n            // do nothing...\n        }\n        else {\n            delta = this._clearBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    _applyAdjustment(total, opts) {\n        if (opts.bonus) {\n            total.bonus = (total.bonus || 0) + opts.bonus;\n        }\n        if (opts.fixed !== undefined) {\n            total.fixed = Math.max(total.fixed || 0, opts.fixed);\n        }\n        if (opts.min !== undefined) {\n            total.min = Math.max(total.min || 0, opts.min);\n        }\n        if (opts.max !== undefined) {\n            total.max = Math.max(total.max || 0, opts.max);\n        }\n        if (opts.sustain !== undefined) {\n            total.sustain = opts.sustain;\n        }\n    }\n}\nexport const attributes = {};\nexport function installAttribute(attr) {\n    if (typeof attr === 'string') {\n        attributes[attr] = 0;\n        return;\n    }\n    // clear existing\n    Object.keys(attributes).forEach((k) => {\n        delete attributes[k];\n    });\n    Object.assign(attributes, attr);\n}\nexport function makeAttributes(defaults) {\n    return new Attributes(defaults);\n}\n/*\nfunction adjust(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = undefined;\n        if (a.base) {\n            delta = being.attributes.addBase(a.name, a.base);\n        } else if (a.restore) {\n            delta = being.attributes.restoreBase(a.name);\n            if (delta == 0) delta = undefined;\n        } else {\n            delta = being.attributes.addBonus(a.name, a);\n        }\n        if (delta !== undefined) {\n            out[a.name] = delta;\n        }\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n\n    return results;\n};\n\n function clearAdjustment(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = 0;\n        delta += being.attributes.clearBonus(a.name, a);\n\n        out[a.name] = delta;\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n    return results;\n};\n\nRUT.Attribute.rollAttributes = function (opts = {}) {\n    let dice = [];\n    let total = 0;\n\n    if (RUT.Calc.isValue(opts)) opts = { value: opts };\n    Object.defaults(opts, RUT.Config.Attribute.rollAttributes);\n\n    let attributes = RUT.Config.Attributes;\n\n    let min_average = Math.max(opts.min_average - 5, 0);\n    let max_average = Math.min(opts.max_average - 5, RUT.Config.ATTRIBUTE_MAX);\n\n    let min_total = min_average * attributes.length;\n    let max_total = max_average * attributes.length;\n\n    do {\n        total = 0;\n        dice = [];\n        for (let i = 0; i < 18; ++i) {\n            dice.push(RUT.RNG.rollDie(3 + (i % 3)));\n            total += dice[i];\n        }\n    } while (total <= min_total || total > max_total);\n\n    let values = attributes.reduce((out, name, i) => {\n        let index = 3 * i;\n        let value = 5 + dice[index] + dice[index + 1] + dice[index + 2];\n        if (opts.value) {\n            value = RUT.Calc.calc(opts.value);\n        } else if (opts[name]) {\n            value = RUT.Calc.calc(opts[name]);\n        }\n        out[name] = value;\n        return out;\n    }, {});\n    return values;\n};\nRUT.Config.Attribute.rollAttributes = { min_average: 11, max_average: 14 };\n*/\n/*\nexport function normalize_adjustment(args: ) {\n    if (args.length == 3) {\n        let opts = args[2];\n        if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        let name = `${args[0]}.${args[1]}`;\n        return [Object.assign({ name }, opts)];\n    }\n    if (args.length == 2) {\n        let opts = args[1];\n        if (opts === true || opts === false) {\n            opts = { has: opts };\n        } else if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        return [Object.assign({ name: args[0] }, opts)];\n    }\n\n    let opts = args[0];\n    if (opts.name) {\n        return [opts];\n    }\n    if (opts.attribute) {\n        opts.name = opts.attribute;\n        return [opts];\n    }\n    if (opts.restore) {\n        if (opts.restore == 'all') {\n            return RUT.Attributes.map((a) => {\n                return { name: a, restore: true };\n            });\n        }\n        return [{ name: opts.restore, restore: true }];\n    }\n    if (opts.skill) {\n        opts.name = opts.skill;\n        return [opts];\n    }\n    if (opts.stat) {\n        opts.name = opts.stat;\n        return [opts];\n    }\n    if (opts.save) {\n        opts.name = opts.save;\n        return [opts];\n    }\n    // if (opts.saves) {\n    //   opts.name = opts.saves;\n    //   return [opts];\n    // }\n    if (opts.ability) {\n        opts.name = opts.ability;\n        return [opts];\n    }\n\n    // now we assume that each key is for a separate skill...\n    return Object.keys(opts).reduce((out, key) => {\n        let opt = opts[key];\n        if (key == 'reset' || key == 'restore') {\n            if (typeof opt == 'string') opt = [opt];\n            opt.forEach((a) => {\n                out.push({ name: a, restore: true });\n            });\n        } else {\n            if (typeof opt == 'number' || Array.isArray(opt)) {\n                opt = { bonus: opt };\n            } else if (opt === true || opt === false) {\n                opt = { has: opt };\n            } else if (opt == 'reset' || opt == 'restore') {\n                opt = { restore: true };\n            } else if (opt == 'sustain') {\n                opt = { sustain: true };\n            }\n            out.push(Object.assign({ name: key }, opt));\n        }\n        return out;\n    }, []);\n}\n*/\n","/*\nSkills\n\nSkills generally fall into 2 categories - binary and progressive.\n\n\n// Create a skills object\nconst skills = new Skills();\n\n// set skills\nskills.set('diving', true); // = { has: true, level: 0 }\nskills.set('diving', 10); // = { has: true, level: 10 }\n\nskills.remove('diving'); // {}\n\n// adjustments\nskills.adjust('diving', { bonus: 1 });\nskills.adjust('diving', { disadvantage: true });\nskills.adjust('diving', { advantage: 3 });\nskills.adjust('diving', { fixed: 10 });\nskills.adjust('diving', { critical: 5 });\n\n\n\n\n\n*/\nclass Skill {\n    constructor(name) {\n        this.name = name;\n    }\n    get has() {\n        return this._bool('_has');\n    }\n    get level() {\n        return this._int('_level');\n    }\n    get disadvantage() {\n        return this._bool('_disadvantage');\n    }\n    get advantage() {\n        return this._bool('_advantage');\n    }\n    get fixed() {\n        return this._int('_fixed');\n    }\n    get bonus() {\n        const b = this._int('_bonus') || 0;\n        if (!this._parent)\n            return b;\n        return b + this._parent.bonus;\n    }\n    get succeed() {\n        return this._bool('_succeed');\n    }\n    get fail() {\n        return this._bool('_fail');\n    }\n    set(value) {\n        if (value === false) {\n            this._has = false;\n            this._level = 0;\n        }\n        else {\n            this._has = true;\n            this._level = value === true ? 0 : value;\n        }\n    }\n    _value(name) {\n        if (this[name] !== undefined) {\n            // @ts-ignore\n            return this[name];\n        }\n        if (this._parent) {\n            // @ts-ignore\n            return this._parent._value(name);\n        }\n        return undefined;\n    }\n    _bool(name) {\n        return !!this._value(name);\n    }\n    _int(name) {\n        return this._value(name);\n    }\n    adjust(adj) {\n        Object.entries(adj).forEach(([key, value]) => {\n            key = '_' + key;\n            if (value === undefined)\n                return;\n            if (key === '_fixed') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = Math.max(value, this._fixed || 0);\n            }\n            else if (key === '_bonus') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = value + (this._bonus || 0);\n            }\n            // @ts-ignore\n            this[key] = value;\n        });\n    }\n    clear(adj) {\n        Object.keys(adj).forEach((key) => {\n            key = '_' + key;\n            // @ts-ignore\n            if (this[key] !== undefined) {\n                // @ts-ignore\n                this[key] = undefined;\n            }\n        });\n    }\n}\nexport class Skills {\n    constructor(vals = {}) {\n        this._skills = {};\n        Object.entries(vals).forEach(([key, value]) => {\n            this.set(key, value);\n        });\n    }\n    set(name, value) {\n        const s = this.get(name);\n        s.set(value);\n        return s;\n    }\n    get(name) {\n        let s = this._skills[name];\n        if (s)\n            return s;\n        s = this._skills[name] = new Skill(name);\n        const index = name.lastIndexOf('.');\n        if (index > 0) {\n            s._parent = this.get(name.substring(0, index));\n        }\n        else {\n            s.set(false);\n        }\n        return s;\n    }\n    adjust(name, adj) {\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        let s = this.get(name);\n        s.adjust(adj);\n        return s;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Scent {\n    constructor(player) {\n        this._player = player;\n    }\n    get(x, y) {\n        if (!this._data)\n            return 0;\n        return this._data[x][y];\n    }\n    clear() {\n        if (!this._player.map)\n            return;\n        if (this._data)\n            GWU.grid.free(this._data);\n        this._data = GWU.grid.alloc(this._player.map.width, this._player.map.height);\n    }\n    update() {\n        if (!this._player.map)\n            return;\n        const scent = this._player.data.scent || 10;\n        this._data[this._player.x][this._player.y] = scent;\n        const updated = GWU.grid.alloc(this._data.width, this._data.height);\n        const map = this._player.map;\n        this._data.forEach((v, x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.blocksMove())\n                return;\n            let highest = v;\n            GWU.xy.eachNeighbor(x, y, (x1, y1) => {\n                if (!this._data.hasXY(x1, y1))\n                    return;\n                const v1 = this._data[x1][y1];\n                if (v1 > highest) {\n                    highest = v1;\n                }\n            }, true);\n            const delta = cell.hasLiquid() ? 3 : 1;\n            updated[x][y] = Math.max(0, highest - delta);\n        });\n        GWU.grid.free(this._data);\n        this._data = updated;\n    }\n    nextDir(x, y) {\n        const v = this._data[x][y] || 0;\n        if (!v)\n            return null;\n        let highest = v;\n        let highestLoc = [];\n        GWU.xy.eachNeighbor(x, y, (x1, y1) => {\n            if (!this._data.hasXY(x1, y1))\n                return;\n            const v1 = this._data[x1][y1];\n            if (v1 == highest) {\n                highestLoc.push([x1, y1]);\n            }\n            else if (v1 > highest) {\n                highestLoc = [[x1, y1]];\n                highest = v1;\n            }\n        }, false);\n        if (!highestLoc.length)\n            return null;\n        const loc = GWU.random.item(highestLoc);\n        loc[0] = loc[0] - x;\n        loc[1] = loc[1] - y;\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Actor } from '../actor';\nimport { Scent } from './scent';\nimport * as Flags from '../flags';\nexport class Player extends Actor {\n    constructor(kind) {\n        super(kind);\n        this.scent = new Scent(this);\n    }\n    interrupt(other) {\n        if (this.hasGoal()) {\n            this.clearGoal();\n            GWU.message.addAt(this.x, this.y, '{{you}} {{verb see~}} {{a other}}.', {\n                actor: this,\n                verb: 'see',\n                other,\n            });\n        }\n    }\n    endTurn(pct = 100) {\n        if (this.map) {\n            if (this.map.fov.update()) {\n                this.clearActorFlag(Flags.Actor.STABLE_COST_MAP);\n            }\n            this.scent.update();\n        }\n        super.endTurn(pct);\n    }\n    addToMap(map, x, y) {\n        if (!super.addToMap(map, x, y))\n            return false;\n        this.scent.clear();\n        return true;\n    }\n    setGoal(x, y) {\n        const map = this._map;\n        if (!map)\n            throw new Error('No map to set goal with!');\n        if (!this._goalMap) {\n            this._goalMap = GWU.grid.alloc(map.width, map.height);\n        }\n        const goalMap = this._goalMap;\n        const mapToPlayer = this.mapToMe();\n        if (mapToPlayer[x][y] < 0 ||\n            mapToPlayer[x][y] >= GWU.path.NO_PATH ||\n            !map.fov.isRevealed(x, y)) {\n            let loc = GWU.path.getClosestValidLocation(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y));\n            loc = loc || [this.x, this.y];\n            x = loc[0];\n            y = loc[1];\n        }\n        GWU.path.calculateDistances(goalMap, x, y, this.costMap());\n        return this._goalMap;\n    }\n    nextGoalStep() {\n        const map = this.map;\n        if (!map)\n            return null;\n        const goalMap = this.goalMap;\n        const step = GWU.path.nextStep(goalMap, this.x, this.y, (x, y) => map.hasActor(x, y) && map.actorAt(x, y) !== this);\n        return step;\n    }\n    pathTo(...args) {\n        let x = args[0];\n        let y = args[1];\n        if (args.length === 1) {\n            x = args[0].x;\n            y = args[0].y;\n        }\n        const map = this.map;\n        if (!map)\n            return null;\n        const mapToPlayer = this.mapToMe();\n        if (mapToPlayer[x][y] < 0 ||\n            mapToPlayer[x][y] >= GWU.path.NO_PATH ||\n            !map.fov.isRevealed(x, y)) {\n            const loc = GWU.path.getClosestValidLocation(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y));\n            if (!loc)\n                return null;\n            x = loc[0];\n            y = loc[1];\n        }\n        const path = GWU.path.getPath(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y), true);\n        return path;\n    }\n}\nPlayer.default = {\n    ch: '@',\n    fg: 'white',\n    name: 'You',\n    swim: true,\n    sidebarFg: 'purple',\n};\n","import * as GWU from 'gw-utils';\nimport * as Actor from '../actor';\nimport * as Skills from './skill';\nimport * as Attributes from './attribute';\nimport { Player } from './player';\nimport * as Flags from '../flags';\nexport class PlayerKind extends Actor.ActorKind {\n    constructor(opts = {}) {\n        super((() => {\n            if (!opts.sprite) {\n                opts.ch = opts.ch || Player.default.ch;\n                opts.fg = opts.fg || Player.default.fg;\n            }\n            if (!opts.name) {\n                opts.name = Player.default.name;\n            }\n            if (opts.swim === undefined) {\n                opts.swim = Player.default.swim;\n            }\n            return opts;\n        })());\n        this.flags.actor |= Flags.Actor.IS_PLAYER;\n        this.flags.entity |= Flags.Entity.L_ALWAYS_PLURAL;\n        this.attributes = new Attributes.Attributes(opts.attributes || {});\n        this.skills = new Skills.Skills(opts.skills || {});\n    }\n    make(options) {\n        const actor = new Player(this);\n        this.init(actor, options);\n        return actor;\n    }\n    cellCost(cell, player) {\n        const map = cell.map;\n        if (!map.fov.isRevealed(cell.x, cell.y))\n            return GWU.path.FORBIDDEN;\n        return super.cellCost(cell, player);\n    }\n}\n","import { PlayerKind } from './kind';\nimport * as Actor from '../actor';\nexport function make(id, makeOptions) {\n    let kind;\n    if (typeof id === 'string') {\n        // @ts-ignore\n        kind = Actor.get(id);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + id);\n        if (!(kind instanceof PlayerKind))\n            throw new Error('Not a player kind.');\n    }\n    else if (id instanceof PlayerKind) {\n        kind = id;\n    }\n    else {\n        kind = makeKind(id);\n    }\n    return kind.make(makeOptions);\n}\nexport function install(id, kind) {\n    if (kind instanceof PlayerKind) {\n        Actor.kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    Actor.kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof PlayerKind)\n        return id;\n    const k = Actor.kinds[id];\n    if (k && !(k instanceof PlayerKind)) {\n        throw new Error('No a player kind.');\n    }\n    return k;\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new PlayerKind(config);\n}\n","import * as GWU from 'gw-utils';\nimport { Player } from '../player/player';\nimport * as Flags from '../flags';\nexport class Viewport extends GWU.widget.Widget {\n    constructor(opts) {\n        super((() => {\n            opts.tag = opts.tag || 'viewport';\n            return opts;\n        })());\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this._subject = null;\n        this.player = null;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.attr('snap', opts.snap || false);\n        this.attr('center', opts.center || false);\n        this.attr('lockX', opts.lock || opts.lockX || false);\n        this.attr('lockY', opts.lock || opts.lockY || false);\n        this.filter = opts.filter || null;\n        this.scent = opts.scent || false;\n    }\n    get subject() {\n        return this._subject;\n    }\n    set subject(subject) {\n        this.attr('center', !!subject);\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n        }\n        this._subject = subject;\n        if (subject && subject instanceof Player) {\n            this.player = subject;\n        }\n        else {\n            this.player = null;\n        }\n    }\n    set lock(v) {\n        this.attr('lockX', v);\n        this.attr('lockY', v);\n    }\n    get lockX() {\n        return this._attrBool('lockX');\n    }\n    set lockX(v) {\n        this.attr('lockX', v);\n    }\n    get lockY() {\n        return this._attrBool('lockY');\n    }\n    set lockY(v) {\n        this.attr('lockY', v);\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(map, x, y) {\n        this.attr('center', true);\n        this.subject = { x, y, map };\n    }\n    showMap(map, x = 0, y = 0) {\n        this.subject = { x, y, map };\n        this.offsetX = x;\n        this.offsetY = y;\n        this.attr('center', false);\n        this.attr('snap', false);\n    }\n    updateOffset() {\n        if (!this._subject) {\n            this.offsetX = 0;\n            this.offsetY = 0;\n            return;\n        }\n        const subject = this._subject;\n        const map = subject.map;\n        const bounds = map;\n        if (subject && map.hasXY(subject.x, subject.y)) {\n            if (this._attrBool('snap')) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (subject.x < left || subject.x > right) {\n                    left = this.offsetX = subject.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (subject.y < top || subject.y > bottom) {\n                    top = this.offsetY = subject.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= subject.x) {\n                    this.offsetX = Math.max(0, subject.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= subject.x) {\n                    this.offsetX = Math.min(subject.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= subject.y) {\n                    this.offsetY = Math.max(0, subject.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= subject.y) {\n                    this.offsetY = Math.min(subject.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this._attrBool('center')) {\n                this.offsetX = subject.x - this.halfWidth();\n                this.offsetY = subject.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = subject.x;\n                this.offsetY = subject.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    _draw(buffer) {\n        if (!this._subject)\n            return;\n        const map = this._subject.map;\n        if (!map || !map.needsRedraw)\n            return;\n        const fov = map.fov;\n        buffer.blackOutRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, this.bg);\n        if (!this._subject) {\n            return;\n        }\n        this.updateOffset();\n        const drawer = map.drawer;\n        drawer.scent = this.scent;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, map, cell, fov);\n                }\n                else {\n                    mixer.draw(' ', this.bg, this.bg); // blackOut\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n    }\n    update(dt) {\n        super.update(dt);\n        if (!this._subject)\n            return;\n        const map = this._subject.map;\n        if (!map)\n            return;\n        if (!map.hasMapFlag(Flags.Map.MAP_DANCES) || !GWU.cosmetic.chance(10)) {\n            return;\n        }\n        map.eachCell((c) => {\n            if (c.hasCellFlag(Flags.Cell.COLORS_DANCE) &&\n                map.fov.isAnyKindOfVisible(c.x, c.y) &&\n                GWU.cosmetic.chance(2)) {\n                c.needsRedraw = true;\n            }\n        });\n        map.needsRedraw = true;\n    }\n    _mousemove(ev) {\n        super._mousemove(ev);\n        if (!this.bounds.contains(ev.x, ev.y)) {\n            this.clearPath();\n            return;\n        }\n        if (!this.player)\n            return;\n        const map = this.player.map;\n        if (!map)\n            return;\n        this.showPath(this.toInnerX(ev.x), this.toInnerY(ev.y));\n    }\n    _click(ev) {\n        super._click(ev);\n        if (!this.player)\n            return;\n        if (this.player.hasGoal()) {\n            this.player.clearGoal();\n        }\n        else {\n            this.player.setGoal(this.toInnerX(ev.x), this.toInnerY(ev.y));\n        }\n    }\n    clearPath() {\n        if (!this.player)\n            return;\n        const map = this.player.map;\n        if (!map)\n            return;\n        map.clearPath();\n    }\n    showPath(x, y) {\n        if (!this.player)\n            return false;\n        const map = this.player.map;\n        if (!map)\n            return false;\n        // if (!this.player.hasGoal()) return false;\n        // console.log('mouse', ev.x, ev.y);\n        const path = this.player.pathTo(x, y);\n        if (path) {\n            map.highlightPath(path, true);\n        }\n        else {\n            map.clearPath();\n        }\n        map.highlightCell(x, y);\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nGWU.app.defaultStyle.add('msgs', { bg: 'darkest_gray', fg: 'white' });\nGWU.app.defaultStyle.add('archive', { bg: 'darkest_gray', fg: 'white' });\nexport class Messages extends GWU.widget.Widget {\n    constructor(opts) {\n        super((() => {\n            opts.tag = opts.tag || 'msgs';\n            return opts;\n        })());\n        if (!this.bounds.height)\n            throw new Error('Must provde a height for messages widget.');\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: opts.archive || 40,\n            match: () => {\n                this.needsDraw = true;\n            },\n        });\n        this.on('click', () => {\n            this.showArchive();\n        });\n    }\n    clear() {\n        this.cache.clear();\n        this.needsDraw = true;\n    }\n    confirmAll() {\n        this.cache.confirmAll();\n        this.needsDraw = true;\n    }\n    draw(buffer) {\n        const isOnTop = this.bounds.y < 10;\n        const bg = this._used.bg;\n        const fg = this._used.fg;\n        // black out the message area\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', bg, bg);\n        this.cache.forEach((line, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = localY + this.bounds.y;\n            buffer.drawText(this.bounds.x, y, line, fg);\n            if (confirmed && bg) {\n                buffer.mix(bg, 50, this.bounds.x, y, this.bounds.width, 1);\n            }\n        });\n        return true;\n    }\n    showArchive() {\n        if (this.cache.length <= this.bounds.height)\n            return;\n        if (!this.scene)\n            return;\n        const app = this.scene.app;\n        app.scenes.run('msg-archive', this);\n    }\n}\nexport const ArchiveScene = {\n    create() { },\n    start(source) {\n        new ArchiveWidget({\n            scene: this,\n            source,\n            id: 'ARCHIVE',\n        });\n    },\n    stop() {\n        this.children.forEach((c) => c.destroy());\n        this.children = [];\n    },\n    destroy() { },\n};\nGWU.app.installScene('msg-archive', ArchiveScene);\nexport class ArchiveWidget extends GWU.widget.Widget {\n    constructor(opts) {\n        super({\n            scene: opts.scene,\n            id: opts.id || 'ARCHIVE',\n            tag: opts.tag || 'archive',\n            x: 0,\n            y: 0,\n            tabStop: true,\n            // depth: 100, // I'm on top\n        });\n        this.mode = 'forward';\n        this._timeout = null;\n        this._needsDraw = true;\n        this.source = opts.source;\n        this.isOnTop = this.source.bounds.y < 10;\n        this.bounds.height = this.isOnTop\n            ? this.scene.height - this.source.bounds.y\n            : this.source.bounds.bottom;\n        this.totalCount = Math.min(this.source.cache.length, this.isOnTop\n            ? this.scene.height - this.source.bounds.top\n            : this.source.bounds.bottom);\n        this.shown = this.source.bounds.height;\n        this._timeout = this.scene.wait(16, () => this._forward());\n        // confirm them as they are right now...\n        this.source.cache.confirmAll();\n        this.on('keypress', () => this._next());\n        this.on('click', () => this._next());\n    }\n    set needsDraw(v) {\n        this._needsDraw || (this._needsDraw = v);\n        super.needsDraw = v;\n    }\n    contains() {\n        return true; // Eat all mouse activity\n    }\n    finish() {\n        this.scene.stop();\n    }\n    _next() {\n        if (!this.scene)\n            return;\n        if (this.mode === 'ack') {\n            this.mode = 'reverse';\n            this.scene.needsDraw = true;\n            if (this._timeout) {\n                this._timeout();\n            }\n            this._timeout = this.scene.wait(16, () => this._reverse());\n        }\n        else if (this.mode === 'reverse') {\n            this.finish();\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n            if (this._timeout) {\n                this._timeout();\n                this._timeout = null;\n            }\n            this.scene.needsDraw = true;\n        }\n    }\n    _forward() {\n        // console.log('forward');\n        if (!this.scene)\n            return;\n        ++this.shown;\n        this._timeout = null;\n        this.scene.needsDraw = true;\n        if (this.shown < this.totalCount) {\n            this._timeout = this.scene.wait(16, () => this._forward());\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n        }\n    }\n    _reverse() {\n        // console.log('reverse');\n        if (!this.scene)\n            return;\n        --this.shown;\n        this._timeout = null;\n        if (this.shown <= this.source.bounds.height) {\n            this.finish();\n        }\n        else {\n            this.scene.needsDraw = true;\n            this._timeout = this.scene.wait(16, () => this._reverse());\n        }\n    }\n    _draw(buffer) {\n        let fadePercent = 0;\n        // let reverse = this.mode === 'reverse';\n        if (!this._needsDraw)\n            return;\n        this._needsDraw = false;\n        // Count the number of lines in the archive.\n        // let totalMessageCount = this.totalCount;\n        const isOnTop = this.isOnTop;\n        const dbuf = buffer;\n        const fg = GWU.color.from(this._used.fg);\n        // const dM = reverse ? -1 : 1;\n        // const startM = reverse ? totalMessageCount : this.bounds.height;\n        // const endM = reverse\n        //     ? this.bounds.height + dM + 1\n        //     : totalMessageCount + dM;\n        const startY = isOnTop\n            ? this.shown - 1\n            : this.bounds.bottom - this.shown;\n        const endY = isOnTop ? 0 : this.bounds.bottom - 1;\n        const dy = isOnTop ? -1 : 1;\n        dbuf.fillRect(this.source.bounds.x, Math.min(startY, endY), this.bounds.width, this.shown, ' ', this._used.bg, this._used.bg);\n        this.source.cache.forEach((line, _confirmed, j) => {\n            const y = startY + j * dy;\n            if (isOnTop) {\n                if (y < endY)\n                    return;\n            }\n            else if (y > endY)\n                return;\n            fadePercent = Math.floor((50 * j) / this.shown);\n            const fgColor = fg.mix(this._used.bg, fadePercent);\n            dbuf.drawText(this.source.bounds.x, y, line, fgColor, this._used.bg);\n        });\n        if (this.mode === 'ack') {\n            const y = this.isOnTop ? 0 : dbuf.height - 1;\n            const x = this.source.bounds.x > 8\n                ? this.source.bounds.x - 8 // to left of box\n                : Math.min(this.source.bounds.x + this.bounds.width, // just to right of box\n                dbuf.width - 8 // But definitely on the screen - overwrite some text if necessary\n                );\n            dbuf.wrapText(x, y, 8, '--DONE--', this._used.bg, this._used.fg);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as Tile from '../tile/tile';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor extends GWU.widget.Text {\n    constructor(opts) {\n        super((() => {\n            opts.tag = opts.tag || 'flavor';\n            return opts;\n        })());\n        this._needsDraw = true;\n        this.overflow = opts.overflow || false;\n    }\n    showText(text) {\n        this.text(text);\n        this.removeClass('prompt');\n        this.needsDraw = true;\n        return this;\n    }\n    clear() {\n        this.text('');\n        this.removeClass('prompt');\n        this.needsDraw = true;\n        return this;\n    }\n    showPrompt(text) {\n        this.text(text);\n        this.addClass('prompt');\n        this.needsDraw = true;\n        return this;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'You see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'You sense';\n        }\n        else if (isRemembered) {\n            intro = 'You remember seeing';\n        }\n        else if (isMapped) {\n            intro = 'You expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(Flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(Flags.Depth.GROUND) || Tile.NULL;\n        const surfaceTile = cell.depthTile(Flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(Flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(Flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('{{intro}} {{text}}.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n    _draw(buffer) {\n        if (!this._needsDraw)\n            return;\n        this._needsDraw = false;\n        super._draw(buffer);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\n// import { UISubject } from './viewport';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.sidebarY = -1;\n    }\n    draw(_buffer, _bounds) {\n        return 0;\n    }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    get changed() {\n        return this.actor.changed;\n    }\n    draw(buffer, bounds) {\n        return this.actor.drawSidebar(buffer, bounds);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    get changed() {\n        return this.item.changed;\n    }\n    draw(buffer, bounds) {\n        return this.item.drawSidebar(buffer, bounds);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.changed = true;\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(buffer, bounds) {\n        return this.cell.drawSidebar(buffer, bounds);\n    }\n}\nexport class Sidebar extends GWU.widget.Widget {\n    constructor(opts) {\n        super((() => {\n            opts.tag = opts.tag || 'sidebar';\n            return opts;\n        })());\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.subject = null;\n        this.highlight = null;\n        this._needsDraw = true;\n    }\n    set needsDraw(v) {\n        if (v)\n            this._needsDraw = v;\n        super.needsDraw = v;\n    }\n    reset() {\n        this.lastMap = null;\n        this.lastX = -1;\n        this.lastY = -1;\n        this._needsDraw = true;\n    }\n    entryAt(e) {\n        return (this.entries.find((entry) => {\n            return entry.sidebarY <= e.y && entry.sidebarY !== -1;\n        }) || null);\n    }\n    click(ev) {\n        if (!this.bounds.contains(ev.x, ev.y))\n            return false;\n        if (!this.highlight)\n            return false;\n        if (!this.subject)\n            return false;\n        this.subject.setGoal(this.highlight.x, this.highlight.y);\n        return true;\n    }\n    mousemove(e) {\n        if (this.contains(e)) {\n            this._highlightRow(e.y);\n            return true;\n        }\n        this.clearHighlight();\n        return false;\n    }\n    highlightAt(x, y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.x == x && e.y == y) {\n                this.highlight = e;\n            }\n        });\n        const changed = this.highlight !== last;\n        this._needsDraw || (this._needsDraw = changed);\n        return changed;\n    }\n    _highlightRow(y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        const changed = this.highlight !== last;\n        this.needsDraw || (this.needsDraw = changed);\n        if (this.highlight && this.subject && this.subject.map) {\n            const path = this.subject.pathTo(\n            // @ts-ignore\n            this.highlight.x, \n            // @ts-ignore\n            this.highlight.y);\n            if (path) {\n                this.subject.map.highlightPath(path, true);\n            }\n            else {\n                // @ts-ignore\n                this.subject.map.showCursor(this.highlight.x, this.highlight.y);\n            }\n            // @ts-ignore\n            this.subject.map.highlightCell(this.highlight.x, this.highlight.y);\n        }\n        return changed;\n    }\n    clearHighlight() {\n        const result = !!this.highlight;\n        this.highlight = null;\n        this.needsDraw || (this.needsDraw = result);\n        return result;\n    }\n    _updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return false;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        this.needsDraw = true;\n        return true;\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(Flags.Cell.STABLE_MEMORY) ? 3 : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            if (map.cell(x, y).hasEntityFlag(Flags.Entity.L_BRIGHT_MEMORY)) {\n                return 3;\n            }\n            else {\n                return 4;\n            }\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        if (!!this.highlight)\n            return true;\n        return entry.priority > 3;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0 || priority > 3)\n            return false;\n        if (actor.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR))\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        if (item.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR))\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _updateEntryCache(map, cx, cy, fov) {\n        if (map === this.lastMap &&\n            cx === this.lastX &&\n            cy === this.lastY &&\n            !map.hasMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED |\n                Flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            let anyChanged = this.entries.some((e) => e.changed);\n            if (!anyChanged)\n                return false;\n        }\n        map.clearMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        const highlightX = this.highlight ? this.highlight.x : -1;\n        const highlightY = this.highlight ? this.highlight.y : -1;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (!done[x][y] && this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n                a.setEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n            else {\n                a.clearEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (!done[x][y] && this._addItemEntry(i, map, cx, cy, fov)) {\n                i.setEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n                done[x][y] = 1;\n            }\n            else {\n                i.clearEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        if (highlightX > -1) {\n            this.highlightAt(highlightX, highlightY);\n        }\n        GWU.grid.free(done);\n        return true;\n    }\n    update() {\n        if (!this.subject) {\n            return false;\n        }\n        return this.updateFor(this.subject);\n    }\n    updateFor(subject) {\n        if (!subject.map)\n            return false;\n        return this.updateAt(subject.map, subject.x, subject.y, subject.map.fov);\n    }\n    updateAt(map, cx, cy, fov) {\n        let changed = this._updateCellCache(map);\n        if (this._updateEntryCache(map, cx, cy, fov)) {\n            changed = true;\n        }\n        return changed;\n    }\n    draw(buffer) {\n        var _a;\n        const map = (_a = this.subject) === null || _a === void 0 ? void 0 : _a.map;\n        if (!map)\n            return false;\n        if (this.update()) {\n            this.needsDraw = true;\n        }\n        if (!this.needsDraw)\n            return false;\n        this.needsDraw = false;\n        const bg = this._used.bg || GWU.color.BLACK;\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', bg, bg);\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        const drawBounds = this.bounds.clone();\n        let currentEntry;\n        for (let i = 0; i < this.entries.length && drawBounds.height > 0; ++i) {\n            currentEntry = this.entries[i];\n            currentEntry.sidebarY = drawBounds.y;\n            let usedLines = currentEntry.draw(buffer, drawBounds);\n            if (this._isDim(currentEntry)) {\n                buffer.mix(bg, 50, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            else if (this.highlight === currentEntry) {\n                buffer.mix('white', 20, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            if (usedLines) {\n                ++usedLines; // skip a space\n                drawBounds.y += usedLines;\n                drawBounds.height -= usedLines;\n            }\n        }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Viewport from './viewport';\nimport * as Message from './message';\nimport * as Flavor from './flavor';\nimport * as Sidebar from './sidebar';\nexport class Game extends GWU.app.Scene {\n    constructor(id, app) {\n        super(id, app);\n        this.result = undefined;\n        this.mouse = false;\n        this.fov = false;\n        this.scent = false;\n        this.running = false;\n        this.keymap = {};\n    }\n    get viewWidth() {\n        return this.viewport.bounds.width;\n    }\n    get viewHeight() {\n        return this.viewport.bounds.height;\n    }\n    _initMenu(_opts) { }\n    _initSidebar(opts) {\n        if (typeof opts.sidebar === 'number') {\n            opts.sidebar = { width: opts.sidebar };\n        }\n        else if (opts.sidebar === true) {\n            opts.sidebar = {};\n        }\n        else if (!opts.sidebar) {\n            return;\n        }\n        const sideOpts = opts.sidebar;\n        sideOpts.width = sideOpts.width || -20; // on right side\n        const viewInit = opts.viewport;\n        if (sideOpts.width < 0) {\n            sideOpts.width *= -1;\n            sideOpts.x = viewInit.x + viewInit.width - sideOpts.width;\n            sideOpts.y = viewInit.y;\n            sideOpts.height = viewInit.height;\n            viewInit.width -= sideOpts.width;\n        }\n        else {\n            sideOpts.x = 0;\n            sideOpts.height = viewInit.height;\n            sideOpts.y = viewInit.y;\n            viewInit.x = sideOpts.width;\n            viewInit.width -= sideOpts.width;\n        }\n        sideOpts.scene = this;\n        this.sidebar = new Sidebar.Sidebar(sideOpts);\n    }\n    _initMessages(opts) {\n        if (opts.messages === false)\n            return;\n        if (opts.messages === true) {\n            opts.messages = { archive: -4 };\n        }\n        else if (typeof opts.messages === 'number') {\n            opts.messages = { archive: opts.messages };\n        }\n        const messOpts = opts.messages || { archive: -4 };\n        messOpts.archive = messOpts.archive || messOpts.y || -4;\n        if (messOpts.archive < 0) {\n            // bottom\n            const viewInit = opts.viewport;\n            messOpts.x = viewInit.x;\n            messOpts.y = viewInit.height + messOpts.archive; // length < 0\n            messOpts.width = viewInit.width;\n            messOpts.height = -messOpts.archive;\n            viewInit.height -= messOpts.height;\n        }\n        else {\n            // top\n            const viewInit = opts.viewport;\n            messOpts.x = viewInit.x;\n            messOpts.y = viewInit.y;\n            messOpts.width = viewInit.width;\n            messOpts.height = messOpts.archive;\n            viewInit.y += messOpts.archive;\n            viewInit.height -= messOpts.archive;\n        }\n        messOpts.scene = this;\n        this.messages = new Message.Messages(messOpts);\n    }\n    _initFlavor(opts) {\n        if (opts.flavor === false)\n            return;\n        if (opts.flavor === true) {\n            opts.flavor = {};\n        }\n        const flavOpts = opts.flavor || {};\n        const viewOpts = opts.viewport;\n        const y = viewOpts.y || 0;\n        if (y === 0) {\n            // messages must be on bottom (or not there)\n            flavOpts.x = viewOpts.x || 0;\n            flavOpts.y = viewOpts.height - 1;\n            flavOpts.width = viewOpts.width;\n            viewOpts.height -= 1;\n        }\n        else {\n            // messages on top\n            flavOpts.x = viewOpts.x;\n            flavOpts.y = viewOpts.y;\n            flavOpts.width = viewOpts.width;\n            viewOpts.y += 1;\n            viewOpts.height -= 1;\n        }\n        flavOpts.scene = this;\n        this.flavor = new Flavor.Flavor(flavOpts);\n    }\n    _initViewport(opts) {\n        if (opts.viewport === true) {\n            opts.viewport = {};\n        }\n        const viewOpts = (opts.viewport || {});\n        viewOpts.lock = true;\n        viewOpts.x = viewOpts.x || 0;\n        viewOpts.y = viewOpts.y || 0;\n        viewOpts.width = viewOpts.width || this.app.width - viewOpts.x;\n        viewOpts.height = viewOpts.height || this.app.height - viewOpts.y;\n        this.viewport = new Viewport.Viewport(viewOpts);\n    }\n    create(opts) {\n        super.create(opts);\n        if (!opts.makeMap || !opts.makePlayer) {\n            throw new Error('Need funcitons for makeMap and makePlayer');\n        }\n        this._makeMap = opts.makeMap;\n        this._makePlayer = opts.makePlayer;\n        this._startMap = opts.startMap || GWU.NOOP;\n        if (opts.keymap) {\n            Object.assign(this.keymap, opts.keymap);\n        }\n        if (opts.mouse) {\n            this.mouse = true;\n        }\n        if (typeof opts.messages === 'number') {\n            opts.messages = { archive: opts.messages };\n        }\n        if (opts.flavor === true) {\n            opts.flavor = {};\n        }\n        else if (opts.flavor === false) {\n            delete opts.flavor;\n        }\n        if (opts.viewport === true) {\n            opts.viewport = {};\n        }\n        const viewOpts = (opts.viewport = opts.viewport || {});\n        viewOpts.x = viewOpts.x || 0;\n        viewOpts.y = viewOpts.y || 0;\n        viewOpts.width = viewOpts.width || this.app.width - viewOpts.x;\n        viewOpts.height = viewOpts.height || this.app.height - viewOpts.y;\n        this._initMenu(opts);\n        if (opts.sidebar)\n            this._initSidebar(opts);\n        if (opts.messages)\n            this._initMessages(opts);\n        if (opts.flavor)\n            this._initFlavor(opts);\n        this._initViewport(opts);\n        this.scheduler = new GWU.scheduler.Scheduler();\n    }\n    start(opts = {}) {\n        if (this.messages)\n            this.messages.clear();\n        // move to create?\n        this.player = opts.player || this._makePlayer.call(this);\n        this.viewport.subject = this.player;\n        if (this.sidebar)\n            this.sidebar.subject = this.player;\n        const id = opts.map || 0;\n        this.startNewMap({ id });\n        this.scheduler.push(this.player, 0);\n        super.start(opts);\n    }\n    startNewMap(opts = { id: 0 }) {\n        this.scheduler.clear();\n        if (opts.id === undefined) {\n            opts.id = this.map.id;\n        }\n        this.map = this._makeMap.call(this, opts);\n        this.map.setPlayer(this.player);\n        this._startMap.call(this, this.map, this.player, opts);\n        // make sure player is on map\n        if (this.player.map !== this.map) {\n            // if not, add them (where?)\n            const loc = this.map.locations.start || [0, 0]; // Is top left fallback any good?\n            if (!this.map.addActorNear(loc[0], loc[1], this.player)) {\n                throw new Error('Failed to find starting spot for player!');\n            }\n        }\n        if (this.scent) {\n            this.map.drawer.scent = this.scent;\n        }\n        this.map.actors.forEach((a) => {\n            if (!a.isPlayer()) {\n                this.scheduler.push(a, a.moveSpeed());\n            }\n        });\n        this.map.fov.update();\n        // this.draw();\n    }\n    // draw() {\n    //     this.viewport.draw(this.buffer);\n    //     if (this.messages) this.messages.draw(this.buffer);\n    //     if (this.flavor) this.flavor.draw(this.buffer);\n    //     if (this.sidebar) this.sidebar.draw(this.buffer);\n    //     if (this.buffer.changed) {\n    //         this.buffer.render();\n    //     }\n    //     this.buffer.changed = false;\n    //     this.map.actors.forEach((a) => (a.changed = false));\n    //     this.map.items.forEach((i) => (i.changed = false));\n    // }\n    // finish(result?: any) {\n    //     this.running = false;\n    //     this.layer.finish();\n    //     this.result = result;\n    // }\n    update(dt) {\n        super.update(dt);\n        if (this.tweens.length)\n            return;\n        let actor = this.scheduler.pop();\n        if (!actor) {\n            this.stop();\n            return;\n        }\n        let nextTime = 99;\n        while (nextTime > 0 && actor) {\n            nextTime = actor.act(this);\n            if (nextTime >= 0) {\n                this.scheduler.push(actor, nextTime);\n                actor = this.scheduler.pop();\n            }\n            // stop every time the player acts so we can draw the screen\n            if (actor === this.player) {\n                nextTime = 0;\n            }\n        }\n    }\n    // playerTurn(player: Player): number {\n    //     let done = 0;\n    //     const timer = setInterval(() => {\n    //         const tick = GWU.app.makeTickEvent(16);\n    //         // console.log('-tick', Date.now());\n    //         this.io.enqueue(tick);\n    //     }, 16);\n    //     let elapsed = 0;\n    //     while (!done && this.running) {\n    //         const ev = await this.io.nextEvent(-1);\n    //         if (ev) {\n    //             if (ev.type === GWU.app.KEYPRESS) {\n    //             }\n    //         }\n    //         if (elapsed < 50) {\n    //             continue;\n    //         }\n    //         elapsed -= 50;\n    //     }\n    //     clearInterval(timer);\n    //     return done;\n    // }\n    input(ev) {\n        super.input(ev);\n        if (ev.defaultPrevented || ev.propagationStopped)\n            return;\n        if (ev.type === GWU.app.MOUSEMOVE) {\n            this.mousemove(ev);\n        }\n        else if (ev.type === GWU.app.CLICK) {\n            this.click(ev);\n        }\n        else if (ev.type === GWU.app.KEYPRESS) {\n            this.keypress(ev);\n        }\n    }\n    mousemove(ev) {\n        if (this.viewport.contains(ev)) {\n            const x = this.viewport.toInnerX(ev.x);\n            const y = this.viewport.toInnerY(ev.y);\n            if (this.flavor) {\n                const text = this.flavor.getFlavorText(this.map, x, y, this.map.fov);\n                this.flavor.showText(text);\n            }\n            if (this.sidebar) {\n                this.sidebar.highlightAt(x, y);\n            }\n        }\n    }\n    click(_ev) { }\n    keypress(ev) {\n        this.map.clearPath();\n        if (this.player.hasGoal()) {\n            this.player.clearGoal();\n        }\n        else {\n            const action = this._actionFor(this.keymap, ev);\n            if (action) {\n                this.player.setAction(action);\n            }\n        }\n    }\n    _actionFor(keymap, ev) {\n        if (ev.dir && keymap.dir)\n            return keymap.dir;\n        return (keymap[ev.key] ||\n            keymap[ev.code] ||\n            keymap.keypress ||\n            keymap.default ||\n            null);\n    }\n}\nGWU.app.installScene('game', (id, app) => new Game(id, app));\n","import * as GWU from 'gw-utils';\nimport * as Tile from './tile';\nimport '../effects';\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([30, 30, 30]).rand(20, 0, 0, 0),\n    bg: GWU.color.from([2, 2, 10]).rand(0, 2, 2, 0),\n    priority: 10,\n    article: 'the',\n    flavor: 'the stone floor',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    actions: {\n        enter: 'TILE:DOOR_OPEN',\n        open: 'TILE:DOOR_OPEN_ALWAYS',\n    },\n    flavor: 'a closed door',\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    actions: {\n        tick: {\n            chance: 100 * 100,\n            tile: 'DOOR~!',\n        },\n        enter: null,\n        open: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    actions: {\n        tick: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('UP_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, T_LIST_IN_SIDEBAR',\n    name: 'upward stairs',\n    article: 'an',\n    actions: {\n        climb(action) {\n            if (!action.actor)\n                return action.didNothing();\n            if (!action.actor.isPlayer())\n                return action.didNothing();\n            action.game.startNewMap({ up: true });\n            return action.actor.endTurn();\n        },\n    },\n    flavor: 'stairs leading upwards',\n});\nTile.install('DOWN_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, T_LIST_IN_SIDEBAR',\n    name: 'downward stairs',\n    article: 'a',\n    actions: {\n        descend(action) {\n            if (!action.actor)\n                return action.didNothing();\n            if (!action.actor.isPlayer())\n                return action.didNothing();\n            action.game.startNewMap({ down: true });\n            return action.actor.endTurn();\n        },\n    },\n    flavor: 'downward leading stairs',\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'a very hard wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: GWU.color.from([25, 28, 60]).dance(20, 0, 4, 15),\n    bg: GWU.color.from([10, 15, 41]).dance(20, 5, 5, 5),\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n    flavor: 'some deep water',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([5, 8, 10]).dance(10, 0, 4, 15),\n    bg: GWU.color.from([10, 30, 30]).dance(6, 0, 10, 10),\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    flags: 'T_SHALLOW_WATER',\n    // depth: 'LIQUID', // 'SURFACE'?\n    flavor: 'some shallow water',\n});\nTile.install('BRIDGE', {\n    ch: '\\u2630',\n    fg: [80, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n    flavor: 'a bridge',\n});\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","T_IS_DEEP_LIQUID","T_SHALLOW_WATER","TileMech","Cell","NEEDS_REDRAW","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_SAFE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Horde","KeyInfo","[object Object]","x","y","disposable","this","Action","opts","actor","item","target","dir","aware","identified","machine","try","force","good","seen","quiet","ok","failed","done","logged","visible","data","map","game","undefined","originX","originY","key","Actions","ctx","_handlers","onUnhandled","_ctx","other","Object","entries","forEach","ev","fns","Array","isArray","slice","events","some","e","fn","cleanup","on","c","cb","handlers","info","unshift","arrayNullify","obj","cfg","once","off","current","findIndex","i","length","action","Error","didSomething","name","trigger","isDone","_unhandled","call","filter","keys","global","install","doAction","canDoAction","fail","defaultAction","_action","lastId","kind","_map","machineHome","changed","actions","ACTION.Actions","_actions","depth","light","flags","entity","next","id","hasEntityFlag","Flags.Entity","L_ALWAYS_PLURAL","setEntityFlag","L_ON_MAP","addToMap","clearEntityFlag","removeFromMap","sprite","isDestroyed","L_DESTROYED","constructor","copy","assign","canBeSeen","tag","tags","includes","matches","cell","forbidsCell","avoidsCell","getName","getDescription","getFlavor","verb","getVerb","buffer","bounds","drawSidebar","dest","_observer","drawSprite","v","has","ACTION.Action","default","sidebarFg","EntityKind","config","requireTileFlags","forbidTileFlags","avoidTileFlags","requireTileTags","forbidTileTags","avoidTileTags","flavor","description","make","split","t","trim","from","Flags.Tile","color","value","init","_entity","hasAllTileFlags","hasTileFlag","T_BRIDGE","hasAllTileTags","hasAnyTileTag","_opts","mixer","Mixer","getAppearanceAt","wrapText","width","a","makeOpts","Status","_set","_time","_count","_done","_value","clearTime","clearCount","setOff","_update","count","Math","max","_addDone","range","delta","status","cleared","noticed","removeTime","rec","was","doneFn","Stats","_max","_rate","round","get","set","amount","allowOver","min","raiseValue","gain","lowerValue","drain","turns","r","elapsed","type","Entity.Entity","super","ai","_turnTime","leader","items","visionDistance","_costMap","_goalMap","_mapToMe","Flags.Depth","ACTOR","stats","grid","free","hasActorFlag","Flags.Actor","IS_PLAYER","bump","IS_VISIBLE","WAS_VISIBLE","canSee","isAbleToSee","isPlayer","fov","isDirectlyVisible","xy","distanceBetween","forLineBetween","j","blocksVision","canSeeOrSense","isAbleToSense","isAnyKindOfVisible","startedVisible","player","setActorFlag","clearActorFlag","becameVisible","interrupt","ACTION.doAction","moveSpeed","pct","L_NO_SIDEBAR","L_IN_SIDEBAR","setMapFlag","Flags.Map","MAP_SIDEBAR_CHANGED","floor","_other","_item","pickupItem","dropItem","mapChanged","STABLE_COST_MAP","staleMap","alloc","height","update","_v","cellCost","goalMap","path","calculateDistances","costMap","installHandler","handler","toLowerCase","NOOP","parts","shift","steps","step","makeArray","s","installed","effect","effects","values","_a","_b","_c","_d","index","dissipate","priority","groundTile","article","tile","tileMech","push","arraysIntersect","every","blocksMove","T_PATHING_BLOCKER","T_IS_FLAMMABLE","EFFECT.make","reverse","NULL","hasAllEntityFlags","T_IS_DOOR","L_BLOCKS_EVERYTHING","isNull","isWall","arg","result","fg","toString","options","_e","_f","base","extends","tiles","text","replace","search","Number","parseInt","substring","Flags.TileMech","ch","bg","opacity","all","args","NEVER_SEEN","TILE.NULL","chokeCount","machineId","memory","volume","Flags.Cell","TILE.tiles","snapshot","makeMixer","TILE.get","setTile","src","hasStableSnapshot","hasCellFlag","STABLE_SNAPSHOT","hasStableMemory","setCellFlag","reduce","out","clone","hasItem","hasActor","clearCellFlag","needsRedraw","getSnapshot","checkEntities","entityFlags","tileFlags","tileMechFlags","hasTag","hasAllTags","hasAnyTag","withEntities","CHANGED","TILE.Tile","highestPriorityTile","find","blocksPathing","blocksEffects","TILE.flags","T_BLOCKS_OTHER_LAYERS","L_SECRETLY_PASSABLE","T_ANY_LIQUID","superpriority","blocksLayer","blockedByItems","blockedByActors","blockedByOtherLayers","highestPriority","GROUND","currentGround","depthTile","wantGround","clearDepth","SURFACE","glowLightChanged","T_LIST_IN_SIDEBAR","MAP_SIDEBAR_TILES_CHANGED","CAUGHT_FIRE_THIS_TURN","MAP_HAS_FIRE","GAS","MAP_HAS_GAS","LIQUID","MAP_HAS_LIQUID","blackOut","tileFlag","tileMechFlag","hasTileMechFlag","hasAction","itemAt","hasItems","foundIndex","actorAt","_actor","actors","HAS_FX","fx","fxAt","_fx","quantity","ITEM","isPlural","messageYou","view","field","messageThe","messageA","L_FORMAL_NAME","char","firstChar","exec","messageVerb","_name","plural","toPluralVerb","toSingularVerb","addHelper","PainMessages","msgs","_msgs","m","add","msg","singular","clamp","_format","painMessages","ais","wander","loc","random","matchingLoc","NO_PATH","console","log","didNothing","setGoal","nextStep","canPass","clearGoal","typical","isDead","willAttack","damagePct","getPct","morale","chargeChance","lastSawPlayer","canAttack","attack","tooFarFrom","canMoveToward","chance","moveToward","tooCloseTo","hasGoal","moveTowardGoal","isSuccess","scent","nextDir","wanderOpt","object","firstOpt","distanceMap","center","eachNeighbor","canMoveAwayFrom","moveAwayFrom","endTurn","distanceFromTo","safetyMap","costGrid","FORBIDDEN","eachCell","AVOIDED","rescan","ActorKind","Entity.EntityKind","DEFAULT","DEFAULT_ACTOR","vision","normal","health","AI.make","waterOnly","lavaOnly","swim","fly","list","remove","OBSTRUCTION","OK","drawText","makeOptions","makeKind","kinds","randomKind","match","forbidTags","startsWith","k","rng","pain","JSON","stringify","made","ItemKind","Flags.Item","isDoor","isStairs","standStill","flashSprite","duration","Entity.make","addFx","tween","to","repeat","repeatDelay","onUpdate","removeFx","hit","fadeInOut","yoyo","onFinish","moveSprite","source","ceil","maxAxisFromTo","speed","isLoc","vals","stepFn","stopBeforeWalls","moveFx","stop","isInShape","shape","cx","cy","allowCenter","sx","abs","sy","dirFromTo","fade","stopAtWalls","line","forLineFromTo","hasXY","lastIndex","addChild","radius","checkExplosionOpts","FOV","isBlocked","calculate","x1","y1","minX","minY","maxX","maxY","bumpActions","getBumpActions","actionName","selfName","moveDir","newX","newY","currentCell","newCell","FX.hit","message","addAt","canRemoveActor","canAddActor","moveActor","rate","idle","dirIndex","number","DIRS","pickup","avoidsItem","canAddItem","removeItem","addItem","climb","startNewMap","up","activateMachine","activateMachineAction","bind","endsWith","parseFloat","chanceAction","clear","layers","ALL_LAYERS","clearAction","emit","emitAction","feature","featureAction","feat","Effect.installed","messageAction","nourish","nourishAction","adjust","n","pukeMsg","spread","grow","decrement","Flags.Effect","matchTile","EFFECT.makeArray","spreadAction","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","spawnMap","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","reset","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","first","floodFill","cellIsOk","isStart","EVENT_PROTECTED","E_BUILD_IN_WALLS","E_MUST_TOUCH_WALLS","E_NO_TOUCH_WALLS","hasTile","x2","y2","madeChange","startProb","probDec","fill","clearAll","blockingMap","eachActor","matchingLocNear","removeActor","addActor","eachItem","stat","statAction","protected","tileAction","MapLayer","properties","_x","_y","_tile","_dt","updateCellVolume","startingVolume","total","highestVolume","startingTile","highestTile","ObjectFlags","TileFlags","TileMechFlags","CellFlags","exposeToFire","alwaysIgnite","firePriority","bestExtinguishingPriority","explosiveNeighborCount","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","TM_EXPLOSIVE_PROMOTE","x0","y0","event","gas","hasMapFlag","updatedVolumes","cells","d","dissipateGas","spreadGas","gasTick","fire","cancelFns","clearMapFlag","someCell","fireTick","highlightColor","BasicDrawer","offsetX","offsetY","MAP_DANCES","drawCell","draw","needSnapshot","getAppearance","putSnapshot","COLORS_DANCE","applyLight","separate","L_VISUALLY_DISTINCT","IS_CURSOR","inverse","IS_HIGHLIGHTED","mix","colors","red","ground","surface","liquid","drawInto","cosmetic","hasFx","dances","bake","isVisible","isRevealed","getLight","multiply","isCursor","invert","L_BRIGHT_MEMORY","scale","locations","_tweens","app","Tweens","Events","seed","machineCount","drawer","LightSystem","alwaysVisible","callback","onFovChange","FovSystem","setPlayer","load","isAt","fireEffects","_addItem","indexOf","_fireAddItemEffects","_removeItem","_fireRemoveItemEffects","arrayDelete","isKey","hasPlayer","_addActor","_fireAddActorEffects","_removeActor","_fireRemoveActorEffects","_addFx","updated","_removeFx","fmt","dump","MAP_NEEDS_REDRAW","markCursor","clearPath","clearCursor","boundary","isBoundaryXY","dt","triggerAll","willFire","EVENT_FIRED_THIS_TURN","promoteChance","w","eachGlowLight","_cb","FovFlags","PLAYER","isDark","storeMemory","clearMemory","makeVisible","updateChokepoints","updateCounts","passMap","passableArcCount","oldX","CLOCK_DIRS","oldY","cellCount","floodFillCount","i2","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","left","designationSurvives","Snapshot","version","isHallway","arcCount","isPassable","getCellPathCost","fillCostMap","h","updateChokeCounts","lightVersion","cellVersion","snap","srcCell","destCell","eightWays","straightDistanceBetween","getPath","prefab","charToTile","isStringArray","len","members","horde","frequency","Flags","canSpawn","TRUE","_spawnLeader","_spawnMembers","leaderKind","Actor.get","Actor.make","_pickLeaderLoc","_addLeader","member","kindId","countRange","_spawnMember","_pickMemberLoc","_addMember","Map.isHallway","hordes","forbidFlags","oodChance","HORDE_NEVER_OOD","weights","weighted","Attributes","baseValues","_base","_bonus","_sustain","attributes","raiseMax","old","_calcValue","loss","lowerMax","bonus","_addBonus","_clearBonus","arr","o","splice","allAdjustments","adj","_applyAdjustment","sustain","fixed","restore","Skill","_bool","level","_int","disadvantage","advantage","b","_parent","succeed","_has","_level","_fixed","Skills","_skills","lastIndexOf","Scent","_player","_data","highest","v1","hasLiquid","highestLoc","Player","mapToPlayer","mapToMe","getClosestValidLocation","PlayerKind","Actor.ActorKind","Attributes.Attributes","skills","Skills.Skills","attr","defaults","Actor.kinds","Viewport","widget","Widget","_subject","Bounds","lock","lockX","lockY","subject","halfWidth","halfHeight","_attrBool","right","top","bottom","edgeX","edgeY","thirdW","thirdH","blackOutRect","updateOffset","mapX","mapY","_mousemove","contains","showPath","toInnerX","toInnerY","_click","pathTo","highlightPath","highlightCell","defaultStyle","Messages","cache","MessageCache","archive","needsDraw","showArchive","confirmAll","isOnTop","_used","fillRect","confirmed","scene","scenes","run","ArchiveScene","ArchiveWidget","children","destroy","installScene","tabStop","mode","_timeout","_needsDraw","totalCount","shown","wait","_forward","_next","_reverse","finish","fadePercent","dbuf","endY","dy","_confirmed","fgColor","Flavor","Text","overflow","removeClass","addClass","buf","isRemembered","isMapped","isMagicMapped","intro","theItem","standsInTile","T_STAND_IN_TILE","needObjectArticle","Tile.NULL","surfaceTile","liquidTile","apply","_draw","EntryBase","dist","sidebarY","_buffer","_bounds","ActorEntry","ItemEntry","CellEntry","Sidebar","cellCache","lastX","lastY","lastMap","highlight","entry","_highlightRow","clearHighlight","last","showCursor","_getPriority","_makeActorEntry","_makeItemEntry","_makeCellEntry","highlightX","highlightY","_addActorEntry","_addItemEntry","_addCellEntry","sort","highlightAt","updateFor","updateAt","_updateCellCache","_updateEntryCache","BLACK","drawBounds","currentEntry","usedLines","_isDim","Game","Scene","mouse","running","keymap","viewWidth","viewport","viewHeight","sidebar","sideOpts","viewInit","Sidebar.Sidebar","messages","messOpts","Message.Messages","flavOpts","viewOpts","Flavor.Flavor","Viewport.Viewport","create","makeMap","makePlayer","_makeMap","_makePlayer","_startMap","startMap","_initMenu","_initSidebar","_initMessages","_initFlavor","_initViewport","scheduler","Scheduler","start","addActorNear","tweens","nextTime","act","input","defaultPrevented","propagationStopped","MOUSEMOVE","mousemove","CLICK","click","KEYPRESS","keypress","getFlavorText","showText","_ev","_actionFor","setAction","code","rand","enter","open","tick","close","descend","down","dance"],"mappings":"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"}