{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/flags/horde.js","../js/entity/key.js","../js/entity/entity.js","../js/entity/kind.js","../js/actor/actor.js","../js/actor/kind.js","../js/actor/make.js","../js/item/item.js","../js/item/kind.js","../js/item/make.js","../js/effect/handler.js","../js/effect/make.js","../js/tile/tile.js","../js/tile/tiles.js","../js/tile/index.js","../js/layer/mapLayer.js","../js/layer/tileLayer.js","../js/layer/actorLayer.js","../js/layer/itemLayer.js","../js/layer/gasLayer.js","../js/effect/fire.js","../js/effect/handlers/emit.js","../js/effect/handlers/fn.js","../js/effect/handlers/message.js","../js/effect/handlers/activateMachine.js","../js/effect/handlers/effect.js","../js/effect/handlers/tile.js","../js/layer/fireLayer.js","../js/map/cell.js","../js/map/cellMemory.js","../js/map/map.js","../js/map/analyze.js","../js/map/snapshot.js","../js/map/utils.js","../js/path.js","../js/horde/horde.js","../js/horde/make.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_LIST_IN_SIDEBAR\"] = Fl(13)] = \"L_LIST_IN_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(0)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(1)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"KNOWN_TO_BE_TRAP_FREE\"] = Fl(2)] = \"KNOWN_TO_BE_TRAP_FREE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"LIGHT_CHANGED\"] = Fl(14)] = \"LIGHT_CHANGED\";\n    Cell[Cell[\"FOV_CHANGED\"] = Fl(15)] = \"FOV_CHANGED\";\n    // These are to help memory\n    Cell[Cell[\"HAS_SURFACE\"] = Fl(16)] = \"HAS_SURFACE\";\n    Cell[Cell[\"HAS_LIQUID\"] = Fl(17)] = \"HAS_LIQUID\";\n    Cell[Cell[\"HAS_GAS\"] = Fl(18)] = \"HAS_GAS\";\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(19)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(20)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(21)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(22)] = \"HAS_ITEM\";\n    Cell[Cell[\"IS_IN_PATH\"] = Fl(23)] = \"IS_IN_PATH\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(24)] = \"IS_CURSOR\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(25)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW | Cell.LIGHT_CHANGED | Cell.FOV_CHANGED] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_TRAP_FREE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW | Cell.LIGHT_CHANGED] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_SPREAD_CIRCLE\"] = Fl(13)] = \"E_SPREAD_CIRCLE\";\n    Effect[Effect[\"E_SPREAD_LINE\"] = Fl(14)] = \"E_SPREAD_LINE\";\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Horde;\n(function (Horde) {\n    Horde[Horde[\"HORDE_DIES_ON_LEADER_DEATH\"] = Fl(0)] = \"HORDE_DIES_ON_LEADER_DEATH\";\n    Horde[Horde[\"HORDE_IS_SUMMONED\"] = Fl(1)] = \"HORDE_IS_SUMMONED\";\n    Horde[Horde[\"HORDE_SUMMONED_AT_DISTANCE\"] = Fl(2)] = \"HORDE_SUMMONED_AT_DISTANCE\";\n    Horde[Horde[\"HORDE_NO_PERIODIC_SPAWN\"] = Fl(4)] = \"HORDE_NO_PERIODIC_SPAWN\";\n    Horde[Horde[\"HORDE_ALLIED_WITH_PLAYER\"] = Fl(5)] = \"HORDE_ALLIED_WITH_PLAYER\";\n    Horde[Horde[\"HORDE_NEVER_OOD\"] = Fl(15)] = \"HORDE_NEVER_OOD\";\n    // Move all these to tags?\n    // HORDE_LEADER_CAPTIVE = Fl(3), // the leader is in chains and the followers are guards\n    // HORDE_MACHINE_BOSS = Fl(6), // used in machines for a boss challenge\n    // HORDE_MACHINE_WATER_MONSTER = Fl(7), // used in machines where the room floods with shallow water\n    // HORDE_MACHINE_CAPTIVE = Fl(8), // powerful captive monsters without any captors\n    // HORDE_MACHINE_STATUE = Fl(9), // the kinds of monsters that make sense in a statue\n    // HORDE_MACHINE_TURRET = Fl(10), // turrets, for hiding in walls\n    // HORDE_MACHINE_MUD = Fl(11), // bog monsters, for hiding in mud\n    // HORDE_MACHINE_KENNEL = Fl(12), // monsters that can appear in cages in kennels\n    // HORDE_VAMPIRE_FODDER = Fl(13), // monsters that are prone to capture and farming by vampires\n    // HORDE_MACHINE_LEGENDARY_ALLY = Fl(14), // legendary allies\n    // HORDE_MACHINE_THIEF = Fl(16), // monsters that can be generated in the key thief area machines\n    // HORDE_MACHINE_GOBLIN_WARREN = Fl(17), // can spawn in goblin warrens\n    // HORDE_SACRIFICE_TARGET = Fl(18), // can be the target of an assassination challenge; leader will get scary light.\n    // HORDE_MACHINE_ONLY = HORDE_MACHINE_BOSS |\n    //     HORDE_MACHINE_WATER_MONSTER |\n    //     HORDE_MACHINE_CAPTIVE |\n    //     HORDE_MACHINE_STATUE |\n    //     HORDE_MACHINE_TURRET |\n    //     HORDE_MACHINE_MUD |\n    //     HORDE_MACHINE_KENNEL |\n    //     HORDE_VAMPIRE_FODDER |\n    //     HORDE_MACHINE_LEGENDARY_ALLY |\n    //     HORDE_MACHINE_THIEF |\n    //     HORDE_MACHINE_GOBLIN_WARREN |\n    //     HORDE_SACRIFICE_TARGET,\n})(Horde || (Horde = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","import * as Flags from '../flags/entity';\nexport class Entity {\n    constructor(kind) {\n        this.map = null;\n        this.key = null;\n        this.machineHome = 0;\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(cell, this);\n    }\n    avoidsCell(cell) {\n        return this.kind.avoidsCell(cell, this);\n    }\n    getName() {\n        return this.kind.getName(this);\n    }\n    getDescription() {\n        return this.kind.getDescription(this);\n    }\n    getFlavor() {\n        return this.kind.getFlavor(this);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity } from './entity';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.requiredTileTags = [];\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        if (config.requiredTileTags) {\n            if (typeof config.requiredTileTags === 'string') {\n                this.requiredTileTags = config.requiredTileTags\n                    .split(/[,|]/)\n                    .map((t) => t.trim());\n            }\n            else {\n                this.requiredTileTags = config.requiredTileTags\n                    .slice()\n                    .map((t) => t.trim());\n            }\n        }\n    }\n    make(opts) {\n        const entity = new Entity(this);\n        this.init(entity, opts);\n        return entity;\n    }\n    init(entity, opts = {}) {\n        if (opts.machineHome) {\n            entity.machineHome = opts.machineHome;\n        }\n    }\n    forbidsCell(cell, _entity) {\n        if (this.requiredTileTags.length &&\n            !cell.hasAllTileTags(this.requiredTileTags))\n            return true;\n        return false;\n    }\n    avoidsCell(cell, _entity) {\n        if (this.requiredTileTags.length &&\n            !cell.hasAnyTileTag(this.requiredTileTags))\n            return true;\n        return false;\n    }\n    getName(_entity) {\n        return this.name;\n    }\n    getDescription(_entity) {\n        return this.description;\n    }\n    getFlavor(_entity) {\n        return this.flavor;\n    }\n    getVerb(_entity, verb) {\n        return verb;\n    }\n}\n","import * as Entity from '../entity';\nimport * as Flags from '../flags';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.next = null;\n        this.leader = null;\n        this.items = null;\n        // @ts-ignore - initialized in Entity\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n        this.kind = kind;\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    async pickupItem(item, opts) {\n        return this.kind.pickupItem(this, item, opts);\n    }\n    async dropItem(item, opts) {\n        return this.kind.dropItem(this, item, opts);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport { Actor } from './actor';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n    }\n    forbidsCell(cell, actor) {\n        if (super.forbidsCell(cell, actor))\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    }\n    avoidsCell(cell, actor) {\n        if (super.avoidsCell(cell, actor))\n            return true;\n        if (cell.blocksMove())\n            return true;\n        if (cell.blocksPathing())\n            return true;\n        return false;\n    }\n    async pickupItem(actor, item, _opts) {\n        if (!GWU.list.push(actor, 'items', item))\n            return false;\n        // TODO - Pickup effects\n        return true;\n    }\n    async dropItem(actor, item, _opts) {\n        if (!GWU.list.remove(actor, 'items', item))\n            return false;\n        // TODO - Drop effects\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ActorKind } from './kind';\nexport function make(id, makeOptions) {\n    const kind = get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ActorKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ActorKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ActorKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ActorKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import { Entity } from '../entity';\nimport { Depth } from '../flags';\nexport class Item extends Entity {\n    constructor(kind) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore - initialized in constructor\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n}\n","// import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport { Item } from './item';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n    init(item, options = {}) {\n        super.init(item, options);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ItemKind } from './kind';\nexport function make(id, makeOptions) {\n    const kind = get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","// @ts-nocheck\nexport class Handler {\n    make(src, dest) {\n        return true;\n    }\n    fire(config, map, x, y, ctx) {\n        return false;\n    }\n}\nexport const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id] = handler;\n}\n","import * as GWU from 'gw-utils';\nimport { handlers } from './handler';\nimport { Effect as Flags } from '../flags';\nexport function make(opts) {\n    var _a;\n    if (!opts)\n        throw new Error('opts required to make effect.');\n    if (typeof opts === 'string') {\n        throw new Error('Cannot make effect from string: ' + opts);\n    }\n    if (typeof opts === 'function') {\n        opts = { fn: opts };\n    }\n    // now make base effect stuff\n    const info = {\n        flags: GWU.flag.from(Flags, opts.flags),\n        chance: (_a = opts.chance) !== null && _a !== void 0 ? _a : 0,\n        next: null,\n        id: opts.id || 'n/a',\n    };\n    if (opts.next) {\n        if (typeof opts.next === 'string') {\n            info.next = opts.next;\n        }\n        else {\n            info.next = make(opts.next);\n        }\n    }\n    // and all the handlers\n    Object.values(handlers).forEach((v) => v.make(opts, info));\n    return info;\n}\nexport function from(opts) {\n    if (!opts)\n        throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'string') {\n        const effect = effects[opts];\n        if (effect)\n            return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\n// resetMessageDisplayed\nexport function reset(effect) {\n    effect.flags &= ~Flags.E_FIRED;\n}\nexport function resetAll() {\n    Object.values(effects).forEach((e) => reset(e));\n}\nexport const effects = {};\nexport function install(id, config) {\n    const effect = make(config);\n    effects[id] = effect;\n    effect.id = id;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import * as GWU from 'gw-utils';\nimport { make as makeEffect } from '../effect/make';\nimport * as Flags from '../flags';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.effects = {};\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.tags = [];\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.effects) {\n            Object.assign(this.effects, config.effects);\n        }\n        if (this.hasEffect('fire')) {\n            this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n        }\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                config.tags\n                    .split(/[,|]/)\n                    .map((t) => t.trim())\n                    .forEach((t) => {\n                    this.tags.push(t);\n                });\n            }\n            else {\n                this.tags = config.tags.slice().map((t) => t.trim());\n            }\n        }\n    }\n    hasTag(tag) {\n        return this.tags.includes(tag);\n    }\n    hasAnyTag(tags) {\n        return GWU.arraysIntersect(this.tags, tags);\n    }\n    hasAllTags(tags) {\n        return tags.every((t) => this.tags.includes(t));\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    hasEffect(name) {\n        return name in this.effects;\n    }\n    getName(arg) {\n        let opts = {};\n        if (arg === true || arg === false) {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription() {\n        return this.description || this.getName();\n    }\n    getFlavor() {\n        return this.flavor || this.getName();\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { effects: {}, flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const effects = {};\n    Object.assign(effects, base.effects);\n    if (options.effects) {\n        Object.entries(options.effects).forEach(([key, value]) => {\n            if (value === null) {\n                delete effects[key];\n                return;\n            }\n            if (typeof value === 'string') {\n                effects[key] = value;\n                return;\n            }\n            effects[key] = makeEffect(value);\n        });\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        effects,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n        tags: options.tags || null,\n    };\n    const tile = new Tile(config);\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import * as Tile from './tile';\n// These are the minimal set of tiles to make the diggers work\nTile.install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: [30, 30, 30, 20, 0, 0, 0],\n    bg: [2, 2, 10, 0, 2, 2, 0],\n    priority: 10,\n    article: 'the',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: { tile: 'DOOR_OPEN' },\n        open: { tile: 'DOOR_OPEN_ALWAYS' },\n    },\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            tile: 'DOOR',\n            flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY',\n        },\n        enter: null,\n        open: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n});\nTile.install('UP_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'upward staircase',\n    article: 'an',\n    effects: {\n        player: { emit: 'UP_STAIRS' },\n    },\n});\nTile.install('DOWN_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'downward staircase',\n    article: 'a',\n    effects: {\n        player: { emit: 'DOWN_STAIRS' },\n    },\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'an impregnable wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: [5, 8, 20, 10, 0, 4, 15, true],\n    bg: [10, 15, 41, 6, 5, 5, 5, true],\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: [5, 8, 10, 10, 0, 4, 15, true],\n    bg: [10, 30, 30, 6, 0, 10, 10, true],\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    depth: 'SURFACE', // 'LIQUID'?\n});\nTile.install('BRIDGE', {\n    ch: '=',\n    fg: [100, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n});\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\nimport './tiles';\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n}\n","import * as Tile from '../tile';\nimport * as Flags from '../flags';\nimport { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts = {}) {\n        const cell = this.map.cell(x, y);\n        const current = cell.depthTile(tile.depth) || Tile.tiles.NULL;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (cell.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && cell.hasItem())\n            return false;\n        if (opts.blockedByActors && cell.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && cell.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const ground = cell.depthTile(Flags.Depth.GROUND);\n            if (!ground || ground === Tile.tiles.NULL) {\n                this.setTile(x, y, Tile.get(tile.groundTile));\n            }\n        }\n        // if nothing changed... return false\n        if (!cell.setTile(tile))\n            return false;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            cell.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            cell.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            cell.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    async tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire, pressure plates and key-activated tiles.\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (!cell.hasCellFlag(Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM) &&\n                    cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)) {\n                    cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n                }\n                if (cell.hasEffect('noKey') && !this.map.hasKey(x, y)) {\n                    await cell.fire('noKey', this.map, x, y);\n                }\n            }\n        }\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        const tile = cell.depthTile(this.depth);\n        if (tile) {\n            dest.drawSprite(tile.sprite);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { MapLayer } from './mapLayer';\nexport class ActorLayer extends MapLayer {\n    constructor(map, name = 'actor') {\n        super(map, name);\n    }\n    async addActor(x, y, obj, _opts) {\n        const actor = obj;\n        if (actor.isDestroyed)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (actor.forbidsCell(cell))\n            return false;\n        if (!GWU.list.push(cell, 'actor', obj))\n            return false;\n        if (obj.isPlayer()) {\n            cell.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        obj.x = x;\n        obj.y = y;\n        obj.map = this.map;\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('key')) {\n            await cell.fire('key', this.map, x, y);\n        }\n        return true;\n    }\n    forceActor(x, y, actor, _opts) {\n        if (actor.isDestroyed)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (!GWU.list.push(cell, 'actor', actor))\n            return false;\n        if (actor.isPlayer()) {\n            cell.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        actor.x = x;\n        actor.y = y;\n        actor.map = this.map;\n        return true;\n    }\n    async removeActor(obj) {\n        const x = obj.x;\n        const y = obj.y;\n        const cell = this.map.cell(x, y);\n        if (!GWU.list.remove(cell, 'actor', obj))\n            return false;\n        if (obj.isPlayer()) {\n            cell.clearCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('nokey')) {\n            await cell.fire('key', this.map, x, y);\n        }\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        if (!cell.actor)\n            return;\n        dest.drawSprite(cell.actor.sprite);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { MapLayer } from './mapLayer';\nexport class ItemLayer extends MapLayer {\n    constructor(map, name = 'item') {\n        super(map, name);\n    }\n    async addItem(x, y, obj, _opts) {\n        const item = obj;\n        if (item.isDestroyed)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (item.forbidsCell(cell))\n            return false;\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('key')) {\n            await cell.fire('key', this.map, x, y);\n            if (obj.key.disposable) {\n                obj.destroy();\n                return true; // ??? didSomething?\n            }\n        }\n        if (!GWU.list.push(cell, 'item', obj))\n            return false;\n        obj.x = x;\n        obj.y = y;\n        obj.depth = this.depth;\n        obj.map = this.map;\n        if (cell.hasEffect('addItem')) {\n            await cell.fire('addItem', this.map, x, y, { item });\n        }\n        return true;\n    }\n    forceItem(x, y, obj, _opts) {\n        if (!this.map.hasXY(x, y))\n            return false;\n        if (this.map.hasXY(obj.x, obj.y)) {\n            const oldCell = this.map.cell(obj.x, obj.y);\n            GWU.list.remove(oldCell, 'item', obj);\n            obj.x = -1;\n            obj.y = -1;\n        }\n        const cell = this.map.cell(x, y);\n        if (!GWU.list.push(cell, 'item', obj))\n            return false;\n        obj.x = x;\n        obj.y = y;\n        obj.depth = this.depth;\n        obj.map = this.map;\n        return true;\n    }\n    async removeItem(obj) {\n        const x = obj.x;\n        const y = obj.y;\n        const cell = this.map.cell(x, y);\n        if (!GWU.list.remove(cell, 'item', obj))\n            return false;\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('nokey')) {\n            await cell.fire('nokey', this.map, x, y);\n        }\n        else if (cell.hasEffect('removeItem')) {\n            await cell.fire('removeItem', this.map, x, y);\n        }\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        if (!cell.item)\n            return;\n        dest.drawSprite(cell.item.sprite);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    clear() {\n        this.volume.fill(0);\n    }\n    setTile(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.setTile(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.changed = true;\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n        this.changed = other.changed;\n    }\n    async tick(_dt) {\n        if (!this.changed)\n            return false;\n        this.changed = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.changed = true;\n            }\n            else {\n                this.clearTile(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clearTile(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n    putAppearance(dest, x, y) {\n        const volume = this.volume[x][y];\n        if (!volume)\n            return;\n        const cell = this.map.cell(x, y);\n        const tile = cell.depthTile(this.depth);\n        if (tile) {\n            const opacity = this.calcOpacity(volume);\n            dest.drawSprite(tile.sprite, opacity);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Effect as Flags } from '../flags';\nimport { from } from './make';\nimport { handlers } from './handler';\nexport async function fire(effect, map, x, y, ctx_ = {}) {\n    if (!effect)\n        return false;\n    if (typeof effect === 'string') {\n        const name = effect;\n        effect = from(name);\n        if (!effect)\n            throw new Error('Failed to find effect: ' + name);\n    }\n    const ctx = ctx_;\n    if (!ctx.force && effect.chance && !map.rng.chance(effect.chance, 10000))\n        return false;\n    const grid = (ctx.grid = GWU.grid.alloc(map.width, map.height));\n    let didSomething = false;\n    const allHandlers = Object.values(handlers);\n    for (let h of allHandlers) {\n        if (await h.fire(effect, map, x, y, ctx)) {\n            didSomething = true;\n        }\n    }\n    // do the next effect - if applicable\n    if (effect.next &&\n        (didSomething || effect.flags & Flags.E_NEXT_ALWAYS) &&\n        !GWU.data.gameHasEnded) {\n        const nextInfo = typeof effect.next === 'string' ? from(effect.next) : effect.next;\n        if (effect.flags & Flags.E_NEXT_EVERYWHERE) {\n            await grid.forEachAsync(async (v, i, j) => {\n                if (!v)\n                    return;\n                didSomething =\n                    (await fire(nextInfo, map, i, j, ctx)) || didSomething;\n            });\n        }\n        else {\n            didSomething =\n                (await fire(nextInfo, map, x, y, ctx)) || didSomething;\n        }\n    }\n    // bookkeeping\n    if (didSomething &&\n        map.isVisible(x, y) &&\n        !(effect.flags & Flags.E_NO_MARK_FIRED)) {\n        effect.flags |= Flags.E_FIRED;\n    }\n    GWU.grid.free(grid);\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport { Handler, installHandler } from '../handler';\n//////////////////////////////////////////////\n// EMIT\nexport class EmitEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.emit)\n            return true;\n        if (typeof src.emit !== 'string') {\n            throw new Error('emit effects must be string name to emit: { emit: \"EVENT\" }');\n        }\n        dest.emit = src.emit;\n        return true;\n    }\n    async fire(config, _map, x, y, ctx) {\n        if (config.emit) {\n            await GWU.events.emit(config.emit, x, y, ctx);\n            return true;\n        }\n        return false;\n    }\n}\ninstallHandler('emit', new EmitEffect());\n","import { Handler, installHandler } from '../handler';\n//////////////////////////////////////////////\n// FN\nexport class FnEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.fn)\n            return true;\n        if (typeof src.fn !== 'function') {\n            throw new Error('fn effects must be functions.');\n        }\n        dest.fn = src.fn;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.fn) {\n            return await config.fn(config, map, x, y, ctx);\n        }\n        return false;\n    }\n}\ninstallHandler('fn', new FnEffect());\n","import * as GWU from 'gw-utils';\nimport { Handler, installHandler } from '../handler';\nimport { Effect as Flags } from '../../flags';\n//////////////////////////////////////////////\n// MESSAGE\nexport class MessageEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.message)\n            return true;\n        if (typeof src.message !== 'string') {\n            throw new Error('Emit must be configured with name of event to emit');\n        }\n        dest.message = src.message;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (!config.message)\n            return false;\n        const fired = !!(config.flags & Flags.E_FIRED);\n        if (config.message &&\n            config.message.length &&\n            !fired &&\n            map.isVisible(x, y)) {\n            GWU.message.addAt(x, y, config.message, ctx);\n            return true;\n        }\n        return false;\n    }\n}\ninstallHandler('message', new MessageEffect());\n","import { Handler, installHandler } from '../handler';\n//////////////////////////////////////////////\n// ActivateMachine\nexport class ActivateMachineEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.activateMachine)\n            return true;\n        dest.activateMachine = true;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.activateMachine) {\n            const cell = map.cell(x, y);\n            const machine = cell.machineId;\n            if (!machine)\n                return false;\n            return await map.activateMachine(machine, x, y, ctx);\n        }\n        return false;\n    }\n}\ninstallHandler('activateMachine', new ActivateMachineEffect());\n","import { Handler, installHandler } from '../handler';\nimport * as FIRE from '../fire';\n//////////////////////////////////////////////\n// EMIT\nexport class EffectEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.effect)\n            return true;\n        dest.effect = src.effect;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.effect) {\n            return await FIRE.fire(config.effect, map, x, y, ctx);\n        }\n        return false;\n    }\n}\ninstallHandler('effect', new EffectEffect());\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../../flags';\nimport * as Tile from '../../tile';\nimport { Handler, installHandler } from '../handler';\nimport { Actor } from '../../actor';\nimport { Item } from '../../item';\nexport class SpawnEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (!src.tile)\n            return true; // no error\n        let config = src.tile;\n        if (typeof config === 'string') {\n            const parts = config.split(/[,|]/).map((p) => p.trim());\n            config = {\n                tile: parts[0],\n                grow: Number.parseInt(parts[1] || '0'),\n                decrement: Number.parseInt(parts[2] || '0'),\n            };\n        }\n        const info = {\n            grow: (_b = (_a = config.grow) !== null && _a !== void 0 ? _a : config.spread) !== null && _b !== void 0 ? _b : 0,\n            decrement: (_c = config.decrement) !== null && _c !== void 0 ? _c : 0,\n            flags: GWU.flag.from(Flags.Effect, config.flags),\n            volume: (_d = config.volume) !== null && _d !== void 0 ? _d : 0,\n            next: (_e = config.next) !== null && _e !== void 0 ? _e : null,\n        };\n        const id = (_f = config.tile) !== null && _f !== void 0 ? _f : config.id;\n        if (typeof id === 'string') {\n            info.tile = id;\n        }\n        else {\n            throw new Error('Invalid tile spawn config: ' + id);\n        }\n        if (!info.tile) {\n            throw new Error('Must have tile.');\n        }\n        const match = (_g = config.matchTile) !== null && _g !== void 0 ? _g : config.match;\n        if (typeof match === 'string') {\n            info.matchTile = match;\n        }\n        else if (match) {\n            throw new Error('Invalid tile spawn match tile: ' + config.matchTile);\n        }\n        dest.tile = info;\n        return true;\n    }\n    fire(effect, map, x, y, ctx) {\n        if (!effect.tile)\n            return false; // did nothing\n        const id = effect.tile.tile;\n        const tile = Tile.tiles[id] || null;\n        if (!tile) {\n            throw new Error('Failed to find tile for effect: ' + id);\n        }\n        const abortIfBlocking = !!(effect.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n        const isBlocking = !!(abortIfBlocking &&\n            !(effect.flags & Flags.Effect.E_PERMIT_BLOCKING) &&\n            (tile.blocksPathing() ||\n                effect.flags & Flags.Effect.E_TREAT_AS_BLOCKING));\n        let didSomething = false;\n        didSomething = computeSpawnMap(effect, map, x, y, ctx);\n        if (!didSomething) {\n            return false;\n        }\n        if (abortIfBlocking &&\n            isBlocking &&\n            this.mapDisruptedBy(map, ctx.grid)) {\n            // GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (effect.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, ctx.grid)) {\n                didSomething = true;\n            }\n        }\n        if (effect.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, ctx.grid)) {\n                didSomething = true;\n            }\n        }\n        if (effect.flags & Flags.Effect.E_CLEAR_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (clearCells(map, ctx.grid, effect.flags)) {\n                didSomething = true;\n            }\n        }\n        const spawned = spawnTiles(effect.flags, ctx.grid, map, tile, effect.tile.volume, ctx.machine);\n        return spawned;\n    }\n    mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n        const walkableGrid = GWU.grid.alloc(map.width, map.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GWU.xy.forRect(map.width, map.height, (i, j) => {\n            const lakeX = i + blockingToMapX;\n            const lakeY = j + blockingToMapY;\n            if (blockingGrid.get(lakeX, lakeY)) {\n                if (map.cellInfo(i, j).isStairs()) {\n                    disrupts = true;\n                }\n            }\n            else if (!map.cellInfo(i, j).blocksMove()) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGWU.grid.dump();\n        GWU.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\ninstallHandler('tile', new SpawnEffect());\n// tick\n// Spawn\nexport function spawnTiles(flags, spawnMap, map, tile, volume = 0, machine) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = !!(flags & Flags.Effect.E_BLOCKED_BY_OTHER_LAYERS);\n    const superpriority = !!(flags & Flags.Effect.E_SUPERPRIORITY);\n    const blockedByActors = !!(flags & Flags.Effect.E_BLOCKED_BY_ACTORS);\n    const blockedByItems = !!(flags & Flags.Effect.E_BLOCKED_BY_ITEMS);\n    // const applyEffects = ctx.refreshCell;\n    volume = volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            // const isRoot = spawnMap[i][j] === 1;\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.hasTile(tile)) {\n                // If the new cell already contains the fill terrain,\n                // if (tile.depth == Flags.Depth.GAS) {\n                //     spawnMap[i][j] = 1;\n                //     cell.gasVolume += volume;\n                // } else if (tile.depth == Flags.Depth.LIQUID) {\n                //     spawnMap[i][j] = 1;\n                //     cell.liquidVolume += volume;\n                // }\n            }\n            else if (map.setTile(i, j, tile, {\n                volume,\n                superpriority,\n                blockedByOtherLayers,\n                blockedByActors,\n                blockedByItems,\n                machine,\n            })) {\n                // if the fill won't violate the priority of the most important terrain in this cell:\n                spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                // map.redrawCell(cell);\n                // if (volume && cell.gas) {\n                //     cell.volume += (feat.volume || 0);\n                // }\n                cell.flags.cell |= Flags.Cell.EVENT_FIRED_THIS_TURN;\n                if (flags & Flags.Effect.E_PROTECTED) {\n                    cell.flags.cell |= Flags.Cell.EVENT_PROTECTED;\n                }\n                accomplishedSomething = true;\n                // debug('- tile', i, j, 'tile=', tile.id);\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.setMapFlag(Flags.Map.MAP_CHANGED);\n    }\n    return accomplishedSomething;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.tile.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cellInfo(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cellInfo(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cellInfo(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cellInfo(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.tile.matchTile &&\n        !isStart &&\n        !cell.hasTile(effect.tile.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, map, x, y, ctx) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const config = effect.tile;\n    let startProb = config.grow || 0;\n    let probDec = config.decrement || 0;\n    const spawnMap = ctx.grid;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, x, y, true)) {\n        return false;\n    }\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\n// export function spreadCircle(\n//     this: any,\n//     ctx: Effect.EffectCtx,\n//     spawnMap: GWU.grid.NumGrid\n// ) {\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     let radius = 0;\n//     startProb = startProb || 100;\n//     if (startProb >= 100) {\n//         probDec = probDec || 100;\n//     }\n//     while (map.rng.chance(startProb)) {\n//         startProb -= probDec;\n//         ++radius;\n//     }\n//     // startProb = 100;\n//     // probDec = 0;\n//     spawnMap.updateCircle(x, y, radius, (_v, i, j) => {\n//         if (!cellIsOk(this, i, j, ctx)) return 0;\n//         // const dist = Math.floor(GWU.utils.distanceBetween(x, y, i, j));\n//         // const prob = startProb - dist * probDec;\n//         // if (!map.rng.chance(prob)) return 0;\n//         return 1;\n//     });\n//     // spawnMap[x][y] = 1;\n//     // if (!isOk(flags, x, y, ctx)) {\n//     //     spawnMap[x][y] = 0;\n//     // }\n//     return true;\n// }\n// export function spreadLine(\n//     this: any,\n//     ctx: Effect.EffectCtx,\n//     spawnMap: GWU.grid.NumGrid\n// ) {\n//     let x2, y2;\n//     let madeChange;\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     if (startProb) {\n//         madeChange = true;\n//         if (startProb >= 100) {\n//             probDec = probDec || 100;\n//         }\n//         x2 = x;\n//         y2 = y;\n//         const dir = GWU.xy.DIRS[map.rng.number(4)];\n//         while (madeChange) {\n//             madeChange = false;\n//             x2 = x2 + dir[0];\n//             y2 = y2 + dir[1];\n//             if (\n//                 spawnMap.hasXY(x2, y2) &&\n//                 !spawnMap[x2][y2] &&\n//                 cellIsOk(this, x2, y2, ctx) &&\n//                 map.rng.chance(startProb)\n//             ) {\n//                 spawnMap[x2][y2] = 1;\n//                 madeChange = true;\n//                 startProb -= probDec;\n//             }\n//         }\n//     }\n//     if (!cellIsOk(this, x, y, ctx)) {\n//         spawnMap[x][y] = 0;\n//     }\n//     return true;\n// }\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let i = 0, j = 0;\n    let didSomething = false;\n    for (i = 0; i < map.width; i++) {\n        for (j = 0; j < map.height; j++) {\n            if (!blockingMap[i][j])\n                continue;\n            const cell = map.cell(i, j);\n            if (!cell.hasActor())\n                continue;\n            GWU.list.forEach(cell.actor, (obj) => {\n                if (!(obj instanceof Actor))\n                    return;\n                const monst = obj;\n                const loc = map.rng.matchingLocNear(i, j, (x, y) => {\n                    if (!map.hasXY(x, y))\n                        return false;\n                    if (blockingMap[x][y])\n                        return false;\n                    const c = map.cell(x, y);\n                    return !monst.forbidsCell(c);\n                });\n                if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                    map.moveActor(loc[0], loc[1], monst);\n                    // map.redrawXY(loc[0], loc[1]);\n                    didSomething = true;\n                }\n            });\n        }\n    }\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    blockingMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (!cell.hasItem())\n            return;\n        GWU.list.forEach(cell.item, (obj) => {\n            if (!(obj instanceof Item))\n                return;\n            const item = obj;\n            const loc = map.rng.matchingLocNear(i, j, (x, y) => {\n                if (!map.hasXY(x, y))\n                    return false;\n                if (blockingMap[x][y])\n                    return false;\n                const dest = map.cell(x, y);\n                return !item.forbidsCell(dest);\n            });\n            if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                map.moveItem(loc[0], loc[1], item);\n                // map.redrawXY(loc[0], loc[1]);\n                didSomething = true;\n            }\n        });\n    });\n    return didSomething;\n}\nclass ClearTileEffect extends Handler {\n    constructor() {\n        super();\n    }\n    make(src, dest) {\n        if (!src.clear)\n            return true;\n        let config = src.clear;\n        let layers = 0;\n        if (typeof config === 'string') {\n            config = config.split(/[,|]/).map((t) => t.trim());\n        }\n        if (config === true) {\n            layers = Flags.Depth.ALL_LAYERS;\n        }\n        else if (typeof config === 'number') {\n            layers = config;\n        }\n        else if (Array.isArray(config)) {\n            layers = config.reduce((out, v) => {\n                if (typeof v === 'number')\n                    return out | v;\n                const depth = Flags.Depth[v] || 0;\n                return out | depth;\n            }, 0);\n        }\n        else {\n            throw new Error('clear effect must have number or string config.');\n        }\n        dest.clear = layers;\n        return layers > 0;\n    }\n    async fire(config, map, x, y, ctx) {\n        return this.fireSync(config, map, x, y, ctx);\n    }\n    fireSync(config, map, x, y, _ctx) {\n        if (!config.clear)\n            return false;\n        if (!map)\n            return false;\n        const cell = map.cell(x, y);\n        return cell.clearDepth(config.clear);\n    }\n}\ninstallHandler('clear', new ClearTileEffect());\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nimport * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    async tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    await this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.xy.DIRS[d];\n                        await this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    async exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = Effect.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && this.map.rng.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            await cell.fire(event, this.map, x, y, {\n                force: true,\n            });\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as Effect from '../effect';\nclass CellObjects {\n    constructor(cell) {\n        this.cell = cell;\n    }\n    eachItem(cb) {\n        let object = this.cell._item;\n        while (object) {\n            cb(object);\n            object = object.next;\n        }\n    }\n    eachActor(cb) {\n        let object = this.cell._actor;\n        while (object) {\n            cb(object);\n            object = object.next;\n        }\n    }\n    forEach(cb) {\n        this.eachItem(cb);\n        this.eachActor(cb);\n    }\n    some(cb) {\n        let object = this.cell._item;\n        while (object) {\n            if (cb(object))\n                return true;\n            object = object.next;\n        }\n        object = this.cell._actor;\n        while (object) {\n            if (cb(object))\n                return true;\n            object = object.next;\n        }\n        return false;\n    }\n    reduce(cb, start) {\n        let object = this.cell._item;\n        while (object) {\n            if (start === undefined) {\n                start = object;\n            }\n            else {\n                start = cb(start, object);\n            }\n            object = object.next;\n        }\n        object = this.cell._actor;\n        while (object) {\n            if (start === undefined) {\n                start = object;\n            }\n            else {\n                start = cb(start, object);\n            }\n            object = object.next;\n        }\n        return start;\n    }\n}\nexport class Cell {\n    constructor(map, x, y, groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        // keyId = 0;\n        // gasVolume: number = 0;\n        // liquidVolume: number = 0;\n        this._actor = null;\n        this._item = null;\n        this.x = -1;\n        this.y = -1;\n        this._objects = new CellObjects(this);\n        this.flags = { cell: Flags.Cell.NEEDS_REDRAW };\n        this.tiles = [TILE.tiles.NULL];\n        this.map = map;\n        this.x = x;\n        this.y = y;\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this._actor = other._actor;\n        this._item = other._item;\n        // this.keyId = other.keyId;\n        this.machineId = other.machineId;\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag) {\n        return (this.tiles.some((t) => t && t.flags.entity & flag) ||\n            this._objects.some((o) => !!(o.flags.entity & flag)));\n    }\n    hasAllEntityFlags(flags) {\n        return (this.entityFlags() & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    hasTileTag(tag) {\n        return this.tiles.some((tile) => tile && tile.hasTag(tag));\n    }\n    hasAllTileTags(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAllTags(tags);\n        });\n    }\n    hasAnyTileTag(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAnyTag(tags);\n        });\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags() {\n        return (this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0) |\n            this._objects.reduce((out, o) => out | o.flags.entity, 0));\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    itemFlags() {\n        let flags = 0;\n        this._objects.eachItem((i) => {\n            flags |= i.flags.item;\n        });\n        return flags;\n    }\n    actorFlags() {\n        let flags = 0;\n        this._objects.eachActor((a) => {\n            flags |= a.flags.actor;\n        });\n        return flags;\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return (this.tiles.some((t) => t && t.blocksVision()) ||\n            this._objects.some((o) => o.blocksVision()));\n    }\n    blocksPathing() {\n        return (this.tiles.some((t) => t && t.blocksPathing()) ||\n            this._objects.some((o) => o.blocksPathing()));\n    }\n    blocksMove() {\n        return (this.tiles.some((t) => t && t.blocksMove()) ||\n            this._objects.some((o) => o.blocksMove()));\n    }\n    blocksEffects() {\n        return (this.tiles.some((t) => t && t.blocksEffects()) ||\n            this._objects.some((o) => o.blocksEffects()));\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isEmpty() {\n        return (this.tiles.every((t) => !t || t === TILE.tiles.NULL) &&\n            this._actor == null &&\n            this._item == null);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile)\n            return false;\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        if (current.light !== tile.light) {\n            this.setCellFlag(Flags.Cell.LIGHT_CHANGED);\n        }\n        if (current.blocksVision() !== tile.blocksVision()) {\n            this.setCellFlag(Flags.Cell.FOV_CHANGED);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this._actor = null;\n        this._item = null;\n        if (tile) {\n            this.setTile(tile);\n        }\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    async fire(event, map, x, y, ctx = {}) {\n        ctx.cell = this;\n        let didSomething = false;\n        if (ctx.depth !== undefined) {\n            const tile = (ctx.tile = this.depthTile(ctx.depth));\n            if (tile && tile.effects) {\n                const ev = tile.effects[event];\n                didSomething = await this._activate(ev, map, x, y, ctx);\n            }\n        }\n        else {\n            // console.log('fire event - %s', event);\n            for (ctx.tile of this.tiles) {\n                if (!ctx.tile || !ctx.tile.effects)\n                    continue;\n                const ev = ctx.tile.effects[event];\n                // console.log(' - ', ev);\n                if (await this._activate(ev, map, x, y, ctx)) {\n                    didSomething = true;\n                    break;\n                }\n                // }\n            }\n        }\n        return didSomething;\n    }\n    async _activate(effect, map, x, y, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.effects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = await Effect.fire(effect, map, x, y, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    get item() {\n        return this._item;\n    }\n    set item(val) {\n        this._item = val;\n        if (val) {\n            this.setCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        else {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        this.needsRedraw = true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this._actor;\n    }\n    set actor(val) {\n        this._actor = val;\n        if (val) {\n            this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        }\n        else {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        var _a, _b, _c, _d;\n        if ((_b = (_a = this._actor) === null || _a === void 0 ? void 0 : _a.sprite) === null || _b === void 0 ? void 0 : _b.ch)\n            return this._actor.sprite.ch;\n        if ((_d = (_c = this._item) === null || _c === void 0 ? void 0 : _c.sprite) === null || _d === void 0 ? void 0 : _d.ch)\n            return this._item.sprite.ch;\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nexport class CellMemory {\n    constructor() {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.keyId = 0;\n        this.flags = {\n            cell: 0,\n            item: 0,\n            actor: 0,\n            tile: 0,\n            tileMech: 0,\n            object: 0,\n        };\n        this.blocks = {\n            vision: false,\n            effects: false,\n            move: false,\n            pathing: false,\n        };\n        this._tile = TILE.tiles.NULL;\n        this._item = null;\n        this._actor = null;\n        this._hasKey = false;\n        this.snapshot = new GWU.sprite.Mixer();\n    }\n    clear() {\n        this.snapshot.blackOut();\n        this._item = null;\n        this._actor = null;\n        this._tile = TILE.tiles.NULL;\n        this.flags.cell = 0;\n        this.flags.object = 0;\n        this.flags.tile = 0;\n        this.flags.tileMech = 0;\n        this.blocks.effects = false;\n        this.blocks.move = false;\n        this.blocks.pathing = false;\n        this.blocks.vision = false;\n        this.machineId = 0;\n        this.chokeCount = 0;\n    }\n    store(cell) {\n        this._item = null;\n        if (cell.hasItem()) {\n            this._item = cell.item;\n        }\n        this._actor = null;\n        if (cell.hasActor()) {\n            this._actor = cell.actor;\n        }\n        this._tile = cell.tile;\n        this.flags.cell = cell.cellFlags();\n        this.flags.tile = cell.tileFlags();\n        this.flags.tileMech = cell.tileMechFlags();\n        this.flags.object = cell.entityFlags();\n        this.flags.item = cell.itemFlags();\n        this.flags.actor = cell.actorFlags();\n        this.blocks.effects = cell.blocksEffects();\n        this.blocks.move = cell.blocksMove();\n        this.blocks.pathing = cell.blocksPathing();\n        this.blocks.vision = cell.blocksVision();\n        this.chokeCount = cell.chokeCount;\n        this.machineId = cell.machineId;\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get needsRedraw() {\n        return this.hasCellFlag(Flags.Cell.NEEDS_REDRAW);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.flags.tile & flags) == flags;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.object & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.object & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags() {\n        return this.flags.object;\n    }\n    tileFlags() {\n        return this.flags.tile;\n    }\n    tileMechFlags() {\n        return this.flags.tileMech;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    blocksVision() {\n        return this.blocks.vision;\n    }\n    blocksPathing() {\n        return this.blocks.pathing;\n    }\n    blocksMove() {\n        return this.blocks.move;\n    }\n    blocksEffects() {\n        return this.blocks.effects;\n    }\n    isWall() {\n        return this.blocksVision() && this.blocksMove();\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isPassable() {\n        return !this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    get tile() {\n        return this._tile;\n    }\n    hasTile(tile) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this._tile === tile;\n    }\n    hasItem() {\n        return !!this._item;\n    }\n    get item() {\n        return this._item;\n    }\n    hasActor() {\n        return !!this._actor;\n    }\n    hasPlayer() {\n        return !!(this.flags.cell & Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this._actor;\n    }\n    getDescription() {\n        throw new Error('Method not implemented.');\n    }\n    getFlavor() {\n        throw new Error('Method not implemented.');\n    }\n    getName(_opts) {\n        throw new Error('Method not implemented.');\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport * as Layer from '../layer';\nimport { CellMemory } from './cellMemory';\nimport * as Effect from '../effect';\nexport class Map {\n    constructor(width, height, opts = {}) {\n        this.machineCount = 0;\n        this._seed = 0;\n        this.rng = GWU.rng.random;\n        this.width = width;\n        this.height = height;\n        this.flags = { map: 0 };\n        this.layers = [];\n        this.cells = GWU.grid.make(width, height, (x, y) => new Cell(this, x, y));\n        this.memory = GWU.grid.make(width, height, () => new CellMemory());\n        if (opts.seed) {\n            this._seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        this.fov = new GWU.fov.FovSystem(this, opts);\n        this.properties = {};\n        this.initLayers();\n    }\n    get seed() {\n        return this._seed;\n    }\n    set seed(v) {\n        this._seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    cellInfo(x, y, useMemory = false) {\n        if (useMemory)\n            return this.memory[x][y];\n        return this.cell(x, y);\n    }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n        this.addLayer(Flags.Depth.SURFACE, new Layer.FireLayer(this, 'surface'));\n        this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n        this.addLayer(Flags.Depth.ITEM, new Layer.ItemLayer(this, 'item'));\n        this.addLayer(Flags.Depth.ACTOR, new Layer.ActorLayer(this, 'actor'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // DRAW\n    drawInto(dest, opts = {}) {\n        const buffer = dest instanceof GWU.canvas.Canvas ? dest.buffer : dest;\n        if (typeof opts === 'boolean')\n            opts = { force: opts };\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                // const cell = this.cell(x, y);\n                // if (\n                //     cell.needsRedraw ||\n                //     this.light.lightChanged(x, y) ||\n                //     this.fov.fovChanged(x, y)\n                // ) {\n                this.getAppearanceAt(x, y, mixer);\n                buffer.drawSprite(x, y, mixer);\n                // }\n            }\n        }\n    }\n    // items\n    hasItem(x, y) {\n        return this.cell(x, y).hasItem();\n    }\n    itemAt(x, y) {\n        return this.cell(x, y).item;\n    }\n    eachItem(cb) {\n        this.cells.forEach((cell) => {\n            GWU.list.forEach(cell.item, cb);\n        });\n    }\n    async addItem(x, y, item) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && (await layer.addItem(x, y, item))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    forceItem(x, y, item) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && layer.forceItem(x, y, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async removeItem(item) {\n        const layer = this.layers[item.depth];\n        return layer.removeItem(item);\n    }\n    async moveItem(x, y, item) {\n        if (!this.hasXY(x, y))\n            return false;\n        const layer = this.layers[item.depth];\n        if (!(await layer.removeItem(item)))\n            return false;\n        return this.addItem(x, y, item);\n    }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    actorAt(x, y) {\n        return this.cell(x, y).actor;\n    }\n    eachActor(cb) {\n        this.cells.forEach((cell) => {\n            GWU.list.forEach(cell.actor, cb);\n        });\n    }\n    async addActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && (await layer.addActor(x, y, actor))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    forceActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && layer.forceActor(x, y, actor)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async removeActor(actor) {\n        const layer = this.layers[actor.depth];\n        return layer.removeActor(actor);\n    }\n    async moveActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        const layer = this.layers[actor.depth];\n        if (!(await layer.removeActor(actor)))\n            return false;\n        return this.addActor(x, y, actor);\n    }\n    // Information\n    isVisible(x, y) {\n        return this.fov.isAnyKindOfVisible(x, y);\n    }\n    hasKey(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cells[x][y];\n        return cell._objects.some((e) => !!e.key && e.key.matches(x, y));\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        const mixer = new GWU.sprite.Mixer();\n        const getCh = (_cell, x, y) => {\n            this.getAppearanceAt(x, y, mixer);\n            if (mixer.ch < 0)\n                return ' ';\n            return mixer.ch;\n        };\n        this.cells.dump(fmt || getCh, log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        this.fov.needsUpdate = true;\n        this.layers.forEach((l) => l.clear());\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cell(i, j);\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile, useMemory = false) {\n        return this.cellInfo(x, y, useMemory).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof Layer.TileLayer))\n            return false;\n        return layer.setTile(x, y, tile, opts);\n    }\n    clearTiles(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clearTiles(tile);\n    }\n    async tick(dt) {\n        let didSomething = await this.fireAll('tick');\n        for (let layer of this.layers) {\n            if (layer && (await layer.tick(dt))) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cells[x][y]);\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.flags.map = src.flags.map;\n        this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        this.machineCount = src.machineCount;\n        this._seed = src._seed;\n        this.properties = Object.assign({}, src.properties);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    async fire(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.fire(event, this, x, y, ctx);\n    }\n    async fireAll(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        await willFire.forEachAsync(async (w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    await cell.fire(event, this, x, y, {\n                        force: true,\n                        depth,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    async activateMachine(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cells[x][y];\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        (await cell.fire('machine', this, x, y, ctx)) ||\n                            didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    getAppearanceAt(x, y, dest) {\n        dest.blackOut();\n        const cell = this.cell(x, y);\n        const isVisible = this.fov.isAnyKindOfVisible(x, y);\n        if (cell.needsRedraw && isVisible) {\n            this.layers.forEach((layer) => layer.putAppearance(dest, x, y));\n            if (dest.dances) {\n                cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n            }\n            else {\n                cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n            }\n            dest.bake();\n            this.memory[x][y].putSnapshot(dest);\n            cell.needsRedraw = false;\n        }\n        else {\n            this.memory[x][y].getSnapshot(dest);\n        }\n        if (isVisible) {\n            const light = this.light.getLight(x, y);\n            dest.multiply(light);\n        }\n        else if (this.fov.isRevealed(x, y)) {\n            dest.scale(50);\n        }\n        else {\n            dest.blackOut();\n        }\n        if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n            GWU.color.separate(dest.fg, dest.bg);\n        }\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(_cb) {\n        // TODO !!\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    onCellRevealed(_x, _y) {\n        // if (DATA.automationActive) {\n        // if (cell.item) {\n        //     const theItem: GW.types.ItemType = cell.item;\n        //     if (\n        //         theItem.hasObjectFlag(ObjectFlags.L_INTERRUPT_WHEN_SEEN)\n        //     ) {\n        //         GW.message.add(\n        //             '§you§ §see§ ΩitemMessageColorΩ§item§∆.',\n        //             {\n        //                 item: theItem,\n        //                 actor: DATA.player,\n        //             }\n        //         );\n        //     }\n        // }\n        // if (\n        //     !(this.fov.isMagicMapped(x, y)) &&\n        //     this.site.hasObjectFlag(\n        //         x,\n        //         y,\n        //         ObjectFlags.L_INTERRUPT_WHEN_SEEN\n        //     )\n        // ) {\n        //     const tile = cell.tileWithLayerFlag(\n        //         ObjectFlags.L_INTERRUPT_WHEN_SEEN\n        //     );\n        //     if (tile) {\n        //         GW.message.add(\n        //             '§you§ §see§ ΩbackgroundMessageColorΩ§item§∆.',\n        //             {\n        //                 actor: DATA.player,\n        //                 item: tile.name,\n        //             }\n        //         );\n        //     }\n        // }\n    }\n    redrawCell(x, y, clearMemory) {\n        if (clearMemory) {\n            this.clearMemory(x, y);\n        }\n        this.cells[x][y].needsRedraw = true;\n    }\n    clearMemory(x, y) {\n        this.memory[x][y].clear();\n    }\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        this.memory[x][y].store(cell);\n    }\n}\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n    }\n    map.light.update();\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount = cellCount;\n                                            map.cell(i2, j2).flags.cell &= ~Flags.Cell\n                                                .IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        this.layerVersion = [];\n        this.lightVersion = 0;\n        this.fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        if (this.map.fov.changed) {\n            this.fovVersion = this.version;\n            this.map.fov.changed = false;\n        }\n        if (snap.version !== this.fovVersion) {\n            snap.map.fov.copy(this.map.fov);\n        }\n        // layers\n        this.map.layers.forEach((layer, index) => {\n            const snapLayer = snap.map.layers[index];\n            if (layer.changed) {\n                this.layerVersion[index] = this.version;\n            }\n            if (this.layerVersion[index] !== snap.version) {\n                snapLayer.copy(layer);\n            }\n        });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        if (snap.version < this.fovVersion || this.map.fov.changed) {\n            this.map.fov.copy(snap.map.fov);\n            this.fovVersion = snap.version;\n        }\n        // layers\n        this.layerVersion.forEach((v, index) => {\n            if (v < snap.version)\n                return;\n            const destLayer = this.map.layers[index];\n            if (v > snap.version || destLayer.changed) {\n                const srcLayer = snap.map.layers[index];\n                destLayer.copy(srcLayer);\n                this.layerVersion[index] = snap.version;\n            }\n        });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function isHallway(map, x, y) {\n    return (GWU.xy.arcCount(x, y, (i, j) => {\n        return map.cell(i, j).isPassable();\n    }) > 1);\n}\n","import * as GWU from 'gw-utils';\nexport function getCellPathCost(map, x, y) {\n    const cell = map.cell(x, y);\n    if (cell.blocksMove())\n        return GWU.path.OBSTRUCTION;\n    if (cell.blocksPathing())\n        return GWU.path.FORBIDDEN;\n    if (cell.hasActor())\n        return 10;\n    return 1;\n}\nexport function fillCostMap(map, costMap) {\n    costMap.update((_v, x, y) => getCellPathCost(map, x, y));\n}\nexport function getPathBetween(map, x0, y0, x1, y1, options = {}) {\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = GWU.grid.alloc(map.width, map.height);\n    fillCostMap(map, costMap);\n    GWU.path.calculateDistances(distanceMap, x0, y0, costMap, options.eightWays, GWU.xy.straightDistanceBetween(x0, y0, x1, y1) + 1);\n    const path = GWU.path.getPath(distanceMap, x1, y1, (x, y) => map.cell(x, y).blocksMove(), options.eightWays);\n    GWU.grid.free(costMap);\n    GWU.grid.free(distanceMap);\n    return path;\n}\n","import * as GWU from 'gw-utils';\nimport { Horde as Flags } from '../flags/horde';\nimport * as Map from '../map';\nimport * as Actor from '../actor';\nexport class Horde {\n    // requiredTile: string | null = null;\n    constructor(config) {\n        this.tags = [];\n        this.members = {};\n        // blueprintId: string | null = null;\n        this.flags = { horde: 0 };\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        this.leader = config.leader;\n        if (config.members) {\n            Object.entries(config.members).forEach(([id, range]) => {\n                this.members[id] = GWU.range.make(range);\n            });\n        }\n        this.frequency = GWU.frequency.make(config.frequency || 100);\n        // this.blueprintId = config.blueprintId || null;\n        this.flags.horde = GWU.flag.from(Flags, config.flags);\n        // if (config.requiredTile) this.requiredTile = config.requiredTile;\n    }\n    async spawn(map, x = -1, y = -1, opts = {}) {\n        var _a, _b;\n        if (typeof opts === 'boolean') {\n            opts = { canBeVisible: opts };\n        }\n        opts.canBeVisible = (_a = opts.canBeVisible) !== null && _a !== void 0 ? _a : !map.fov.isEnabled;\n        opts.rng = opts.rng || map.rng;\n        opts.machine = (_b = opts.machine) !== null && _b !== void 0 ? _b : 0;\n        const leader = await this._spawnLeader(map, x, y, opts);\n        if (!leader)\n            return null;\n        await this._spawnMembers(leader, map, opts);\n        return leader;\n    }\n    async _spawnLeader(map, x, y, opts) {\n        const leaderKind = Actor.get(this.leader);\n        if (!leaderKind) {\n            throw new Error('Failed to find leader kind = ' + this.leader);\n        }\n        if (x >= 0 && y >= 0) {\n            if (leaderKind.avoidsCell(map.cell(x, y)))\n                return null;\n        }\n        const leader = Actor.make(leaderKind, { machineHome: opts.machine });\n        if (!leader)\n            throw new Error('Failed to make horde leader - ' + this.leader);\n        if (x < 0 || y < 0) {\n            [x, y] = this._pickLeaderLoc(leader, map, opts) || [-1, -1];\n            if (x < 0 || y < 0) {\n                return null;\n            }\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!(await this._addLeader(leader, map, x, y, opts))) {\n            return null;\n        }\n        return leader;\n    }\n    async _addLeader(leader, map, x, y, _opts) {\n        return map.addActor(x, y, leader);\n    }\n    async _addMember(member, map, x, y, leader, _opts) {\n        member.leader = leader;\n        return map.addActor(x, y, member);\n    }\n    async _spawnMembers(leader, map, opts) {\n        const entries = Object.entries(this.members);\n        if (entries.length == 0)\n            return 0;\n        let count = 0;\n        await Promise.all(entries.map(async ([kindId, countRange]) => {\n            const count = countRange.value(opts.rng);\n            for (let i = 0; i < count; ++i) {\n                await this._spawnMember(kindId, map, leader, opts);\n            }\n        }));\n        return count;\n    }\n    async _spawnMember(kindId, map, leader, opts) {\n        const kind = Actor.get(kindId);\n        if (!kind) {\n            throw new Error('Failed to find member kind = ' + kindId);\n        }\n        const member = Actor.make(kind, { machineHome: opts.machine });\n        if (!member)\n            throw new Error('Failed to make horde member - ' + kindId);\n        const [x, y] = this._pickMemberLoc(member, map, leader, opts) || [\n            -1,\n            -1,\n        ];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!(await this._addMember(member, map, x, y, leader, opts))) {\n            return null;\n        }\n        return member;\n    }\n    _pickLeaderLoc(leader, map, opts) {\n        let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            if (!opts.canBeVisible && map.fov.isAnyKindOfVisible(x, y))\n                return false;\n            if (leader.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n    _pickMemberLoc(actor, map, leader, opts) {\n        let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Horde } from './horde';\nimport { Horde as Flags } from '../flags/horde';\nexport const hordes = {};\nexport function install(id, horde) {\n    if (typeof horde === 'string') {\n        horde = { leader: horde };\n    }\n    if (!(horde instanceof Horde)) {\n        horde = new Horde(horde);\n    }\n    hordes[id] = horde;\n    return horde;\n}\nexport function installAll(hordes) {\n    Object.entries(hordes).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function from(id) {\n    if (id instanceof Horde) {\n        return id;\n    }\n    if (typeof id === 'string') {\n        return hordes[id];\n    }\n    return new Horde(id);\n}\nexport function random(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n        flags: 0,\n        forbidFlags: 0,\n        depth: 0,\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    const rng = opts.rng || GWU.rng.random;\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    if (opts.flags) {\n        if (typeof opts.flags === 'string') {\n            opts.flags\n                .split(/[,|]/)\n                .map((t) => t.trim())\n                .forEach((flag) => {\n                if (flag.startsWith('!')) {\n                    const key = flag.substring(1);\n                    match.forbidFlags |= Flags[key];\n                }\n                else {\n                    match.flags |= Flags[flag];\n                }\n            });\n        }\n    }\n    if (opts.forbidFlags) {\n        match.forbidFlags = GWU.flag.from(Flags, opts.forbidFlags);\n    }\n    if (opts.depth) {\n        match.depth = opts.depth;\n    }\n    if (match.depth && opts.oodChance) {\n        while (rng.chance(opts.oodChance)) {\n            match.depth += 1;\n        }\n        match.forbidFlags |= Flags.HORDE_NEVER_OOD;\n    }\n    const matches = Object.values(hordes).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        if (match.flags && !(k.flags.horde & match.flags)) {\n            return false;\n        }\n        if (match.forbidFlags && k.flags.horde & match.forbidFlags) {\n            return false;\n        }\n        return true;\n    });\n    if (match.depth) {\n        return rng.item(matches) || null;\n    }\n    const depth = match.depth;\n    const weights = matches.map((h) => h.frequency(depth));\n    const index = rng.weighted(weights);\n    if (index < 0)\n        return null;\n    return matches[index];\n}\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","TileMech","Cell","NEEDS_REDRAW","LIGHT_CHANGED","FOV_CHANGED","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_TRAP_FREE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Horde","KeyInfo","[object Object]","x","y","disposable","this","kind","map","key","machineHome","depth","light","flags","entity","next","sprite","isDestroyed","hasEntityFlag","Flags.Entity","L_DESTROYED","tag","tags","includes","cell","forbidsCell","avoidsCell","getName","getDescription","getFlavor","verb","getVerb","EntityKind","config","requiredTileTags","id","name","flavor","description","make","split","t","trim","slice","opts","init","_entity","length","hasAllTileTags","hasAnyTileTag","Entity.Entity","super","leader","items","actor","Flags.Depth","ACTOR","hasActorFlag","Flags.Actor","IS_PLAYER","item","pickupItem","dropItem","ActorKind","Entity.EntityKind","options","blocksMove","blocksPathing","_opts","list","push","remove","makeOptions","get","Error","kinds","makeKind","info","Object","assign","randomKind","match","forbidTags","forEach","startsWith","substring","Array","isArray","matches","values","filter","k","arraysIntersect","rng","random","JSON","stringify","made","quantity","ITEM","ItemKind","Handler","src","dest","ctx","handlers","installHandler","handler","_a","fn","from","Flags","chance","v","effect","effects","reset","E_FIRED","install","_b","_c","_d","index","dissipate","priority","groundTile","article","tile","tileMech","hasEffect","Flags.Tile","T_IS_FLAMMABLE","every","hasTileFlag","T_PATHING_BLOCKER","arg","color","result","fg","toString","_e","_f","base","extends","tiles","text","replace","search","Number","parseInt","delta","undefined","entries","value","makeEffect","Flags.TileMech","ch","bg","opacity","all","args","enter","open","tick","close","player","emit","MapLayer","changed","properties","_other","_x","_y","_tile","_actor","_item","_dt","TileLayer","current","depthTile","Tile.tiles","NULL","superpriority","blocksLayer","blockedByItems","hasItem","blockedByActors","hasActor","blockedByOtherLayers","highestPriority","GROUND","ground","setTile","Tile.get","clearDepth","SURFACE","machine","machineId","glowLightChanged","setCellFlag","Flags.Cell","CAUGHT_FIRE_THIS_TURN","width","height","hasCellFlag","clearCellFlag","hasKey","fire","drawSprite","ActorLayer","obj","isPlayer","ItemLayer","destroy","hasXY","oldCell","GasLayer","volume","grid","alloc","fill","other","copy","startingVolume","spread","free","update","d","Math","max","clearTile","floor","min","total","count","highestVolume","startingTile","highestTile","i","j","needsRedraw","updateCellVolume","calcOpacity","async","ctx_","force","didSomething","allHandlers","h","E_NEXT_ALWAYS","data","gameHasEnded","nextInfo","E_NEXT_EVERYWHERE","forEachAsync","isVisible","E_NO_MARK_FIRED","EmitEffect","_map","events","FnEffect","MessageEffect","message","fired","addAt","ActivateMachineEffect","activateMachine","EffectEffect","FIRE.fire","SpawnEffect","_g","parts","p","grow","decrement","Flags.Effect","matchTile","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","isBlocking","E_PERMIT_BLOCKING","E_TREAT_AS_BLOCKING","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","spawnTiles","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","xy","forRect","lakeX","lakeY","cellInfo","isStairs","first","floodFill","spawnMap","accomplishedSomething","E_BLOCKED_BY_OTHER_LAYERS","E_SUPERPRIORITY","hasTile","EVENT_FIRED_THIS_TURN","E_PROTECTED","EVENT_PROTECTED","setMapFlag","Flags.Map","MAP_CHANGED","cellIsOk","isStart","blocksEffects","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","ok","eachNeighbor","E_NO_TOUCH_WALLS","dir","x2","y2","madeChange","startProb","probDec","DIRS","clearAll","clear","GAS","LIQUID","blockingMap","monst","loc","matchingLocNear","c","moveActor","moveItem","layers","ALL_LAYERS","reduce","out","fireSync","_ctx","e","ObjectFlags","TileFlags","TileMechFlags","CellFlags","FireLayer","exposeToFire","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","Effect.from","hasTileMechFlag","TM_EXPLOSIVE_PROMOTE","x0","y0","n","event","CellObjects","cb","object","eachItem","eachActor","start","chokeCount","_objects","TILE.tiles","TILE.get","some","o","entityFlags","tileFlags","tileMechFlags","hasTag","hasAllTags","hasAnyTag","a","CHANGED","TILE.Tile","highestPriorityTile","find","blocksVision","TILE.flags","T_BLOCKS_OTHER_LAYERS","hasAllEntityFlags","L_BLOCKS_EVERYTHING","L_SECRETLY_PASSABLE","tileFlag","tileMechFlag","ev","_activate","Effect.effects","Effect.fire","val","CellMemory","keyId","blocks","vision","move","pathing","_hasKey","snapshot","Mixer","blackOut","cellFlags","itemFlags","actorFlags","machineCount","_seed","cells","memory","seed","LightSystem","fov","FovSystem","initLayers","useMemory","addLayer","Layer.TileLayer","Layer.FireLayer","Layer.GasLayer","Layer.ItemLayer","Layer.ActorLayer","layer","buffer","canvas","Canvas","mixer","getAppearanceAt","addItem","forceItem","removeItem","hasPlayer","addActor","forceActor","removeActor","isAnyKindOfVisible","fmt","log","console","dump","_cell","needsUpdate","l","boundary","isBoundaryXY","clearTiles","dt","fireAll","constructor","willFire","promoteChance","w","originX","originY","putAppearance","dances","COLORS_DANCE","bake","putSnapshot","getSnapshot","getLight","multiply","isRevealed","scale","L_VISUALLY_DISTINCT","separate","eachGlowLight","_cb","isDark","clearMemory","store","updateChokepoints","updateCounts","passMap","passableArcCount","oldX","CLOCK_DIRS","oldY","newX","newY","cellCount","floodFillCount","i2","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","eachCell","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","up","left","designationSurvives","Snapshot","version","isHallway","arcCount","isPassable","prefab","charToTile","isStringArray","len","line","updateChokeCounts","layerVersion","lightVersion","fovVersion","cellVersion","snap","srcCell","snapLayer","destCell","destLayer","srcLayer","getCellPathCost","path","OBSTRUCTION","FORBIDDEN","fillCostMap","costMap","_v","x1","y1","distanceMap","calculateDistances","eightWays","straightDistanceBetween","getPath","members","horde","range","frequency","canBeVisible","isEnabled","_spawnLeader","_spawnMembers","leaderKind","Actor.get","Actor.make","_pickLeaderLoc","_addLeader","member","Promise","kindId","countRange","_spawnMember","_pickMemberLoc","_addMember","matchingLoc","Map.isHallway","hordes","forbidFlags","oodChance","HORDE_NEVER_OOD","weights","weighted"],"mappings":"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"}