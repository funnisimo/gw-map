{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/flags/horde.js","../js/entity/key.js","../js/entity/entity.js","../js/entity/kind.js","../js/actor/action.js","../js/actor/status.js","../js/actor/stat.js","../js/actor/actor.js","../js/effect/effect.js","../js/tile/tile.js","../js/tile/index.js","../js/effect/types/basic.js","../js/effect/types/spread.js","../js/effect/handlers/emit.js","../js/effect/handlers/message.js","../js/effect/handlers/activateMachine.js","../js/effect/handlers/tile.js","../js/effect/handlers/clear.js","../js/effect/handlers/feature.js","../js/effect/handlers/nourish.js","../js/effect/handlers/stat.js","../js/map/cell.js","../js/item/item.js","../js/entity/message.js","../js/actor/pain.js","../js/ai/ai.js","../js/ai/typical.js","../js/ai/wander.js","../js/ai/utils.js","../js/actor/kind.js","../js/actor/make.js","../js/actor/actions/bump.js","../js/actor/actions/standStill.js","../js/fx/fx.js","../js/actor/actions/moveDir.js","../js/actor/actions/idle.js","../js/actor/actions/pickup.js","../js/actor/actions/climb.js","../js/item/kind.js","../js/item/make.js","../js/layer/mapLayer.js","../js/layer/tileLayer.js","../js/layer/gasLayer.js","../js/layer/fireLayer.js","../js/draw/basic.js","../js/map/map.js","../js/map/analyze.js","../js/map/snapshot.js","../js/map/utils.js","../js/map/make.js","../js/horde/horde.js","../js/horde/make.js","../js/command/command.js","../js/command/moveDir.js","../js/command/pickup.js","../js/memory/index.js","../js/player/attribute.js","../js/player/skill.js","../js/player/scent.js","../js/player/player.js","../js/player/kind.js","../js/player/make.js","../js/game/viewport.js","../js/game/message.js","../js/game/flavor.js","../js/game/sidebar.js","../js/game/game.js","../js/tile/tiles.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_NO_SIDEBAR\"] = Fl(13)] = \"L_NO_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_ON_MAP\"] = Fl(17)] = \"L_ON_MAP\";\n    Entity[Entity[\"L_IN_SIDEBAR\"] = Fl(18)] = \"L_IN_SIDEBAR\";\n    Entity[Entity[\"L_FORMAL_NAME\"] = Fl(20)] = \"L_FORMAL_NAME\";\n    Entity[Entity[\"L_ALWAYS_PLURAL\"] = Fl(21)] = \"L_ALWAYS_PLURAL\";\n    Entity[Entity[\"DEFAULT_ACTOR\"] = 0] = \"DEFAULT_ACTOR\";\n    Entity[Entity[\"DEFAULT_ITEM\"] = 0] = \"DEFAULT_ITEM\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n    Actor[Actor[\"HAS_MEMORY\"] = Fl(1)] = \"HAS_MEMORY\";\n    Actor[Actor[\"USES_FOV\"] = Fl(2)] = \"USES_FOV\";\n    Actor[Actor[\"STABLE_COST_MAP\"] = Fl(3)] = \"STABLE_COST_MAP\";\n    Actor[Actor[\"IS_VISIBLE\"] = Fl(4)] = \"IS_VISIBLE\";\n    Actor[Actor[\"WAS_VISIBLE\"] = Fl(5)] = \"WAS_VISIBLE\";\n    Actor[Actor[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n    Item[Item[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_SHALLOW_WATER\"] = Fl(4)] = \"T_SHALLOW_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_LIST_IN_SIDEBAR\"] = Fl(22)] = \"T_LIST_IN_SIDEBAR\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n    Tile[Tile[\"T_ANY_LIQUID\"] = Tile.T_IS_DEEP_LIQUID | Tile.T_SHALLOW_WATER] = \"T_ANY_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(0)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(1)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"KNOWN_TO_BE_SAFE\"] = Fl(2)] = \"KNOWN_TO_BE_SAFE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(14)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"STABLE_SNAPSHOT\"] = Fl(15)] = \"STABLE_SNAPSHOT\";\n    // These are to speed checks\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(16)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(17)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(18)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(19)] = \"HAS_ITEM\";\n    Cell[Cell[\"HAS_FX\"] = Fl(20)] = \"HAS_FX\";\n    Cell[Cell[\"HAS_TICK_EFFECT\"] = Fl(22)] = \"HAS_TICK_EFFECT\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(23)] = \"IS_CURSOR\";\n    Cell[Cell[\"IS_HIGHLIGHTED\"] = Fl(24)] = \"IS_HIGHLIGHTED\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_SAFE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_NEEDS_REDRAW\"] = Fl(1)] = \"MAP_NEEDS_REDRAW\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_SIDEBAR_TILES_CHANGED\"] = Fl(10)] = \"MAP_SIDEBAR_TILES_CHANGED\";\n    Map[Map[\"MAP_SIDEBAR_CHANGED\"] = Fl(11)] = \"MAP_SIDEBAR_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_IGNORE_FOV\"] = Fl(12)] = \"E_IGNORE_FOV\";\n    // E_SPREAD_CIRCLE = Fl(13), // Spread in a circle around the spot (using FOV), radius calculated using spread+decrement\n    // E_SPREAD_LINE = Fl(14), // Spread in a line in one random direction\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Horde;\n(function (Horde) {\n    Horde[Horde[\"HORDE_DIES_ON_LEADER_DEATH\"] = Fl(0)] = \"HORDE_DIES_ON_LEADER_DEATH\";\n    Horde[Horde[\"HORDE_IS_SUMMONED\"] = Fl(1)] = \"HORDE_IS_SUMMONED\";\n    Horde[Horde[\"HORDE_SUMMONED_AT_DISTANCE\"] = Fl(2)] = \"HORDE_SUMMONED_AT_DISTANCE\";\n    Horde[Horde[\"HORDE_NO_PERIODIC_SPAWN\"] = Fl(4)] = \"HORDE_NO_PERIODIC_SPAWN\";\n    Horde[Horde[\"HORDE_ALLIED_WITH_PLAYER\"] = Fl(5)] = \"HORDE_ALLIED_WITH_PLAYER\";\n    Horde[Horde[\"HORDE_NEVER_OOD\"] = Fl(15)] = \"HORDE_NEVER_OOD\";\n    // Move all these to tags?\n    // HORDE_LEADER_CAPTIVE = Fl(3), // the leader is in chains and the followers are guards\n    // HORDE_MACHINE_BOSS = Fl(6), // used in machines for a boss challenge\n    // HORDE_MACHINE_WATER_MONSTER = Fl(7), // used in machines where the room floods with shallow water\n    // HORDE_MACHINE_CAPTIVE = Fl(8), // powerful captive monsters without any captors\n    // HORDE_MACHINE_STATUE = Fl(9), // the kinds of monsters that make sense in a statue\n    // HORDE_MACHINE_TURRET = Fl(10), // turrets, for hiding in walls\n    // HORDE_MACHINE_MUD = Fl(11), // bog monsters, for hiding in mud\n    // HORDE_MACHINE_KENNEL = Fl(12), // monsters that can appear in cages in kennels\n    // HORDE_VAMPIRE_FODDER = Fl(13), // monsters that are prone to capture and farming by vampires\n    // HORDE_MACHINE_LEGENDARY_ALLY = Fl(14), // legendary allies\n    // HORDE_MACHINE_THIEF = Fl(16), // monsters that can be generated in the key thief area machines\n    // HORDE_MACHINE_GOBLIN_WARREN = Fl(17), // can spawn in goblin warrens\n    // HORDE_SACRIFICE_TARGET = Fl(18), // can be the target of an assassination challenge; leader will get scary light.\n    // HORDE_MACHINE_ONLY = HORDE_MACHINE_BOSS |\n    //     HORDE_MACHINE_WATER_MONSTER |\n    //     HORDE_MACHINE_CAPTIVE |\n    //     HORDE_MACHINE_STATUE |\n    //     HORDE_MACHINE_TURRET |\n    //     HORDE_MACHINE_MUD |\n    //     HORDE_MACHINE_KENNEL |\n    //     HORDE_VAMPIRE_FODDER |\n    //     HORDE_MACHINE_LEGENDARY_ALLY |\n    //     HORDE_MACHINE_THIEF |\n    //     HORDE_MACHINE_GOBLIN_WARREN |\n    //     HORDE_SACRIFICE_TARGET,\n})(Horde || (Horde = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","import * as Flags from '../flags/entity';\nlet lastId = 0;\nexport class Entity {\n    // lastSeen: GWU.xy.Loc = [-1, -1];\n    constructor(kind) {\n        this._map = null;\n        this.key = null;\n        this.machineHome = 0;\n        this.changed = true;\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n        this.id = '' + ++lastId;\n    }\n    get map() {\n        return this._map;\n    }\n    isPlural() {\n        return !!(this.flags.entity & Flags.Entity.L_ALWAYS_PLURAL);\n    }\n    addToMap(map, x, y) {\n        this.x = x;\n        this.y = y;\n        this.setEntityFlag(Flags.Entity.L_ON_MAP);\n        if (this._map === map) {\n            return false;\n        }\n        this._map = map;\n        this.kind.addToMap(this, map);\n        return true;\n    }\n    removeFromMap() {\n        this.clearEntityFlag(Flags.Entity.L_ON_MAP);\n        this.kind.removeFromMap(this);\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    isAt(x, y) {\n        return this.x === x && this.y === y;\n    }\n    clone() {\n        const other = new this.constructor(this.kind);\n        other.copy(this);\n        return other;\n    }\n    copy(other) {\n        this.depth = other.depth;\n        this.light = other.light;\n        Object.assign(this.flags, other.flags);\n        this.next = other.next;\n        this.x = other.x;\n        this.y = other.y;\n        this.kind = other.kind;\n        this.id = other.id;\n    }\n    canBeSeen() {\n        return this.kind.canBeSeen(this);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    setEntityFlag(flag) {\n        this.flags.entity |= flag;\n    }\n    clearEntityFlag(flag) {\n        this.flags.entity &= ~flag;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isKey(x, y) {\n        return this.key && this.key.matches(x, y);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(cell, this);\n    }\n    avoidsCell(cell) {\n        return this.kind.avoidsCell(cell, this);\n    }\n    getName(opts) {\n        return this.kind.getName(this, opts);\n    }\n    getDescription(opts) {\n        return this.kind.getDescription(this, opts);\n    }\n    getFlavor(opts) {\n        return this.kind.getFlavor(this, opts);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n    drawSidebar(buffer, bounds) {\n        return this.kind.drawSidebar(this, buffer, bounds);\n    }\n    drawInto(dest, _observer) {\n        dest.drawSprite(this.sprite);\n    }\n    toString() {\n        return `${this.kind.id}-${this.id} @ ${this.x},${this.y}`;\n    }\n}\nEntity.default = {\n    sidebarFg: 'purple',\n};\n","import * as GWU from 'gw-utils';\nimport { Entity } from './entity';\nimport * as Flags from '../flags';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.requireTileFlags = 0;\n        this.forbidTileFlags = 0;\n        this.avoidTileFlags = 0;\n        this.requireTileTags = [];\n        this.forbidTileTags = [];\n        this.avoidTileTags = [];\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config.sprite ? config.sprite : config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        if (config.requireTileFlags) {\n            this.requireTileFlags = GWU.flag.from(Flags.Tile, config.requireTileFlags);\n        }\n        if (config.avoidTileFlags) {\n            this.avoidTileFlags = GWU.flag.from(Flags.Tile, config.avoidTileFlags);\n        }\n        if (config.forbidTileFlags) {\n            this.forbidTileFlags = GWU.flag.from(Flags.Tile, config.forbidTileFlags);\n        }\n        if (config.requireTileTags) {\n            if (typeof config.requireTileTags === 'string') {\n                config.requireTileTags = config.requireTileTags.split(/[,|]/g);\n            }\n            this.requireTileTags = config.requireTileTags.map((t) => t.trim());\n        }\n        if (config.avoidTileTags) {\n            if (typeof config.avoidTileTags === 'string') {\n                config.avoidTileTags = config.avoidTileTags.split(/[,|]/g);\n            }\n            this.avoidTileTags = config.avoidTileTags.map((t) => t.trim());\n        }\n        if (config.forbidTileTags) {\n            if (typeof config.forbidTileTags === 'string') {\n                config.forbidTileTags = config.forbidTileTags.split(/[,|]/g);\n            }\n            this.forbidTileTags = config.forbidTileTags.map((t) => t.trim());\n        }\n        if (config.drawSidebar) {\n            this.drawSidebar = config.drawSidebar;\n        }\n        this.sidebarFg = GWU.color.from(config.sidebarFg || Entity.default.sidebarFg);\n    }\n    make(opts) {\n        const entity = new Entity(this);\n        this.init(entity, opts);\n        return entity;\n    }\n    init(entity, opts = {}) {\n        if (opts.machineHome) {\n            entity.machineHome = opts.machineHome;\n        }\n    }\n    addToMap(_entity, _map) { }\n    removeFromMap(_entity) { }\n    canBeSeen(_entity) {\n        return true;\n    }\n    forbidsCell(cell, _entity) {\n        if (this.requireTileFlags &&\n            !cell.hasAllTileFlags(this.requireTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.forbidTileFlags &&\n            cell.hasTileFlag(this.forbidTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.requireTileTags.length &&\n            !cell.hasAllTileTags(this.requireTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.forbidTileTags.length &&\n            cell.hasAnyTileTag(this.forbidTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        return false;\n    }\n    avoidsCell(cell, entity) {\n        if (this.forbidsCell(cell, entity))\n            return true;\n        if (this.avoidTileFlags &&\n            cell.hasTileFlag(this.avoidTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.avoidTileTags.length &&\n            cell.hasAnyTileTag(this.avoidTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        return false;\n    }\n    getName(_entity, _opts) {\n        return this.name;\n    }\n    getDescription(_entity, _opts) {\n        return this.description;\n    }\n    getFlavor(_entity, _opts) {\n        return this.flavor;\n    }\n    getVerb(_entity, verb) {\n        return verb;\n    }\n    drawSidebar(entity, buffer, bounds) {\n        if (!entity.map)\n            return 0;\n        if (entity.isDestroyed)\n            return 0;\n        const mixer = new GWU.sprite.Mixer();\n        entity.map.getAppearanceAt(entity.x, entity.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, entity.getName(), this.sidebarFg);\n        return 1;\n    }\n}\nexport function make(opts, makeOpts = {}) {\n    const kind = new EntityKind(opts);\n    return kind.make(makeOpts);\n}\n","export const installedActions = {};\nexport function installAction(name, fn) {\n    installedActions[name.toLowerCase()] = fn;\n}\nexport function getAction(name) {\n    return installedActions[name.toLowerCase()] || null;\n}\n","import * as GWU from 'gw-utils';\nexport class Status {\n    constructor() {\n        this._set = {};\n        this._time = {};\n        this._count = {};\n        this._done = {};\n        this._value = {};\n        this.changed = null;\n    }\n    clear(name) {\n        this.clearTime(name);\n        this.clearCount(name);\n        this.setOff(name);\n        return this._update(name);\n    }\n    get(name) {\n        return this._value[name] || false;\n    }\n    has(name) {\n        return this._value[name] || false;\n    }\n    _addDone(name, done) {\n        if (done) {\n            if (!this._done[name]) {\n                this._done[name] = done;\n            }\n        }\n    }\n    /**\n     * Sets the count for a status variable.\n     * If setting the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} count The count to set.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not setting the count turned the status on.\n     */\n    setCount(name, count, done) {\n        const status = this;\n        status._count[name] = Math.max(count, status._count[name] || 0);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Increments the count for the status by the given amount (1=default)\n     * If incrementing the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} [count=1] The count to incrmeent.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not incrementing the count turned the status on.\n     */\n    increment(name, count = 1, done) {\n        if (typeof count == 'function') {\n            done = count;\n            count = 1;\n        }\n        const status = this;\n        status._count[name] = (status._count[name] || 0) + count;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Decrements the count for the status by the given amount (1=default)\n     * If decrementing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @param {number} [count=1] The count to decrement.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    decrement(name, count = 1) {\n        const status = this;\n        status._count[name] = Math.max(0, (status._count[name] || 0) - count);\n        return this._update(name);\n    }\n    /**\n     * Clears all counts from the given status.\n     * If clearing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    clearCount(name) {\n        const status = this;\n        status._count[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Turns on the given status.\n     * @param {string} name The status to adjust.\n     * @param {function} [done] The function to call when the status is turned off.\n     * @returns {boolean} True if this turns on the status. (It could be on because of a time or count).\n     */\n    setOn(name, done) {\n        const status = this;\n        status._set[name] = true;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Turns off the given status.\n     *\n     * @param {string} name The status to adjust.\n     * @returns {boolean} True if this turns off the status. (It could be on because of a time or count).\n     */\n    setOff(name) {\n        const status = this;\n        status._set[name] = false;\n        return this._update(name);\n    }\n    /**\n     * Sets the time for a status variable.\n     * If setting the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to set.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not setting the time turned the status on.\n     */\n    setTime(name, value, done) {\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        const current = status._time[name] || 0;\n        status._time[name] = Math.max(value, current);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Adds to the time for a status variable.\n     * If adding to the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to add.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not adding the time turned the status on.\n     */\n    addTime(name, value = 1, done) {\n        if (typeof value == 'function') {\n            done = value;\n            value = 1;\n        }\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        status._time[name] = (status._time[name] || 0) + value;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Removes time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to remove.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    removeTime(name, value = 1) {\n        const status = this;\n        value = GWU.range.make(value).value();\n        status._time[name] = Math.max(0, (status._time[name] || 0) - value);\n        return this._update(name);\n    }\n    /**\n     * Removes all time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    clearTime(name) {\n        const status = this;\n        status._time[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Removes time for all status variables that have time.\n     * If removing the time turns off any status (it was on),\n     * then this function returns an object with all of those statuses as keys and false as the values.  Otherwise, false.\n     * @param {Status|object} source The object to set the status on.  If object.status is set then that is where the values are updated.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean|object} false or an object with the names of the statuses that were cleared as keys and false as the values.\n     */\n    decayAllTimes(delta = 1) {\n        const status = this;\n        const cleared = {};\n        let noticed = false;\n        for (let name in status._time) {\n            if (this.removeTime(name, delta)) {\n                noticed = true;\n                cleared[name] = false;\n            }\n        }\n        return noticed ? cleared : false;\n    }\n    /**\n     * Updates the value of the status and returns whether or not this change\n     * turned the status on or off (true = change, false = no change)\n     * @param {string} name The name of the status to update\n     * @returns {boolean} True if the value was turned on or off, False otherwise.\n     */\n    _update(name) {\n        const status = this;\n        const rec = this._value;\n        let was = rec[name];\n        let value = (rec[name] =\n            status._set[name] ||\n                status._time[name] > 0 ||\n                status._count[name] > 0 ||\n                false);\n        const doneFn = this._done[name];\n        if (!value && doneFn) {\n            doneFn(this, name);\n            status._done[name] = null;\n        }\n        if (was && !value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: false');\n            return true;\n        }\n        else if (!was && value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: true');\n            return true;\n        }\n        return false;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Stats {\n    constructor(opts = {}) {\n        this._max = {};\n        this._rate = {};\n        this._value = {};\n        this.init(opts);\n    }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    getPct(name) {\n        const max = this.max(name);\n        return max ? Math.round((100 * this.get(name)) / max) : 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    regen(name) {\n        return this._rate[name] || null;\n    }\n    init(opts) {\n        for (let name in opts) {\n            this.set(name, opts[name]);\n        }\n    }\n    set(name, v, max) {\n        if (typeof v !== 'number') {\n            const r = GWU.range.make(v);\n            v = r.value();\n        }\n        this._value[name] = v;\n        this._max[name] = max || v;\n    }\n    gain(name, amount, allowOver = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        let v = this._value[name] + amount;\n        if (!allowOver) {\n            v = Math.min(v, this._max[name]);\n        }\n        this._value[name] = v;\n    }\n    drain(name, amount) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._value[name] = Math.max(0, this._value[name] - amount);\n    }\n    raiseMax(name, amount, raiseValue = true) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] += amount;\n        if (raiseValue) {\n            this.gain(name, amount);\n        }\n    }\n    reduceMax(name, amount, lowerValue = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] = Math.max(0, this._max[name] - amount);\n        if (lowerValue) {\n            this.drain(name, amount);\n        }\n    }\n    setRegen(name, turns, count = 1) {\n        const r = (this._rate[name] = this._rate[name] || { elapsed: 0 });\n        r.turns = turns;\n        r.count = count;\n    }\n    regenAll() {\n        for (let name in this._max) {\n            const r = this._rate[name];\n            r.elapsed += 1;\n            if (r.elapsed >= r.turns) {\n                this.gain(name, r.count);\n                r.elapsed -= r.turns;\n            }\n        }\n    }\n    restore(name, value) {\n        if (value === undefined)\n            value = this._max[name];\n        this._value[name] = value;\n    }\n    adjust(name, type, amount) {\n        amount = GWU.range.from(amount);\n        const v = amount.value();\n        const c = this.get(name);\n        if (type === 'inc') {\n            this.gain(name, amount);\n        }\n        else if (type === 'dec') {\n            this.drain(name, amount);\n        }\n        else if (type === 'set') {\n            this.set(name, amount);\n        }\n        else if (type === 'min') {\n            const v = amount.value();\n            if (this.get(name) < v) {\n                this.set(name, v);\n            }\n        }\n        else if (type === 'max') {\n            if (this.get(name) > v) {\n                this.set(name, v);\n            }\n        }\n        else {\n            throw new Error('Invalid stat adjust type: ' + type);\n        }\n        return c !== this.get(name);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity/entity';\nimport * as Flags from '../flags';\nimport { getAction } from './action';\nimport { Status } from './status';\nimport { Stats } from './stat';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.ai = {};\n        this.leader = null;\n        this.items = null; // inventory\n        this.visionDistance = 99;\n        this.data = {};\n        this._costMap = null;\n        this._goalMap = null;\n        this._mapToMe = null;\n        this.next = null; // TODO - can we get rid of this?\n        // @ts-ignore - initialized in Entity\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n        this.kind = kind;\n        this.stats = new Stats();\n        this.status = new Status();\n    }\n    setData(key, value) {\n        this.data[key] = value;\n        this.changed = true;\n    }\n    copy(other) {\n        super.copy(other);\n        this.leader = other.leader;\n        this.items = other.items;\n        this.visionDistance = other.visionDistance;\n    }\n    destroy() {\n        this.setEntityFlag(Flags.Entity.L_DESTROYED);\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n        if (this._mapToMe) {\n            GWU.grid.free(this._mapToMe);\n            this._mapToMe = null;\n        }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    setActorFlag(flag) {\n        this.flags.actor |= flag;\n    }\n    clearActorFlag(flag) {\n        this.flags.actor &= ~flag;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    isDead() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    getAction(name) {\n        const action = this.kind.actions[name];\n        if (action === undefined || action === true) {\n            const main = getAction(name); // default is to do any action\n            return main || false;\n        }\n        else if (action === false) {\n            return false;\n        }\n        return action;\n    }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n    /////////////// VISIBILITY\n    becameVisible() {\n        return (this.hasActorFlag(Flags.Actor.IS_VISIBLE) &&\n            !this.hasActorFlag(Flags.Actor.WAS_VISIBLE));\n    }\n    canSee(x, y) {\n        if (x instanceof Entity.Entity) {\n            return this.canSee(x.x, x.y) && this.kind.isAbleToSee(this, x);\n        }\n        else if (this.map) {\n            if (this.isPlayer()) {\n                return this.map.fov.isDirectlyVisible(x, y);\n            }\n            if (GWU.xy.distanceBetween(this.x, this.y, x, y) >\n                this.visionDistance) {\n                return false;\n            }\n            return GWU.xy.forLineBetween(this.x, this.y, x, y, (i, j) => {\n                if (this.map.cell(i, j).blocksVision())\n                    return false;\n            });\n        }\n        else {\n            return false; // need a map or an fov\n        }\n    }\n    canSeeOrSense(x, y) {\n        if (x instanceof Entity.Entity) {\n            return (this.canSeeOrSense(x.x, x.y) &&\n                (this.kind.isAbleToSee(this, x) ||\n                    this.kind.isAbleToSense(this, x)));\n        }\n        if (this.map && this.isPlayer()) {\n            return this.map.fov.isAnyKindOfVisible(x, y);\n        }\n        return this.canSee(x, y);\n    }\n    isAbleToSee(entity) {\n        return this.kind.isAbleToSee(this, entity);\n    }\n    isAbleToSense(entity) {\n        return this.kind.isAbleToSense(this, entity);\n    }\n    ////////////////// ACTOR\n    async act(game) {\n        let startedVisible = false;\n        if (game.player.canSee(this)) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n            startedVisible = true;\n        }\n        else {\n            if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n                console.log('not visible');\n            }\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n        if (this.becameVisible()) {\n            console.log('became visible');\n            game.player.interrupt(this);\n        }\n        let r = 0;\n        if (this.ai && this.ai.fn) {\n            r = await this.ai.fn(game, this);\n        }\n        if (r == 0 && this.kind.ai.fn) {\n            r = await this.kind.ai.fn(game, this);\n        }\n        if (r) {\n            // did something\n            if (startedVisible || game.player.canSee(this)) {\n            }\n            return r;\n        }\n        // idle - always\n        return this.endTurn();\n    }\n    moveSpeed() {\n        return this.kind.moveSpeed;\n    }\n    startTurn() {\n        if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n            this.setActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        const map = this.map;\n        const isVisible = map && map.fov.isAnyKindOfVisible(this.x, this.y);\n        if (isVisible) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n    }\n    endTurn(pct = 100) {\n        if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n            this.setActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        const map = this.map;\n        const isVisible = map && map.fov.isAnyKindOfVisible(this.x, this.y);\n        if (isVisible) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n            if (!this.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR) &&\n                !this.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n                map.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n            }\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n            if (map &&\n                !this.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR) &&\n                this.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n                map.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n            }\n        }\n        return Math.floor((pct * this.moveSpeed()) / 100);\n    }\n    ///////\n    willAttack(_other) {\n        return true;\n    }\n    canPass(_other) {\n        return false;\n    }\n    ////////////////// INVENTORY\n    avoidsItem(_item) {\n        return false;\n    }\n    canAddItem(_item) {\n        return false;\n    }\n    addItem(_item) { }\n    pickupItem(item, opts) {\n        return this.kind.pickupItem(this, item, opts);\n    }\n    dropItem(item, opts) {\n        return this.kind.dropItem(this, item, opts);\n    }\n    // PATHFINDING\n    addToMap(map, x, y) {\n        const mapChanged = super.addToMap(map, x, y);\n        if (mapChanged) {\n            this.clearActorFlag(Flags.Actor.STABLE_COST_MAP);\n        }\n        return mapChanged;\n    }\n    removeFromMap() {\n        super.removeFromMap();\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n        if (this._mapToMe) {\n            GWU.grid.free(this._mapToMe);\n            this._mapToMe = null;\n        }\n    }\n    /*\n    Calculates and returns the actor's move cost map.\n    Used in pathfinding.\n    */\n    costMap() {\n        if (!this.map) {\n            throw new Error('Actor must have map to calculate costMap.');\n        }\n        const staleMap = !this.hasActorFlag(Flags.Actor.STABLE_COST_MAP);\n        if (staleMap && this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (!this._costMap) {\n            this._costMap = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        else if (!staleMap) {\n            return this._costMap;\n        }\n        const kind = this.kind;\n        const map = this.map;\n        this._costMap.update((_v, x, y) => {\n            const cell = map.cell(x, y);\n            return kind.cellCost(cell, this);\n        });\n        this.setActorFlag(Flags.Actor.STABLE_COST_MAP);\n        /*\n\n            if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n            && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))\n            {\n                playerCostMap[i][j] = monsterCostMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_SACRED)) {\n                    playerCostMap[i][j] = 1;\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_LAVA_INSTA_DEATH)) {\n        monsterCostMap[i][j] = PDS_FORBIDDEN;\n        if (player.status[STATUS_LEVITATING] || !player.status[STATUS_IMMUNE_TO_FIRE]) {\n            playerCostMap[i][j] = 1;\n        } else {\n            playerCostMap[i][j] = PDS_FORBIDDEN;\n        }\n            } else {\n                if (pmap[i][j].flags & HAS_MONSTER) {\n                    monst = monsterAtLoc(i, j);\n                    if ((monst.creatureState == MONSTER_SLEEPING\n                         || monst.turnsSpentStationary > 2\n             || (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)\n                         || monst.creatureState == MONSTER_ALLY)\n                        && monst.creatureState != MONSTER_FLEEING)\n                    {\n                        playerCostMap[i][j] = 1;\n                        monsterCostMap[i][j] = PDS_FORBIDDEN;\n                        continue;\n                    }\n                }\n\n                if (cellHasTerrainFlag(i, j, (T_AUTO_DESCENT | T_IS_DF_TRAP))) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, T_IS_FIRE)) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_IMMUNE_TO_FIRE]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, (T_IS_DEEP_WATER | T_SPONTANEOUSLY_IGNITES))) {\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = 5;\n          }\n                    monsterCostMap[i][j] = 5;\n        } else if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n                   && cellHasTMFlag(i, j, TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)\n                   && !(pmap[i][j].flags & IN_FIELD_OF_VIEW))\n             {\n            // Secret door that the player can't currently see\n            playerCostMap[i][j] = 100;\n            monsterCostMap[i][j] = 1;\n                } else {\n                    playerCostMap[i][j] = monsterCostMap[i][j] = 1;\n                }\n            }\n        }\n    }\n        */\n        return this._costMap;\n    }\n    get goalMap() {\n        return this._goalMap;\n    }\n    hasGoal() {\n        return !!this._goalMap;\n    }\n    setGoal(x, y) {\n        const map = this._map;\n        if (!map)\n            throw new Error('No map to set goal with!');\n        if (!this._goalMap) {\n            this._goalMap = GWU.grid.alloc(map.width, map.height);\n        }\n        const goalMap = this._goalMap;\n        GWU.path.calculateDistances(goalMap, x, y, this.costMap());\n        return this._goalMap;\n    }\n    clearGoal() {\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n    }\n    mapToMe() {\n        if (!this.map)\n            throw new Error('No map!');\n        if (!this._mapToMe) {\n            this._mapToMe = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        if (this._mapToMe.x !== this.x || this._mapToMe.y !== this.y) {\n            GWU.path.calculateDistances(this._mapToMe, this.x, this.y, this.costMap());\n        }\n        return this._mapToMe;\n    }\n}\nActor.default = {\n    sidebarFg: 'purple',\n};\n","export const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id.toLowerCase()] = handler;\n}\nexport const effectTypes = {};\nexport function installType(id, type) {\n    effectTypes[id] = type;\n}\n// export class Effect {\n//     id = '';\n//     chance = 100 * 100; // 100%\n//     type: string; // self | bolt | beam | ball | burst | adjacent | spread\n//     aim: string; // actor | item | cell\n//     bolt: string | GWU.sprite.SpriteData | null = null;\n//     beam = false;\n//     range = 0;\n//     ball: string | GWU.sprite.SpriteData | null = null;\n//     radius = 0;\n//     center = false;\n//     effects: EffectFn[];\n//     good = false;\n//     seen = false;\n//     next: Effect | null = null;\n//     constructor(config: EffectConfig) {\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         this.aim = config.aim || 'actor';\n//         if (typeof config.chance === 'string') {\n//             // '20%' becomes 2000\n//             config.chance = Math.floor(Number.parseFloat(config.chance) * 100);\n//         }\n//         this.chance = config.chance || 100 * 100;\n//         const type = config.type || 'basic';\n//         const parts = type.split(':');\n//         if (type.startsWith('bolt') || type.startsWith('beam')) {\n//             // bolt:range:sprite\n//             this.type = parts[0];\n//             this.range = parts[1] ? Number.parseInt(parts[1]) : 99;\n//             this.bolt = parts[1] || 'missile';\n//             this.beam = type.startsWith('beam');\n//         } else if (\n//             type.startsWith('ball') ||\n//             type.startsWith('burst') ||\n//             type.startsWith('aura')\n//         ) {\n//             this.type = parts[0];\n//             this.radius = parts[1] ? Number.parseInt(parts[1]) : 2;\n//             this.range = parts[2] ? Number.parseInt(parts[2]) : 99;\n//             this.ball = parts[3] || 'explosion';\n//             this.center = !type.startsWith('aura');\n//         } else {\n//             this.type = 'basic';\n//         }\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         if (Array.isArray(config.effects)) {\n//             this.effects = config.effects.map((e) => {\n//                 if (typeof e === 'function') return e;\n//                 return effectFnFromString(e);\n//             });\n//         } else {\n//             this.effects = [];\n//             Object.entries(config.effects).forEach(([key, value]) => {\n//                 const handler = handlers[key.toLowerCase()];\n//                 if (handler) {\n//                     this.effects.push(handler(value));\n//                 } else if (typeof value === 'function') {\n//                     this.effects.push(value);\n//                 } else {\n//                     throw new Error('Unknown effect: ' + key);\n//                 }\n//             });\n//         }\n//         if (this.effects.length === 0) throw new Error('No effects!');\n//     }\n//     clone(): this {\n//         const other = new (this.constructor as new (\n//             config: EffectConfig\n//         ) => this)(this as EffectConfig);\n//         return other;\n//     }\n//     fire(map: Map.MapType, x: number, y: number, ctx: EffectCtx = {}): boolean {\n//         let didSomething = false;\n//         ctx.good = this.good;\n//         ctx.seen = this.seen;\n//         if (!this.chance || map.rng.chance(this.chance, 10000)) {\n//             // fire\n//             for (let effect of this.effects) {\n//                 if (GWU.data.gameHasEnded) break;\n//                 if (effect(map, x, y, ctx)) {\n//                     didSomething = true;\n//                 } else {\n//                     break;\n//                 }\n//             }\n//         }\n//         if (ctx.aware && didSomething) {\n//             this.seen = true;\n//         }\n//         this.good = ctx.good;\n//         return didSomething;\n//     }\n//     reset() {\n//         this.seen = false;\n//     }\n// }\n// export function effectFnFromString(e: string): EffectFn {\n//     const parts = e.split(':');\n//     if (parts.length === 0) throw new Error('Invalid effect string.');\n//     // @ts-ignore\n//     const name = parts.shift().toLowerCase();\n//     const handler = handlers[name] || null;\n//     if (!handler) {\n//         throw new Error('Failed to find effect handler: ' + name);\n//     }\n//     return handler(parts);\n// }\nexport function make(opts) {\n    if (!opts)\n        throw new Error('opts required to make effect.');\n    let config = {};\n    if (typeof opts === 'string') {\n        // Special case\n        if (opts.toLowerCase().startsWith('spread:')) {\n            const endPos = opts.indexOf(':', 8);\n            const tile = opts.substring(8, endPos);\n            config = {\n                type: 'spread:' + opts.substring(endPos),\n                effects: ['tile:' + tile],\n            };\n        }\n        else {\n            config = { type: 'basic', effects: [opts] };\n        }\n    }\n    else if (typeof opts === 'function') {\n        config = { type: 'basic', effects: [opts] };\n    }\n    else if (Array.isArray(opts)) {\n        config = { type: 'basic', effects: opts };\n    }\n    else {\n        // @ts-ignore\n        if (opts.effect) {\n            // @ts-ignore\n            opts.effects = [opts.effect];\n            delete opts.effect;\n        }\n        // object only\n        if (opts.effects) {\n            Object.assign(config, opts);\n            if (typeof config.effects === 'string') {\n                config.effects = [opts.effects];\n            }\n            else if (typeof config.effects === 'function') {\n                config.effects = [opts.effects];\n            }\n        }\n        else {\n            config.effects = {};\n            Object.entries(opts).forEach(([key, value]) => {\n                const handler = handlers[key.toLowerCase()];\n                if (handler !== undefined) {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                }\n                else if (typeof value === 'function') {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                }\n                else {\n                    // @ts-ignore\n                    config[key] = value;\n                }\n            });\n        }\n    }\n    config.type = config.type || 'basic';\n    if (typeof config.type !== 'string')\n        throw new Error('Invalid effect type: ' + JSON.stringify(config.type));\n    const typeParts = config.type.split(':').map((t) => t.trim());\n    const typeName = typeParts.shift();\n    const makeFn = effectTypes[typeName.toLowerCase()];\n    if (!makeFn)\n        throw new Error('Invalid effect type: ' + typeName);\n    const effect = makeFn(config);\n    if (Array.isArray(config.effects)) {\n        config.effects.forEach((e) => {\n            if (typeof e === 'function') {\n                effect.effects.push(e);\n            }\n            else {\n                const parts = e.split(':').map((t) => t.trim());\n                if (parts.length === 1) {\n                    const effect = installedEffects[parts[0]];\n                    if (!effect)\n                        throw new Error('Failed to find effect with id: ' + parts[0]);\n                    effect.effects.push(effect.trigger.bind(effect));\n                }\n                else {\n                    const handler = handlers[parts[0].toLowerCase()];\n                    if (!handler)\n                        throw new Error('Unknown effect: ' + parts[0]);\n                    parts.shift();\n                    effect.effects.push(handler(parts));\n                }\n            }\n        });\n    }\n    else {\n        Object.entries(config.effects).forEach(([key, value]) => {\n            const handler = handlers[key.toLowerCase()];\n            if (!handler)\n                throw new Error('Failed to find handler type: ' + key);\n            effect.effects.push(handler(value));\n        });\n    }\n    if (config.next) {\n        effect.next = make(config.next);\n    }\n    return effect;\n}\nexport function from(opts) {\n    if (!opts)\n        throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'object' && 'trigger' in opts) {\n        return opts;\n    }\n    if (typeof opts === 'string') {\n        const effect = installedEffects[opts];\n        if (effect)\n            return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\nfunction isEffect(obj) {\n    return typeof obj === 'object' && 'trigger' in obj;\n}\n//////////////////////////////\n// INSTALL\nexport const installedEffects = {};\nexport function install(id, config) {\n    const effect = isEffect(config) ? config.clone() : make(config);\n    installedEffects[id] = effect;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function resetAll() {\n    Object.values(installedEffects).forEach((e) => (e.seen = false));\n}\n","import * as GWU from 'gw-utils';\nimport { make as makeEffect } from '../effect/effect';\nimport * as Flags from '../flags';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.effects = {};\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.tags = [];\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.effects) {\n            Object.assign(this.effects, config.effects);\n        }\n        if (this.hasEffect('fire')) {\n            this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n        }\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                config.tags\n                    .split(/[,|]/)\n                    .map((t) => t.trim())\n                    .forEach((t) => {\n                    this.tags.push(t);\n                });\n            }\n            else {\n                this.tags = config.tags.slice().map((t) => t.trim());\n            }\n        }\n    }\n    hasTag(tag) {\n        return this.tags.includes(tag);\n    }\n    hasAnyTag(tags) {\n        return GWU.arraysIntersect(this.tags, tags);\n    }\n    hasAllTags(tags) {\n        return tags.every((t) => this.tags.includes(t));\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    hasEffect(name) {\n        return name in this.effects;\n    }\n    isNull() {\n        return this === NULL;\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isDoor() {\n        return this.hasTileFlag(Flags.Tile.T_IS_DOOR);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isDiggable() {\n        return this.isNull() || this.isWall();\n    }\n    getName(arg) {\n        let opts = {};\n        if (typeof arg === 'boolean') {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `${color}${this.name}`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription(opts) {\n        return this.description || this.getName(opts);\n    }\n    getFlavor(opts) {\n        return this.flavor || this.getName(opts);\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { effects: {}, flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const effects = {};\n    Object.assign(effects, base.effects);\n    if (options.effects) {\n        Object.entries(options.effects).forEach(([key, value]) => {\n            if (value === null) {\n                delete effects[key];\n                return;\n            }\n            if (typeof value === 'string' && !value.includes(':')) {\n                effects[key] = value;\n                return;\n            }\n            try {\n                effects[key] = makeEffect(value);\n            }\n            catch (e) {\n                throw new Error(`Failed to add effect to tile => ${key} : ${JSON.stringify(value)} : ` + e.message);\n            }\n        });\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        effects,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n        tags: options.tags || null,\n    };\n    const tile = new Tile(config);\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n// These are the minimal set of tiles to make the diggers work\nexport const NULL = install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\n// import './tiles';\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nimport * as Flags from '../../flags';\nexport class BasicEffect {\n    constructor(config) {\n        this.effects = [];\n        this.chance = 100 * 100; // 100%\n        this.seen = false;\n        this.flags = 0;\n        this.next = null;\n        if (typeof config === 'object' && !Array.isArray(config)) {\n            this.flags = GWU.flag.from(Flags.Effect, config.flags);\n            if (typeof config.chance === 'string' &&\n                config.chance.endsWith('%')) {\n                this.chance = Number.parseFloat(config.chance) * 100;\n            }\n            else {\n                this.chance = Number.parseInt(config.chance || '10000');\n            }\n        }\n    }\n    clone() {\n        const other = new this.constructor();\n        other.effects = this.effects.slice();\n        other.chance = this.chance;\n        other.seen = false;\n        other.flags = this.flags;\n        other.next = this.next;\n        return other;\n    }\n    trigger(loc, ctx = {}) {\n        if (!ctx.force && this.chance) {\n            const rng = ctx.rng || loc.map.rng || GWU.random;\n            if (!rng.chance(this.chance, 10000))\n                return false;\n        }\n        let didSomething = false;\n        for (let eff of this.effects) {\n            if (eff(loc, ctx)) {\n                didSomething = true;\n            }\n        }\n        if (this.next) {\n            const nextAlways = !!(this.flags & Flags.Effect.E_NEXT_ALWAYS);\n            if (didSomething || nextAlways) {\n                return this.next.trigger(loc, ctx);\n            }\n        }\n        return didSomething;\n    }\n}\nexport function makeBasicEffect(config) {\n    if (typeof config !== 'object') {\n        return new BasicEffect();\n    }\n    return new BasicEffect(config);\n}\nEffect.installType('basic', makeBasicEffect);\n","import * as GWU from 'gw-utils';\nimport { BasicEffect } from './basic';\nimport { installType } from '../effect';\nimport * as Flags from '../../flags';\nexport function makeSpreadEffect(config) {\n    return new SpreadEffect(config);\n}\ninstallType('spread', makeSpreadEffect);\nexport class SpreadEffect extends BasicEffect {\n    constructor(config) {\n        super(config);\n        this.grow = 0;\n        this.decrement = 0;\n        this.matchTile = '';\n        if (!config) {\n            config = { grow: 0, decrement: 0, flags: 0 };\n        }\n        if (typeof config === 'string') {\n            config = config.split(':').map((t) => t.trim());\n        }\n        if (Array.isArray(config)) {\n            if (config[0].toLowerCase() === 'spread') {\n                config.shift();\n            }\n            config = {\n                grow: config[0] || '0',\n                decrement: config[1] || '100',\n                flags: config[2] || '0',\n            };\n        }\n        else if (typeof config.type === 'string' &&\n            config.type.includes(':')) {\n            const parts = config.type.split(':').map((t) => t.trim());\n            if (parts[0].toLowerCase() === 'spread') {\n                parts.shift();\n            }\n            config.grow = parts[0] || '0';\n            config.decrement = parts[1] || '100';\n            config.flags = config.flags + '|' + parts[2];\n        }\n        this.grow = Number.parseInt(config.grow || 0);\n        this.decrement = Number.parseInt(config.decrement || 100);\n        this.flags = GWU.flag.from(Flags.Effect, config.flags || 0);\n        this.matchTile = config.matchTile || '';\n    }\n    clone() {\n        const other = super.clone();\n        other.grow = this.grow;\n        other.decrement = this.decrement;\n        other.matchTile = this.matchTile;\n        return other;\n    }\n    trigger(xy, ctx = {}) {\n        const abortIfBlocking = !!(this.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n        let didSomething = false;\n        const map = xy.map;\n        const spawnMap = GWU.grid.alloc(map.width, map.height);\n        didSomething = computeSpawnMap(this, xy, spawnMap);\n        if (!didSomething) {\n            GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (abortIfBlocking && mapDisruptedBy(map, spawnMap)) {\n            GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (this.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (this.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (this.flags & Flags.Effect.E_CLEAR_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (clearCells(map, spawnMap, this.flags)) {\n                didSomething = true;\n            }\n        }\n        spawnMap.forEach((v, x, y) => {\n            if (!v)\n                return;\n            spawnMap[x][y] = 1; // convert from generations to off/on/success\n            for (let eff of this.effects) {\n                if (eff({ map, x, y }, ctx)) {\n                    didSomething = true;\n                    spawnMap[x][y] = 2;\n                }\n            }\n        });\n        if (this.next) {\n            const nextAlways = !!(this.flags & Flags.Effect.E_NEXT_ALWAYS);\n            if (didSomething || nextAlways) {\n                if (this.flags & Flags.Effect.E_NEXT_EVERYWHERE) {\n                    spawnMap.forEach((v, x, y) => {\n                        if (!v)\n                            return;\n                        if (v == 2 || nextAlways) {\n                            this.next.trigger({ map, x, y }, ctx);\n                        }\n                    });\n                }\n                else {\n                    this.next.trigger({ map, x: xy.x, y: xy.y }, ctx);\n                }\n            }\n        }\n        GWU.grid.free(spawnMap);\n        return didSomething;\n    }\n}\nexport function mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(map.width, map.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (map.cell(i, j).isStairs()) {\n                disrupts = true;\n            }\n        }\n        else if (!map.cell(i, j).blocksMove()) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGWU.grid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cell(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cell(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.matchTile && !isStart && !cell.hasTile(effect.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, loc, spawnMap) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const map = loc.map;\n    let startProb = effect.grow || 0;\n    let probDec = effect.decrement || 0;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, loc.x, loc.y, true)) {\n        return false;\n    }\n    spawnMap[loc.x][loc.y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap[a.x][a.y])\n            return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const c = map.cell(x, y);\n            return !a.forbidsCell(c);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeActor(a);\n            map.addActor(loc[0], loc[1], a);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap[i.x][i.y])\n            return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const dest = map.cell(x, y);\n            return !i.forbidsCell(dest);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(i);\n            map.addItem(loc[0], loc[1], i);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// EMIT\nexport function makeEmitHandler(config) {\n    if (Array.isArray(config))\n        config = config[0];\n    if (typeof config !== 'string')\n        throw new Error('Invalid EMIT handler config - ' + config);\n    return emitEffect.bind(undefined, config);\n}\nexport function emitEffect(id, loc, ctx) {\n    return loc.map.events.emit(id, loc, ctx);\n}\ninstallHandler('emit', makeEmitHandler);\n","import * as GWU from 'gw-utils';\nimport { installHandler } from '../effect';\n//////////////////////////////////////////////\n// MESSAGE\nexport function makeMessageHandler(src) {\n    if (Array.isArray(src))\n        src = src[0];\n    if (typeof src !== 'string') {\n        throw new Error('Need message for message effect.');\n    }\n    const info = {\n        msg: src,\n    };\n    return messageEffect.bind(undefined, info);\n}\nexport function messageEffect(info, loc, ctx) {\n    const seen = ctx.seen;\n    const msg = info.msg;\n    if (msg &&\n        msg.length &&\n        ctx.aware &&\n        !seen\n    // && map.isVisible(x, y)\n    ) {\n        GWU.message.addAt(loc.x, loc.y, msg, ctx);\n        return true;\n    }\n    return false;\n}\ninstallHandler('msg', makeMessageHandler);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// ActivateMachine\nexport function makeActivateMachine() {\n    return activateMachine.bind(undefined);\n}\nexport function activateMachine(loc, ctx) {\n    const cell = loc.map.cell(loc.x, loc.y);\n    const machine = cell.machineId;\n    if (!machine)\n        return false;\n    return loc.map.activateMachine(machine, loc.x, loc.y, ctx);\n}\ninstallHandler('activateMachine', makeActivateMachine);\n","import { installHandler } from '../effect';\nexport function makeTileHandler(src) {\n    if (!src)\n        throw new Error('Tile effect needs configuration.');\n    if (typeof src === 'string') {\n        src = { id: src };\n    }\n    else if (Array.isArray(src)) {\n        src = { id: src[0] };\n    }\n    else if (!src.id) {\n        throw new Error('Tile effect needs configuration with id.');\n    }\n    const opts = src;\n    if (opts.id.includes('!')) {\n        opts.superpriority = true;\n    }\n    if (opts.id.includes('~')) {\n        opts.blockedByActors = true;\n        opts.blockedByItems = true;\n    }\n    opts.id = opts.id.replace(/[!~]*/g, '');\n    return tileEffect.bind(opts);\n}\nexport function tileEffect(loc, ctx) {\n    this.machine = ctx.machine || 0;\n    const didSomething = loc.map.setTile(loc.x, loc.y, this.id, this);\n    return didSomething;\n}\ninstallHandler('tile', makeTileHandler);\n","import * as Flags from '../../flags';\nimport { installHandler } from '../effect';\nexport function makeClearHandler(config) {\n    let layers = 0;\n    if (!config) {\n        layers = Flags.Depth.ALL_LAYERS;\n    }\n    else if (typeof config === 'number') {\n        layers = config;\n    }\n    else if (typeof config === 'string') {\n        const parts = config.split(/[,|]/g);\n        layers = parts.reduce((out, v) => {\n            if (typeof v === 'number')\n                return out | v;\n            const depth = Flags.Depth[v] || 0;\n            return out | depth;\n        }, 0);\n    }\n    else {\n        throw new Error('Invalid config for clear effect: ' + JSON.stringify(config));\n    }\n    return clearEffect.bind(undefined, layers);\n}\nexport function clearEffect(layers, loc, _ctx) {\n    if (!layers)\n        return false;\n    const cell = loc.map.cell(loc.x, loc.y);\n    return cell.clearDepth(layers);\n}\ninstallHandler('clear', makeClearHandler);\n","import * as Effect from '../effect';\nexport function makeFeatureHandler(id) {\n    if (Array.isArray(id))\n        id = id[0];\n    if (id && typeof id !== 'string') {\n        id = id.id;\n    }\n    if (!id || !id.length)\n        throw new Error('Feature effect needs ID');\n    return featureEffect.bind(undefined, id);\n}\nexport function featureEffect(id, loc, ctx) {\n    const feat = Effect.installedEffects[id];\n    if (!feat) {\n        throw new Error('Failed to find feature: ' + id);\n    }\n    return feat.trigger(loc, ctx);\n}\nEffect.installHandler('feature', makeFeatureHandler);\nEffect.installHandler('effect', makeFeatureHandler);\nEffect.installHandler('id', makeFeatureHandler);\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nexport function makeNourishEffect(opts) {\n    if (!opts)\n        throw new Error('Invalid Nourish config.');\n    let info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.type = opts[0] || 'inc';\n        info.amount = GWU.range.make(opts[1] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(opts.amount || 1);\n    }\n    else {\n        throw new Error('Invalid Nourish config: ' + JSON.stringify(opts));\n    }\n    return nourishEffect.bind(undefined, info);\n}\nexport function nourishEffect(config, loc, _ctx) {\n    if (!config.amount)\n        return false;\n    // who am I nourishing?\n    const actor = loc.map.actorAt(loc.x, loc.y);\n    if (!actor) {\n        return false;\n    }\n    const stats = actor.stats;\n    const c = stats.get('food');\n    if (!stats.adjust('food', config.type, config.amount))\n        return false;\n    const n = stats.get('food');\n    if (n < c && n / stats.max('food') < 0.1) {\n        GWU.message.addAt(actor.x, actor.y, nourishEffect.default.pukeMsg, {\n            actor,\n        });\n    }\n    return true;\n}\nnourishEffect.default = {\n    pukeMsg: '%you vomit.',\n};\nEffect.installHandler('nourish', makeNourishEffect);\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nexport function makeStatEffect(opts) {\n    if (!opts)\n        throw new Error('Invalid Stat config.');\n    const info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.stat = opts[0];\n        info.type = opts[1] || 'inc';\n        info.amount = GWU.range.make(opts[2] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.stat = opts.stat;\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(info.amount || 1);\n    }\n    else {\n        throw new Error('Invalid stat effect configuration: ' + JSON.stringify(opts));\n    }\n    return statEffect.bind(undefined, info);\n}\nexport function statEffect(config, loc, _ctx) {\n    if (!config.amount)\n        return false;\n    // who am I nourishing?\n    const actor = loc.map.actorAt(loc.x, loc.y);\n    if (!actor) {\n        return false;\n    }\n    // sustain?\n    const stats = actor.stats;\n    if (!stats.adjust('food', config.type, config.amount))\n        return false;\n    return true;\n}\nEffect.installHandler('stat', makeStatEffect);\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as Effect from '../effect';\nGWU.color.install('cellStatusName', 'light_blue');\nexport const NEVER_SEEN = {\n    tiles: [TILE.NULL],\n    item: null,\n    actor: null,\n    flags: {\n        cell: 0,\n        entity: TILE.NULL.flags.entity,\n        tile: TILE.NULL.flags.tile,\n        tileMech: TILE.NULL.flags.tileMech,\n    },\n};\nexport class Cell {\n    constructor(map, x, y, groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.x = -1;\n        this.y = -1;\n        // toFire: Partial<Effect.EffectCtx>[] = [];\n        this.memory = null;\n        // this._entities = new CellEntities(this);\n        this.flags = { cell: Flags.Cell.NEEDS_REDRAW };\n        this.tiles = [TILE.tiles.NULL];\n        this.map = map;\n        this.x = x;\n        this.y = y;\n        this.snapshot = GWU.sprite.makeMixer();\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n        this.memory = NEVER_SEEN;\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get hasStableSnapshot() {\n        return this.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    }\n    get hasStableMemory() {\n        return this.hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    storeMemory() {\n        var _a;\n        this.setCellFlag(Flags.Cell.STABLE_MEMORY);\n        // store memory\n        this.memory = {\n            flags: {\n                cell: this.flags.cell,\n                entity: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.entity) || 0), 0),\n                tile: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.tile) || 0), 0),\n                tileMech: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.tileMech) || 0), 0),\n            },\n            tiles: this.tiles.slice(),\n            item: ((_a = this.item) === null || _a === void 0 ? void 0 : _a.clone()) || null,\n            actor: null,\n        };\n        if (this.hasItem()) {\n            const item = this.item;\n            if (item) {\n                this.memory.flags.entity |= item.flags.entity;\n            }\n        }\n        if (this.hasActor()) {\n            const actor = this.actor;\n            if (actor) {\n                this.memory.flags.entity |= actor.flags.entity;\n            }\n            this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n    }\n    clearMemory() {\n        this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT | Flags.Cell.STABLE_MEMORY);\n        this.memory = null;\n        this.needsRedraw = true;\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this.machineId = other.machineId;\n        // this._actor = other.actor;\n        // this._item = other.item;\n        this.memory = other.memory;\n        this.map = other.map;\n        this.x = other.x;\n        this.y = other.y;\n        other.getSnapshot(this.snapshot);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag, checkEntities = false) {\n        var _a, _b;\n        if (this.tiles.some((t) => t && t.flags.entity & flag))\n            return true;\n        if (!checkEntities)\n            return false;\n        if (this.hasItem()) {\n            if ((_a = this.item) === null || _a === void 0 ? void 0 : _a.hasEntityFlag(flag))\n                return true;\n        }\n        if (this.hasActor()) {\n            if ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.hasEntityFlag(flag))\n                return true;\n        }\n        return false;\n    }\n    hasAllEntityFlags(flags, checkEntities = false) {\n        return (this.entityFlags(checkEntities) & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    hasTileTag(tag) {\n        return this.tiles.some((tile) => tile && tile.hasTag(tag));\n    }\n    hasAllTileTags(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAllTags(tags);\n        });\n    }\n    hasAnyTileTag(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAnyTag(tags);\n        });\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags(withEntities = false) {\n        var _a, _b;\n        let flag = this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0);\n        if (withEntities) {\n            if (this.hasItem()) {\n                flag |= ((_a = this.item) === null || _a === void 0 ? void 0 : _a.flags.entity) || 0;\n            }\n            if (this.hasActor()) {\n                flag |= ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.flags.entity) || 0;\n            }\n        }\n        return flag;\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            if (!this.memory) {\n                this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n                this.flags.cell &= ~Flags.Cell.STABLE_SNAPSHOT;\n                this.map.needsRedraw = true;\n            }\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return this.tiles.some((t) => t && t.blocksVision());\n    }\n    blocksPathing() {\n        return (this.tiles.some((t) => t && t.blocksPathing()) &&\n            !this.tiles.some((t) => t && t.hasTileFlag(Flags.Tile.T_BRIDGE)));\n    }\n    blocksMove() {\n        return this.tiles.some((t) => t && t.blocksMove());\n    }\n    blocksEffects() {\n        return this.tiles.some((t) => t && t.blocksEffects());\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isNull() {\n        return this.tiles.every((t) => !t || t === TILE.tiles.NULL);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isDoor() {\n        return this.hasTileFlag(Flags.Tile.T_IS_DOOR);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    // hasKey(): boolean {\n    //     return this._entities.some(\n    //         (e) => !!e.key && e.key.matches(this.x, this.y)\n    //     );\n    // }\n    hasLiquid() {\n        return this.hasTileFlag(Flags.Tile.T_ANY_LIQUID);\n    }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile, opts = {}) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile)\n            return false;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (this.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && this.hasItem())\n            return false;\n        if (opts.blockedByActors && this.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && this.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const currentGround = this.depthTile(Flags.Depth.GROUND);\n            const wantGround = TILE.get(tile.groundTile);\n            if (currentGround !== wantGround) {\n                if (!this.setTile(wantGround, opts)) {\n                    return false;\n                }\n            }\n        }\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            this.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            this.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (current.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR) !==\n            tile.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n            this.map.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            this.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.needsRedraw = true;\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.snapshot.blackOut();\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    tileWithEffect(name) {\n        return this.tiles.find((t) => t === null || t === void 0 ? void 0 : t.hasEffect(name)) || null;\n    }\n    fireEvent(event, ctx = {}) {\n        // ctx.cell = this;\n        let didSomething = false;\n        // console.log('fire event - %s', event);\n        for (const tile of this.tiles) {\n            if (!tile || !tile.effects)\n                continue;\n            const ev = tile.effects[event];\n            if (ev) {\n                const r = this._activate(ev, ctx);\n                if (r) {\n                    didSomething = true;\n                }\n            }\n        }\n        return didSomething;\n    }\n    _activate(effect, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.installedEffects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = effect.trigger(this, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    get item() {\n        return this.map.itemAt(this.x, this.y);\n    }\n    canAddItem(_item) {\n        return true;\n    }\n    canRemoveItem(_item) {\n        return true;\n    }\n    _addItem(_item) {\n        this.setCellFlag(Flags.Cell.HAS_ITEM);\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeItem(item) {\n        let hasItems = false;\n        let foundIndex = -1;\n        this.map.items.forEach((obj, index) => {\n            if (obj === item) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasItems = true;\n            }\n        });\n        if (!hasItems) {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this.map.actorAt(this.x, this.y);\n    }\n    canAddActor(_actor) {\n        return !this.hasActor();\n    }\n    canRemoveActor(_actor) {\n        return true;\n    }\n    _addActor(actor) {\n        this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        if (actor.isPlayer()) {\n            this.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeActor(actor) {\n        let hasActor = false;\n        let foundIndex = -1;\n        this.map.actors.forEach((obj, index) => {\n            if (obj === actor) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasActor = true;\n            }\n        });\n        if (!hasActor) {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.HAS_PLAYER);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    hasFx() {\n        return !!(this.flags.cell & Flags.Cell.HAS_FX);\n    }\n    get fx() {\n        return this.map.fxAt(this.x, this.y);\n    }\n    _addFx(_fx) {\n        this.setCellFlag(Flags.Cell.HAS_FX);\n        this.needsRedraw = true;\n    }\n    _removeFx(_fx) {\n        if (!this.fx) {\n            this.clearCellFlag(Flags.Cell.HAS_FX);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        if (this.hasActor()) {\n            const actor = this.map.actorAt(this.x, this.y);\n            if (actor && actor.sprite.ch)\n                return actor.sprite.ch;\n        }\n        if (this.hasItem()) {\n            const item = this.map.itemAt(this.x, this.y);\n            if (item && item.sprite.ch)\n                return item.sprite.ch;\n        }\n        if (this.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return '=';\n        }\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n    drawSidebar(buffer, bounds) {\n        const mixer = new GWU.sprite.Mixer();\n        this.map.getAppearanceAt(this.x, this.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, this.getName(), 'cellStatusName');\n        return 1;\n    }\n    toString() {\n        return `Cell @ ${this.x},${this.y}`;\n    }\n}\n","import { Entity } from '../entity/entity';\nimport { Depth } from '../flags';\nexport class Item extends Entity {\n    constructor(kind) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore - initialized in constructor\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n    }\n    isPlural() {\n        if (this.quantity > 1)\n            return true;\n        return super.isPlural();\n    }\n    copy(other) {\n        super.copy(other);\n        this.quantity = other.quantity;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n    getAction(name) {\n        const action = this.kind.actions[name];\n        return action;\n    }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n}\nItem.default = {\n    sidebarFg: 'gold',\n};\n","import * as GWU from 'gw-utils';\nimport { Actor } from '../actor/actor';\nimport { Cell } from '../map/cell';\nimport { Item } from '../item/item';\nimport * as Flags from '../flags';\nexport function messageYou(name, view, args) {\n    const field = args[0] || 'actor';\n    const actor = this.get(view, field);\n    if (actor && actor instanceof Actor) {\n        if (actor.isPlayer()) {\n            return 'you';\n        }\n        else {\n            return 'the ' + actor.getName();\n        }\n    }\n    return actor || name;\n}\nGWU.text.addHelper('you', messageYou);\nexport function messageThe(name, view, args) {\n    const value = args[0]\n        ? this.get(view, args[0])\n        : view.item || view.cell || view.target || view.actor;\n    if (value) {\n        if (value instanceof Cell) {\n            return value.getFlavor();\n        }\n        else if (value instanceof Actor) {\n            if (value.isPlayer()) {\n                return 'you';\n            }\n            else {\n                return 'the ' + value.getName();\n            }\n        }\n        else if (value instanceof Item) {\n            return 'the ' + value.getName();\n        }\n    }\n    return name;\n}\nGWU.text.addHelper('the', messageThe);\nexport function messageA(name, view, args) {\n    const value = args[0]\n        ? this.get(view, args[0])\n        : view.item || view.cell || view.target || view.actor;\n    if (value) {\n        if (value instanceof Cell) {\n            return value.getFlavor();\n        }\n        else if (value instanceof Actor) {\n            if (value.isPlayer()) {\n                return 'you';\n            }\n            else if (value.hasEntityFlag(Flags.Entity.L_FORMAL_NAME)) {\n                return value.getName();\n            }\n        }\n        if ('getName' in value) {\n            const name = value.getName();\n            const char = GWU.text.firstChar(name);\n            const ana = /[aeiouy]/i.exec(char) ? 'an ' : 'a ';\n            return ana + name;\n        }\n    }\n    return name;\n}\nGWU.text.addHelper('a', messageA);\nGWU.text.addHelper('an', messageA);\nexport function messageVerb(_name, view, args) {\n    const verb = args[0] || 'verb';\n    const value = args[1]\n        ? this.get(view, args[1])\n        : view.actor || view.target || view.item || view.cell;\n    let plural = false;\n    if (value) {\n        if (value instanceof Cell) {\n            plural = false;\n        }\n        else if (value instanceof Actor) {\n            plural = value.isPlural();\n        }\n        else if (value instanceof Item) {\n            plural = value.isPlural();\n        }\n    }\n    return plural ? GWU.text.toPluralVerb(verb) : GWU.text.toSingularVerb(verb);\n}\nGWU.text.addHelper('verb', messageVerb);\n","import * as GWU from 'gw-utils';\nexport class PainMessages {\n    constructor(msgs = []) {\n        this._msgs = [];\n        msgs.forEach((m) => this.add(m));\n    }\n    add(msg) {\n        this._msgs.push(msg);\n        return this;\n    }\n    get(pct, singular = true) {\n        const index = GWU.clamp(Math.floor(pct * this._msgs.length), 0, this._msgs.length - 1);\n        const msg = this._msgs[index];\n        return this._format(msg, singular);\n    }\n    _format(msg, singular = true) {\n        return msg.replace(/\\[(\\w+)\\|?(\\w*)\\]/g, singular ? '$1' : '$2');\n    }\n}\nexport const painMessages = {};\nexport function installPain(id, pain) {\n    if (Array.isArray(pain)) {\n        pain = new PainMessages(pain);\n    }\n    painMessages[id] = pain;\n}\nexport function getPain(id) {\n    const m = painMessages[id];\n    if (!m)\n        throw new Error('No such pain message index: ' + id);\n    return m;\n}\n","export const ais = {};\nexport function install(name, fn) {\n    ais[name] = fn;\n}\nexport function make(opts) {\n    if (typeof opts === 'string') {\n        opts = { fn: opts };\n    }\n    if (typeof opts === 'function') {\n        opts = { fn: opts };\n    }\n    if (typeof opts.fn === 'string') {\n        opts.fn = ais[opts.fn];\n    }\n    if (!opts.fn) {\n        opts.fn = ais.default;\n    }\n    return opts;\n}\n","import * as GWU from 'gw-utils';\nimport { getAction } from '../actor/action';\nimport * as AI from './ai';\nimport { wander } from './wander';\nexport class AICtx {\n    constructor(game, actor, target) {\n        this.item = null;\n        this.count = 0;\n        this.game = game;\n        this.actor = actor;\n        this.target = target || null;\n        this.distanceMap = GWU.grid.alloc(game.map.width, game.map.height);\n        if (target) {\n            const costMap = actor.costMap();\n            GWU.path.calculateDistances(this.distanceMap, target.x, target.y, costMap);\n        }\n    }\n    start() {\n        ++this.count;\n        return this;\n    }\n    done(result) {\n        --this.count;\n        if (this.count == 0) {\n            GWU.grid.free(this.distanceMap);\n        }\n        return result;\n    }\n}\n/*\nhttp://roguebasin.com/index.php/Roguelike_Intelligence_-_Stateless_AIs\n-- Typical AI\n*/\nexport async function typical(game, actor) {\n    if (actor.isDead())\n        return -1;\n    const map = actor.map;\n    if (!map)\n        return -1; // actor not on map ?!?!\n    const target = game.player;\n    const tryAttack = actor.canSee(target) && actor.willAttack(target);\n    if (tryAttack) {\n        const damagePct = 100 - actor.stats.getPct('health');\n        const morale = actor.stats.get('morale');\n        const chargeChance = 100;\n        const retreatChance = 0;\n        actor.ai.lastSawPlayer = [target.x, target.y];\n        actor.clearGoal();\n        console.log('SAW YOU!', actor.id, target.x, target.y);\n        const ctx = new AICtx(game, actor, target).start();\n        let result = 0;\n        if (damagePct > morale) {\n            if (canRunAwayFrom(game, actor, target, ctx)) {\n                result = await runAwayFrom(game, actor, target, ctx);\n            }\n            else if (canAttack(game, actor, target, ctx)) {\n                result = await attack(game, actor, target, ctx);\n            }\n            return ctx.done(result);\n        }\n        if (tooFarFrom(game, actor, target, ctx) &&\n            canAttack(game, actor, target, ctx) &&\n            canMoveToward(game, actor, target, ctx)) {\n            if (GWU.random.chance(chargeChance)) {\n                result = await moveToward(game, actor, target, ctx);\n            }\n            else {\n                result = await attack(game, actor, target, ctx);\n            }\n            return ctx.done(result);\n        }\n        if (tooCloseTo(game, actor, target, ctx) &&\n            canAttack(game, actor, target, ctx) &&\n            canMoveAwayFrom(game, actor, target, ctx)) {\n            if (GWU.random.chance(retreatChance)) {\n                result = await moveAwayFrom(game, actor, target, ctx);\n            }\n            else {\n                result = await attack(game, actor, target, ctx);\n            }\n            return ctx.done(result);\n        }\n        if (canAttack(game, actor, target, ctx)) {\n            result = await attack(game, actor, target, ctx);\n            return ctx.done(result);\n        }\n        if (tooFarFrom(game, actor, target, ctx) &&\n            canMoveToward(game, actor, target, ctx)) {\n            result = await moveToward(game, actor, target, ctx);\n            return ctx.done(result);\n        }\n        if (tooCloseTo(game, actor, target, ctx) &&\n            canMoveAwayFrom(game, actor, target, ctx)) {\n            result = await moveAwayFrom(game, actor, target, ctx);\n            return ctx.done(result);\n        }\n    }\n    // TODO - Use scent, menory, other teammates info, ...\n    else if (actor.ai.lastSawPlayer) {\n        if (!actor.hasGoal()) {\n            const loc = actor.ai.lastSawPlayer;\n            actor.setGoal(loc[0], loc[1]);\n        }\n        console.log('CHASING YOU!', actor.id, actor.goalMap.x, actor.goalMap.y);\n        const result = await moveTowardGoal(game, actor);\n        if (result) {\n            return result;\n        }\n        actor.ai.lastSawPlayer = null; // no longer\n        actor.clearGoal();\n    }\n    // check if they noticed the player scent\n    if (target.scent) {\n        const dir = target.scent.nextDir(actor.x, actor.y);\n        if (dir) {\n            console.log('tracking scent', actor.id, dir);\n            const moveDir = getAction('moveDir');\n            if (!moveDir)\n                throw new Error('No moveDir action found for Actors!');\n            const result = await moveDir(game, actor, { dir });\n            if (result)\n                return result;\n        }\n    }\n    const wanderOpt = GWU.object.firstOpt('wander', actor.ai, actor.kind.ai, false);\n    if (wanderOpt) {\n        if (actor.goalMap || // we have a current goal\n            typeof wanderOpt !== 'number' || // wander: true\n            GWU.random.chance(wanderOpt) // chance\n        ) {\n            const result = wander(game, actor);\n            if (result)\n                return result;\n        }\n        else {\n            const idle = getAction('idle');\n            if (idle) {\n                return idle(game, actor);\n            }\n        }\n    }\n    const standStill = getAction('standStill');\n    if (!standStill)\n        throw new Error('No standStill action found for actors!');\n    return standStill(game, actor);\n}\nAI.install('typical', typical);\nAI.install('default', typical);\nexport function canMoveToward(game, actor, target, ctx) {\n    // can move?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    const distanceMap = ctx.distanceMap;\n    const canMoveDiagonal = false;\n    // look for distance > current around me\n    let center = distanceMap[actor.x][actor.y];\n    let count = 0;\n    GWU.xy.eachNeighbor(actor.x, actor.y, (x, y) => {\n        if (distanceMap[x][y] < center) {\n            ++count;\n        }\n    }, canMoveDiagonal);\n    return ctx.done(count > 0);\n}\nexport async function moveToward(game, actor, target, ctx) {\n    // pathfinding?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    // distanceMap.dump();\n    const map = game.map;\n    const step = GWU.path.nextStep(ctx.distanceMap, actor.x, actor.y, (x, y) => {\n        const cell = map.cell(x, y);\n        if (!cell)\n            return true;\n        if (cell.hasActor() && cell.actor !== target)\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    });\n    let result = 0;\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        const standStill = getAction('standStill');\n        if (!standStill)\n            throw new Error('No standStill action found for actors!');\n        result = await standStill(game, actor);\n        return ctx.done(result);\n    }\n    const moveDir = getAction('moveDir');\n    if (!moveDir)\n        throw new Error('No moveDir action found for Actors!');\n    result = await moveDir(game, actor, { dir: step });\n    return ctx.done(result);\n}\nexport function canMoveAwayFrom(game, actor, target, ctx) {\n    // can move?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    const distanceMap = ctx.distanceMap;\n    const canMoveDiagonal = false;\n    // look for distance > current around me\n    let center = distanceMap[actor.x][actor.y];\n    let count = 0;\n    GWU.xy.eachNeighbor(actor.x, actor.y, (x, y) => {\n        const d = distanceMap[x][y];\n        if (d >= GWU.path.NO_PATH)\n            return;\n        if (distanceMap[x][y] > center) {\n            ++count;\n        }\n    }, canMoveDiagonal);\n    return ctx.done(count > 0);\n}\nexport async function moveAwayFrom(_game, actor, _target, _ctx) {\n    // safety/strategy?\n    // always move using safety map?\n    return actor.endTurn();\n}\nexport function canRunAwayFrom(_game, _actor, _target, _ctx) {\n    // can move?\n    return false;\n}\nexport async function runAwayFrom(_game, actor, _target, _ctx) {\n    // move toward loop if away from player\n    return actor.endTurn();\n}\nexport function canAttack(_game, actor, target, _ctx) {\n    // has attack?\n    // attack affects player?\n    // cooldown?\n    return GWU.xy.distanceFromTo(actor, target) <= 1;\n}\nexport async function attack(game, actor, target, _ctx) {\n    console.log('attack!', actor.id, target.id);\n    let attack = actor.getAction('attack');\n    if (!attack)\n        return 0;\n    return attack(game, actor, { actor: target });\n}\nexport function tooFarFrom(_game, actor, target, _ctx) {\n    // diagonal?\n    return GWU.xy.distanceFromTo(actor, target) > 1;\n}\nexport function tooCloseTo(_game, actor, target, _ctx) {\n    return GWU.xy.distanceFromTo(actor, target) < 1;\n}\n// TODO - make an action\nexport async function moveTowardGoal(game, actor) {\n    if (!actor.hasGoal())\n        return 0;\n    const nextStep = GWU.path.nextStep(actor.goalMap, actor.x, actor.y, (x, y) => {\n        return actor.map.hasActor(x, y);\n    });\n    if (!nextStep) {\n        actor.clearGoal();\n        return 0;\n    }\n    const moveDir = actor.getAction('moveDir');\n    if (!moveDir)\n        throw new Error('No moveDir action for actor!');\n    return await moveDir(game, actor, { dir: nextStep });\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { getAction } from '../actor/action';\nexport async function wander(game, actor) {\n    // Do we have a wander target?\n    let goalMap = actor.goalMap;\n    if (!goalMap) {\n        //      pick new wander target\n        const costMap = actor.costMap();\n        const loc = GWU.random.matchingLoc(costMap.width, costMap.height, (x, y) => {\n            return costMap[x][y] > 0 && costMap[x][y] !== GWU.path.NO_PATH;\n        });\n        if (!loc || loc[0] < 0 || loc[1] < 0) {\n            console.log('No wander location found!');\n            return 0;\n        }\n        //      build distance map to target\n        goalMap = actor.setGoal(loc[0], loc[1]);\n    }\n    // take the next step to the target\n    const step = GWU.path.nextStep(goalMap, actor.x, actor.y, (x, y) => {\n        if (!game.map.hasActor(x, y))\n            return false;\n        const other = game.map.actorAt(x, y);\n        if (!other) {\n            console.log(`Cell @ ${x},${y} has actor flag, but no actor.`);\n            game.map.cell(x, y).clearCellFlag(Flags.Cell.HAS_ACTOR);\n            return false;\n        }\n        return !actor.canPass(other);\n    });\n    if (!step) {\n        actor.clearGoal();\n        return 0;\n    }\n    let result = 0;\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        return 0; // did nothing\n    }\n    const moveDir = getAction('moveDir');\n    if (!moveDir)\n        throw new Error('No moveDir action found for Actors!');\n    result = await moveDir(game, actor, { dir: step });\n    return result;\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nexport function fillSafetyMap(safetyMap, actor, target) {\n    const costGrid = GWU.grid.alloc(actor.costMap());\n    GWU.path.calculateDistances(safetyMap, target.x, target.y, costGrid, true);\n    safetyMap.update((v) => v * -1); // Can set factor to be < -1 e.g. -1.2\n    actor.map.actors.forEach((a) => {\n        if (a.willAttack(actor)) {\n            costGrid[a.x][a.y] = GWU.path.FORBIDDEN; // This is why we allocate a copy\n        }\n    });\n    actor.map.eachCell((c, x, y) => {\n        if (c.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n            safetyMap[x][y] -= GWU.path.AVOIDED; // loop cells are extra good\n        }\n    });\n    GWU.path.rescan(safetyMap, costGrid, true);\n    safetyMap.update((v) => (v <= -30000 ? 30000 : v));\n    GWU.grid.free(costGrid);\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Actor } from './actor';\nimport * as AI from '../ai';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n        this.flags = {\n            actor: Flags.Actor.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.vision = {};\n        this.actions = {};\n        this.bump = ['attack'];\n        this.moveSpeed = 100;\n        if (opts.flags) {\n            this.flags.actor = GWU.flag.from(Flags.Actor, this.flags.actor, opts.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, opts.flags);\n        }\n        if (opts.vision) {\n            this.vision.normal = opts.vision;\n        }\n        this.stats = Object.assign({ health: 1, morale: 100 }, opts.stats);\n        if (opts.actions) {\n            Object.assign(this.actions, opts.actions);\n        }\n        if (opts.moveSpeed) {\n            this.moveSpeed = opts.moveSpeed;\n        }\n        this.ai = AI.make(opts.ai || 'default');\n        if (opts.bump) {\n            if (typeof opts.bump === 'string') {\n                opts.bump = opts.bump.split(/[|,]/g).map((t) => t.trim());\n            }\n            if (typeof opts.bump === 'function') {\n                opts.bump = [opts.bump];\n            }\n            if (Array.isArray(opts.bump)) {\n                this.bump = opts.bump.slice();\n            }\n        }\n        if (opts.waterOnly) {\n            this.forbidTileFlags =\n                this.forbidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            this.avoidTileFlags =\n                this.avoidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            this.requireTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n        }\n        else if (opts.lavaOnly) {\n            this.forbidTileFlags = this.forbidTileFlags & ~Flags.Tile.T_LAVA;\n            this.avoidTileFlags = this.avoidTileFlags & ~Flags.Tile.T_LAVA;\n            this.requireTileFlags |= Flags.Tile.T_LAVA;\n        }\n        else {\n            if (opts.swim) {\n                this.avoidTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n            else {\n                this.forbidTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n            if (opts.fly) {\n                this.forbidTileFlags =\n                    this.forbidTileFlags & ~Flags.Tile.T_LAVA;\n                this.avoidTileFlags = this.avoidTileFlags & ~Flags.Tile.T_LAVA;\n                this.requireTileFlags =\n                    this.requireTileFlags & ~Flags.Tile.T_LAVA;\n                this.forbidTileFlags =\n                    this.forbidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n                this.avoidTileFlags =\n                    this.avoidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n                this.requireTileFlags =\n                    this.requireTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n        }\n        this.sidebarFg = GWU.color.from(opts.sidebarFg || Actor.default.sidebarFg);\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n        Object.assign(actor.flags, this.flags);\n        // if (options.fov) {\n        //     actor.fov = options.fov;\n        // }\n        // if (options.memory) {\n        //     actor.memory = options.memory;\n        // }\n        if (this.vision.normal) {\n            actor.visionDistance = this.vision.normal;\n        }\n        actor.stats.init(this.stats);\n    }\n    addToMap(actor, map) {\n        super.addToMap(actor, map);\n        // if (this.hasActorFlag(Flags.Actor.HAS_MEMORY)) {\n        //     actor.memory = Memory.get(actor, map);\n        // }\n        // if (this.hasActorFlag(Flags.Actor.USES_FOV)) {\n        //     actor.fov = new GWU.fov.FovSystem(map);\n        //     actor.fov.follow = actor;\n        //     if (actor.memory) {\n        //         actor.fov.callback = actor.memory;\n        //     }\n        // }\n    }\n    removeFromMap(actor) {\n        super.removeFromMap(actor);\n        // if (actor._map && actor.memory) {\n        //     Memory.store(actor, actor._map, actor.memory);\n        // }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    canSeeEntity(_actor, _entity) {\n        return true;\n    }\n    isAbleToSee(_actor, _entity) {\n        return true;\n    }\n    isAbleToSense(_actor, _entity) {\n        return true;\n    }\n    forbidsCell(cell, actor) {\n        if (super.forbidsCell(cell, actor)) {\n            return true;\n        }\n        if (cell.blocksMove())\n            return true;\n        return false;\n    }\n    avoidsCell(cell, actor) {\n        if (super.avoidsCell(cell, actor))\n            return true;\n        if (cell.blocksPathing())\n            return true;\n        return false;\n    }\n    getFlavor(actor, opts) {\n        const flavor = actor.isPlayer() ? 'yourself' : this.flavor;\n        if (opts && opts.action) {\n            return flavor + ' standing';\n        }\n        return flavor;\n    }\n    pickupItem(actor, item, _opts) {\n        if (!GWU.list.push(actor, 'items', item))\n            return false;\n        // TODO - Pickup effects\n        return true;\n    }\n    dropItem(actor, item, _opts) {\n        if (!GWU.list.remove(actor, 'items', item))\n            return false;\n        // TODO - Drop effects\n        return true;\n    }\n    cellCost(cell, actor) {\n        if (this.forbidsCell(cell, actor)) {\n            return cell.hasEntityFlag(Flags.Entity.L_BLOCKS_DIAGONAL)\n                ? GWU.path.OBSTRUCTION\n                : GWU.path.FORBIDDEN;\n        }\n        else if (this.avoidsCell(cell, actor)) {\n            return GWU.path.AVOIDED;\n        }\n        return GWU.path.OK;\n    }\n    drawSidebar(actor, buffer, bounds) {\n        let count = super.drawSidebar(actor, buffer, bounds);\n        if (actor.map.hasTileFlag(actor.x, actor.y, Flags.Tile.T_DEEP_WATER) &&\n            !actor.map.hasTileFlag(actor.x, actor.y, Flags.Tile.T_BRIDGE)) {\n            buffer.drawText(bounds.x + 3, bounds.y + count++, 'Swimming', '#66F');\n        }\n        return count;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ActorKind } from './kind';\nexport function make(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ActorKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ActorKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ActorKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ActorKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import { installAction } from '../action';\n// BUMP\n//\n// prefixes:\n// @ = only for player\n// + = only for ally\n// - = only for opposed\n// = = only for same kind\n// $ = use my action (if used with one of the above, this comes last)\n//\nexport async function bump(game, actor, ctx = {}) {\n    const other = ctx.actor;\n    if (other) {\n        const bumpActions = other.getBumpActions();\n        for (let action of bumpActions) {\n            if (typeof action === 'string') {\n                if (action.startsWith('$')) {\n                    const selfName = action.substring(1);\n                    let selfAction = other.getAction(selfName);\n                    if (selfAction === false) {\n                        throw new Error('Cannot have bump action for self action that actor cannot do: ' +\n                            action);\n                    }\n                    const ctx2 = Object.assign({}, ctx, { actor });\n                    const result = await selfAction(game, other, ctx2);\n                    if (result)\n                        return result;\n                }\n                else {\n                    const config = actor.getAction(action);\n                    if (config === false) {\n                        throw new Error('Cannot configure actor with bump action they cannot do: ' +\n                            action);\n                    }\n                    else {\n                        action = config;\n                    }\n                    const result = await action(game, actor, ctx);\n                    if (result)\n                        return result;\n                }\n            }\n            else {\n                const result = await action(game, actor, ctx);\n                if (result)\n                    return result;\n            }\n        }\n    }\n    const item = ctx.item;\n    if (item) {\n        // TODO - Item Actions\n    }\n    return 0;\n}\ninstallAction('bump', bump);\n","import { installAction } from '../action';\nexport async function standStill(_game, actor, _ctx) {\n    return actor.endTurn();\n}\ninstallAction('standStill', standStill);\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\n// export class SpriteFX extends FX {\n//     sprite: GWU.sprite.SpriteConfig;\n//     stepCount: number;\n//     x: number;\n//     y: number;\n//     constructor(\n//         map: Map,\n//         sprite: string | GWU.sprite.SpriteConfig,\n//         x: number,\n//         y: number,\n//         opts: SpriteFxOptions = {}\n//     ) {\n//         const count = opts.blink || 1;\n//         const duration = opts.duration || 1000;\n//         opts.speed = opts.speed || duration / (2 * count - 1);\n//         super(map, opts);\n//         if (typeof sprite === 'string') {\n//             const name = sprite;\n//             sprite = GWU.sprite.sprites[sprite];\n//             if (!sprite) throw new Error('Cannot find sprite! ' + name);\n//         }\n//         this.sprite = sprite;\n//         this.x = x || 0;\n//         this.y = y || 0;\n//         this.stepCount = 2 * count - 1;\n//     }\n//     start() {\n//         this.map.addFx(this.x, this.y, this.sprite);\n//         return super.start();\n//     }\n//     step() {\n//         --this.stepCount;\n//         if (this.stepCount <= 0) return this.stop();\n//         if (this.stepCount % 2 == 0) {\n//             this.map.removeFx(this);\n//         } else {\n//             this.map.addFx(this.x, this.y, this);\n//         }\n//     }\n//     stop(result?: any) {\n//         this.map.removeFx(this);\n//         return super.stop(result);\n//     }\n//     moveDir(dx: number, dy: number) {\n//         return this.moveTo(this.x + dx, this.y + dy);\n//     }\n//     moveTo(x: number, y: number) {\n//         this.map.moveFx(x, y, this);\n//         return true;\n//     }\n// }\nexport async function flashSprite(map, x, y, sprite, duration = 100, count = 1, animator) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ visible: true })\n        .to({ visible: false })\n        .repeat(count)\n        .repeatDelay(duration)\n        .duration(duration)\n        .onUpdate((obj) => {\n        if (obj.visible) {\n            map.addFx(x, y, entity);\n        }\n        else {\n            map.removeFx(entity);\n        }\n    });\n    // realTime\n    animator = animator || GWU.io.loop;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nGWU.sprite.install('bump', 'white', 50);\nexport async function hit(map, target, sprite, duration, animator) {\n    sprite = sprite || 'hit';\n    duration = duration || 200;\n    await flashSprite(map, target.x, target.y, sprite, duration, 1, animator);\n}\nGWU.sprite.install('hit', 'red', 50);\nexport async function miss(map, target, sprite, duration, animator) {\n    sprite = sprite || 'miss';\n    duration = duration || 200;\n    await flashSprite(map, target.x, target.y, sprite, duration, 1, animator);\n}\nGWU.sprite.install('miss', 'green', 50);\nexport async function fadeInOut(map, x, y, sprite, duration = 100, animator) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite).clone();\n    }\n    else {\n        sprite = GWU.sprite.make(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ opacity: 0 })\n        .to({ opacity: 100 })\n        .repeat(2)\n        .yoyo(true)\n        .duration(Math.floor(duration / 2))\n        .onUpdate((obj) => {\n        entity.sprite.opacity = obj.opacity;\n        map.cell(x, y).needsRedraw = true; // we changed the sprite so redraw\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n    });\n    // realTime\n    animator = animator || GWU.io.loop;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nexport async function moveSprite(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    const from = { x: GWU.xy.x(source), y: GWU.xy.y(source) };\n    map.addFx(from.x, from.y, entity);\n    let duration = opts.duration ||\n        Math.ceil(16 * (GWU.xy.maxAxisFromTo(source, target) / (opts.speed || 8)));\n    if (GWU.xy.isLoc(target)) {\n        target = { x: target[0], y: target[1] };\n    }\n    const tween = GWU.tween\n        .make(from)\n        .to(target)\n        .duration(duration)\n        .onUpdate((vals) => {\n        // tweens dont update every step, so...\n        // draw line from current pos to vals pos\n        // check each step for blocking...\n        // end at either vals or last blocking spot\n        const dest = { x: entity.x, y: entity.y };\n        const ok = GWU.xy.forLineBetween(dest.x, dest.y, vals.x, vals.y, (x, y) => {\n            if (opts.stepFn) {\n                if (opts.stepFn(x, y)) {\n                    if (!opts.stopBeforeWalls) {\n                        dest.x = x;\n                        dest.y = y;\n                    }\n                    return false;\n                }\n            }\n            else if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (!opts.stopBeforeWalls) {\n                    dest.x = x;\n                    dest.y = y;\n                }\n                return false;\n            }\n            dest.x = x;\n            dest.y = y;\n        });\n        map.moveFx(entity, dest.x, dest.y);\n        if (!ok) {\n            tween.stop();\n        }\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n        return entity;\n    });\n    const animator = opts.animator || map;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nexport function bolt(map, source, target, sprite, opts = {}) {\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport async function projectile(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    if (sprite.ch && sprite.ch.length == 4) {\n        const dir = GWU.xy.dirFromTo(source, target);\n        let index = 0;\n        if (dir[0] && dir[1]) {\n            index = 2;\n            if (dir[0] != dir[1]) {\n                // remember up is -y\n                index = 3;\n            }\n        }\n        else if (dir[0]) {\n            index = 1;\n        }\n        const ch = sprite.ch[index];\n        sprite = GWU.sprite.make(ch, sprite.fg, sprite.bg);\n    }\n    else if (sprite.ch && sprite.ch.length !== 1) {\n        throw new Error('projectile requires 4 chars - vert,horiz,diag-left,diag-right (e.g: \"|-\\\\/\")');\n    }\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport function beam(map, from, to, sprite, opts = {}) {\n    opts.fade = opts.fade || 100;\n    if (opts.stopAtWalls === undefined)\n        opts.stopAtWalls = true;\n    const line = [];\n    GWU.xy.forLineFromTo(from, to, (x, y) => {\n        if (!map.hasXY(x, y))\n            return false;\n        if (opts.stepFn && opts.stepFn(x, y))\n            return false;\n        if (opts.stopAtWalls || opts.stopBeforeWalls) {\n            if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (opts.stopBeforeWalls)\n                    return false;\n                line.push([x, y]);\n                return false;\n            }\n        }\n        line.push([x, y]);\n        return true;\n    });\n    const duration = opts.duration || Math.ceil(16 * (line.length / (opts.speed || 8)));\n    const animator = opts.animator || map;\n    const promises = [];\n    let lastIndex = -1;\n    const tween = GWU.tween\n        .make({ index: 0 })\n        .to({ index: line.length - 1 })\n        .duration(duration)\n        .onUpdate((vals) => {\n        while (lastIndex < vals.index) {\n            ++lastIndex;\n            const loc = line[lastIndex] || [-1, -1];\n            promises.push(fadeInOut(map, loc[0], loc[1], sprite, opts.fade, animator));\n        }\n    })\n        .onFinish(async () => {\n        await Promise.all(promises);\n        const loc = line[line.length - 1];\n        return { x: loc[0], y: loc[1] };\n    });\n    animator.addAnimation(tween);\n    return tween.start();\n}\nfunction isInShape(shape, cx, cy, allowCenter, x, y) {\n    const sx = Math.abs(x - cx);\n    const sy = Math.abs(y - cy);\n    if (sx == 0 && sy == 0 && !allowCenter)\n        return false;\n    switch (shape) {\n        case '+':\n            return sx == 0 || sy == 0;\n        case 'x':\n        case 'X':\n            return sx == sy;\n        case '*':\n            return sx == 0 || sy == 0 || sx == sy;\n        default:\n            return true;\n    }\n}\nfunction checkExplosionOpts(opts) {\n    opts.speed = opts.speed || 2;\n    opts.fade = opts.fade || 100;\n    opts.shape = opts.shape || 'o';\n    if (opts.center === undefined) {\n        opts.center = true;\n    }\n}\nexport function explosion(map, x, y, radius, sprite, opts = {}) {\n    checkExplosionOpts(opts);\n    opts.animator = opts.animator || map;\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const grid = GWU.grid.alloc(map.width, map.height);\n    const fov = new GWU.fov.FOV({\n        isBlocked(x, y) {\n            return map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE);\n        },\n        hasXY(x, y) {\n            return map.hasXY(x, y);\n        },\n    });\n    fov.calculate(x, y, radius, (x1, y1) => {\n        grid[x1][y1] = 1;\n    });\n    const duration = opts.duration || 32 * (radius / opts.speed);\n    const promises = [];\n    const tween = GWU.tween\n        .make({ r: 0 })\n        .to({ r: radius })\n        .duration(duration)\n        .onUpdate((vals) => {\n        const minX = Math.max(0, x - vals.r);\n        const minY = Math.max(0, y - vals.r);\n        const maxX = Math.min(map.width - 1, x + vals.r);\n        const maxY = Math.min(map.height - 1, y + vals.r);\n        for (let x1 = minX; x1 <= maxX; ++x1) {\n            for (let y1 = minY; y1 <= maxY; ++y1) {\n                if (grid[x1][y1] &&\n                    GWU.xy.distanceBetween(x, y, x1, y1) <= vals.r) {\n                    grid[x1][y1] = 0;\n                    if (isInShape(opts.shape, x, y, opts.center, x1, y1)) {\n                        promises.push(fadeInOut(map, x1, y1, sprite, opts.fade, opts.animator));\n                    }\n                }\n            }\n        }\n    })\n        .onFinish(async (_obj, success) => {\n        GWU.grid.free(grid);\n        await Promise.all(promises);\n        return success;\n    });\n    opts.animator.addAnimation(tween);\n    return tween.start();\n}\n/*\nexport function explosionFor(\n    map: Map,\n    grid: GWU.grid.NumGrid,\n    x: number,\n    y: number,\n    radius: number,\n    sprite: string | GWU.sprite.SpriteConfig,\n    opts: ExplosionOptions = {}\n) {\n    checkExplosionOpts(opts);\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    const animation = new ExplosionFX(\n        map,\n        grid,\n        x,\n        y,\n        radius,\n        sprite,\n        opts.speed,\n        opts.fade,\n        opts.shape,\n        opts.center,\n        opts.stepFn\n    );\n    return opts.playFn!(animation);\n}\n*/\n","import * as GWU from 'gw-utils';\nimport { installAction } from '../action';\nimport { bump } from './bump';\nimport { standStill } from './standStill';\nimport * as FX from '../../fx';\nimport * as Flags from '../../flags';\nexport async function moveDir(game, actor, ctx = {}) {\n    //\n    const step = ctx.dir;\n    if (!step)\n        throw new Error('moveDir called with no direction!');\n    const newX = actor.x + step[0];\n    const newY = actor.y + step[1];\n    const map = game.map;\n    const currentCell = map.cell(actor.x, actor.y);\n    const newCell = map.cell(newX, newY);\n    let result = 0;\n    if (actor.forbidsCell(newCell)) {\n        if (ctx.try)\n            return 0;\n        if (actor.isPlayer()) {\n            FX.hit(map, newCell, 'hit', 100);\n            GWU.message.addAt(newCell.x, newCell.y, '{{you}} {{verb bump~}} into {{a cell}}.', { actor, cell: newCell });\n        }\n        actor.clearGoal();\n        return actor.endTurn();\n    }\n    if (newCell.blocksMove()) {\n        if (ctx.try)\n            return 0;\n        FX.hit(map, newCell, 'hit', 100);\n        actor.clearGoal();\n        return actor.endTurn();\n    }\n    // can we leave?\n    if (!currentCell.canRemoveActor(actor)) {\n        if (ctx.try)\n            return 0;\n        // canActorLeave must add appropriate message\n        return actor.endTurn();\n    }\n    // is there an actor there?\n    if (newCell.hasActor() || newCell.hasItem()) {\n        if (ctx.try)\n            return 0;\n        const ctx2 = { actor: newCell.actor, item: newCell.item };\n        result = await bump(game, actor, ctx2);\n        if (result)\n            return result;\n    }\n    // can we enter?\n    if (!newCell.canAddActor(actor)) {\n        if (ctx.try)\n            return 0;\n        return actor.endTurn();\n    }\n    if (!map.moveActor(actor, newX, newY)) {\n        result = await standStill(game, actor, ctx);\n        return result;\n    }\n    let rate = 100;\n    if (newCell.hasTileFlag(Flags.Tile.T_DEEP_WATER)) {\n        rate = 150;\n    }\n    result = actor.endTurn(rate);\n    return result;\n}\ninstallAction('moveDir', moveDir);\n","import * as GWU from 'gw-utils';\nimport { installAction } from '../action';\nimport { moveDir } from './moveDir';\nexport async function idle(game, actor, _ctx) {\n    if (GWU.random.chance(50)) {\n        // do nothing\n        return actor.endTurn();\n    }\n    // try to step in a random direction\n    const dirIndex = GWU.random.number(4);\n    const dir = GWU.xy.DIRS[dirIndex];\n    const result = await moveDir(game, actor, { dir, try: true });\n    if (result)\n        return result;\n    // stand still\n    return actor.endTurn();\n}\ninstallAction('idle', idle);\n","import * as GWU from 'gw-utils';\nimport { installAction } from '../action';\nexport async function pickup(game, actor, ctx = {}) {\n    const map = actor.map;\n    if (!map)\n        throw new Error('Actor not on map!');\n    const item = actor.map.itemAt(actor.x, actor.y);\n    if (!item) {\n        if (!ctx.quiet) {\n            GWU.message.addAt(actor.x, actor.y, 'Nothing to pickup.');\n        }\n        return 0;\n    }\n    if (actor.avoidsItem(item))\n        return 0;\n    const itemAction = item.getAction('pickup');\n    if (itemAction === false) {\n        if (!ctx.quiet) {\n            GWU.message.addAt(actor.x, actor.y, '{{you}} cannot pickup {{the item}}.', {\n                actor,\n                item,\n            });\n        }\n        return 0;\n    }\n    else if (typeof itemAction === 'function') {\n        // You have to do everything\n        const result = await itemAction(game, actor, item);\n        if (result)\n            return result; // handled\n    }\n    // logs error messages\n    if (!actor.canAddItem(item)) {\n        return 0;\n    }\n    if (!actor.map.removeItem(item)) {\n        return 0;\n    }\n    actor.addItem(item);\n    if (!ctx.quiet) {\n        GWU.message.addAt(actor.x, actor.y, '{{you}} {{verb pick[s]}} up {{an item}}.', {\n            actor,\n            item,\n        });\n    }\n    return actor.endTurn();\n}\ninstallAction('pickup', pickup);\n","import * as GWU from 'gw-utils';\nimport { installAction } from '../action';\nimport * as Flags from '../../flags';\nexport async function climb(game, actor, _ctx) {\n    const map = game.map;\n    const x = actor.x;\n    const y = actor.y;\n    if (map.hasTileFlag(x, y, Flags.Tile.T_UP_STAIRS)) {\n        GWU.message.addAt(x, y, '{{you}} {{verb climb[s]}}.', { actor });\n        game.startNewMap(map.id + 1);\n        return actor.endTurn();\n    }\n    GWU.message.addAt(x, y, 'Nothing to climb.');\n    return actor.endTurn(50); // half turn\n}\ninstallAction('climb', climb);\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Item } from './item';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n        this.flags = {\n            item: Flags.Item.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.actions = {};\n        this.bump = [];\n        if (config.flags) {\n            this.flags.item = GWU.flag.from(Flags.Item, this.flags.item, config.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, config.flags);\n        }\n        if (config.actions) {\n            Object.entries(config.actions).forEach(([key, value]) => {\n                this.actions[key] = value;\n            });\n        }\n        if (config.bump) {\n            if (typeof config.bump === 'string' ||\n                typeof config.bump === 'function') {\n                config.bump = [config.bump];\n            }\n            if (Array.isArray(config.bump)) {\n                this.bump = config.bump.slice();\n            }\n        }\n        this.avoidTileFlags |= Flags.Tile.T_DEEP_WATER;\n        this.forbidTileFlags |= Flags.Tile.T_LAVA | Flags.Tile.T_AUTO_DESCENT;\n        this.sidebarFg = GWU.color.from(config.sidebarFg || Item.default.sidebarFg);\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n    init(item, options = {}) {\n        super.init(item, options);\n        Object.assign(item.flags, this.flags);\n        item.quantity = options.quantity || 1;\n    }\n    avoidsCell(cell, item) {\n        if (cell.isDoor() || cell.isStairs())\n            return true;\n        return super.avoidsCell(cell, item);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ItemKind } from './kind';\nexport function make(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        kind.id = id;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile, _opts) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n}\n","import { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts) {\n        const cell = this.map.cell(x, y);\n        return cell.setTile(tile, opts);\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // // Bookkeeping for fire, pressure plates and key-activated tiles.\n        // for (let x = 0; x < this.map.width; ++x) {\n        //     for (let y = 0; y < this.map.height; ++y) {\n        //         const cell = this.map.cell(x, y);\n        //         if (\n        //             !cell.hasCellFlag(\n        //                 Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM\n        //             ) &&\n        //             cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)\n        //         ) {\n        //             cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n        //         }\n        //     }\n        // }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    clear() {\n        this.volume.fill(0);\n    }\n    setTile(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.setTile(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.changed = true;\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n        this.changed = other.changed;\n    }\n    tick(_dt) {\n        if (!this.changed)\n            return false;\n        this.changed = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.changed = true;\n            }\n            else {\n                this.clearTile(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clearTile(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nimport * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.xy.DIRS[d];\n                        this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = Effect.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && this.map.rng.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            cell.fireEvent(event, {\n                force: true,\n            });\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nconst highlightColor = GWU.color.install('highlight', [100, 100, 0]);\nexport class BasicDrawer {\n    constructor() {\n        this.scent = false;\n    }\n    drawInto(dest, map, opts = {}) {\n        const buffer = dest instanceof GWU.buffer.Buffer ? dest : dest.buffer;\n        const offsetX = opts.offsetX || 0;\n        const offsetY = opts.offsetY || 0;\n        map.clearMapFlag(Flags.Map.MAP_DANCES);\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                if (map.hasXY(x + offsetX, y + offsetY)) {\n                    const cell = map.cell(x + offsetX, y + offsetY);\n                    this.drawCell(mixer, map, cell, map.fov);\n                    buffer.drawSprite(x, y, mixer);\n                }\n            }\n        }\n    }\n    drawCell(dest, map, cell, fov) {\n        dest.blackOut();\n        // const isVisible = fov ? fov.isAnyKindOfVisible(cell.x, cell.y) : true;\n        const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (cell.needsRedraw || needSnapshot) {\n            this.getAppearance(dest, map, cell);\n            cell.putSnapshot(dest);\n            cell.needsRedraw = false;\n            cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n        else {\n            cell.getSnapshot(dest);\n            if (cell.hasCellFlag(Flags.Cell.COLORS_DANCE)) {\n                map.setMapFlag(Flags.Map.MAP_DANCES);\n            }\n        }\n        this.applyLight(dest, cell, fov);\n        let separate = false;\n        if (cell.memory) {\n            separate = !!((cell.memory.flags.entity & Flags.Entity.L_VISUALLY_DISTINCT)\n            // Flags.Entity.L_LIST_IN_SIDEBAR)\n            );\n        }\n        else {\n            separate = cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT, \n            // Flags.Entity.L_LIST_IN_SIDEBAR,\n            true);\n        }\n        if (cell.hasCellFlag(Flags.Cell.IS_CURSOR)) {\n            dest.bg = highlightColor;\n            dest.fg = dest.bg.inverse();\n            separate = true;\n        }\n        else if (cell.hasCellFlag(Flags.Cell.IS_HIGHLIGHTED)) {\n            dest.bg = highlightColor.mix(dest.bg, 35);\n            dest.fg = dest.bg.inverse();\n            separate = true;\n        }\n        if (this.scent && map.player) {\n            const s = GWU.clamp(map.player.scent.get(cell.x, cell.y) * 5, 0, 50);\n            if (s) {\n                const c = GWU.color.colors.red;\n                dest.mix(c, 0, s);\n            }\n        }\n        if (separate) {\n            [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n        }\n        return true;\n    }\n    // getCellAppearance(cell: CellType, dest: GWU.sprite.Mixer) {\n    //     dest.blackOut();\n    //     const isVisible = true; // this.fov.isAnyKindOfVisible(x, y);\n    //     const isRevealed = true; // this.fov.isRevealed(x, y);\n    //     const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     if (needSnapshot || (cell.needsRedraw && isVisible)) {\n    //         this.layers.forEach((layer) => layer.putAppearance(dest, cell));\n    //         if (dest.dances) {\n    //             cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n    //         } else {\n    //             cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n    //         }\n    //         dest.bake();\n    //         cell.putSnapshot(dest);\n    //         cell.needsRedraw = false;\n    //         cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     } else {\n    //         cell.getSnapshot(dest);\n    //     }\n    //     if (isVisible) {\n    //         const light = this.light.getLight(cell.x, cell.y);\n    //         dest.multiply(light);\n    //     } else if (isRevealed) {\n    //         dest.scale(50);\n    //     } else {\n    //         dest.blackOut();\n    //     }\n    //     if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n    //         [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n    //     }\n    // }\n    getAppearance(dest, map, cell) {\n        let tiles = cell.tiles;\n        let actor = null;\n        let item = null;\n        if (cell.memory) {\n            tiles = cell.memory.tiles;\n            item = cell.memory.item;\n        }\n        else {\n            actor = cell.hasActor() ? cell.actor : null;\n            item = cell.hasItem() ? cell.item : null;\n        }\n        const ground = tiles[Flags.Depth.GROUND];\n        const surface = tiles[Flags.Depth.SURFACE];\n        const liquid = tiles[Flags.Depth.LIQUID];\n        const gas = tiles[Flags.Depth.GAS]; // How to get volume!?!?!?!\n        dest.drawSprite(ground.sprite);\n        if (surface) {\n            dest.drawSprite(surface.sprite);\n        }\n        if (liquid) {\n            dest.drawSprite(liquid.sprite);\n        }\n        if (item) {\n            item.drawInto(dest);\n        }\n        if (actor) {\n            actor.drawInto(dest);\n        }\n        if (gas) {\n            const opacity = GWU.rng.cosmetic.number(50) + 25;\n            dest.drawSprite(gas.sprite, opacity);\n        }\n        if (cell.hasFx()) {\n            const fx = map.fxAt(cell.x, cell.y);\n            if (fx)\n                dest.drawSprite(fx.sprite);\n        }\n        if (dest.dances) {\n            cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n            map.setMapFlag(Flags.Map.MAP_DANCES);\n        }\n        else {\n            cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n        }\n        dest.bake(true); // apply dancing\n    }\n    applyLight(dest, cell, fov) {\n        const isVisible = !fov || fov.isAnyKindOfVisible(cell.x, cell.y);\n        const isRevealed = !fov || fov.isRevealed(cell.x, cell.y);\n        const light = cell.map.light.getLight(cell.x, cell.y);\n        dest.multiply(light);\n        // TODO - is Clairy\n        // TODO - is Telepathy\n        if (fov && fov.isCursor(cell.x, cell.y)) {\n            dest.invert();\n        }\n        else if (!isVisible) {\n            if (isRevealed) {\n                dest.scale(70);\n            }\n            else {\n                dest.blackOut();\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport { Tile } from '../tile';\nimport * as Layer from '../layer';\nimport * as Effect from '../effect';\nimport { BasicDrawer } from '../draw/basic';\nexport class Map {\n    constructor(width, height, opts = {}) {\n        this.locations = {};\n        // _memory: GWU.grid.Grid<CellMemory>;\n        // machineCount = 0;\n        // _seed = 0;\n        this.rng = GWU.rng.random;\n        this.id = 0;\n        this.actors = [];\n        this.items = [];\n        this.fx = [];\n        this.player = null;\n        this._animations = [];\n        this.events = new GWU.events.EventEmitter();\n        this.flags = { map: 0 };\n        this.layers = [];\n        this.data = { seed: 0, machineCount: 0 };\n        if (opts.id) {\n            this.data.id = opts.id;\n        }\n        this.drawer = opts.drawer || new BasicDrawer();\n        this.cells = GWU.grid.make(width, height, (x, y) => new Cell(this, x, y));\n        // this._memory = GWU.grid.make(\n        //     width,\n        //     height,\n        //     (x, y) => new CellMemory(this, x, y)\n        // );\n        if (opts.seed) {\n            this.data.seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        if (opts.fov === undefined) {\n            opts.alwaysVisible = true;\n        }\n        else if (opts.fov === false) {\n            opts.visible = true;\n        }\n        opts.callback = this.onFovChange.bind(this);\n        this.fov = new GWU.fov.FovSystem(this, opts);\n        this.initLayers();\n        if (opts.player) {\n            this.setPlayer(opts.player);\n        }\n    }\n    get seed() {\n        return this.data.seed;\n    }\n    set seed(v) {\n        this.data.seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    get width() {\n        return this.cells.width;\n    }\n    get height() {\n        return this.cells.height;\n    }\n    // memory(x: number, y: number): CellMemory {\n    //     return this._memory[x][y];\n    // }\n    // knowledge(x: number, y: number): CellInfoType {\n    //     if (this.fov.isAnyKindOfVisible(x, y)) return this.cell(x,y);\n    //     return this._memory[x][y];\n    // }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n        this.addLayer(Flags.Depth.SURFACE, new Layer.FireLayer(this, 'surface'));\n        this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // items\n    hasItem(x, y) {\n        return this.cell(x, y).hasItem();\n    }\n    itemAt(x, y) {\n        return this.items.find((i) => i.isAt(x, y)) || null;\n    }\n    eachItem(cb) {\n        this.items.forEach(cb);\n    }\n    addItem(x, y, item, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        // if (!cell.canAddItem(item)) return false;\n        if (cell._addItem(item)) {\n            const index = this.items.indexOf(item);\n            if (index < 0) {\n                this.items.push(item);\n            }\n            item.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddItemEffects(item, cell);\n            }\n            if (index < 0) {\n                this.events.emit('item', this, item, true);\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddItemEffects(item, cell) {\n        if (item.key &&\n            item.key.matches(cell.x, cell.y) &&\n            cell.hasEffect('key')) {\n            cell.fireEvent('key', {\n                key: item,\n                item,\n            });\n        }\n        else if (cell.hasEffect('add_item')) {\n            cell.fireEvent('add_item', {\n                key: item,\n                item,\n            });\n        }\n    }\n    addItemNear(x, y, item, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasItem())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (item.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addItem(loc[0], loc[1], item, fireEffects);\n    }\n    removeItem(item, fireEffects = false) {\n        const cell = this.cell(item.x, item.y);\n        // if (!cell.canRemoveItem(item)) return false;\n        if (cell._removeItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, cell);\n            }\n            GWU.arrayDelete(this.items, item);\n            item.removeFromMap();\n            this.events.emit('item', this, item, false);\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveItemEffects(item, cell) {\n        if (item.isKey(cell.x, cell.y) && cell.hasEffect('no_key')) {\n            cell.fireEvent('no_key', {\n                key: item,\n                item,\n            });\n        }\n        else if (cell.hasEffect('remove_item')) {\n            cell.fireEvent('remove_item', {\n                key: item,\n                item,\n            });\n        }\n    }\n    moveItem(item, x, y, fireEffects = false) {\n        if (item.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this.cell(item.x, item.y);\n        const newCell = this.cell(x, y);\n        // if (!currentCell.canRemoveItem(item)) return false;\n        // if (!newCell.canAddItem(item)) return false;\n        currentCell._removeItem(item);\n        if (newCell._addItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, currentCell);\n                this._fireAddItemEffects(item, newCell);\n            }\n            item.addToMap(this, x, y);\n        }\n        return true;\n    }\n    //  moveItem(item: Item, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = item.x;\n    //     const oldY = item.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[item.depth] as Layer.ItemLayer;\n    //     if (!( layer.removeItem(item))) return false;\n    //     if (!( this.addItem(x, y, item))) {\n    //         layer.forceItem(item.x, item.y, item);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (item.lastSeen) {\n    //     //         this._memory[item.lastSeen.x][item.lastSeen.y].removeItem(item);\n    //     //         this.clearCellFlag(\n    //     //             item.lastSeen.x,\n    //     //             item.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         item.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.item = item;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     item.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    setPlayer(player) {\n        this.player = player;\n    }\n    actorAt(x, y) {\n        return this.actors.find((a) => a.isAt(x, y)) || null;\n    }\n    eachActor(cb) {\n        this.actors.forEach(cb);\n    }\n    addActor(x, y, actor, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (!cell.canAddActor(actor))\n            return false;\n        if (cell._addActor(actor)) {\n            const index = this.actors.indexOf(actor);\n            if (index < 0) {\n                this.actors.push(actor);\n            }\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddActorEffects(actor, cell);\n            }\n            if (index < 0) {\n                this.events.emit('actor', this, actor, true);\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddActorEffects(actor, cell) {\n        if (actor.isKey(cell.x, cell.y) && cell.hasEffect('key')) {\n            cell.fireEvent('key', {\n                key: actor,\n                actor,\n            });\n        }\n        else if (actor.isPlayer() && cell.hasEffect('add_player')) {\n            cell.fireEvent('add_player', {\n                player: actor,\n                actor,\n            });\n        }\n        else if (cell.hasEffect('add_actor')) {\n            cell.fireEvent('add_actor', {\n                actor,\n            });\n        }\n    }\n    addActorNear(x, y, actor, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasActor())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addActor(loc[0], loc[1], actor, fireEffects);\n    }\n    removeActor(actor, fireEffects = false) {\n        const cell = this.cell(actor.x, actor.y);\n        if (!cell.canRemoveActor(actor))\n            return false;\n        if (cell._removeActor(actor)) {\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, cell);\n            }\n            actor.removeFromMap();\n            GWU.arrayDelete(this.actors, actor);\n            this.events.emit('actor', this, actor, false);\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveActorEffects(actor, cell) {\n        if (actor.isKey(actor.x, actor.y) && cell.hasEffect('no_key')) {\n            cell.fireEvent('no_key', {\n                key: actor,\n                actor,\n            });\n        }\n        else if (actor.isPlayer() && cell.hasEffect('remove_player')) {\n            cell.fireEvent('remove_player', {\n                actor,\n                player: actor,\n            });\n        }\n        else if (cell.hasEffect('remove_actor')) {\n            cell.fireEvent('remove_actor', {\n                actor,\n            });\n        }\n    }\n    moveActor(actor, x, y, fireEffects = false) {\n        if (actor.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this.cell(actor.x, actor.y);\n        const newCell = this.cell(x, y);\n        // if (!currentCell.canRemoveActor(actor)) return false;\n        // if (!newCell.canAddActor(actor)) return false;\n        currentCell._removeActor(actor);\n        if (newCell._addActor(actor)) {\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, currentCell);\n                this._fireAddActorEffects(actor, newCell);\n            }\n        }\n        return true;\n    }\n    //  moveActor(actor: Actor, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = actor.x;\n    //     const oldY = actor.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[actor.depth] as Layer.ActorLayer;\n    //     if (!( layer.removeActor(actor))) return false;\n    //     if (!( layer.addActor(x, y, actor))) {\n    //         layer.forceActor(actor.x, actor.y, actor);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (actor.lastSeen) {\n    //     //         this._memory[actor.lastSeen.x][actor.lastSeen.y].removeActor(\n    //     //             actor\n    //     //         );\n    //     //         this.clearCellFlag(\n    //     //             actor.lastSeen.x,\n    //     //             actor.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         actor.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.actor = actor;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     actor.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    fxAt(x, y) {\n        return this.fx.find((i) => i.isAt(x, y)) || null;\n    }\n    eachFx(cb) {\n        this.fx.forEach(cb);\n    }\n    addFx(x, y, fx) {\n        const cell = this.get(x, y);\n        if (!cell)\n            return false;\n        fx.x = x;\n        fx.y = y;\n        cell._addFx(fx);\n        this.fx.push(fx);\n        this.events.emit('fx', this, fx, true);\n        return true;\n    }\n    moveFx(fx, x, y) {\n        const current = this.get(fx.x, fx.y);\n        const updated = this.get(x, y);\n        if (!updated)\n            return false;\n        current._removeFx(fx);\n        fx.x = x;\n        fx.y = y;\n        updated._addFx(fx);\n        return true;\n    }\n    removeFx(fx) {\n        const cell = this.get(fx.x, fx.y);\n        GWU.arrayDelete(this.fx, fx);\n        if (cell) {\n            cell._removeFx(fx);\n        }\n        this.events.emit('fx', this, fx, false);\n        return true;\n    }\n    // Information\n    // isVisible(x: number, y: number): boolean {\n    //     return this.fov.isAnyKindOfVisible(x, y);\n    // }\n    hasKey(x, y) {\n        const actor = this.actorAt(x, y);\n        if (actor && actor.isKey(x, y))\n            return true;\n        const item = this.itemAt(x, y);\n        if (item && item.isKey(x, y))\n            return true;\n        return false;\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        const getCh = (cell) => {\n            return cell.dump();\n        };\n        this.cells.dump(fmt || getCh, log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    get needsRedraw() {\n        return this.hasMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v)\n            this.setMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n        else\n            this.clearMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).hasCellFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    hasEntityFlag(x, y, flag) {\n        return this.cell(x, y).hasEntityFlag(flag);\n    }\n    hasTileFlag(x, y, flag) {\n        return this.cell(x, y).hasTileFlag(flag);\n    }\n    highlightPath(path, markCursor = true) {\n        this.clearPath();\n        path.forEach((loc) => {\n            this.setCellFlag(loc[0], loc[1], Flags.Cell.IS_HIGHLIGHTED);\n        });\n        if (markCursor && path[0]) {\n            const loc = path[0];\n            this.setCellFlag(loc[0], loc[1], Flags.Cell.IS_CURSOR);\n        }\n        this.needsRedraw = true;\n    }\n    highlightCell(x, y, markCursor = false) {\n        this.setCellFlag(x, y, markCursor ? Flags.Cell.IS_CURSOR : Flags.Cell.IS_HIGHLIGHTED);\n        this.needsRedraw = true;\n    }\n    clearPath() {\n        this.cells.forEach((c) => c.clearCellFlag(Flags.Cell.IS_CURSOR | Flags.Cell.IS_HIGHLIGHTED));\n        this.needsRedraw = true;\n    }\n    showCursor(x, y) {\n        this.clearCursor();\n        this.cell(x, y).setCellFlag(Flags.Cell.IS_CURSOR);\n        this.needsRedraw = true;\n    }\n    clearCursor() {\n        this.cells.forEach((c) => c.clearCellFlag(Flags.Cell.IS_CURSOR));\n        this.needsRedraw = true;\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        // this.fov.needsUpdate = true;\n        this.layers.forEach((l) => l.clear());\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cells[i][j];\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile\n    // useMemory = false\n    ) {\n        return this.cell(x, y).hasTile(tile);\n        // if (!useMemory) return this.cell(x, y).hasTile(tile);\n        // return this.memory(x, y).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof Tile)) {\n            const name = tile;\n            tile = TILE.get(name);\n            if (!tile)\n                throw new Error('Failed to find tile: ' + name);\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof Layer.TileLayer))\n            return false;\n        return layer.setTile(x, y, tile, opts);\n    }\n    clearTiles(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clearTiles(tile);\n    }\n    tick(dt) {\n        let didSomething = false;\n        this._animations.forEach((a) => {\n            didSomething = a.tick(dt) || didSomething;\n        });\n        this._animations = this._animations.filter((a) => a.isRunning());\n        didSomething = this.fireAll('tick') || didSomething;\n        for (let layer of this.layers) {\n            if (layer && layer.tick(dt)) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cell(x, y));\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.actors = src.actors.slice();\n        this.items = src.items.slice();\n        this.flags.map = src.flags.map;\n        // this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        this.data = Object.assign({}, src.data);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    fire(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.fireEvent(event, ctx);\n    }\n    fireAll(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        willFire.forEach((w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    cell.fireEvent(event, {\n                        force: true,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    activateMachine(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        cell.fireEvent('machine', ctx) || didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    // DRAW\n    drawInto(dest, opts) {\n        this.drawer.drawInto(dest, this, opts);\n    }\n    getAppearanceAt(x, y, dest) {\n        const cell = this.cell(x, y);\n        return this.drawer.drawCell(dest, this, cell);\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            // cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(cb) {\n        // TODO - Clairy, Telepathy, Detect, etc...\n        if (this.player) {\n            cb(this.player.x, this.player.y, this.player.visionDistance, GWU.fov.FovFlags.PLAYER);\n        }\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    // redrawCell(x: number, y: number): void {\n    //     // if (clearMemory) {\n    //     //     this.clearMemory(x, y);\n    //     // }\n    //     this.cell(x, y).needsRedraw = true;\n    // }\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        cell.storeMemory();\n        if (cell.hasActor() &&\n            cell.actor.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n    }\n    makeVisible(x, y) {\n        const cell = this.cell(x, y);\n        cell.clearMemory();\n        if (cell.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED |\n                Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n        else if (cell.hasActor() &&\n            !cell.actor.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n        else if (cell.hasItem() &&\n            !cell.item.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n    }\n    onFovChange(x, y, isVisible) {\n        if (!isVisible) {\n            this.storeMemory(x, y);\n        }\n        else {\n            this.makeVisible(x, y);\n        }\n    }\n    // Animator\n    addAnimation(a) {\n        this._animations.push(a);\n    }\n    removeAnimation(a) {\n        GWU.arrayDelete(this._animations, a);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount =\n                                                cellCount;\n                                            map.cell(i2, j2).flags.cell &=\n                                                ~Flags.Cell.IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        this.layerVersion = [];\n        this.lightVersion = 0;\n        // fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        // if (this.map.fov.changed) {\n        //     this.fovVersion = this.version;\n        //     this.map.fov.changed = false;\n        // }\n        // if (snap.version !== this.fovVersion) {\n        //     snap.map.fov.copy(this.map.fov);\n        // }\n        // layers\n        this.map.layers.forEach((layer, index) => {\n            const snapLayer = snap.map.layers[index];\n            if (layer.changed) {\n                this.layerVersion[index] = this.version;\n            }\n            if (this.layerVersion[index] !== snap.version) {\n                snapLayer.copy(layer);\n            }\n        });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        // if (snap.version < this.fovVersion || this.map.fov.changed) {\n        //     this.map.fov.copy(snap.map.fov);\n        //     this.fovVersion = snap.version;\n        // }\n        // layers\n        this.layerVersion.forEach((v, index) => {\n            if (v < snap.version)\n                return;\n            const destLayer = this.map.layers[index];\n            if (v > snap.version || destLayer.changed) {\n                const srcLayer = snap.map.layers[index];\n                destLayer.copy(srcLayer);\n                this.layerVersion[index] = snap.version;\n            }\n        });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function isHallway(map, x, y) {\n    return (GWU.xy.arcCount(x, y, (i, j) => {\n        return map.cell(i, j).isPassable();\n    }) > 1);\n}\nexport function replaceTile(map, find, replace) {\n    let count = 0;\n    map.eachCell((c) => {\n        if (!c.hasTile(find))\n            return;\n        if (c.setTile(replace)) {\n            ++count;\n        }\n    });\n    return count;\n}\nexport function getCellPathCost(map, x, y) {\n    const cell = map.cell(x, y);\n    if (cell.blocksMove())\n        return GWU.path.OBSTRUCTION;\n    if (cell.blocksPathing())\n        return GWU.path.FORBIDDEN;\n    if (cell.hasActor())\n        return 10;\n    return 1;\n}\nexport function fillCostMap(map, costMap) {\n    costMap.update((_v, x, y) => getCellPathCost(map, x, y));\n}\nexport function getPathBetween(map, x0, y0, x1, y1, options = {}) {\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = GWU.grid.alloc(map.width, map.height);\n    fillCostMap(map, costMap);\n    GWU.path.calculateDistances(distanceMap, x0, y0, costMap, options.eightWays, GWU.xy.straightDistanceBetween(x0, y0, x1, y1) + 1);\n    const path = GWU.path.getPath(distanceMap, x1, y1, (x, y) => map.cell(x, y).blocksMove(), options.eightWays);\n    GWU.grid.free(costMap);\n    GWU.grid.free(distanceMap);\n    return path;\n}\n","import { Map } from './map';\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile === undefined) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === undefined) {\n        opts.boundary = 'WALL';\n    }\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n        map.light.update();\n    }\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    // // In case we reveal the map or make it all visible we need our memory set correctly\n    // map.cells.forEach((_c, x, y) => {\n    //     if (map.fov.isRevealed(x, y)) {\n    //         map.storeMemory(x, y, true); // with snapshot\n    //     }\n    // });\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Horde as Flags } from '../flags/horde';\nimport * as Map from '../map';\nimport * as Actor from '../actor';\nexport class Horde {\n    // requiredTile: string | null = null;\n    constructor(config) {\n        this.tags = [];\n        this.members = {};\n        // blueprintId: string | null = null;\n        this.flags = { horde: 0 };\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        this.leader = config.leader;\n        if (config.members) {\n            Object.entries(config.members).forEach(([id, range]) => {\n                this.members[id] = GWU.range.make(range);\n            });\n        }\n        this.frequency = GWU.frequency.make(config.frequency || 100);\n        // this.blueprintId = config.blueprintId || null;\n        this.flags.horde = GWU.flag.from(Flags, config.flags);\n        // if (config.requiredTile) this.requiredTile = config.requiredTile;\n    }\n    spawn(map, x = -1, y = -1, opts = {}) {\n        var _a;\n        opts.canSpawn = opts.canSpawn || GWU.TRUE;\n        opts.rng = opts.rng || map.rng;\n        opts.machine = (_a = opts.machine) !== null && _a !== void 0 ? _a : 0;\n        const leader = this._spawnLeader(map, x, y, opts);\n        if (!leader)\n            return null;\n        this._spawnMembers(leader, map, opts);\n        return leader;\n    }\n    _spawnLeader(map, x, y, opts) {\n        const leaderKind = Actor.get(this.leader);\n        if (!leaderKind) {\n            throw new Error('Failed to find leader kind = ' + this.leader);\n        }\n        if (x >= 0 && y >= 0) {\n            if (leaderKind.avoidsCell(map.cell(x, y)))\n                return null;\n        }\n        const leader = Actor.make(leaderKind, { machineHome: opts.machine });\n        if (!leader)\n            throw new Error('Failed to make horde leader - ' + this.leader);\n        if (x < 0 || y < 0) {\n            [x, y] = this._pickLeaderLoc(leader, map, opts) || [-1, -1];\n            if (x < 0 || y < 0) {\n                return null;\n            }\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addLeader(leader, map, x, y, opts)) {\n            return null;\n        }\n        return leader;\n    }\n    _addLeader(leader, map, x, y, _opts) {\n        return map.addActor(x, y, leader);\n    }\n    _addMember(member, map, x, y, leader, _opts) {\n        member.leader = leader;\n        return map.addActor(x, y, member);\n    }\n    _spawnMembers(leader, map, opts) {\n        const entries = Object.entries(this.members);\n        if (entries.length == 0)\n            return 0;\n        let count = 0;\n        entries.forEach(([kindId, countRange]) => {\n            const count = countRange.value(opts.rng);\n            for (let i = 0; i < count; ++i) {\n                this._spawnMember(kindId, map, leader, opts);\n            }\n        });\n        return count;\n    }\n    _spawnMember(kindId, map, leader, opts) {\n        const kind = Actor.get(kindId);\n        if (!kind) {\n            throw new Error('Failed to find member kind = ' + kindId);\n        }\n        const member = Actor.make(kind, { machineHome: opts.machine });\n        if (!member)\n            throw new Error('Failed to make horde member - ' + kindId);\n        const [x, y] = this._pickMemberLoc(member, map, leader, opts) || [\n            -1, -1,\n        ];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addMember(member, map, x, y, leader, opts)) {\n            return null;\n        }\n        return member;\n    }\n    _pickLeaderLoc(leader, map, opts) {\n        let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            if (!opts.canSpawn(x, y))\n                return false;\n            if (leader.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n    _pickMemberLoc(actor, map, leader, opts) {\n        let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Horde } from './horde';\nimport { Horde as Flags } from '../flags/horde';\nexport const hordes = {};\nexport function install(id, horde) {\n    if (typeof horde === 'string') {\n        horde = { leader: horde };\n    }\n    if (!(horde instanceof Horde)) {\n        horde = new Horde(horde);\n    }\n    hordes[id] = horde;\n    return horde;\n}\nexport function installAll(hordes) {\n    Object.entries(hordes).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function from(id) {\n    if (id instanceof Horde) {\n        return id;\n    }\n    if (typeof id === 'string') {\n        return hordes[id];\n    }\n    return new Horde(id);\n}\nexport function random(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n        flags: 0,\n        forbidFlags: 0,\n        depth: 0,\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    const rng = opts.rng || GWU.rng.random;\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    if (opts.flags) {\n        if (typeof opts.flags === 'string') {\n            opts.flags\n                .split(/[,|]/)\n                .map((t) => t.trim())\n                .forEach((flag) => {\n                if (flag.startsWith('!')) {\n                    const key = flag.substring(1);\n                    match.forbidFlags |= Flags[key];\n                }\n                else {\n                    match.flags |= Flags[flag];\n                }\n            });\n        }\n    }\n    if (opts.forbidFlags) {\n        match.forbidFlags = GWU.flag.from(Flags, opts.forbidFlags);\n    }\n    if (opts.depth) {\n        match.depth = opts.depth;\n    }\n    if (match.depth && opts.oodChance) {\n        while (rng.chance(opts.oodChance)) {\n            match.depth += 1;\n        }\n        match.forbidFlags |= Flags.HORDE_NEVER_OOD;\n    }\n    const matches = Object.values(hordes).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        if (match.flags && !(k.flags.horde & match.flags)) {\n            return false;\n        }\n        if (match.forbidFlags && k.flags.horde & match.forbidFlags) {\n            return false;\n        }\n        return true;\n    });\n    if (match.depth) {\n        return rng.item(matches) || null;\n    }\n    const depth = match.depth;\n    const weights = matches.map((h) => h.frequency(depth));\n    const index = rng.weighted(weights);\n    if (index < 0)\n        return null;\n    return matches[index];\n}\n","export const actions = {};\nexport function installCommand(name, fn) {\n    actions[name] = fn;\n}\nexport function getCommand(name) {\n    return actions[name];\n}\n","import { installCommand } from './command';\nimport * as Actor from '../actor';\n// COMMANDS\n// this === GAME\nexport async function moveDir(actor, e) {\n    const dir = e.dir;\n    if (!actor.map || !dir)\n        return -1;\n    return Actor.actions.moveDir(this, actor, e);\n}\ninstallCommand('moveDir', moveDir);\n","import * as GWU from 'gw-utils';\nimport { installCommand } from './command';\nexport async function pickup(actor, _ev) {\n    if (!actor.map)\n        return -1;\n    const playerAction = actor.getAction('pickup');\n    if (!playerAction) {\n        GWU.message.addAt(actor.x, actor.y, 'You cannot pickup items.');\n        return actor.endTurn();\n    }\n    else {\n        // You have to do everything\n        const result = await playerAction(this, actor);\n        if (result)\n            return result; // handled\n    }\n    // Should never get here, but...\n    const standStill = actor.getAction('standStill');\n    if (!standStill)\n        throw new Error('Actor cannot stand still.');\n    return standStill(this, actor);\n}\ninstallCommand('pickup', pickup);\n","// export * from './memory';\n// export * from './system';\nexport const empty = {};\n","/*\n    Attributes\n    ========================\n\n    To configure attributes, set the defaults:\n\n    Attribute.install(')\n\n    const attr = new Attributes(10);\n\n    attr.set('str', 10);\n    attr.set('dex', 10);\n    ...\n    attr.set('chr', 10);\n\n    // to get the current value\n    attr.get('str');\n\n    // To raise an attribute permanently\n    attr.gain('chr', 1);\n\n    // To raise an attribute temporarily\n    attr.gain('chr', 1, false);\n\n    // To lower an attribute permanently\n    attr.drain('chr', 1, true);\n\n    // to lower an attribute temporarily\n    attr.drain('chr', 1);\n\n    // to restore (remove) all temporary changes\n    attr.restore();\n\n    // to add a temporary change that can be removed by itself\n    attr.addBonus('str', 1);\n\n    // to remove the bonus\n    attr.clearBonus('str', 1);\n\n    // adjustments (bonuses) are also possible via:\n    attr.adjust('str', { bonus: 1 });\n\n    // But adjustments can also set the\n    attr.adjust('str', { fixed: 14 });      // temporarily sets base\n    attr.adjust('str', { base: 21 });       // resets the base\n    attr.adjust('str', { restore: true });  // removes all bonuses/penalties\n    attr.adjust('str', { min: 10 });        // limits value\n    attr.adjust('str', { max: 30 });        // limits value\n    attr.adjust('str', { sustain: true });  // turns off lowering values\n*/\nexport class Attributes {\n    constructor(baseValues) {\n        this._base = {};\n        this._max = {};\n        this._bonus = {};\n        this._sustain = {};\n        this._value = {};\n        this.changed = null;\n        this.init(baseValues);\n    }\n    init(baseValues) {\n        for (let k in attributes) {\n            const v = typeof baseValues === 'number' ? baseValues : attributes[k];\n            this.set(k, v);\n        }\n        if (typeof baseValues !== 'number') {\n            for (let k in baseValues) {\n                this.set(k, baseValues[k]);\n            }\n        }\n    }\n    forEach(fn) {\n        Object.keys(attributes).forEach((k) => fn(this.get(k)));\n    }\n    // modifier(name: string) {\n    //     return Math.floor((this.get(name) - 10) / 2);\n    // }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    set(name, value = 0) {\n        this._value[name] = value;\n        this._base[name] = value;\n        this._max[name] = value;\n        this._bonus[name] = [];\n        return value;\n    }\n    base(name) {\n        return this._base[name] || 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    sustain(name) {\n        return this._sustain[name] || false;\n    }\n    gain(name, delta, raiseMax = true) {\n        if (delta < 0 && this._sustain[name])\n            return 0;\n        this._base[name] += delta;\n        if (raiseMax && this._base[name] > this._max[name]) {\n            this._max[name] = this._base[name];\n        }\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    drain(name, loss, lowerMax = false) {\n        if (loss < 0)\n            loss = -loss;\n        const changed = this.gain(name, -loss, false);\n        if (changed && lowerMax) {\n            this._max[name] = this._base[name];\n        }\n        return changed;\n    }\n    restore(name) {\n        this._base[name] = this._max[name];\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    addBonus(name, bonus) {\n        return this._addBonus(name, { bonus });\n    }\n    _addBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        if (this._value[name] === undefined) {\n            this.set(name, 0);\n        }\n        this._bonus[name].push(bonus);\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    clearBonus(name, bonus) {\n        return this._clearBonus(name, { bonus });\n    }\n    _clearBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        let arr = this._bonus[name] || [];\n        let key = JSON.stringify(bonus);\n        let index = arr.findIndex((o) => {\n            return JSON.stringify(o) == key;\n        });\n        if (index > -1) {\n            arr.splice(index, 1);\n            let old = this.get(name);\n            return this._calcValue(name) - old;\n        }\n        return 0;\n    }\n    _calcValue(name) {\n        let allAdjustments = {};\n        this._bonus[name].forEach((adj) => this._applyAdjustment(allAdjustments, adj));\n        this._sustain[name] = allAdjustments.sustain || false;\n        let value = this._base[name] || 0;\n        if (allAdjustments.fixed !== undefined) {\n            value = allAdjustments.fixed;\n        }\n        else {\n            value += allAdjustments.bonus || 0;\n            if (allAdjustments.min !== undefined) {\n                value = Math.max(allAdjustments.min, value);\n            }\n            if (allAdjustments.max !== undefined) {\n                value = Math.min(allAdjustments.max, value);\n            }\n        }\n        return (this._value[name] = value);\n    }\n    adjust(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.gain(name, adj.base);\n        }\n        else if (adj.restore) {\n            delta = this.restore(name);\n            if (delta == 0)\n                delta = undefined;\n        }\n        else {\n            delta = this._addBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    clearAdjustment(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.drain(name, adj.base, true);\n        }\n        else if (adj.restore) {\n            // do nothing...\n        }\n        else {\n            delta = this._clearBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    _applyAdjustment(total, opts) {\n        if (opts.bonus) {\n            total.bonus = (total.bonus || 0) + opts.bonus;\n        }\n        if (opts.fixed !== undefined) {\n            total.fixed = Math.max(total.fixed || 0, opts.fixed);\n        }\n        if (opts.min !== undefined) {\n            total.min = Math.max(total.min || 0, opts.min);\n        }\n        if (opts.max !== undefined) {\n            total.max = Math.max(total.max || 0, opts.max);\n        }\n        if (opts.sustain !== undefined) {\n            total.sustain = opts.sustain;\n        }\n    }\n}\nexport const attributes = {};\nexport function installAttribute(attr) {\n    if (typeof attr === 'string') {\n        attributes[attr] = 0;\n        return;\n    }\n    // clear existing\n    Object.keys(attributes).forEach((k) => {\n        delete attributes[k];\n    });\n    Object.assign(attributes, attr);\n}\nexport function makeAttributes(defaults) {\n    return new Attributes(defaults);\n}\n/*\nfunction adjust(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = undefined;\n        if (a.base) {\n            delta = being.attributes.addBase(a.name, a.base);\n        } else if (a.restore) {\n            delta = being.attributes.restoreBase(a.name);\n            if (delta == 0) delta = undefined;\n        } else {\n            delta = being.attributes.addBonus(a.name, a);\n        }\n        if (delta !== undefined) {\n            out[a.name] = delta;\n        }\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n\n    return results;\n};\n\n function clearAdjustment(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = 0;\n        delta += being.attributes.clearBonus(a.name, a);\n\n        out[a.name] = delta;\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n    return results;\n};\n\nRUT.Attribute.rollAttributes = function (opts = {}) {\n    let dice = [];\n    let total = 0;\n\n    if (RUT.Calc.isValue(opts)) opts = { value: opts };\n    Object.defaults(opts, RUT.Config.Attribute.rollAttributes);\n\n    let attributes = RUT.Config.Attributes;\n\n    let min_average = Math.max(opts.min_average - 5, 0);\n    let max_average = Math.min(opts.max_average - 5, RUT.Config.ATTRIBUTE_MAX);\n\n    let min_total = min_average * attributes.length;\n    let max_total = max_average * attributes.length;\n\n    do {\n        total = 0;\n        dice = [];\n        for (let i = 0; i < 18; ++i) {\n            dice.push(RUT.RNG.rollDie(3 + (i % 3)));\n            total += dice[i];\n        }\n    } while (total <= min_total || total > max_total);\n\n    let values = attributes.reduce((out, name, i) => {\n        let index = 3 * i;\n        let value = 5 + dice[index] + dice[index + 1] + dice[index + 2];\n        if (opts.value) {\n            value = RUT.Calc.calc(opts.value);\n        } else if (opts[name]) {\n            value = RUT.Calc.calc(opts[name]);\n        }\n        out[name] = value;\n        return out;\n    }, {});\n    return values;\n};\nRUT.Config.Attribute.rollAttributes = { min_average: 11, max_average: 14 };\n*/\n/*\nexport function normalize_adjustment(args: ) {\n    if (args.length == 3) {\n        let opts = args[2];\n        if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        let name = `${args[0]}.${args[1]}`;\n        return [Object.assign({ name }, opts)];\n    }\n    if (args.length == 2) {\n        let opts = args[1];\n        if (opts === true || opts === false) {\n            opts = { has: opts };\n        } else if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        return [Object.assign({ name: args[0] }, opts)];\n    }\n\n    let opts = args[0];\n    if (opts.name) {\n        return [opts];\n    }\n    if (opts.attribute) {\n        opts.name = opts.attribute;\n        return [opts];\n    }\n    if (opts.restore) {\n        if (opts.restore == 'all') {\n            return RUT.Attributes.map((a) => {\n                return { name: a, restore: true };\n            });\n        }\n        return [{ name: opts.restore, restore: true }];\n    }\n    if (opts.skill) {\n        opts.name = opts.skill;\n        return [opts];\n    }\n    if (opts.stat) {\n        opts.name = opts.stat;\n        return [opts];\n    }\n    if (opts.save) {\n        opts.name = opts.save;\n        return [opts];\n    }\n    // if (opts.saves) {\n    //   opts.name = opts.saves;\n    //   return [opts];\n    // }\n    if (opts.ability) {\n        opts.name = opts.ability;\n        return [opts];\n    }\n\n    // now we assume that each key is for a separate skill...\n    return Object.keys(opts).reduce((out, key) => {\n        let opt = opts[key];\n        if (key == 'reset' || key == 'restore') {\n            if (typeof opt == 'string') opt = [opt];\n            opt.forEach((a) => {\n                out.push({ name: a, restore: true });\n            });\n        } else {\n            if (typeof opt == 'number' || Array.isArray(opt)) {\n                opt = { bonus: opt };\n            } else if (opt === true || opt === false) {\n                opt = { has: opt };\n            } else if (opt == 'reset' || opt == 'restore') {\n                opt = { restore: true };\n            } else if (opt == 'sustain') {\n                opt = { sustain: true };\n            }\n            out.push(Object.assign({ name: key }, opt));\n        }\n        return out;\n    }, []);\n}\n*/\n","/*\nSkills\n\nSkills generally fall into 2 categories - binary and progressive.\n\n\n// Create a skills object\nconst skills = new Skills();\n\n// set skills\nskills.set('diving', true); // = { has: true, level: 0 }\nskills.set('diving', 10); // = { has: true, level: 10 }\n\nskills.remove('diving'); // {}\n\n// adjustments\nskills.adjust('diving', { bonus: 1 });\nskills.adjust('diving', { disadvantage: true });\nskills.adjust('diving', { advantage: 3 });\nskills.adjust('diving', { fixed: 10 });\nskills.adjust('diving', { critical: 5 });\n\n\n\n\n\n*/\nclass Skill {\n    constructor(name) {\n        this.name = name;\n    }\n    get has() {\n        return this._bool('_has');\n    }\n    get level() {\n        return this._int('_level');\n    }\n    get disadvantage() {\n        return this._bool('_disadvantage');\n    }\n    get advantage() {\n        return this._bool('_advantage');\n    }\n    get fixed() {\n        return this._int('_fixed');\n    }\n    get bonus() {\n        const b = this._int('_bonus') || 0;\n        if (!this._parent)\n            return b;\n        return b + this._parent.bonus;\n    }\n    get succeed() {\n        return this._bool('_succeed');\n    }\n    get fail() {\n        return this._bool('_fail');\n    }\n    set(value) {\n        if (value === false) {\n            this._has = false;\n            this._level = 0;\n        }\n        else {\n            this._has = true;\n            this._level = value === true ? 0 : value;\n        }\n    }\n    _value(name) {\n        if (this[name] !== undefined) {\n            // @ts-ignore\n            return this[name];\n        }\n        if (this._parent) {\n            // @ts-ignore\n            return this._parent._value(name);\n        }\n        return undefined;\n    }\n    _bool(name) {\n        return !!this._value(name);\n    }\n    _int(name) {\n        return this._value(name);\n    }\n    adjust(adj) {\n        Object.entries(adj).forEach(([key, value]) => {\n            key = '_' + key;\n            if (value === undefined)\n                return;\n            if (key === '_fixed') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = Math.max(value, this._fixed || 0);\n            }\n            else if (key === '_bonus') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = value + (this._bonus || 0);\n            }\n            // @ts-ignore\n            this[key] = value;\n        });\n    }\n    clear(adj) {\n        Object.keys(adj).forEach((key) => {\n            key = '_' + key;\n            // @ts-ignore\n            if (this[key] !== undefined) {\n                // @ts-ignore\n                this[key] = undefined;\n            }\n        });\n    }\n}\nexport class Skills {\n    constructor(vals = {}) {\n        this._skills = {};\n        Object.entries(vals).forEach(([key, value]) => {\n            this.set(key, value);\n        });\n    }\n    set(name, value) {\n        const s = this.get(name);\n        s.set(value);\n        return s;\n    }\n    get(name) {\n        let s = this._skills[name];\n        if (s)\n            return s;\n        s = this._skills[name] = new Skill(name);\n        const index = name.lastIndexOf('.');\n        if (index > 0) {\n            s._parent = this.get(name.substring(0, index));\n        }\n        else {\n            s.set(false);\n        }\n        return s;\n    }\n    adjust(name, adj) {\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        let s = this.get(name);\n        s.adjust(adj);\n        return s;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Scent {\n    constructor(player) {\n        this._player = player;\n    }\n    get(x, y) {\n        if (!this._data)\n            return 0;\n        return this._data[x][y];\n    }\n    clear() {\n        if (!this._player.map)\n            return;\n        if (this._data)\n            GWU.grid.free(this._data);\n        this._data = GWU.grid.alloc(this._player.map.width, this._player.map.height);\n    }\n    update() {\n        if (!this._player.map)\n            return;\n        const scent = this._player.data.scent || 10;\n        this._data[this._player.x][this._player.y] = scent;\n        const updated = GWU.grid.alloc(this._data.width, this._data.height);\n        const map = this._player.map;\n        this._data.forEach((v, x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.blocksMove())\n                return;\n            let highest = v;\n            GWU.xy.eachNeighbor(x, y, (x1, y1) => {\n                if (!this._data.hasXY(x1, y1))\n                    return;\n                const v1 = this._data[x1][y1];\n                if (v1 > highest) {\n                    highest = v1;\n                }\n            }, true);\n            const delta = cell.hasLiquid() ? 3 : 1;\n            updated[x][y] = Math.max(0, highest - delta);\n        });\n        GWU.grid.free(this._data);\n        this._data = updated;\n    }\n    nextDir(x, y) {\n        const v = this._data[x][y] || 0;\n        if (!v)\n            return null;\n        let highest = v;\n        let highestLoc = [];\n        GWU.xy.eachNeighbor(x, y, (x1, y1) => {\n            if (!this._data.hasXY(x1, y1))\n                return;\n            const v1 = this._data[x1][y1];\n            if (v1 == highest) {\n                highestLoc.push([x1, y1]);\n            }\n            else if (v1 > highest) {\n                highestLoc = [[x1, y1]];\n                highest = v1;\n            }\n        }, false);\n        if (!highestLoc.length)\n            return null;\n        const loc = GWU.random.item(highestLoc);\n        loc[0] = loc[0] - x;\n        loc[1] = loc[1] - y;\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Actor } from '../actor';\nimport { Scent } from './scent';\nimport * as Flags from '../flags';\nexport class Player extends Actor {\n    constructor(kind) {\n        super(kind);\n        this.scent = new Scent(this);\n    }\n    interrupt(other) {\n        if (this.hasGoal()) {\n            this.clearGoal();\n            GWU.message.addAt(this.x, this.y, '{{you}} {{verb see~}} {{a other}}.', {\n                actor: this,\n                verb: 'see',\n                other,\n            });\n        }\n    }\n    endTurn(pct = 100) {\n        if (this.map) {\n            if (this.map.fov.update()) {\n                this.clearActorFlag(Flags.Actor.STABLE_COST_MAP);\n            }\n            this.scent.update();\n        }\n        return super.endTurn(pct);\n    }\n    addToMap(map, x, y) {\n        if (!super.addToMap(map, x, y))\n            return false;\n        this.scent.clear();\n        return true;\n    }\n    setGoal(x, y) {\n        const map = this._map;\n        if (!map)\n            throw new Error('No map to set goal with!');\n        if (!this._goalMap) {\n            this._goalMap = GWU.grid.alloc(map.width, map.height);\n        }\n        const goalMap = this._goalMap;\n        const mapToPlayer = this.mapToMe();\n        if (mapToPlayer[x][y] < 0 ||\n            mapToPlayer[x][y] >= GWU.path.NO_PATH ||\n            !map.fov.isRevealed(x, y)) {\n            let loc = GWU.path.getClosestValidLocation(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y));\n            loc = loc || [this.x, this.y];\n            x = loc[0];\n            y = loc[1];\n        }\n        GWU.path.calculateDistances(goalMap, x, y, this.costMap());\n        return this._goalMap;\n    }\n    nextGoalStep() {\n        const map = this.map;\n        if (!map)\n            return null;\n        const goalMap = this.goalMap;\n        const step = GWU.path.nextStep(goalMap, this.x, this.y, (x, y) => map.hasActor(x, y) && map.actorAt(x, y) !== this);\n        return step;\n    }\n    pathTo(...args) {\n        let x = args[0];\n        let y = args[1];\n        if (args.length === 1) {\n            x = args[0].x;\n            y = args[0].y;\n        }\n        const map = this.map;\n        if (!map)\n            return null;\n        const mapToPlayer = this.mapToMe();\n        if (mapToPlayer[x][y] < 0 ||\n            mapToPlayer[x][y] >= GWU.path.NO_PATH ||\n            !map.fov.isRevealed(x, y)) {\n            const loc = GWU.path.getClosestValidLocation(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y));\n            if (!loc)\n                return null;\n            x = loc[0];\n            y = loc[1];\n        }\n        const path = GWU.path.getPath(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y), true);\n        return path;\n    }\n}\nPlayer.default = {\n    ch: '@',\n    fg: 'white',\n    name: 'You',\n    swim: true,\n    sidebarFg: 'purple',\n};\n","import * as GWU from 'gw-utils';\nimport * as Actor from '../actor';\nimport * as Skills from './skill';\nimport * as Attributes from './attribute';\nimport { Player } from './player';\nimport * as Flags from '../flags';\nexport class PlayerKind extends Actor.ActorKind {\n    constructor(opts = {}) {\n        super((() => {\n            if (!opts.sprite) {\n                opts.ch = opts.ch || Player.default.ch;\n                opts.fg = opts.fg || Player.default.fg;\n            }\n            if (!opts.name) {\n                opts.name = Player.default.name;\n            }\n            if (opts.swim === undefined) {\n                opts.swim = Player.default.swim;\n            }\n            return opts;\n        })());\n        this.flags.actor |= Flags.Actor.IS_PLAYER;\n        this.flags.entity |= Flags.Entity.L_ALWAYS_PLURAL;\n        this.attributes = new Attributes.Attributes(opts.attributes || {});\n        this.skills = new Skills.Skills(opts.skills || {});\n    }\n    make(options) {\n        const actor = new Player(this);\n        this.init(actor, options);\n        return actor;\n    }\n    cellCost(cell, player) {\n        const map = cell.map;\n        if (!map.fov.isRevealed(cell.x, cell.y))\n            return GWU.path.FORBIDDEN;\n        return super.cellCost(cell, player);\n    }\n}\n","import { PlayerKind } from './kind';\nimport * as Actor from '../actor';\nexport function make(id, makeOptions) {\n    let kind;\n    if (typeof id === 'string') {\n        // @ts-ignore\n        kind = Actor.get(id);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + id);\n        if (!(kind instanceof PlayerKind))\n            throw new Error('Not a player kind.');\n    }\n    else if (id instanceof PlayerKind) {\n        kind = id;\n    }\n    else {\n        kind = makeKind(id);\n    }\n    return kind.make(makeOptions);\n}\nexport function install(id, kind) {\n    if (kind instanceof PlayerKind) {\n        Actor.kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    Actor.kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof PlayerKind)\n        return id;\n    const k = Actor.kinds[id];\n    if (k && !(k instanceof PlayerKind)) {\n        throw new Error('No a player kind.');\n    }\n    return k;\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new PlayerKind(config);\n}\n","import * as GWU from 'gw-utils';\nimport { Player } from '../player/player';\nimport * as Flags from '../flags';\nexport class Viewport {\n    constructor(opts) {\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this._subject = null;\n        this.player = null;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.snap = opts.snap || false;\n        this.center = opts.center || false;\n        this.filter = opts.filter || null;\n        this.lockX = opts.lock || opts.lockX || false;\n        this.lockY = opts.lock || opts.lockY || false;\n        this.scent = opts.scent || false;\n    }\n    contains(xy) {\n        return this.bounds.contains(xy);\n    }\n    get subject() {\n        return this._subject;\n    }\n    set subject(subject) {\n        this.center = !!subject;\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n        }\n        this._subject = subject;\n        if (subject && subject instanceof Player) {\n            this.player = subject;\n        }\n        else {\n            this.player = null;\n        }\n    }\n    set lock(v) {\n        this.lockX = v;\n        this.lockY = v;\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(map, x, y) {\n        this.center = true;\n        this.subject = { x, y, map };\n    }\n    showMap(map, x = 0, y = 0) {\n        this.subject = { x, y, map };\n        this.offsetX = x;\n        this.offsetY = y;\n        this.center = false;\n        this.snap = false;\n    }\n    updateOffset() {\n        if (!this._subject) {\n            this.offsetX = 0;\n            this.offsetY = 0;\n            return;\n        }\n        const subject = this._subject;\n        const map = subject.map;\n        const bounds = map;\n        if (subject && map.hasXY(subject.x, subject.y)) {\n            if (this.snap) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (subject.x < left || subject.x > right) {\n                    left = this.offsetX = subject.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (subject.y < top || subject.y > bottom) {\n                    top = this.offsetY = subject.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= subject.x) {\n                    this.offsetX = Math.max(0, subject.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= subject.x) {\n                    this.offsetX = Math.min(subject.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= subject.y) {\n                    this.offsetY = Math.max(0, subject.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= subject.y) {\n                    this.offsetY = Math.min(subject.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this.center) {\n                this.offsetX = subject.x - this.halfWidth();\n                this.offsetY = subject.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = subject.x;\n                this.offsetY = subject.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    draw(buffer) {\n        if (!this._subject)\n            return false;\n        const map = this._subject.map;\n        if (!map || !map.needsRedraw)\n            return false;\n        const fov = map.fov;\n        buffer.blackOutRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, this.bg);\n        if (!this._subject) {\n            return false;\n        }\n        this.updateOffset();\n        const drawer = map.drawer;\n        drawer.scent = this.scent;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, map, cell, fov);\n                }\n                else {\n                    mixer.draw(' ', this.bg, this.bg); // blackOut\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n    tick(_dt) {\n        if (!this._subject)\n            return false;\n        const map = this._subject.map;\n        if (!map)\n            return false;\n        if (!map.hasMapFlag(Flags.Map.MAP_DANCES) || !GWU.cosmetic.chance(10)) {\n            return false;\n        }\n        map.eachCell((c) => {\n            if (c.hasCellFlag(Flags.Cell.COLORS_DANCE) &&\n                map.fov.isAnyKindOfVisible(c.x, c.y) &&\n                GWU.cosmetic.chance(2)) {\n                c.needsRedraw = true;\n            }\n        });\n        map.needsRedraw = true;\n        return true;\n    }\n    mousemove(ev) {\n        if (!this.bounds.contains(ev.x, ev.y)) {\n            this.clearPath();\n            return false;\n        }\n        if (!this.player)\n            return false;\n        const map = this.player.map;\n        if (!map)\n            return false;\n        return this.showPath(this.toInnerX(ev.x), this.toInnerY(ev.y));\n    }\n    click(ev) {\n        if (!this.bounds.contains(ev.x, ev.y))\n            return false;\n        if (!this.player)\n            return false;\n        if (this.player.hasGoal()) {\n            this.player.clearGoal();\n        }\n        else {\n            this.player.setGoal(this.toInnerX(ev.x), this.toInnerY(ev.y));\n        }\n        return true;\n    }\n    clearPath() {\n        if (!this.player)\n            return;\n        const map = this.player.map;\n        if (!map)\n            return;\n        map.clearPath();\n    }\n    showPath(x, y) {\n        if (!this.player)\n            return false;\n        const map = this.player.map;\n        if (!map)\n            return false;\n        // if (!this.player.hasGoal()) return false;\n        // console.log('mouse', ev.x, ev.y);\n        const path = this.player.pathTo(x, y);\n        if (path) {\n            map.highlightPath(path, true);\n        }\n        else {\n            map.clearPath();\n        }\n        map.highlightCell(x, y);\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        this.needsDraw = true;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'darkest_gray');\n        this.fg = GWU.color.from(opts.fg || 'white');\n        if (!this.bounds.height)\n            throw new Error('Must provde a height for messages widget.');\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: opts.archive || 40,\n            match: () => {\n                this.needsDraw = true;\n            },\n        });\n    }\n    contains(xy) {\n        return this.bounds.contains(xy);\n    }\n    clear() {\n        this.cache.clear();\n        this.needsDraw = true;\n    }\n    click(e, game) {\n        if (!this.bounds.contains(e))\n            return false;\n        return this.showArchive(game);\n    }\n    confirmAll() {\n        this.cache.confirmAll();\n        this.needsDraw = true;\n    }\n    draw(buffer) {\n        if (!this.needsDraw)\n            return false;\n        this.needsDraw = false;\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.bg, this.bg);\n        this.cache.forEach((line, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = localY + this.bounds.y;\n            buffer.drawText(this.bounds.x, y, line, this.fg);\n            if (confirmed && this.bg) {\n                buffer.mix(this.bg, 50, this.bounds.x, y, this.bounds.width, 1);\n            }\n        });\n        return true;\n    }\n    showArchive(game) {\n        if (this.cache.length <= this.bounds.height)\n            return false;\n        return showArchive(this, game).then(() => this.confirmAll());\n    }\n}\nexport class MessageArchive extends GWU.widget.Widget {\n    constructor(layer, source) {\n        super(layer, {\n            id: 'ARCHIVE',\n            tag: 'messages',\n            height: source.bounds.height,\n            width: source.bounds.width,\n            bg: source.bg,\n            x: 0,\n            y: 0,\n            tabStop: true,\n            depth: 100, // I'm on top\n        });\n        this.mode = 'forward';\n        this._timeout = null;\n        this.source = source;\n        this.isOnTop = this.source.bounds.y < 10;\n        this.bounds.height = this.isOnTop\n            ? layer.height - source.bounds.y\n            : source.bounds.bottom;\n        this.totalCount = Math.min(source.cache.length, this.isOnTop\n            ? layer.height - this.source.bounds.top\n            : this.source.bounds.bottom);\n        this.shown = source.bounds.height;\n        this._timeout = this.layer.setTimeout(() => this._forward(), 16);\n        // confirm them as they are right now...\n        this.source.cache.confirmAll();\n    }\n    contains() {\n        return true; // Eat all mouse activity\n    }\n    finish() {\n        this.layer.finish();\n    }\n    keypress(e) {\n        return this.click(e);\n    }\n    click(_e) {\n        if (this.mode === 'ack') {\n            this.mode = 'reverse';\n            this.layer.needsDraw = true;\n            if (this._timeout) {\n                this.layer.clearTimeout(this._timeout);\n            }\n            this._timeout = this.layer.setTimeout(() => this._reverse(), 16);\n        }\n        else if (this.mode === 'reverse') {\n            this.finish();\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n            if (this._timeout) {\n                this.layer.clearTimeout(this._timeout);\n                this._timeout = null;\n            }\n            this.layer.needsDraw = true;\n        }\n        return true;\n    }\n    _forward() {\n        // console.log('forward');\n        ++this.shown;\n        this._timeout = null;\n        this.layer.needsDraw = true;\n        if (this.shown < this.totalCount) {\n            this._timeout = this.layer.setTimeout(() => this._forward(), 16);\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n        }\n        return true;\n    }\n    _reverse() {\n        // console.log('reverse');\n        --this.shown;\n        this._timeout = null;\n        if (this.shown <= this.source.bounds.height) {\n            this.finish();\n        }\n        else {\n            this.layer.needsDraw = true;\n            this._timeout = this.layer.setTimeout(() => this._reverse(), 16);\n        }\n        return true;\n    }\n    _draw(buffer) {\n        let fadePercent = 0;\n        // let reverse = this.mode === 'reverse';\n        // Count the number of lines in the archive.\n        // let totalMessageCount = this.totalCount;\n        const isOnTop = this.isOnTop;\n        const dbuf = buffer;\n        const fg = GWU.color.from(this.source.fg);\n        // const dM = reverse ? -1 : 1;\n        // const startM = reverse ? totalMessageCount : this.bounds.height;\n        // const endM = reverse\n        //     ? this.bounds.height + dM + 1\n        //     : totalMessageCount + dM;\n        const startY = isOnTop\n            ? this.shown - 1\n            : this.bounds.bottom - this.shown;\n        const endY = isOnTop ? 0 : this.bounds.bottom - 1;\n        const dy = isOnTop ? -1 : 1;\n        dbuf.fillRect(this.source.bounds.x, Math.min(startY, endY), this.bounds.width, this.shown, ' ', this._used.bg, this._used.bg);\n        this.source.cache.forEach((line, _confirmed, j) => {\n            const y = startY + j * dy;\n            if (isOnTop) {\n                if (y < endY)\n                    return;\n            }\n            else if (y > endY)\n                return;\n            fadePercent = Math.floor((50 * j) / this.shown);\n            const fgColor = fg.mix(this._used.bg, fadePercent);\n            dbuf.drawText(this.source.bounds.x, y, line, fgColor, this._used.bg);\n        });\n        if (this.mode === 'ack') {\n            const y = this.isOnTop ? 0 : dbuf.height - 1;\n            const x = this.source.bounds.x > 8\n                ? this.source.bounds.x - 8 // to left of box\n                : Math.min(this.source.bounds.x + this.bounds.width, // just to right of box\n                dbuf.width - 8 // But definitely on the screen - overwrite some text if necessary\n                );\n            dbuf.wrapText(x, y, 8, '--DONE--', this._used.bg, this._used.fg);\n        }\n        return true;\n    }\n}\nexport async function showArchive(widget, game) {\n    const layer = new GWU.widget.WidgetLayer(game.ui);\n    // @ts-ignore\n    const w = new MessageArchive(layer, widget);\n    await layer.run();\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as Tile from '../tile/tile';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor {\n    constructor(opts) {\n        this.needsDraw = true;\n        this.text = '';\n        this.fg = GWU.color.from(opts.fg || 'purple');\n        this.bg = GWU.color.from(opts.bg || 'darkest_gray');\n        this.promptFg = GWU.color.from(opts.promptFg || 'gold');\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, 1);\n        this.overflow = opts.overflow || false;\n        this.isPrompt = false;\n    }\n    showText(text) {\n        this.text = text;\n        this.isPrompt = false;\n        this.needsDraw = true;\n        return this;\n    }\n    clear() {\n        this.text = '';\n        this.isPrompt = false;\n        this.needsDraw = true;\n        return this;\n    }\n    showPrompt(text) {\n        this.text = text;\n        this.isPrompt = true;\n        this.needsDraw = true;\n        return this;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'You see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'You sense';\n        }\n        else if (isRemembered) {\n            intro = 'You remember seeing';\n        }\n        else if (isMapped) {\n            intro = 'You expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(Flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(Flags.Depth.GROUND) || Tile.NULL;\n        const surfaceTile = cell.depthTile(Flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(Flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(Flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('{{intro}} {{text}}.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n    draw(buffer) {\n        if (!this.needsDraw)\n            return false;\n        this.needsDraw = false;\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, 1, ' ', this.bg, this.bg);\n        buffer.drawText(this.bounds.x, this.bounds.y, this.text, this.fg, this.bg, this.bounds.width, 'left');\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\n// import { UISubject } from './viewport';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.sidebarY = -1;\n    }\n    draw(_buffer, _bounds) {\n        return 0;\n    }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    get changed() {\n        return this.actor.changed;\n    }\n    draw(buffer, bounds) {\n        return this.actor.drawSidebar(buffer, bounds);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    get changed() {\n        return this.item.changed;\n    }\n    draw(buffer, bounds) {\n        return this.item.drawSidebar(buffer, bounds);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.changed = true;\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(buffer, bounds) {\n        return this.cell.drawSidebar(buffer, bounds);\n    }\n}\nexport class Sidebar {\n    constructor(opts) {\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.subject = null;\n        this.highlight = null;\n        this.needsDraw = true;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'darkest_gray');\n    }\n    contains(xy) {\n        return this.bounds.contains(xy);\n    }\n    reset() {\n        this.lastMap = null;\n        this.lastX = -1;\n        this.lastY = -1;\n        this.needsDraw = true;\n    }\n    entryAt(e) {\n        return (this.entries.find((entry) => {\n            return entry.sidebarY <= e.y && entry.sidebarY !== -1;\n        }) || null);\n    }\n    click(ev) {\n        if (!this.bounds.contains(ev.x, ev.y))\n            return false;\n        if (!this.highlight)\n            return false;\n        if (!this.subject)\n            return false;\n        this.subject.setGoal(this.highlight.x, this.highlight.y);\n        return true;\n    }\n    mousemove(e) {\n        if (this.contains(e)) {\n            this._highlightRow(e.y);\n            return true;\n        }\n        this.clearHighlight();\n        return false;\n    }\n    highlightAt(x, y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.x == x && e.y == y) {\n                this.highlight = e;\n            }\n        });\n        const changed = this.highlight !== last;\n        this.needsDraw || (this.needsDraw = changed);\n        return changed;\n    }\n    _highlightRow(y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        const changed = this.highlight !== last;\n        this.needsDraw || (this.needsDraw = changed);\n        if (this.highlight && this.subject && this.subject.map) {\n            const path = this.subject.pathTo(\n            // @ts-ignore\n            this.highlight.x, \n            // @ts-ignore\n            this.highlight.y);\n            if (path) {\n                this.subject.map.highlightPath(path, true);\n            }\n            else {\n                // @ts-ignore\n                this.subject.map.showCursor(this.highlight.x, this.highlight.y);\n            }\n            // @ts-ignore\n            this.subject.map.highlightCell(this.highlight.x, this.highlight.y);\n        }\n        return changed;\n    }\n    clearHighlight() {\n        const result = !!this.highlight;\n        this.highlight = null;\n        this.needsDraw || (this.needsDraw = result);\n        return result;\n    }\n    _updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return false;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        this.needsDraw = true;\n        return true;\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(Flags.Cell.STABLE_MEMORY) ? 3 : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            return 3;\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        return entry.priority > 2 || !!this.highlight;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0 || priority === 3)\n            return false;\n        if (actor.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR))\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        if (item.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR))\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _updateEntryCache(map, cx, cy, fov) {\n        if (map === this.lastMap &&\n            cx === this.lastX &&\n            cy === this.lastY &&\n            !map.hasMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED |\n                Flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            let anyChanged = this.entries.some((e) => e.changed);\n            if (!anyChanged)\n                return false;\n        }\n        map.clearMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        const highlightX = this.highlight ? this.highlight.x : -1;\n        const highlightY = this.highlight ? this.highlight.y : -1;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (!done[x][y] && this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n                a.setEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n            else {\n                a.clearEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (!done[x][y] && this._addItemEntry(i, map, cx, cy, fov)) {\n                i.setEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n                done[x][y] = 1;\n            }\n            else {\n                i.clearEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        if (highlightX > -1) {\n            this.highlightAt(highlightX, highlightY);\n        }\n        GWU.grid.free(done);\n        return true;\n    }\n    update() {\n        if (!this.subject) {\n            return false;\n        }\n        return this.updateFor(this.subject);\n    }\n    updateFor(subject) {\n        if (!subject.map)\n            return false;\n        return this.updateAt(subject.map, subject.x, subject.y, subject.map.fov);\n    }\n    updateAt(map, cx, cy, fov) {\n        let changed = this._updateCellCache(map);\n        if (this._updateEntryCache(map, cx, cy, fov)) {\n            changed = true;\n        }\n        return changed;\n    }\n    draw(buffer) {\n        var _a;\n        const map = (_a = this.subject) === null || _a === void 0 ? void 0 : _a.map;\n        if (!map)\n            return false;\n        if (this.update()) {\n            this.needsDraw = true;\n        }\n        if (!this.needsDraw)\n            return false;\n        this.needsDraw = false;\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, 0, 0, this.bg);\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        const drawBounds = this.bounds.clone();\n        let currentEntry;\n        for (let i = 0; i < this.entries.length && drawBounds.height > 0; ++i) {\n            currentEntry = this.entries[i];\n            currentEntry.sidebarY = drawBounds.y;\n            let usedLines = currentEntry.draw(buffer, drawBounds);\n            if (this._isDim(currentEntry)) {\n                buffer.mix(this.bg, 50, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            else if (this.highlight === currentEntry) {\n                buffer.mix('white', 20, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            if (usedLines) {\n                ++usedLines; // skip a space\n                drawBounds.y += usedLines;\n                drawBounds.height -= usedLines;\n            }\n        }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Command from '../command';\nimport * as Actor from '../actor';\nimport * as Viewport from './viewport';\nimport * as Message from './message';\nimport * as Flavor from './flavor';\nimport * as Sidebar from './sidebar';\nexport class Game {\n    constructor(opts) {\n        this.result = undefined;\n        this.mouse = false;\n        this.fov = false;\n        this.scent = false;\n        this.running = false;\n        this.keymap = {};\n        this.ui = opts.ui || new GWU.ui.UI(opts);\n        if (!opts.makeMap || !opts.makePlayer) {\n            throw new Error('Need funcitons for makeMap and makePlayer');\n        }\n        this._start = opts.start || GWU.NOOP;\n        this._makeMap = opts.makeMap;\n        this._makePlayer = opts.makePlayer;\n        this._startMap = opts.startMap || GWU.NOOP;\n        if (opts.keymap) {\n            Object.assign(this.keymap, opts.keymap);\n        }\n        if (opts.mouse) {\n            this.mouse = true;\n        }\n        if (typeof opts.messages === 'number') {\n            opts.messages = { size: opts.messages };\n        }\n        if (opts.flavor === true) {\n            opts.flavor = {};\n        }\n        else if (opts.flavor === false) {\n            delete opts.flavor;\n        }\n        opts.viewport = opts.viewport || {};\n        const _opts = opts;\n        _opts.viewport.x = 0;\n        _opts.viewport.y = 0;\n        _opts.viewport.width = this.ui.width;\n        _opts.viewport.height = this.ui.height;\n        this._initMenu(_opts);\n        if (opts.sidebar)\n            this._initSidebar(_opts);\n        if (opts.messages)\n            this._initMessages(_opts);\n        if (opts.flavor)\n            this._initFlavor(_opts);\n        this._initViewport(_opts);\n    }\n    get width() {\n        return this.viewport.bounds.width;\n    }\n    get height() {\n        return this.viewport.bounds.height;\n    }\n    _initMenu(_opts) { }\n    _initSidebar(opts) {\n        if (typeof opts.sidebar === 'number') {\n            opts.sidebar = { width: opts.sidebar };\n        }\n        else if (opts.sidebar === true) {\n            opts.sidebar = {};\n        }\n        const sideOpts = opts.sidebar;\n        sideOpts.width = sideOpts.width || -20; // on right side\n        const viewInit = opts.viewport;\n        if (sideOpts.width < 0) {\n            sideOpts.width *= -1;\n            sideOpts.x = viewInit.x + viewInit.width - sideOpts.width;\n            sideOpts.y = viewInit.y;\n            sideOpts.height = viewInit.height;\n            viewInit.width -= sideOpts.width;\n        }\n        else {\n            sideOpts.x = 0;\n            sideOpts.height = viewInit.height;\n            sideOpts.y = viewInit.y;\n            viewInit.x = sideOpts.width;\n            viewInit.width -= sideOpts.width;\n        }\n        this.sidebar = new Sidebar.Sidebar(sideOpts);\n    }\n    _initMessages(opts) {\n        if (opts.messages === false)\n            return;\n        if (opts.messages === true) {\n            opts.messages = { size: -4 };\n        }\n        const messOpts = opts.messages || { size: -4 };\n        messOpts.size = messOpts.size || messOpts.y || -4;\n        if (messOpts.size < 0) {\n            // bottom\n            const viewInit = opts.viewport;\n            messOpts.x = viewInit.x;\n            messOpts.y = this.ui.height + messOpts.size; // length < 0\n            messOpts.width = viewInit.width;\n            messOpts.height = -messOpts.size;\n            opts.viewport.height -= messOpts.height;\n        }\n        else {\n            // top\n            const viewInit = opts.viewport;\n            messOpts.x = viewInit.x;\n            messOpts.y = viewInit.y;\n            messOpts.width = viewInit.width;\n            messOpts.height = messOpts.size;\n            viewInit.y += messOpts.size;\n            viewInit.height -= messOpts.size;\n        }\n        this.messages = new Message.Messages(messOpts);\n    }\n    _initFlavor(opts) {\n        const flavOpts = opts.flavor || {};\n        const viewOpts = opts.viewport;\n        if (viewOpts.y === 0) {\n            // messages must be on bottom (or not there)\n            flavOpts.x = viewOpts.x;\n            flavOpts.y = viewOpts.height - 1;\n            flavOpts.width = viewOpts.width;\n            viewOpts.height -= 1;\n        }\n        else {\n            // messages on top\n            flavOpts.x = viewOpts.x;\n            flavOpts.y = viewOpts.y;\n            flavOpts.width = viewOpts.width;\n            viewOpts.y += 1;\n            viewOpts.height -= 1;\n        }\n        this.flavor = new Flavor.Flavor(flavOpts);\n    }\n    _initViewport(opts) {\n        const viewOpts = opts.viewport || {};\n        const viewInit = viewOpts;\n        viewInit.lock = true;\n        this.viewport = new Viewport.Viewport(viewInit);\n    }\n    async start() {\n        this.layer = new GWU.ui.Layer(this.ui);\n        this.buffer = this.layer.buffer;\n        this.io = this.layer.io;\n        this.running = true;\n        this.scheduler = new GWU.scheduler.Scheduler();\n        if (this.messages)\n            this.messages.clear();\n        this.player = this._makePlayer.call(this);\n        this.viewport.subject = this.player;\n        if (this.sidebar)\n            this.sidebar.subject = this.player;\n        this._start.call(this);\n        this.startNewMap(0);\n        this.scheduler.push(this.player, 0);\n        while (this.running) {\n            await this.animate();\n            await this.runTurn();\n        }\n        return this.result;\n    }\n    startNewMap(id, _location = 'start') {\n        this.scheduler.clear();\n        this.map = this._makeMap.call(this, id);\n        this.map.setPlayer(this.player);\n        this.map.id = id;\n        this._startMap.call(this, this.map, this.player);\n        // make sure player is on map\n        if (this.player.map !== this.map) {\n            // if not, add them (where?)\n            const loc = this.map.locations.start || [0, 0]; // Is top left fallback any good?\n            this.map.addActorNear(loc[0], loc[1], this.player);\n        }\n        if (this.scent) {\n            this.map.drawer.scent = this.scent;\n        }\n        this.map.actors.forEach((a) => {\n            if (!a.isPlayer()) {\n                this.scheduler.push(a, a.moveSpeed());\n            }\n        });\n        this.map.fov.update();\n        this.draw();\n    }\n    draw() {\n        this.viewport.draw(this.buffer);\n        if (this.messages)\n            this.messages.draw(this.buffer);\n        if (this.flavor)\n            this.flavor.draw(this.buffer);\n        if (this.sidebar)\n            this.sidebar.draw(this.buffer);\n        if (this.buffer.changed) {\n            this.buffer.render();\n        }\n        this.buffer.changed = false;\n        this.map.actors.forEach((a) => (a.changed = false));\n        this.map.items.forEach((i) => (i.changed = false));\n    }\n    finish(result) {\n        this.running = false;\n        this.layer.finish();\n        this.result = result;\n    }\n    async runTurn() {\n        const actor = this.scheduler.pop();\n        if (!actor) {\n            this.finish();\n            return;\n        }\n        let nextTime = 0;\n        while (nextTime === 0) {\n            if (actor === this.player) {\n                nextTime = await this.playerTurn(actor);\n            }\n            else if ('act' in actor) {\n                nextTime = await actor.act(this);\n            }\n            else if ('tick' in actor) {\n                nextTime = await actor.tick(); // dt === 100 -- TODO\n            }\n            this.draw();\n        }\n        if (nextTime >= 0) {\n            this.scheduler.push(actor, nextTime);\n        }\n    }\n    async animate() {\n        if (!this.io._tweens.length)\n            return;\n        const timer = setInterval(() => {\n            const tick = GWU.io.makeTickEvent(16);\n            this.io.enqueue(tick);\n        }, 16);\n        this.io.clearEvents();\n        while (this.io._tweens.length) {\n            const ev = await this.io.nextTick();\n            if (ev && ev.dt) {\n                this.io._tweens.forEach((a) => a && a.tick(ev.dt));\n                this.io._tweens = this.io._tweens.filter((a) => a && a.isRunning());\n            }\n            this.draw();\n        }\n        clearInterval(timer);\n    }\n    async playerTurn(player) {\n        let done = 0;\n        const timer = setInterval(() => {\n            const tick = GWU.io.makeTickEvent(16);\n            // console.log('-tick', Date.now());\n            this.io.enqueue(tick);\n        }, 16);\n        let elapsed = 0;\n        while (!done && this.running) {\n            const ev = await this.io.nextEvent(-1);\n            if (ev) {\n                if (ev.type === GWU.io.KEYPRESS) {\n                    this.map.clearPath();\n                    if (this.player.hasGoal()) {\n                        this.player.clearGoal();\n                    }\n                    else {\n                        const handler = GWU.io.handlerFor(ev, this.keymap);\n                        if (handler) {\n                            if (typeof handler === 'string') {\n                                const action = Command.getCommand(handler);\n                                if (action) {\n                                    done = await action.call(this, player, ev);\n                                }\n                                else {\n                                    const action = this.player.getAction(handler);\n                                    if (action) {\n                                        done = await action(this, this.player);\n                                    }\n                                }\n                            }\n                            else if (typeof handler === 'function') {\n                                done = await handler.call(this, player, ev);\n                            }\n                        }\n                    }\n                }\n                else if (ev.type === GWU.io.TICK) {\n                    this.layer.tick(ev); // timeouts\n                    elapsed += ev.dt || 16;\n                    if (this.viewport.tick(ev.dt)) {\n                        this.draw();\n                    }\n                    // console.log('-- event', elapsed);\n                }\n                else if (this.mouse && ev.type === GWU.io.MOUSEMOVE) {\n                    if (this.viewport.mousemove(ev)) {\n                        const x = this.viewport.toInnerX(ev.x);\n                        const y = this.viewport.toInnerY(ev.y);\n                        if (this.flavor) {\n                            const text = this.flavor.getFlavorText(this.map, x, y, this.map.fov);\n                            this.flavor.showText(text);\n                        }\n                        if (this.sidebar) {\n                            this.sidebar.highlightAt(x, y);\n                        }\n                        this.draw();\n                    }\n                    else if (this.sidebar && this.sidebar.mousemove(ev)) {\n                        this.draw();\n                    }\n                }\n                else if (this.mouse && ev.type === GWU.io.CLICK) {\n                    // console.log('click', ev.x, ev.y);\n                    if (this.viewport.contains(ev)) {\n                        this.viewport.click(ev);\n                    }\n                    else if (this.messages && this.messages.contains(ev)) {\n                        await this.messages.showArchive(this);\n                    }\n                    else if (this.sidebar && this.sidebar.contains(ev)) {\n                        await this.sidebar.click(ev);\n                    }\n                }\n            }\n            if (elapsed < 50) {\n                continue;\n            }\n            elapsed -= 50;\n            if (this.player.hasGoal()) {\n                const step = this.player.nextGoalStep();\n                if (!step) {\n                    this.player.clearGoal();\n                }\n                else {\n                    const action = Actor.getAction('moveDir');\n                    if (!action)\n                        throw new Error('Failed to find moveDir action.');\n                    done = await action(this, this.player, { dir: step });\n                    if (done && this.player.hasGoal()) {\n                        const goalMap = this.player.goalMap;\n                        this.viewport.showPath(goalMap.x, goalMap.y);\n                    }\n                }\n            }\n        }\n        clearInterval(timer);\n        return done;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Tile from './tile';\nimport '../effect/handlers';\nimport '../effect/types';\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([30, 30, 30]).rand(20, 0, 0, 0),\n    bg: GWU.color.from([2, 2, 10]).rand(0, 2, 2, 0),\n    priority: 10,\n    article: 'the',\n    flavor: 'the stone floor',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: 'TILE:DOOR_OPEN',\n        open: 'TILE:DOOR_OPEN_ALWAYS',\n    },\n    flavor: 'a closed door',\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            effects: 'TILE:DOOR~!',\n        },\n        enter: null,\n        open: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('UP_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, T_LIST_IN_SIDEBAR',\n    name: 'upward stairs',\n    article: 'an',\n    effects: {\n        player: 'EMIT:UP_STAIRS',\n    },\n    flavor: 'stairs leading upwards',\n});\nTile.install('DOWN_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, T_LIST_IN_SIDEBAR',\n    name: 'downward stairs',\n    article: 'a',\n    effects: {\n        player: 'EMIT:DOWN_STAIRS',\n    },\n    flavor: 'downward leading stairs',\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'a very hard wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: GWU.color.from([25, 28, 60]).dance(20, 0, 4, 15),\n    bg: GWU.color.from([10, 15, 41]).dance(20, 5, 5, 5),\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n    flavor: 'some deep water',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([5, 8, 10]).dance(10, 0, 4, 15),\n    bg: GWU.color.from([10, 30, 30]).dance(6, 0, 10, 10),\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    flags: 'T_SHALLOW_WATER',\n    // depth: 'LIQUID', // 'SURFACE'?\n    flavor: 'some shallow water',\n});\nTile.install('BRIDGE', {\n    ch: '\\u2630',\n    fg: [80, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n    flavor: 'a bridge',\n});\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","T_IS_DEEP_LIQUID","T_SHALLOW_WATER","TileMech","Cell","NEEDS_REDRAW","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_SAFE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Horde","KeyInfo","[object Object]","x","y","disposable","this","lastId","kind","_map","key","machineHome","changed","depth","light","flags","entity","next","id","map","Flags.Entity","L_ALWAYS_PLURAL","setEntityFlag","L_ON_MAP","addToMap","clearEntityFlag","removeFromMap","sprite","isDestroyed","hasEntityFlag","L_DESTROYED","other","constructor","copy","Object","assign","canBeSeen","tag","tags","includes","matches","cell","forbidsCell","avoidsCell","opts","getName","getDescription","getFlavor","verb","getVerb","buffer","bounds","drawSidebar","dest","_observer","drawSprite","default","sidebarFg","EntityKind","config","requireTileFlags","forbidTileFlags","avoidTileFlags","requireTileTags","forbidTileTags","avoidTileTags","name","flavor","description","make","split","t","trim","slice","from","Flags.Tile","color","init","_entity","hasAllTileFlags","hasTileFlag","T_BRIDGE","length","hasAllTileTags","hasAnyTileTag","_opts","mixer","Mixer","getAppearanceAt","wrapText","width","makeOpts","installedActions","installAction","fn","toLowerCase","getAction","Status","_set","_time","_count","_done","_value","clearTime","clearCount","setOff","_update","done","count","Math","max","_addDone","value","range","current","delta","status","cleared","noticed","removeTime","rec","was","doneFn","Stats","_max","_rate","round","get","set","v","amount","allowOver","min","raiseValue","gain","lowerValue","drain","turns","r","elapsed","undefined","type","c","Error","Entity.Entity","super","ai","leader","items","visionDistance","data","_costMap","_goalMap","_mapToMe","actor","Flags.Depth","ACTOR","stats","grid","free","hasActorFlag","Flags.Actor","IS_PLAYER","action","actions","bump","IS_VISIBLE","WAS_VISIBLE","canSee","isAbleToSee","isPlayer","fov","isDirectlyVisible","xy","distanceBetween","forLineBetween","i","j","blocksVision","canSeeOrSense","isAbleToSense","isAnyKindOfVisible","game","startedVisible","player","setActorFlag","console","log","clearActorFlag","becameVisible","interrupt","endTurn","moveSpeed","pct","L_NO_SIDEBAR","L_IN_SIDEBAR","setMapFlag","Flags.Map","MAP_SIDEBAR_CHANGED","floor","_other","_item","item","pickupItem","dropItem","mapChanged","STABLE_COST_MAP","staleMap","alloc","height","update","_v","cellCost","goalMap","path","calculateDistances","costMap","handlers","installHandler","handler","effectTypes","installType","startsWith","endPos","indexOf","tile","substring","effects","Array","isArray","effect","entries","forEach","JSON","stringify","typeName","shift","makeFn","e","push","parts","installedEffects","trigger","bind","install","obj","clone","_a","_b","_c","_d","index","dissipate","priority","groundTile","article","tileMech","hasEffect","T_IS_FLAMMABLE","arraysIntersect","every","blocksMove","T_PATHING_BLOCKER","NULL","hasAllEntityFlags","T_IS_DOOR","L_BLOCKS_EVERYTHING","isNull","isWall","arg","result","fg","toString","options","_e","_f","base","extends","tiles","text","replace","search","Number","parseInt","makeEffect","message","Flags.TileMech","ch","bg","opacity","all","args","BasicEffect","chance","seen","Flags.Effect","endsWith","parseFloat","loc","ctx","force","rng","random","didSomething","eff","nextAlways","E_NEXT_ALWAYS","makeBasicEffect","makeSpreadEffect","SpreadEffect","grow","decrement","matchTile","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","spawnMap","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","E_NEXT_EVERYWHERE","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","isStairs","first","floodFill","cellIsOk","isStart","hasXY","hasCellFlag","Flags.Cell","EVENT_PROTECTED","blocksEffects","E_BUILD_IN_WALLS","E_MUST_TOUCH_WALLS","ok","eachNeighbor","E_NO_TOUCH_WALLS","hasTile","dir","x2","y2","madeChange","startProb","probDec","fill","DIRS","clearAll","clear","clearDepth","GAS","LIQUID","SURFACE","GROUND","blockingMap","eachActor","a","matchingLocNear","removeActor","addActor","eachItem","removeItem","addItem","makeEmitHandler","emitEffect","events","emit","makeMessageHandler","src","info","msg","messageEffect","aware","addAt","makeActivateMachine","activateMachine","machine","machineId","makeTileHandler","superpriority","blockedByActors","blockedByItems","tileEffect","setTile","makeClearHandler","layers","reduce","out","ALL_LAYERS","clearEffect","_ctx","makeFeatureHandler","featureEffect","feat","Effect.installedEffects","makeNourishEffect","nourishEffect","actorAt","adjust","n","pukeMsg","makeStatEffect","stat","statEffect","values","NEVER_SEEN","TILE.NULL","chokeCount","memory","TILE.tiles","snapshot","makeMixer","TILE.get","hasStableSnapshot","STABLE_SNAPSHOT","hasStableMemory","setCellFlag","hasItem","hasActor","clearCellFlag","needsRedraw","getSnapshot","checkEntities","some","entityFlags","tileFlags","tileMechFlags","hasTag","hasAllTags","hasAnyTag","withEntities","CHANGED","TILE.Tile","highestPriorityTile","cb","find","blocksPathing","TILE.flags","T_BLOCKS_OTHER_LAYERS","L_SECRETLY_PASSABLE","T_ANY_LIQUID","blocksLayer","blockedByOtherLayers","highestPriority","currentGround","depthTile","wantGround","glowLightChanged","T_LIST_IN_SIDEBAR","MAP_SIDEBAR_TILES_CHANGED","CAUGHT_FIRE_THIS_TURN","blackOut","tileFlag","tileMechFlag","hasTileMechFlag","event","ev","_activate","itemAt","hasItems","foundIndex","_actor","actors","HAS_FX","fx","fxAt","_fx","quantity","ITEM","isPlural","messageYou","view","field","messageThe","target","messageA","L_FORMAL_NAME","char","firstChar","exec","messageVerb","_name","plural","toPluralVerb","toSingularVerb","addHelper","PainMessages","msgs","_msgs","m","add","singular","clamp","_format","painMessages","ais","AICtx","distanceMap","async","typical","isDead","willAttack","damagePct","getPct","morale","chargeChance","retreatChance","lastSawPlayer","clearGoal","start","canAttack","attack","tooFarFrom","canMoveToward","moveToward","tooCloseTo","canMoveAwayFrom","moveAwayFrom","hasGoal","setGoal","moveTowardGoal","scent","nextDir","moveDir","wanderOpt","object","firstOpt","matchingLoc","NO_PATH","step","nextStep","canPass","wander","idle","standStill","center","_game","_target","distanceFromTo","safetyMap","costGrid","FORBIDDEN","eachCell","AVOIDED","rescan","ActorKind","Entity.EntityKind","DEFAULT","DEFAULT_ACTOR","vision","normal","health","AI.make","waterOnly","lavaOnly","swim","fly","list","remove","OBSTRUCTION","OK","drawText","makeOptions","makeKind","kinds","randomKind","match","forbidTags","filter","k","bumpActions","getBumpActions","selfName","selfAction","ctx2","flashSprite","duration","animator","Entity.make","addFx","tween","visible","to","repeat","repeatDelay","onUpdate","removeFx","io","loop","addAnimation","hit","fadeInOut","yoyo","onFinish","moveSprite","source","ceil","maxAxisFromTo","speed","isLoc","vals","stepFn","stopBeforeWalls","moveFx","stop","isInShape","shape","cx","cy","allowCenter","sx","abs","sy","dirFromTo","fade","stopAtWalls","line","forLineFromTo","promises","lastIndex","Promise","radius","checkExplosionOpts","FOV","isBlocked","calculate","x1","y1","minX","minY","maxX","maxY","_obj","success","newX","newY","currentCell","newCell","try","FX.hit","canRemoveActor","canAddActor","moveActor","rate","dirIndex","number","pickup","quiet","avoidsItem","itemAction","canAddItem","climb","startNewMap","pain","made","ItemKind","Flags.Item","isDoor","MapLayer","properties","_x","_y","_tile","_dt","TileLayer","GasLayer","volume","startingVolume","spread","d","clearTile","total","highestVolume","startingTile","highestTile","updateCellVolume","ObjectFlags","TileFlags","TileMechFlags","CellFlags","FireLayer","exposeToFire","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","Effect.from","fire","TM_EXPLOSIVE_PROMOTE","x0","y0","fireEvent","highlightColor","BasicDrawer","Buffer","offsetX","offsetY","clearMapFlag","MAP_DANCES","drawCell","needSnapshot","getAppearance","putSnapshot","COLORS_DANCE","applyLight","separate","L_VISUALLY_DISTINCT","IS_CURSOR","inverse","IS_HIGHLIGHTED","mix","s","colors","red","ground","surface","liquid","gas","drawInto","cosmetic","hasFx","dances","bake","isVisible","isRevealed","getLight","multiply","isCursor","invert","scale","locations","_animations","EventEmitter","seed","machineCount","drawer","cells","LightSystem","alwaysVisible","callback","onFovChange","FovSystem","initLayers","setPlayer","addLayer","Layer.TileLayer","Layer.FireLayer","Layer.GasLayer","layer","isAt","fireEffects","_addItem","_fireAddItemEffects","_removeItem","_fireRemoveItemEffects","arrayDelete","isKey","hasPlayer","_addActor","_fireAddActorEffects","_removeActor","_fireRemoveActorEffects","_addFx","updated","_removeFx","fmt","dump","hasMapFlag","MAP_NEEDS_REDRAW","markCursor","clearPath","clearCursor","l","boundary","isBoundaryXY","clearTiles","dt","tick","isRunning","fireAll","willFire","EVENT_FIRED_THIS_TURN","promoteChance","w","originX","originY","eachGlowLight","_cb","FovFlags","PLAYER","isDark","storeMemory","clearMemory","makeVisible","updateChokepoints","updateCounts","passMap","passableArcCount","oldX","CLOCK_DIRS","oldY","cellCount","floodFillCount","i2","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","up","left","designationSurvives","Snapshot","version","isHallway","arcCount","isPassable","getCellPathCost","fillCostMap","h","updateChokeCounts","layerVersion","lightVersion","cellVersion","snap","srcCell","snapLayer","destCell","destLayer","srcLayer","eightWays","straightDistanceBetween","getPath","prefab","charToTile","isStringArray","len","members","horde","frequency","Flags","canSpawn","TRUE","_spawnLeader","_spawnMembers","leaderKind","Actor.get","Actor.make","_pickLeaderLoc","_addLeader","member","kindId","countRange","_spawnMember","_pickMemberLoc","_addMember","Map.isHallway","hordes","forbidFlags","oodChance","HORDE_NEVER_OOD","weights","weighted","installCommand","getCommand","Actor.actions.moveDir","_ev","playerAction","Attributes","baseValues","_base","_bonus","_sustain","attributes","keys","raiseMax","old","_calcValue","loss","lowerMax","bonus","_addBonus","_clearBonus","arr","findIndex","o","splice","allAdjustments","adj","_applyAdjustment","sustain","fixed","restore","Skill","has","_bool","level","_int","disadvantage","advantage","b","_parent","succeed","fail","_has","_level","_fixed","Skills","_skills","lastIndexOf","Scent","_player","_data","highest","v1","hasLiquid","highestLoc","Player","mapToPlayer","mapToMe","getClosestValidLocation","PlayerKind","Actor.ActorKind","Attributes.Attributes","skills","Skills.Skills","attr","defaults","Actor.kinds","Viewport","_subject","Bounds","lockX","lock","lockY","contains","subject","halfWidth","halfHeight","right","top","bottom","edgeX","edgeY","thirdW","thirdH","blackOutRect","updateOffset","mapX","mapY","draw","showPath","toInnerX","toInnerY","pathTo","highlightPath","highlightCell","Messages","needsDraw","cache","MessageCache","archive","showArchive","confirmAll","isOnTop","fillRect","confirmed","then","MessageArchive","widget","Widget","tabStop","mode","_timeout","totalCount","shown","setTimeout","_forward","finish","click","clearTimeout","_reverse","fadePercent","dbuf","endY","dy","_used","_confirmed","fgColor","WidgetLayer","ui","run","Flavor","promptFg","overflow","isPrompt","buf","isRemembered","isMapped","isMagicMapped","intro","theItem","standsInTile","T_STAND_IN_TILE","needObjectArticle","Tile.NULL","surfaceTile","liquidTile","apply","EntryBase","dist","sidebarY","_buffer","_bounds","ActorEntry","ItemEntry","CellEntry","Sidebar","cellCache","lastX","lastY","lastMap","highlight","entry","_highlightRow","clearHighlight","last","showCursor","_getPriority","_makeActorEntry","_makeItemEntry","_makeCellEntry","highlightX","highlightY","_addActorEntry","_addItemEntry","_addCellEntry","sort","highlightAt","updateFor","updateAt","_updateCellCache","_updateEntryCache","drawBounds","currentEntry","usedLines","_isDim","mouse","running","keymap","UI","makeMap","makePlayer","_start","NOOP","_makeMap","_makePlayer","_startMap","startMap","messages","size","viewport","_initMenu","sidebar","_initSidebar","_initMessages","_initFlavor","_initViewport","sideOpts","viewInit","Sidebar.Sidebar","messOpts","Message.Messages","flavOpts","viewOpts","Flavor.Flavor","Viewport.Viewport","Layer","scheduler","Scheduler","call","animate","runTurn","_location","addActorNear","render","nextTime","playerTurn","act","_tweens","timer","setInterval","makeTickEvent","enqueue","clearEvents","nextTick","clearInterval","nextEvent","KEYPRESS","handlerFor","Command.getCommand","TICK","MOUSEMOVE","mousemove","getFlavorText","showText","CLICK","nextGoalStep","Actor.getAction","rand","enter","open","close","dance"],"mappings":"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"}