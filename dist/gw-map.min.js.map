{"version":3,"file":"gw-map.min.js","sources":["../js/flags.js","../js/light.js","../js/entity.js","../js/tileEvent.js","../js/tile.js","../js/cell.js","../js/visibility.js","../js/map.js","../js/tiles.js"],"sourcesContent":["import { flag as Flag } from \"gw-utils\";\nexport var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"LIQUID\"] = 1] = \"LIQUID\";\n    Depth[Depth[\"SURFACE\"] = 2] = \"SURFACE\";\n    Depth[Depth[\"GAS\"] = 3] = \"GAS\";\n    Depth[Depth[\"ITEM\"] = 4] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 5] = \"ACTOR\";\n    Depth[Depth[\"PLAYER\"] = 6] = \"PLAYER\";\n    Depth[Depth[\"FX\"] = 7] = \"FX\";\n    Depth[Depth[\"UI\"] = 8] = \"UI\";\n})(Depth || (Depth = {}));\nconst Fl = Flag.fl;\nexport var Layer;\n(function (Layer) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Layer[Layer[\"L_SUPERPRIORITY\"] = Fl(1)] = \"L_SUPERPRIORITY\";\n    Layer[Layer[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Layer[Layer[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Layer[Layer[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Layer[Layer[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Layer[Layer[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Layer[Layer[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Layer[Layer[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Layer[Layer[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Layer[Layer[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Layer[Layer[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Layer[Layer[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(11)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Layer[Layer[\"L_LIST_IN_SIDEBAR\"] = Fl(12)] = \"L_LIST_IN_SIDEBAR\";\n    Layer[Layer[\"L_VISUALLY_DISTINCT\"] = Fl(13)] = \"L_VISUALLY_DISTINCT\";\n    Layer[Layer[\"L_BRIGHT_MEMORY\"] = Fl(14)] = \"L_BRIGHT_MEMORY\";\n    Layer[Layer[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(15)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Layer[Layer[\"L_BLOCKED_BY_STAIRS\"] = Layer.L_BLOCKS_ITEMS |\n        Layer.L_BLOCKS_SURFACE |\n        Layer.L_BLOCKS_GAS |\n        Layer.L_BLOCKS_LIQUID |\n        Layer.L_BLOCKS_EFFECTS |\n        Layer.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Layer[Layer[\"L_BLOCKS_SCENT\"] = Layer.L_BLOCKS_MOVE | Layer.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Layer[Layer[\"L_DIVIDES_LEVEL\"] = Layer.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Layer[Layer[\"L_WAYPOINT_BLOCKER\"] = Layer.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Layer[Layer[\"L_IS_WALL\"] = Layer.L_BLOCKS_MOVE |\n        Layer.L_BLOCKS_VISION |\n        Layer.L_BLOCKS_LIQUID |\n        Layer.L_BLOCKS_GAS |\n        Layer.L_BLOCKS_EFFECTS |\n        Layer.L_BLOCKS_DIAGONAL] = \"L_IS_WALL\";\n    Layer[Layer[\"L_BLOCKS_EVERYTHING\"] = Layer.L_IS_WALL |\n        Layer.L_BLOCKS_ITEMS |\n        Layer.L_BLOCKS_ACTORS |\n        Layer.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Layer || (Layer = {}));\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Activation;\n(function (Activation) {\n    Activation[Activation[\"DFF_SUBSEQ_ALWAYS\"] = Fl(0)] = \"DFF_SUBSEQ_ALWAYS\";\n    Activation[Activation[\"DFF_SUBSEQ_EVERYWHERE\"] = Fl(1)] = \"DFF_SUBSEQ_EVERYWHERE\";\n    Activation[Activation[\"DFF_TREAT_AS_BLOCKING\"] = Fl(2)] = \"DFF_TREAT_AS_BLOCKING\";\n    Activation[Activation[\"DFF_PERMIT_BLOCKING\"] = Fl(3)] = \"DFF_PERMIT_BLOCKING\";\n    Activation[Activation[\"DFF_ACTIVATE_DORMANT_MONSTER\"] = Fl(4)] = \"DFF_ACTIVATE_DORMANT_MONSTER\";\n    Activation[Activation[\"DFF_BLOCKED_BY_OTHER_LAYERS\"] = Fl(6)] = \"DFF_BLOCKED_BY_OTHER_LAYERS\";\n    Activation[Activation[\"DFF_SUPERPRIORITY\"] = Fl(7)] = \"DFF_SUPERPRIORITY\";\n    Activation[Activation[\"DFF_AGGRAVATES_MONSTERS\"] = Fl(8)] = \"DFF_AGGRAVATES_MONSTERS\";\n    Activation[Activation[\"DFF_RESURRECT_ALLY\"] = Fl(9)] = \"DFF_RESURRECT_ALLY\";\n    Activation[Activation[\"DFF_EMIT_EVENT\"] = Fl(10)] = \"DFF_EMIT_EVENT\";\n    Activation[Activation[\"DFF_NO_REDRAW_CELL\"] = Fl(11)] = \"DFF_NO_REDRAW_CELL\";\n    Activation[Activation[\"DFF_ABORT_IF_BLOCKS_MAP\"] = Fl(12)] = \"DFF_ABORT_IF_BLOCKS_MAP\";\n    Activation[Activation[\"DFF_BLOCKED_BY_ITEMS\"] = Fl(13)] = \"DFF_BLOCKED_BY_ITEMS\";\n    Activation[Activation[\"DFF_BLOCKED_BY_ACTORS\"] = Fl(14)] = \"DFF_BLOCKED_BY_ACTORS\";\n    Activation[Activation[\"DFF_ALWAYS_FIRE\"] = Fl(15)] = \"DFF_ALWAYS_FIRE\";\n    Activation[Activation[\"DFF_NO_MARK_FIRED\"] = Fl(16)] = \"DFF_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Activation[Activation[\"DFF_PROTECTED\"] = Fl(19)] = \"DFF_PROTECTED\";\n    Activation[Activation[\"DFF_SPREAD_CIRCLE\"] = Fl(20)] = \"DFF_SPREAD_CIRCLE\";\n    Activation[Activation[\"DFF_SPREAD_LINE\"] = Fl(21)] = \"DFF_SPREAD_LINE\";\n    Activation[Activation[\"DFF_NULL_SURFACE\"] = Fl(22)] = \"DFF_NULL_SURFACE\";\n    Activation[Activation[\"DFF_NULL_LIQUID\"] = Fl(23)] = \"DFF_NULL_LIQUID\";\n    Activation[Activation[\"DFF_NULL_GAS\"] = Fl(24)] = \"DFF_NULL_GAS\";\n    Activation[Activation[\"DFF_EVACUATE_CREATURES\"] = Fl(25)] = \"DFF_EVACUATE_CREATURES\";\n    Activation[Activation[\"DFF_EVACUATE_ITEMS\"] = Fl(26)] = \"DFF_EVACUATE_ITEMS\";\n    Activation[Activation[\"DFF_BUILD_IN_WALLS\"] = Fl(27)] = \"DFF_BUILD_IN_WALLS\";\n    Activation[Activation[\"DFF_MUST_TOUCH_WALLS\"] = Fl(28)] = \"DFF_MUST_TOUCH_WALLS\";\n    Activation[Activation[\"DFF_NO_TOUCH_WALLS\"] = Fl(29)] = \"DFF_NO_TOUCH_WALLS\";\n    Activation[Activation[\"DFF_ONLY_IF_EMPTY\"] = Activation.DFF_BLOCKED_BY_ITEMS | Activation.DFF_BLOCKED_BY_ACTORS] = \"DFF_ONLY_IF_EMPTY\";\n    Activation[Activation[\"DFF_NULLIFY_CELL\"] = Activation.DFF_NULL_SURFACE | Activation.DFF_NULL_LIQUID | Activation.DFF_NULL_GAS] = \"DFF_NULLIFY_CELL\";\n})(Activation || (Activation = {}));\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(4)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(5)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(6)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(7)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(8)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(9)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(10)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(11)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(12)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(13)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(14)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(15)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(16)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(17)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(18)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(19)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n})(Tile || (Tile = {}));\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"VISIBLE\"] = Fl(0)] = \"VISIBLE\";\n    Cell[Cell[\"WAS_VISIBLE\"] = Fl(1)] = \"WAS_VISIBLE\";\n    Cell[Cell[\"CLAIRVOYANT_VISIBLE\"] = Fl(2)] = \"CLAIRVOYANT_VISIBLE\";\n    Cell[Cell[\"WAS_CLAIRVOYANT_VISIBLE\"] = Fl(3)] = \"WAS_CLAIRVOYANT_VISIBLE\";\n    Cell[Cell[\"TELEPATHIC_VISIBLE\"] = Fl(4)] = \"TELEPATHIC_VISIBLE\";\n    Cell[Cell[\"WAS_TELEPATHIC_VISIBLE\"] = Fl(5)] = \"WAS_TELEPATHIC_VISIBLE\";\n    Cell[Cell[\"ITEM_DETECTED\"] = Fl(6)] = \"ITEM_DETECTED\";\n    Cell[Cell[\"WAS_ITEM_DETECTED\"] = Fl(7)] = \"WAS_ITEM_DETECTED\";\n    Cell[Cell[\"MONSTER_DETECTED\"] = Fl(8)] = \"MONSTER_DETECTED\";\n    Cell[Cell[\"WAS_MONSTER_DETECTED\"] = Fl(9)] = \"WAS_MONSTER_DETECTED\";\n    Cell[Cell[\"REVEALED\"] = Fl(10)] = \"REVEALED\";\n    Cell[Cell[\"MAGIC_MAPPED\"] = Fl(11)] = \"MAGIC_MAPPED\";\n    Cell[Cell[\"IN_FOV\"] = Fl(12)] = \"IN_FOV\";\n    Cell[Cell[\"WAS_IN_FOV\"] = Fl(13)] = \"WAS_IN_FOV\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(14)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"CELL_CHANGED\"] = Fl(15)] = \"CELL_CHANGED\";\n    // These are to help memory\n    Cell[Cell[\"HAS_SURFACE\"] = Fl(16)] = \"HAS_SURFACE\";\n    Cell[Cell[\"HAS_LIQUID\"] = Fl(17)] = \"HAS_LIQUID\";\n    Cell[Cell[\"HAS_GAS\"] = Fl(18)] = \"HAS_GAS\";\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(19)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(20)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(21)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(22)] = \"HAS_ITEM\";\n    Cell[Cell[\"IS_IN_PATH\"] = Fl(23)] = \"IS_IN_PATH\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(24)] = \"IS_CURSOR\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(25)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"LIGHT_CHANGED\"] = Fl(26)] = \"LIGHT_CHANGED\";\n    Cell[Cell[\"CELL_LIT\"] = Fl(27)] = \"CELL_LIT\";\n    Cell[Cell[\"IS_IN_SHADOW\"] = Fl(28)] = \"IS_IN_SHADOW\";\n    Cell[Cell[\"CELL_DARK\"] = Fl(29)] = \"CELL_DARK\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.REVEALED |\n        Cell.MAGIC_MAPPED |\n        Cell.ITEM_DETECTED |\n        Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"ANY_KIND_OF_VISIBLE\"] = Cell.VISIBLE | Cell.CLAIRVOYANT_VISIBLE | Cell.TELEPATHIC_VISIBLE] = \"ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"IS_WAS_ANY_KIND_OF_VISIBLE\"] = Cell.VISIBLE |\n        Cell.WAS_VISIBLE |\n        Cell.CLAIRVOYANT_VISIBLE |\n        Cell.WAS_CLAIRVOYANT_VISIBLE |\n        Cell.TELEPATHIC_VISIBLE |\n        Cell.WAS_TELEPATHIC_VISIBLE] = \"IS_WAS_ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"WAS_ANY_KIND_OF_VISIBLE\"] = Cell.WAS_VISIBLE |\n        Cell.WAS_CLAIRVOYANT_VISIBLE |\n        Cell.WAS_TELEPATHIC_VISIBLE] = \"WAS_ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.VISIBLE | Cell.IN_FOV | Cell.NEEDS_REDRAW | Cell.CELL_CHANGED] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n///////////////////////////////////////////////////////\n// CELL MECH\nexport var CellMech;\n(function (CellMech) {\n    CellMech[CellMech[\"SEARCHED_FROM_HERE\"] = Fl(0)] = \"SEARCHED_FROM_HERE\";\n    CellMech[CellMech[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(1)] = \"PRESSURE_PLATE_DEPRESSED\";\n    CellMech[CellMech[\"KNOWN_TO_BE_TRAP_FREE\"] = Fl(2)] = \"KNOWN_TO_BE_TRAP_FREE\";\n    CellMech[CellMech[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(4)] = \"CAUGHT_FIRE_THIS_TURN\";\n    CellMech[CellMech[\"EVENT_FIRED_THIS_TURN\"] = Fl(5)] = \"EVENT_FIRED_THIS_TURN\";\n    CellMech[CellMech[\"EVENT_PROTECTED\"] = Fl(6)] = \"EVENT_PROTECTED\";\n    CellMech[CellMech[\"IS_IN_LOOP\"] = Fl(10)] = \"IS_IN_LOOP\";\n    CellMech[CellMech[\"IS_CHOKEPOINT\"] = Fl(11)] = \"IS_CHOKEPOINT\";\n    CellMech[CellMech[\"IS_GATE_SITE\"] = Fl(12)] = \"IS_GATE_SITE\";\n    CellMech[CellMech[\"IS_IN_ROOM_MACHINE\"] = Fl(13)] = \"IS_IN_ROOM_MACHINE\";\n    CellMech[CellMech[\"IS_IN_AREA_MACHINE\"] = Fl(14)] = \"IS_IN_AREA_MACHINE\";\n    CellMech[CellMech[\"IS_POWERED\"] = Fl(15)] = \"IS_POWERED\";\n    CellMech[CellMech[\"IMPREGNABLE\"] = Fl(20)] = \"IMPREGNABLE\";\n    CellMech[CellMech[\"DARKENED\"] = Fl(19)] = \"DARKENED\";\n    CellMech[CellMech[\"IS_IN_MACHINE\"] = CellMech.IS_IN_ROOM_MACHINE | CellMech.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    CellMech[CellMech[\"PERMANENT_MECH_FLAGS\"] = CellMech.SEARCHED_FROM_HERE |\n        CellMech.PRESSURE_PLATE_DEPRESSED |\n        CellMech.KNOWN_TO_BE_TRAP_FREE |\n        CellMech.IS_IN_LOOP |\n        CellMech.IS_CHOKEPOINT |\n        CellMech.IS_GATE_SITE |\n        CellMech.IS_IN_MACHINE |\n        CellMech.IMPREGNABLE] = \"PERMANENT_MECH_FLAGS\";\n})(CellMech || (CellMech = {}));\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_STABLE_GLOW_LIGHTS\"] = Fl(1)] = \"MAP_STABLE_GLOW_LIGHTS\";\n    Map[Map[\"MAP_STABLE_LIGHTS\"] = Fl(2)] = \"MAP_STABLE_LIGHTS\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = Map.MAP_STABLE_LIGHTS | Map.MAP_STABLE_GLOW_LIGHTS] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import { utils as Utils, range as Range, grid as Grid, color as Color, data as DATA, config as CONFIG, make as Make, } from \"gw-utils\";\nimport * as Flags from \"./flags\";\n// const LIGHT_SMOOTHING_THRESHOLD = 150;       // light components higher than this magnitude will be toned down a little\nexport const config = (CONFIG.light = { INTENSITY_DARK: 20 }); // less than 20% for highest color in rgb\nconst LIGHT_COMPONENTS = Color.make();\nexport class Light {\n    constructor(color, range, fadeTo, pass = false) {\n        this.fadeTo = 0;\n        this.passThroughActors = false;\n        this.id = null;\n        this.color = Color.from(color) || null; /* color */\n        this.radius = Range.make(range || 1);\n        this.fadeTo = fadeTo || 0;\n        this.passThroughActors = pass; // generally no, but miner light does (TODO - string parameter?  'false' or 'true')\n    }\n    copy(other) {\n        this.color = other.color;\n        this.radius.copy(other.radius);\n        this.fadeTo = other.fadeTo;\n        this.passThroughActors = other.passThroughActors;\n    }\n    get intensity() {\n        return intensity(this.color);\n    }\n    // Returns true if any part of the light hit cells that are in the player's field of view.\n    paint(map, x, y, maintainShadows = false, isMinersLight = false) {\n        if (!map)\n            return false;\n        let k;\n        // let colorComponents = [0,0,0];\n        let lightMultiplier;\n        let radius = this.radius.value();\n        let outerRadius = Math.ceil(radius);\n        // calcLightComponents(colorComponents, this);\n        LIGHT_COMPONENTS.copy(this.color).bake();\n        // console.log('paint', LIGHT_COMPONENTS.toString(true), x, y, outerRadius);\n        // the miner's light does not dispel IS_IN_SHADOW,\n        // so the player can be in shadow despite casting his own light.\n        const dispelShadows = !isMinersLight &&\n            !maintainShadows &&\n            intensity(LIGHT_COMPONENTS) > config.INTENSITY_DARK;\n        const fadeToPercent = this.fadeTo;\n        const grid = Grid.alloc(map.width, map.height, 0);\n        map.calcFov(grid, x, y, outerRadius, this.passThroughActors ? 0 : Flags.Cell.HAS_ANY_ACTOR, Flags.Layer.L_BLOCKS_VISION);\n        let overlappedFieldOfView = false;\n        grid.forCircle(x, y, outerRadius, (v, i, j) => {\n            if (!v)\n                return;\n            const cell = map.cell(i, j);\n            lightMultiplier = Math.floor(100 -\n                (100 - fadeToPercent) * (Utils.distanceBetween(x, y, i, j) / radius));\n            for (k = 0; k < 3; k++) {\n                cell.light[k] += Math.floor((LIGHT_COMPONENTS[k] * lightMultiplier) / 100);\n            }\n            if (dispelShadows) {\n                cell.flags &= ~Flags.Cell.IS_IN_SHADOW;\n            }\n            if (cell.flags & (Flags.Cell.IN_FOV | Flags.Cell.ANY_KIND_OF_VISIBLE)) {\n                overlappedFieldOfView = true;\n            }\n            // console.log(i, j, lightMultiplier, cell.light);\n        });\n        if (dispelShadows) {\n            const cell = map.cell(x, y);\n            cell.flags &= ~Flags.Cell.IS_IN_SHADOW;\n        }\n        Grid.free(grid);\n        return overlappedFieldOfView;\n    }\n}\nexport function intensity(color) {\n    return Math.max(color[0], color[1], color[2]);\n}\nexport function make(...args) {\n    if (args.length == 1) {\n        const config = args[0];\n        if (typeof config === \"string\") {\n            const cached = lights[config];\n            if (cached)\n                return cached;\n            const [color, radius, fadeTo, pass] = config\n                .split(/[,|]/)\n                .map((t) => t.trim());\n            return new Light(Color.from(color), Range.from(radius || 1), Number.parseInt(fadeTo || \"0\"), !!pass && pass !== \"false\");\n        }\n        else if (Array.isArray(config)) {\n            const [color, radius, fadeTo, pass] = config;\n            return new Light(color, radius, fadeTo, pass);\n        }\n        else if (config && config.color) {\n            return new Light(Color.from(config.color), Range.from(config.radius), Number.parseInt(config.fadeTo || \"0\"), config.pass);\n        }\n        else {\n            throw new Error(\"Unknown Light config - \" + config);\n        }\n    }\n    else {\n        const [color, radius, fadeTo, pass] = args;\n        return new Light(color, radius, fadeTo, pass);\n    }\n}\nMake.light = make;\nexport const lights = {};\nexport function from(...args) {\n    if (args.length != 1)\n        Utils.ERROR(\"Unknown Light config: \" + JSON.stringify(args));\n    const arg = args[0];\n    if (typeof arg === \"string\") {\n        const cached = lights[arg];\n        if (cached)\n            return cached;\n    }\n    return make(arg);\n}\nexport function install(id, ...args) {\n    let source;\n    if (args.length == 1) {\n        source = make(args[0]);\n    }\n    else {\n        source = make(args[0], args[1], args[2], args[3]);\n    }\n    lights[id] = source;\n    if (source)\n        source.id = id;\n    return source;\n}\nexport function installAll(config = {}) {\n    const entries = Object.entries(config);\n    entries.forEach(([name, info]) => {\n        install(name, info);\n    });\n}\n// export function calcLightComponents(colorComponents, theLight) {\n// \tconst randComponent = cosmetic.range(0, theLight.color.rand);\n// \tcolorComponents[0] = randComponent + theLight.color.red + cosmetic.range(0, theLight.color.redRand);\n// \tcolorComponents[1] = randComponent + theLight.color.green + cosmetic.range(0, theLight.color.greenRand);\n// \tcolorComponents[2] = randComponent + theLight.color.blue + cosmetic.range(0, theLight.color.blueRand);\n// }\nfunction updateDisplayDetail(map) {\n    map.eachCell((cell, _i, _j) => {\n        // clear light flags\n        cell.flags &= ~(Flags.Cell.CELL_LIT | Flags.Cell.CELL_DARK);\n        if (cell.light.some((v, i) => v !== cell.oldLight[i])) {\n            cell.lightChanged = true;\n        }\n        if (cell.isDark()) {\n            cell.flags |= Flags.Cell.CELL_DARK;\n        }\n        else if (!(cell.flags & Flags.Cell.IS_IN_SHADOW)) {\n            cell.flags |= Flags.Cell.CELL_LIT;\n        }\n    });\n}\n// export function backUpLighting(map: Map.Map, lights: LightDataGrid) {\n//   let k;\n//   map.eachCell((cell, i, j) => {\n//     for (k = 0; k < 3; k++) {\n//       lights[i][j][k] = cell.light[k];\n//     }\n//   });\n// }\n// export function restoreLighting(map: Map.Map, lights: LightDataGrid) {\n//   let k;\n//   map.eachCell((cell, i, j) => {\n//     for (k = 0; k < 3; k++) {\n//       cell.light[k] = lights[i][j][k];\n//     }\n//   });\n// }\nexport function recordOldLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.oldLight[k] = cell.light[k];\n            cell.lightChanged = false;\n        }\n    });\n}\nexport function zeroOutLights(map) {\n    let k;\n    const light = map.ambientLight ? map.ambientLight : [0, 0, 0];\n    map.eachCell((cell, _i, _j) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = light[k];\n        }\n        cell.flags |= Flags.Cell.IS_IN_SHADOW;\n    });\n}\nexport function recordGlowLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.glowLight[k] = cell.light[k];\n        }\n    });\n}\nexport function restoreGlowLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = cell.glowLight[k];\n        }\n    });\n}\nexport function updateLighting(map) {\n    if (!map.anyLightChanged)\n        return false;\n    // Copy Light over oldLight\n    recordOldLights(map);\n    // and then zero out Light.\n    zeroOutLights(map);\n    if (!map.staticLightChanged) {\n        restoreGlowLights(map);\n    }\n    else {\n        // GW.debug.log('painting glow lights.');\n        // Paint all glowing tiles.\n        map.eachStaticLight((light, x, y) => {\n            //   const light = lights[id];\n            if (light) {\n                light.paint(map, x, y);\n            }\n        });\n        recordGlowLights(map);\n        map.staticLightChanged = false;\n    }\n    // Cycle through monsters and paint their lights:\n    map.eachDynamicLight((light, x, y) => {\n        light.paint(map, x, y);\n        // if (monst.mutationIndex >= 0 && mutationCatalog[monst.mutationIndex].light != lights['NO_LIGHT']) {\n        //     paint(map, mutationCatalog[monst.mutationIndex].light, actor.x, actor.y, false, false);\n        // }\n        // if (actor.isBurning()) { // monst.status.burning && !(actor.kind.flags & Flags.Actor.AF_FIERY)) {\n        // \tpaint(map, lights.BURNING_CREATURE, actor.x, actor.y, false, false);\n        // }\n        // if (actor.isTelepathicallyRevealed()) {\n        // \tpaint(map, lights['TELEPATHY_LIGHT'], actor.x, actor.y, false, true);\n        // }\n    });\n    // Also paint telepathy lights for dormant monsters.\n    // for (monst of map.dormantMonsters) {\n    //     if (monsterTelepathicallyRevealed(monst)) {\n    //         paint(map, lights['TELEPATHY_LIGHT'], monst.xLoc, monst.yLoc, false, true);\n    //     }\n    // }\n    updateDisplayDetail(map);\n    // Miner's light:\n    const PLAYER = DATA.player;\n    if (PLAYER) {\n        const PLAYERS_LIGHT = lights.PLAYERS_LIGHT;\n        if (PLAYERS_LIGHT && PLAYERS_LIGHT.radius) {\n            PLAYERS_LIGHT.paint(map, PLAYER.x, PLAYER.y, true, true);\n        }\n    }\n    map.anyLightChanged = false;\n    // if (PLAYER.status.invisible) {\n    //     PLAYER.info.foreColor = playerInvisibleColor;\n    // } else if (playerInDarkness()) {\n    // \tPLAYER.info.foreColor = playerInDarknessColor;\n    // } else if (pmap[PLAYER.xLoc][PLAYER.yLoc].flags & IS_IN_SHADOW) {\n    // \tPLAYER.info.foreColor = playerInShadowColor;\n    // } else {\n    // \tPLAYER.info.foreColor = playerInLightColor;\n    // }\n    return true;\n}\n// TODO - Move?\nexport function playerInDarkness(map, PLAYER, darkColor) {\n    const cell = map.cell(PLAYER.x, PLAYER.y);\n    return cell.isDark(darkColor);\n    // return (\n    //   cell.light[0] + 10 < darkColor.r &&\n    //   cell.light[1] + 10 < darkColor.g &&\n    //   cell.light[2] + 10 < darkColor.b\n    // );\n}\n","import * as GW from 'gw-utils';\nimport { Layer as Flags, Depth } from './flags';\nimport * as Light from './light';\nexport { Flags, Depth };\nexport class Entity {\n    constructor(config) {\n        this.priority = 50;\n        this.layer = 0;\n        this.light = null;\n        this.flags = { layer: 0 };\n        this.sprite = GW.make.sprite(config.sprite || config);\n        this.light = config.light ? Light.make(config.light) : null;\n        this.priority = GW.utils.first(config.priority, 50);\n        this.layer =\n            (config.layer && typeof config.layer !== 'number'\n                ? Depth[config.layer]\n                : config.layer) || 0;\n        // @ts-ignore\n        this.flags.layer = GW.flag.from(Flags, config.layerFlags, config.flags, 0);\n    }\n    hasLayerFlag(flag) {\n        return (this.flags.layer & flag) > 0;\n    }\n}\nexport function make(config) {\n    return new Entity(config);\n}\nGW.make.layer = make;\n","import { utils as Utils, random, grid as Grid, events as Events, color as Color, flag as Flag, data as Data, message as Msg, make as Make, } from \"gw-utils\";\nimport { Depth, Activation as Flags, Tile as TileFlags, CellMech as CellMechFlags, Layer as LayerFlags, } from \"./flags\";\nimport * as Tile from \"./tile\";\nexport { Flags };\nexport class TileEvent {\n    constructor(opts = {}) {\n        if (typeof opts === \"function\") {\n            opts = {\n                fn: opts,\n            };\n        }\n        this.tile = opts.tile || null;\n        this.fn = opts.fn || null;\n        this.item = opts.item || null;\n        this.chance = opts.chance || 0;\n        this.volume = opts.volume || 0;\n        // spawning pattern:\n        this.spread = opts.spread || 0;\n        this.radius = opts.radius || 0;\n        this.decrement = opts.decrement || 0;\n        this.flags = Flag.from(Flags, opts.flags);\n        this.matchTile = opts.matchTile || opts.needs || 0; /* ENUM tileType */\n        this.next = opts.next || null; /* ENUM makeEventTypes */\n        this.message = opts.message || null;\n        this.lightFlare = opts.flare || null;\n        this.flashColor = opts.flash ? Color.from(opts.flash) : null;\n        // this.effectRadius = radius || 0;\n        this.messageDisplayed = false;\n        this.emit = opts.emit || null; // name of the event to emit when activated\n        this.id = opts.id || null;\n    }\n}\nexport function make(opts) {\n    if (!opts)\n        return null;\n    if (typeof opts === \"string\") {\n        opts = { tile: opts };\n    }\n    const te = new TileEvent(opts);\n    return te;\n}\nMake.tileEvent = make;\nexport const activations = {};\nexport function install(id, event) {\n    if (!(event instanceof TileEvent)) {\n        event = make(event);\n    }\n    activations[id] = event;\n    if (event)\n        event.id = id;\n    return event;\n}\nexport function installAll(events) {\n    Object.entries(events).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function resetAllMessages() {\n    Object.values(activations).forEach((f) => {\n        if (f instanceof TileEvent) {\n            f.messageDisplayed = false;\n        }\n    });\n}\n// returns whether the feature was successfully generated (false if we aborted because of blocking)\nexport async function spawn(activation, ctx = {}) {\n    let i, j;\n    if (!activation)\n        Utils.ERROR(\"No activation.\");\n    if (!ctx)\n        Utils.ERROR(\"Context required - and must include map, x, y\");\n    let feat;\n    if (typeof activation === \"string\") {\n        // @ts-ignore\n        feat = activations[activation];\n        if (!feat)\n            Utils.ERROR(\"Unknown tile Event: \" + activation);\n    }\n    else if (typeof activation === \"function\") {\n        return activation(ctx);\n    }\n    else {\n        feat = activation;\n    }\n    const map = ctx.map;\n    const x = ctx.x;\n    const y = ctx.y;\n    if (x === undefined || y === undefined || !map) {\n        Utils.ERROR(\"MAP, x, y are required in context.\");\n    }\n    if (ctx.safe &&\n        map.hasCellMechFlag(x, y, CellMechFlags.EVENT_FIRED_THIS_TURN)) {\n        if (!(feat.flags & Flags.DFF_ALWAYS_FIRE)) {\n            // Activation.debug('spawn - already fired.');\n            return false;\n        }\n    }\n    // Activation.debug('spawn', x, y, 'id=', feat.id, 'tile=', feat.tile, 'item=', feat.item);\n    ctx.refreshCell = ctx.refreshCell || !(feat.flags & Flags.DFF_NO_REDRAW_CELL);\n    const abortIfBlocking = (ctx.abortIfBlocking =\n        ctx.abortIfBlocking || feat.flags & Flags.DFF_ABORT_IF_BLOCKS_MAP);\n    // if ((feat.flags & DFF_RESURRECT_ALLY) && !resurrectAlly(x, y))\n    // {\n    //     return false;\n    // }\n    if (feat.message &&\n        feat.message.length &&\n        !feat.messageDisplayed &&\n        map.isVisible(x, y)) {\n        feat.messageDisplayed = true;\n        Msg.add(feat.message);\n    }\n    let tile = null;\n    if (feat.tile) {\n        tile = Tile.tiles[feat.tile] || null;\n        if (!tile) {\n            Utils.ERROR(\"Unknown tile: \" + feat.tile);\n        }\n    }\n    let item = null;\n    if (feat.item && \"item\" in Make) {\n        item = Make.item(feat.item);\n        if (!item) {\n            Utils.ERROR(\"Unknown item: \" + feat.item);\n        }\n    }\n    // Blocking keeps track of whether to abort if it turns out that the DF would obstruct the level.\n    const blocking = (ctx.blocking =\n        abortIfBlocking &&\n            !(feat.flags & Flags.DFF_PERMIT_BLOCKING) &&\n            ((tile && tile.blocksPathing()) ||\n                (item && item.blocksMove()) ||\n                feat.flags & Flags.DFF_TREAT_AS_BLOCKING)\n            ? true\n            : false);\n    // Activation.debug('- blocking', blocking);\n    const spawnMap = Grid.alloc(map.width, map.height);\n    let didSomething = false;\n    computeSpawnMap(feat, spawnMap, ctx);\n    if (!blocking ||\n        !map.gridDisruptsPassability(spawnMap, { bounds: ctx.bounds })) {\n        if (feat.flags & Flags.DFF_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (feat.flags & Flags.DFF_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (feat.flags & Flags.DFF_NULLIFY_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (nullifyCells(map, spawnMap, feat.flags)) {\n                didSomething = true;\n            }\n        }\n        if (tile || item || feat.fn) {\n            if (await spawnTiles(feat, spawnMap, ctx, tile, item)) {\n                didSomething = true;\n            }\n        }\n    }\n    if (item) {\n        item.delete();\n    }\n    if (didSomething && feat.flags & Flags.DFF_PROTECTED) {\n        spawnMap.forEach((v, i, j) => {\n            if (!v)\n                return;\n            const cell = map.cell(i, j);\n            cell.mechFlags |= CellMechFlags.EVENT_PROTECTED;\n        });\n    }\n    if (didSomething) {\n        // if ((feat.flags & Flags.DFF_AGGRAVATES_MONSTERS) && feat.effectRadius) {\n        //     await aggravateMonsters(feat.effectRadius, x, y, /* Color. */gray);\n        // }\n        // if (refreshCell && feat.flashColor && feat.effectRadius) {\n        //     await colorFlash(feat.flashColor, 0, (IN_FOV | CLAIRVOYANT_VISIBLE), 4, feat.effectRadius, x, y);\n        // }\n        // if (refreshCell && feat.lightFlare) {\n        //     createFlare(x, y, feat.lightFlare);\n        // }\n    }\n    // if (refreshCell && feat.tile\n    // \t&& (tile.flags & (TileFlags.T_IS_FIRE | TileFlags.T_AUTO_DESCENT))\n    // \t&& map.hasTileFlag(PLAYER.xLoc, PLAYER.yLoc, (TileFlags.T_IS_FIRE | TileFlags.T_AUTO_DESCENT)))\n    // {\n    // \tawait applyInstantTileEffectsToCreature(PLAYER);\n    // }\n    // apply tile effects\n    if (didSomething) {\n        for (let i = 0; i < spawnMap.width; ++i) {\n            for (let j = 0; j < spawnMap.height; ++j) {\n                const v = spawnMap[i][j];\n                if (!v || Data.gameHasEnded)\n                    continue;\n                const cell = map.cell(i, j);\n                if (cell.actor || cell.item) {\n                    await cell.activate(\"enter\", { map, x: i, y: j, cell });\n                }\n            }\n        }\n    }\n    if (feat.emit) {\n        await Events.emit(feat.emit, ctx);\n        didSomething = true;\n    }\n    if (Data.gameHasEnded) {\n        Grid.free(spawnMap);\n        return didSomething;\n    }\n    //\tif (succeeded && feat.message[0] && !feat.messageDisplayed && isVisible(x, y)) {\n    //\t\tfeat.messageDisplayed = true;\n    //\t\tmessage(feat.message, false);\n    //\t}\n    if (feat.next && (didSomething || feat.flags & Flags.DFF_SUBSEQ_ALWAYS)) {\n        // Activation.debug('- subsequent: %s, everywhere=%s', feat.next, feat.flags & Flags.DFF_SUBSEQ_EVERYWHERE);\n        if (feat.flags & Flags.DFF_SUBSEQ_EVERYWHERE) {\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j]) {\n                        ctx.x = i;\n                        ctx.y = j;\n                        await spawn(feat.next, ctx);\n                    }\n                }\n            }\n            ctx.x = x;\n            ctx.y = y;\n        }\n        else {\n            await spawn(feat.next, ctx);\n        }\n    }\n    if (didSomething) {\n        if (tile &&\n            tile.flags.tile &\n                (TileFlags.T_DEEP_WATER | TileFlags.T_LAVA | TileFlags.T_AUTO_DESCENT)) {\n            Data.updateMapToShoreThisTurn = false;\n        }\n        // awaken dormant creatures?\n        // if (feat.flags & Flags.DFF_ACTIVATE_DORMANT_MONSTER) {\n        //     for (monst of map.dormant) {\n        //         if (monst.x == x && monst.y == y || spawnMap[monst.x][monst.y]) {\n        //             // found it!\n        //             toggleMonsterDormancy(monst);\n        //         }\n        //     }\n        // }\n    }\n    if (didSomething) {\n        spawnMap.forEach((v, i, j) => {\n            if (v)\n                map.redrawXY(i, j);\n        });\n        map.changed = true;\n        if (!(feat.flags & Flags.DFF_NO_MARK_FIRED)) {\n            spawnMap.forEach((v, i, j) => {\n                if (v) {\n                    map.setCellFlags(i, j, 0, CellMechFlags.EVENT_FIRED_THIS_TURN);\n                }\n            });\n        }\n    }\n    // Activation.debug('- spawn complete : @%d,%d, ok=%s, feat=%s', ctx.x, ctx.y, didSomething, feat.id);\n    Grid.free(spawnMap);\n    return didSomething;\n}\nfunction cellIsOk(feat, x, y, ctx = {}) {\n    const map = ctx.map;\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (feat.flags & Flags.DFF_BUILD_IN_WALLS) {\n        if (!cell.isWall())\n            return false;\n    }\n    else if (feat.flags & Flags.DFF_MUST_TOUCH_WALLS) {\n        let ok = false;\n        map.eachNeighbor(x, y, (c) => {\n            if (c.isWall()) {\n                ok = true;\n            }\n        });\n        if (!ok)\n            return false;\n    }\n    else if (feat.flags & Flags.DFF_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (cell.isWall())\n            return false; // or on wall\n        map.eachNeighbor(x, y, (c) => {\n            if (c.isWall()) {\n                ok = false;\n            }\n        });\n        if (!ok)\n            return false;\n    }\n    if (ctx.bounds && !ctx.bounds.containsXY(x, y))\n        return false;\n    if (feat.matchTile && !cell.hasTile(feat.matchTile))\n        return false;\n    if (cell.hasLayerFlag(LayerFlags.L_BLOCKS_EFFECTS) &&\n        !feat.matchTile &&\n        (ctx.x != x || ctx.y != y)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(feat, spawnMap, ctx = {}) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    const map = ctx.map;\n    const x = ctx.x;\n    const y = ctx.y;\n    const bounds = ctx.bounds || null;\n    if (bounds) {\n        // Activation.debug('- bounds', bounds);\n    }\n    let startProb = feat.spread || 0;\n    let probDec = feat.decrement || 0;\n    if (feat.matchTile && typeof feat.matchTile === \"string\") {\n        const name = feat.matchTile;\n        const tile = Tile.tiles[name];\n        if (!tile) {\n            Utils.ERROR(\"Failed to find match tile with name:\" + name);\n        }\n        feat.matchTile = tile.id;\n    }\n    spawnMap.fill(0);\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let radius = feat.radius || 0;\n    if (feat.flags & Flags.DFF_SPREAD_CIRCLE) {\n        radius = 0;\n        startProb = startProb || 100;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        while (random.chance(startProb)) {\n            startProb -= probDec;\n            ++radius;\n        }\n        startProb = 100;\n        probDec = 0;\n    }\n    if (radius) {\n        startProb = startProb || 100;\n        spawnMap.updateCircle(x, y, radius, (_v, i, j) => {\n            if (!cellIsOk(feat, i, j, ctx))\n                return 0;\n            const dist = Math.floor(Utils.distanceBetween(x, y, i, j));\n            const prob = startProb - dist * probDec;\n            if (!random.chance(prob))\n                return 0;\n            return 1;\n        });\n        spawnMap[x][y] = 1;\n    }\n    else if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (feat.flags & Flags.DFF_SPREAD_LINE) {\n            x2 = x;\n            y2 = y;\n            const dir = Utils.DIRS[random.number(4)];\n            while (madeChange) {\n                madeChange = false;\n                x2 = x2 + dir[0];\n                y2 = y2 + dir[1];\n                if (spawnMap.hasXY(x2, y2) &&\n                    !spawnMap[x2][y2] &&\n                    cellIsOk(feat, x2, y2, ctx) &&\n                    random.chance(startProb)) {\n                    spawnMap[x2][y2] = 1;\n                    madeChange = true;\n                    startProb -= probDec;\n                }\n            }\n        }\n        else {\n            if (probDec <= 0)\n                probDec = startProb;\n            while (madeChange && startProb > 0) {\n                madeChange = false;\n                t++;\n                for (i = 0; i < map.width; i++) {\n                    for (j = 0; j < map.height; j++) {\n                        if (spawnMap[i][j] == t - 1) {\n                            for (dir = 0; dir < 4; dir++) {\n                                x2 = i + Utils.DIRS[dir][0];\n                                y2 = j + Utils.DIRS[dir][1];\n                                if (spawnMap.hasXY(x2, y2) &&\n                                    !spawnMap[x2][y2] &&\n                                    cellIsOk(feat, x2, y2, ctx) &&\n                                    random.chance(startProb)) {\n                                    spawnMap[x2][y2] = t;\n                                    madeChange = true;\n                                }\n                            }\n                        }\n                    }\n                }\n                startProb -= probDec;\n            }\n        }\n    }\n    if (!cellIsOk(feat, x, y, ctx)) {\n        spawnMap[x][y] = 0;\n    }\n}\nexport async function spawnTiles(feat, spawnMap, ctx, tile, item) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = feat.flags & Flags.DFF_BLOCKED_BY_OTHER_LAYERS;\n    const superpriority = feat.flags & Flags.DFF_SUPERPRIORITY;\n    const applyEffects = ctx.refreshCell;\n    const map = ctx.map;\n    const volume = ctx.volume || feat.volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.mechFlags & CellMechFlags.EVENT_PROTECTED)\n                continue;\n            if (tile) {\n                if (cell.tile(tile.layer) === tile) {\n                    // If the new cell already contains the fill terrain,\n                    if (tile.layer == Depth.GAS) {\n                        spawnMap[i][j] = 1;\n                        cell.gasVolume += volume;\n                    }\n                    else if (tile.layer == Depth.LIQUID) {\n                        spawnMap[i][j] = 1;\n                        cell.liquidVolume += volume;\n                    }\n                }\n                else if ((superpriority || cell.tile(tile.layer).priority < tile.priority) && // If the terrain in the layer to be overwritten has a higher priority number (unless superpriority),\n                    !cell.obstructsLayer(tile.layer) && // If we will be painting into the surface layer when that cell forbids it,\n                    (!cell.item || !(feat.flags & Flags.DFF_BLOCKED_BY_ITEMS)) &&\n                    (!cell.actor || !(feat.flags & Flags.DFF_BLOCKED_BY_ACTORS)) &&\n                    (!blockedByOtherLayers || cell.topmostTile().priority < tile.priority)) {\n                    // if the fill won't violate the priority of the most important terrain in this cell:\n                    spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                    map.setTile(i, j, tile, volume);\n                    // map.redrawCell(cell);\n                    // if (volume && cell.gas) {\n                    //     cell.volume += (feat.volume || 0);\n                    // }\n                    // debug('- tile', i, j, 'tile=', tile.id);\n                    // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                    accomplishedSomething = true;\n                }\n            }\n            if (item) {\n                if (superpriority || !cell.item) {\n                    if (!cell.hasLayerFlag(LayerFlags.L_BLOCKS_ITEMS)) {\n                        spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                        if (cell.item) {\n                            map.removeItem(cell.item);\n                        }\n                        const clone = item.clone();\n                        map.addItem(i, j, clone);\n                        // map.redrawCell(cell);\n                        // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                        accomplishedSomething = true;\n                        // Activation.debug('- item', i, j, 'item=', itemKind.id);\n                    }\n                }\n            }\n            if (feat.fn) {\n                ctx.spawnMap = spawnMap;\n                if (await feat.fn(i, j, ctx)) {\n                    spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                    // map.redrawCell(cell);\n                    // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                    accomplishedSomething = true;\n                }\n            }\n            if (applyEffects) {\n                // if (PLAYER.xLoc == i && PLAYER.yLoc == j && !PLAYER.status.levitating && refresh) {\n                // \tflavorMessage(tileFlavor(PLAYER.xLoc, PLAYER.yLoc));\n                // }\n                // if (cell.actor || cell.item) {\n                // \tfor(let t of cell.tiles()) {\n                // \t\tawait t.applyInstantEffects(map, i, j, cell);\n                // \t\tif (Data.gameHasEnded) {\n                // \t\t\treturn true;\n                // \t\t}\n                // \t}\n                // }\n                // if (tile.flags & TileFlags.T_IS_FIRE) {\n                // \tif (cell.flags & CellFlags.HAS_ITEM) {\n                // \t\ttheItem = map.itemAt(i, j);\n                // \t\tif (theItem.flags & Flags.Item.ITEM_FLAMMABLE) {\n                // \t\t\tawait burnItem(theItem);\n                // \t\t}\n                // \t}\n                // }\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.changed = true;\n    }\n    return accomplishedSomething;\n}\nexport function nullifyCells(map, spawnMap, flags) {\n    let didSomething = false;\n    const nullSurface = flags & Flags.DFF_NULL_SURFACE;\n    const nullLiquid = flags & Flags.DFF_NULL_LIQUID;\n    const nullGas = flags & Flags.DFF_NULL_GAS;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        map.clearCellLayers(i, j, !!nullLiquid, !!nullSurface, !!nullGas);\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let i, j;\n    let didSomething = false;\n    for (i = 0; i < map.width; i++) {\n        for (j = 0; j < map.height; j++) {\n            if (!blockingMap[i][j])\n                continue;\n            const cell = map.cell(i, j);\n            if (!cell.actor)\n                continue;\n            const monst = cell.actor;\n            const loc = map.matchingLocNear(i, j, (cell) => {\n                return !monst.forbidsCell(cell);\n            }, { hallways: true, blockingMap });\n            if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                map.moveActor(loc[0], loc[1], monst);\n                // map.redrawXY(loc[0], loc[1]);\n                didSomething = true;\n            }\n        }\n    }\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    blockingMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (!cell.item)\n            return;\n        const item = cell.item;\n        const loc = map.matchingLocNear(i, j, (dest) => {\n            return !item.forbidsCell(dest);\n        }, { hallways: true, blockingMap });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(item);\n            map.addItem(loc[0], loc[1], item);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import { flag as Flag, utils as Utils, color as Color, make as Make, } from \"gw-utils\";\nimport { Tile as Flags, TileMech as MechFlags } from \"./flags\";\nimport * as TileEvent from \"./tileEvent\";\nimport * as Layer from \"./entity\";\nexport { Flags, MechFlags };\n/** Tile Class */\nexport class Tile extends Layer.Entity {\n    /**\n     * Creates a new Tile object.\n     * @param {Object} [config={}] - The configuration of the Tile\n     * @param {String|Number|String[]} [config.flags=0] - Flags and MechFlags for the tile\n     * @param {String} [config.layer=GROUND] - Name of the layer for this tile\n     * @param {String} [config.ch] - The sprite character\n     * @param {String} [config.fg] - The sprite foreground color\n     * @param {String} [config.bg] - The sprite background color\n     */\n    constructor(config) {\n        super((() => {\n            if (!config.Extends)\n                return config;\n            if (typeof config.Extends === \"string\") {\n                config.Extends = tiles[config.Extends];\n                if (!config.Extends)\n                    throw new Error(\"Unknown tile base - \" + config.Extends);\n            }\n            const base = config.Extends;\n            config.ch = Utils.first(config.ch, base.sprite.ch, -1);\n            config.fg = Utils.first(config.fg, base.sprite.fg, -1);\n            config.bg = Utils.first(config.bg, base.sprite.bg, -1);\n            config.layer = Utils.first(config.layer, base.layer);\n            config.priority = Utils.first(config.priority, base.priority);\n            config.opacity = Utils.first(config.opacity, base.sprite.opacity);\n            config.light = Utils.first(config.light, base.light);\n            return config;\n        })());\n        this.flags = { layer: 0, tile: 0, tileMech: 0 };\n        this.activates = {};\n        this.flavor = null;\n        this.desc = null;\n        this.article = null;\n        this.dissipate = 2000; // 20 * 100 = 20%\n        this.defaultGround = null;\n        let base = config.Extends;\n        if (base) {\n            Utils.assignOmitting([\"sprite\", \"depth\", \"priority\", \"activates\", \"flags\", \"light\"], this, base);\n            if (base.activates) {\n                Object.assign(this.activates, base.activates);\n            }\n            Object.assign(this.flags, base.flags);\n        }\n        Utils.assignOmitting([\n            \"Extends\",\n            \"extends\",\n            \"flags\",\n            \"layerFlags\",\n            \"mechFlags\",\n            \"sprite\",\n            \"activates\",\n            \"ch\",\n            \"fg\",\n            \"bg\",\n            \"opacity\",\n            \"light\",\n            \"layer\",\n            \"priority\",\n            \"flags\",\n            \"ground\",\n            \"light\",\n        ], this, config);\n        this.name = config.name || (base ? base.name : config.id);\n        this.id = config.id;\n        if (config.ground) {\n            this.defaultGround = config.ground;\n        }\n        // @ts-ignore\n        this.flags.tile = Flag.from(Flags, this.flags.tile, config.flags);\n        // @ts-ignore\n        this.flags.layer = Flag.from(Layer.Flags, this.flags.layer, config.layerFlags || config.flags);\n        // @ts-ignore\n        this.flags.tileMech = Flag.from(MechFlags, this.flags.tileMech, config.mechFlags || config.flags);\n        if (config.activates) {\n            Object.entries(config.activates).forEach(([key, info]) => {\n                if (info) {\n                    const activation = TileEvent.make(info);\n                    this.activates[key] = activation;\n                }\n                else {\n                    delete this.activates[key];\n                }\n            });\n        }\n    }\n    /**\n     * Returns whether or not this tile as the given flag.\n     * Will return true if any bit in the flag is true, so testing with\n     * multiple flags will return true if any of them is set.\n     * @param {number} flag - The flag to check\n     * @returns {boolean} Whether or not the flag is set\n     */\n    hasAllFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllLayerFlags(flag) {\n        return (this.flags.layer & flag) === flag;\n    }\n    hasAllMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksPathing() {\n        return (this.flags.layer & Layer.Flags.L_BLOCKS_MOVE ||\n            this.flags.tile & Flags.T_PATHING_BLOCKER);\n    }\n    activatesOn(name) {\n        return !!this.activates[name];\n    }\n    getName(arg) {\n        let opts = {};\n        if (arg === true || arg === false) {\n            opts.article = arg;\n        }\n        else if (typeof arg === \"string\") {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || \"white\";\n            }\n            if (typeof color !== \"string\") {\n                color = Color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === \"string\" ? opts.article : this.article || \"a\";\n            result = article + \" \" + result;\n        }\n        return result;\n    }\n    getDescription(opts = {}) {\n        return this.getName(opts);\n    }\n}\n// Types.Tile = Tile;\nexport function make(config) {\n    return new Tile(config);\n}\nMake.tile = make;\nexport const tiles = {};\nexport function install(...args) {\n    let id = args[0];\n    let base = args[1];\n    let config = args[2];\n    if (arguments.length == 1) {\n        config = args[0];\n        base = config.Extends || null;\n        id = config.id;\n    }\n    else if (arguments.length == 2) {\n        config = base;\n    }\n    if (typeof base === \"string\") {\n        config.Extends = tiles[base] || Utils.ERROR(\"Unknown base tile: \" + base);\n    }\n    // config.name = config.name || base.name || id.toLowerCase();\n    config.id = id;\n    const tile = make(config);\n    tiles[id] = tile;\n    return tile;\n}\n/**\n * Adds multiple tiles to the GW.tiles collection.\n * It extracts all the id:opts pairs from the config object and uses\n * them to call addTileKind.\n * @param {Object} config - The tiles to add in [id, config] pairs\n * @returns {void} Nothing\n * @see addTileKind\n */\nexport function installAll(config) {\n    Object.entries(config).forEach(([id, opts]) => {\n        opts.id = id;\n        install(id, opts);\n    });\n}\n","import { color as Color, sprite as Sprite, utils as Utils, config as CONFIG, data as DATA, random, make as Make, } from 'gw-utils';\nimport { Tile, tiles as TILES } from './tile';\nimport * as Activation from './tileEvent';\nimport * as Light from './light';\nimport * as Layer from './entity';\nimport { Cell as Flags, CellMech as MechFlags, Tile as TileFlags, Map as MapFlags, Layer as LayerFlags, Depth, } from './flags';\nexport { Flags, MechFlags };\n// TODO - Move to gw-ui\nColor.install('cursorColor', 25, 100, 150);\nCONFIG.cursorPathIntensity = 50;\nexport class CellMemory {\n    constructor() {\n        this.mixer = new Sprite.Mixer();\n        this.item = null;\n        this.itemQuantity = 0;\n        this.actor = null;\n        this.tile = null;\n        this.cellFlags = 0;\n        this.cellMechFlags = 0;\n        this.layerFlags = 0;\n        this.tileFlags = 0;\n        this.tileMechFlags = 0;\n    }\n    clear() {\n        this.mixer.nullify();\n        this.item = null;\n        this.itemQuantity = 0;\n        this.actor = null;\n        this.tile = null;\n        this.cellFlags = 0;\n        this.cellMechFlags = 0;\n        this.layerFlags = 0;\n        this.tileFlags = 0;\n        this.tileMechFlags = 0;\n    }\n    copy(other) {\n        const mixer = this.mixer;\n        Object.assign(this, other);\n        this.mixer = mixer;\n        this.mixer.copy(other.mixer);\n    }\n}\nexport class Cell {\n    constructor() {\n        this._tiles = [];\n        this.layers = null;\n        this._actor = null;\n        this._item = null;\n        this.data = {};\n        this.flags = Flags.CELL_DEFAULT; // non-terrain cell flags\n        this.mechFlags = 0;\n        this.gasVolume = 0; // quantity of gas in cell\n        this.liquidVolume = 0;\n        this.machineNumber = 0;\n        this.memory = new CellMemory();\n        this.light = [100, 100, 100];\n        this.oldLight = [100, 100, 100];\n        this.glowLight = [100, 100, 100];\n    }\n    copy(other) {\n        Utils.copyObject(this, other);\n    }\n    clear() {\n        for (let i = 0; i < this._tiles.length; ++i) {\n            this._tiles[i] = null;\n        }\n        this.layers = null;\n        this._actor = null;\n        this._item = null;\n        this.data = {};\n        this.flags = Flags.CELL_DEFAULT; // non-terrain cell flags\n        this.mechFlags = 0;\n        this.gasVolume = 0; // quantity of gas in cell\n        this.liquidVolume = 0;\n        this.machineNumber = 0;\n        this.memory.clear();\n        this.light = [100, 100, 100];\n        this.oldLight = [100, 100, 100];\n        this.glowLight = [100, 100, 100];\n    }\n    clearLayers(nullLiquid = false, nullSurface = false, nullGas = false) {\n        if (nullLiquid) {\n            this._tiles[1] = null;\n            this.liquidVolume = 0;\n        }\n        if (nullSurface) {\n            this._tiles[2] = null;\n        }\n        if (nullGas) {\n            this._tiles[3] = null;\n            this.gasVolume = 0;\n        }\n        this.flags |= Flags.CELL_CHANGED;\n    }\n    get ground() {\n        var _a;\n        return ((_a = this._tiles[Depth.GROUND]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get liquid() {\n        var _a;\n        return ((_a = this._tiles[Depth.LIQUID]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get surface() {\n        var _a;\n        return ((_a = this._tiles[Depth.SURFACE]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get gas() {\n        var _a;\n        return ((_a = this._tiles[Depth.GAS]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get groundTile() {\n        return this._tiles[Depth.GROUND] || TILES.NULL;\n    }\n    get liquidTile() {\n        return this._tiles[Depth.LIQUID] || TILES.NULL;\n    }\n    get surfaceTile() {\n        return this._tiles[Depth.SURFACE] || TILES.NULL;\n    }\n    get gasTile() {\n        return this._tiles[Depth.GAS] || TILES.NULL;\n    }\n    dump() {\n        if (this.actor)\n            return this.actor.sprite.ch;\n        if (this.item)\n            return this.item.sprite.ch;\n        for (let i = this._tiles.length - 1; i >= 0; --i) {\n            if (!this._tiles[i])\n                continue;\n            const tile = this._tiles[i] || TILES.NULL;\n            if (tile.sprite.ch)\n                return tile.sprite.ch;\n        }\n        return TILES.NULL.sprite.ch;\n    }\n    get changed() {\n        return (this.flags & Flags.CELL_CHANGED) > 0;\n    }\n    set changed(v) {\n        if (v) {\n            this.flags |= Flags.CELL_CHANGED;\n        }\n        else {\n            this.flags &= ~Flags.CELL_CHANGED;\n        }\n    }\n    isVisible() {\n        return this.flags & Flags.VISIBLE;\n    }\n    isAnyKindOfVisible() {\n        return (this.flags &\n            Flags.ANY_KIND_OF_VISIBLE /* || CONFIG.playbackOmniscience */);\n    }\n    isOrWasAnyKindOfVisible() {\n        return (this.flags &\n            Flags.IS_WAS_ANY_KIND_OF_VISIBLE /* || CONFIG.playbackOmniscience */);\n    }\n    isRevealed(orMapped = false) {\n        const flag = Flags.REVEALED | (orMapped ? Flags.MAGIC_MAPPED : 0);\n        return (this.flags & flag) > 0;\n    }\n    listInSidebar() {\n        return this.hasLayerFlag(LayerFlags.L_LIST_IN_SIDEBAR, true);\n    }\n    get needsRedraw() {\n        return (this.flags & Flags.NEEDS_REDRAW) > 0;\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags |= Flags.NEEDS_REDRAW;\n        }\n        else {\n            this.flags &= ~Flags.NEEDS_REDRAW;\n        }\n    }\n    // TODO - Use functions in LIGHT to check these on cell.light directly???\n    hasVisibleLight() {\n        return Light.intensity(this.light) > CONFIG.light.INTENSITY_DARK;\n    } // TODO\n    isDark(darkColor) {\n        const intensity = darkColor\n            ? Light.intensity(darkColor)\n            : CONFIG.light.INTENSITY_DARK;\n        return Light.intensity(this.light) <= intensity;\n    } // TODO\n    get lightChanged() {\n        return (this.flags & Flags.LIGHT_CHANGED) > 0;\n    }\n    set lightChanged(v) {\n        if (v) {\n            this.flags |= Flags.LIGHT_CHANGED | Flags.NEEDS_REDRAW;\n        }\n        else {\n            this.flags &= ~Flags.LIGHT_CHANGED;\n        }\n    }\n    tile(layer = Depth.GROUND) {\n        return this._tiles[layer] || TILES.NULL;\n    }\n    *tiles() {\n        for (let tile of this._tiles) {\n            if (tile) {\n                yield tile;\n            }\n        }\n    }\n    layerFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.layerFlags;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.layer;\n        }\n        return flags;\n    }\n    tileFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.tileFlags;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.tile;\n        }\n        return flags;\n    }\n    tileMechFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.tileMechFlags;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.tileMech;\n        }\n        return flags;\n    }\n    hasLayerFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = this.layerFlags(limitToPlayerKnowledge);\n        return !!(flag & flags);\n    }\n    hasAllLayerFlags(flag, limitToPlayerKnowledge = false) {\n        const flags = this.layerFlags(limitToPlayerKnowledge);\n        return (flag & flags) === flag;\n    }\n    hasTileFlag(flagMask, limitToPlayerKnowledge = false) {\n        const tileFlags = this.tileFlags(limitToPlayerKnowledge);\n        return !!(flagMask & tileFlags);\n    }\n    hasAllTileFlags(flags, limitToPlayerKnowledge = false) {\n        return (flags & this.tileFlags(limitToPlayerKnowledge)) === flags;\n    }\n    hasTileMechFlag(flagMask, limitToPlayerKnowledge = false) {\n        const mechFlags = this.tileMechFlags(limitToPlayerKnowledge);\n        return !!(flagMask & mechFlags);\n    }\n    hasAllTileMechFlags(flags, limitToPlayerKnowledge = false) {\n        return (flags & this.tileMechFlags(limitToPlayerKnowledge)) === flags;\n    }\n    setFlags(cellFlag = 0, cellMechFlag = 0) {\n        this.flags |= cellFlag;\n        this.mechFlags |= cellMechFlag;\n        // this.flags |= Flags.NEEDS_REDRAW;\n    }\n    clearFlags(cellFlag = 0, cellMechFlag = 0) {\n        this.flags &= ~cellFlag;\n        this.mechFlags &= ~cellMechFlag;\n        // if ((~cellFlag) & Flags.NEEDS_REDRAW) {\n        //   this.flags |= Flags.NEEDS_REDRAW;\n        // }\n    }\n    hasFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = limitToPlayerKnowledge && !this.isAnyKindOfVisible()\n            ? this.memory.cellFlags\n            : this.flags;\n        return (flag & flags) > 0;\n    }\n    hasMechFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = limitToPlayerKnowledge && !this.isAnyKindOfVisible()\n            ? this.memory.cellMechFlags\n            : this.mechFlags;\n        return (flag & flags) > 0;\n    }\n    hasTile(tile) {\n        let id;\n        if (tile instanceof Tile) {\n            id = tile.id;\n        }\n        else {\n            id = tile;\n        }\n        return this._tiles.some((t) => t && t.id === id);\n    }\n    // hasTileInGroup(...groups) {\n    //   if (groups.length == 1 && Array.isArray(groups[0])) {\n    //     groups = groups[0];\n    //   }\n    //   return this.layers.some( (tileId) => {\n    //     const tile = TILES[tileId] || TILES.NOTHING;\n    //     return Utils.intersect(groups, tile.groups);\n    //   });\n    // }\n    // promotedTileFlags() {\n    //   return this.successorTileFlags(\"promote\");\n    // }\n    // discoveredTileFlags() {\n    //   return this.successorTileFlags(\"discover\");\n    // }\n    // hasDiscoveredTileFlag(flag: number) {\n    //   // if (!this.hasTileMechFlag(TM_IS_SECRET)) return false;\n    //   return this.discoveredTileFlags() & flag;\n    // }\n    topmostTile(skipGas = false) {\n        let best = TILES.NULL;\n        let bestPriority = -10000;\n        for (let layer = Depth.GROUND; layer <= (skipGas ? Depth.LIQUID : Depth.GAS); ++layer) {\n            // @ts-ignore\n            const tile = this._tiles[layer];\n            if (!tile)\n                continue;\n            if (tile.priority > bestPriority) {\n                best = tile;\n                bestPriority = tile.priority;\n            }\n        }\n        return best;\n    }\n    tileWithLayerFlag(layerFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags.layer & layerFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileWithFlag(tileFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags.tile & tileFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileWithMechFlag(mechFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags.tileMech & mechFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileDesc() {\n        return this.topmostTile().desc;\n    }\n    tileFlavor() {\n        return this.topmostTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.topmostTile().getName(opts);\n    }\n    isClear() {\n        return this.ground == null;\n    }\n    isEmpty() {\n        return !(this._actor || this._item);\n    }\n    isMoveableNow(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.layerFlags\n            : this.layerFlags(false);\n        return (layerFlags & LayerFlags.L_BLOCKS_MOVE) === 0;\n    }\n    isWalkableNow(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.layerFlags\n            : this.layerFlags(false);\n        if (layerFlags & LayerFlags.L_BLOCKS_MOVE)\n            return false;\n        const tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        if (!(tileFlags & TileFlags.T_IS_DEEP_LIQUID))\n            return true;\n        return (tileFlags & TileFlags.T_BRIDGE) > 0;\n    }\n    canBeWalked(limitToPlayerKnowledge = false) {\n        if (this.isWalkableNow(limitToPlayerKnowledge))\n            return true;\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.layerFlags\n            : this.layerFlags(false);\n        return (layerFlags & LayerFlags.L_SECRETLY_PASSABLE) > 0;\n    }\n    isWall(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory ? this.memory.layerFlags : this.layerFlags();\n        return (layerFlags & LayerFlags.L_IS_WALL) === LayerFlags.L_IS_WALL;\n    }\n    isObstruction(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory ? this.memory.layerFlags : this.layerFlags();\n        return !!(layerFlags & LayerFlags.L_BLOCKS_DIAGONAL);\n    }\n    isDoorway(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory ? this.memory.layerFlags : this.layerFlags();\n        return ((layerFlags & LayerFlags.L_BLOCKS_VISION) > 0 &&\n            (layerFlags & LayerFlags.L_BLOCKS_MOVE) === 0);\n    }\n    isSecretDoorway(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge)\n            return false;\n        const layerFlags = this.layerFlags(limitToPlayerKnowledge);\n        return (layerFlags & LayerFlags.L_SECRETLY_PASSABLE) > 0;\n    }\n    blocksPathing(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        if (!this.isWalkableNow(limitToPlayerKnowledge))\n            return true;\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_PATHING_BLOCKER);\n    }\n    blocksVision() {\n        const layerFlags = this.layerFlags();\n        return !!(layerFlags & LayerFlags.L_BLOCKS_VISION);\n    }\n    isLiquid(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_IS_DEEP_LIQUID);\n    }\n    // TODO - Should this look at the tiles instead of the flags?\n    // What if a gas tile is not set with T_GAS?\n    // Should we force T_GAS if layer === GAS when creating a tile?\n    // Should these be cell flags - indicating we have this layer\n    hasGas(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let cellFlags = useMemory ? this.memory.cellFlags : this.flags;\n        return !!(cellFlags & Flags.HAS_GAS);\n    }\n    markRevealed() {\n        this.flags &= ~Flags.STABLE_MEMORY;\n        if (this.flags & Flags.REVEALED)\n            return false;\n        this.flags |= Flags.REVEALED;\n        return !this.isWall();\n    }\n    obstructsLayer(depth) {\n        return (depth === Depth.SURFACE &&\n            this.hasLayerFlag(LayerFlags.L_BLOCKS_SURFACE));\n    }\n    setTile(tileId = null, volume = 0, map) {\n        map = map || DATA.map;\n        let tile;\n        if (tileId === null) {\n            tile = TILES.NULL;\n            tileId = null;\n        }\n        else if (typeof tileId === 'string') {\n            tile = TILES[tileId];\n        }\n        else if (tileId instanceof Tile) {\n            tile = tileId;\n            tileId = tile.id;\n        }\n        if (!tile) {\n            return Utils.ERROR('Unknown tile - ' + tileId);\n        }\n        if (tile.layer > 0 && !this._tiles[0]) {\n            this.setTile(tile.defaultGround || TILES.FLOOR, 0, map); // TODO - do not use FLOOR?  Does map have the tile to use?\n        }\n        const oldTile = this._tiles[tile.layer] || TILES.NULL;\n        const oldTileId = oldTile === TILES.NULL ? null : oldTile.id;\n        if (oldTile.blocksPathing() != tile.blocksPathing()) {\n            DATA.staleLoopMap = true;\n        }\n        if (tile.flags.tile & TileFlags.T_IS_FIRE &&\n            !(oldTile.flags.tile & TileFlags.T_IS_FIRE)) {\n            this.mechFlags |= MechFlags.CAUGHT_FIRE_THIS_TURN;\n        }\n        const blocksVision = tile.flags.layer & LayerFlags.L_BLOCKS_VISION;\n        const oldBlocksVision = oldTile.flags.layer & LayerFlags.L_BLOCKS_VISION;\n        if (map &&\n            this.isAnyKindOfVisible() &&\n            blocksVision != oldBlocksVision) {\n            map.setFlag(MapFlags.MAP_FOV_CHANGED);\n        }\n        if (oldTileId !== null)\n            this.removeLayer(oldTile);\n        this._tiles[tile.layer] = tileId === null ? null : tile;\n        if (tileId !== null)\n            this.addLayer(tile);\n        let layerFlag = 0;\n        if (tile.layer == Depth.LIQUID) {\n            layerFlag = Flags.HAS_LIQUID;\n            this.liquidVolume =\n                volume + (tileId == oldTileId ? this.liquidVolume : 0);\n            if (map)\n                map.clearFlag(MapFlags.MAP_NO_LIQUID);\n        }\n        else if (tile.layer == Depth.GAS) {\n            layerFlag = Flags.HAS_GAS;\n            this.gasVolume =\n                volume + (tileId == oldTileId ? this.gasVolume : 0);\n            if (map)\n                map.clearFlag(MapFlags.MAP_NO_GAS);\n        }\n        else if (tile.layer === Depth.SURFACE) {\n            layerFlag = Flags.HAS_SURFACE;\n        }\n        if (tileId) {\n            this.flags |= layerFlag;\n        }\n        else {\n            this.flags &= ~layerFlag;\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n        this.flags |= Flags.CELL_CHANGED | Flags.NEEDS_REDRAW;\n        if (map && oldTile.light !== tile.light) {\n            map.clearFlag(MapFlags.MAP_STABLE_GLOW_LIGHTS | MapFlags.MAP_STABLE_LIGHTS);\n        }\n        return true;\n    }\n    clearLayer(depth) {\n        // @ts-ignore\n        if (typeof depth === 'string')\n            depth = Layer[depth];\n        const current = this._tiles[depth];\n        if (current) {\n            // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n            this.flags |= Flags.CELL_CHANGED;\n            this.removeLayer(current);\n        }\n        this._tiles[depth] = null;\n        let layerFlag = 0;\n        if (depth == Depth.LIQUID) {\n            layerFlag = Flags.HAS_LIQUID;\n            this.liquidVolume = 0;\n        }\n        else if (depth == Depth.GAS) {\n            layerFlag = Flags.HAS_GAS;\n            this.gasVolume = 0;\n        }\n        else if (depth == Depth.SURFACE) {\n            layerFlag = Flags.HAS_SURFACE;\n        }\n        this.flags &= ~layerFlag;\n    }\n    clearLayersExcept(except = Depth.GROUND, ground) {\n        const floorTile = ground ? TILES[ground] : this.groundTile;\n        for (let layer = 0; layer < this._tiles.length; layer++) {\n            if (layer != except && layer != Depth.GAS) {\n                if (layer === Depth.GROUND) {\n                    if (floorTile !== this.groundTile)\n                        this.setTile(floorTile);\n                }\n                else {\n                    this.clearLayer(layer);\n                }\n            }\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n        this.flags |= Flags.CELL_CHANGED;\n    }\n    clearLayersWithFlags(tileFlags, tileMechFlags = 0) {\n        for (let i = 0; i < this._tiles.length; ++i) {\n            const tile = this._tiles[i];\n            if (!tile)\n                continue;\n            if (tileFlags && tileMechFlags) {\n                if (tile.flags.tile & tileFlags &&\n                    tile.flags.tileMech & tileMechFlags) {\n                    this.clearLayer(i);\n                }\n            }\n            else if (tileFlags) {\n                if (tile.flags.tile & tileFlags) {\n                    this.clearLayer(i);\n                }\n            }\n            else if (tileMechFlags) {\n                if (tile.flags.tileMech & tileMechFlags) {\n                    this.clearLayer(i);\n                }\n            }\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n    }\n    // EVENTS\n    async activate(name, ctx = {}) {\n        ctx.cell = this;\n        let fired = false;\n        // cell.debug(\"fire event - %s\", name);\n        for (let tile of this.tiles()) {\n            if (!tile.activates)\n                continue;\n            const ev = tile.activates[name];\n            if (ev) {\n                // cell.debug(\" - has event\");\n                if (ev.chance && !random.chance(ev.chance, 10000)) {\n                    continue;\n                }\n                ctx.tile = tile;\n                // cell.debug(\" - spawn event @%d,%d - %s\", ctx.x, ctx.y, name);\n                fired = (await Activation.spawn(ev, ctx)) || fired;\n                // cell.debug(\" - spawned\");\n                if (fired) {\n                    break;\n                }\n            }\n        }\n        if (fired) {\n            // this.mechFlags |= MechFlags.EVENT_FIRED_THIS_TURN;\n        }\n        return fired;\n    }\n    activatesOn(name) {\n        for (let tile of this.tiles()) {\n            if (tile.activatesOn(name))\n                return true;\n        }\n        return false;\n    }\n    // ITEM\n    get item() {\n        return this._item;\n    }\n    set item(item) {\n        if (this.item) {\n            this.removeLayer(this.item);\n        }\n        this._item = item;\n        if (item) {\n            this.flags |= Flags.HAS_ITEM;\n            this.addLayer(item);\n        }\n        else {\n            this.flags &= ~Flags.HAS_ITEM;\n        }\n    }\n    // ACTOR\n    get actor() {\n        return this._actor;\n    }\n    set actor(actor) {\n        if (this.actor) {\n            this.removeLayer(this.actor);\n        }\n        this._actor = actor;\n        if (actor) {\n            this.flags |= Flags.HAS_ANY_ACTOR;\n            this.addLayer(actor);\n        }\n        else {\n            this.flags &= ~Flags.HAS_ANY_ACTOR;\n        }\n    }\n    addLayer(layer) {\n        if (!layer)\n            return;\n        // this.flags |= Flags.NEEDS_REDRAW;\n        this.flags |= Flags.CELL_CHANGED;\n        let current = this.layers;\n        if (!current ||\n            current.layer.layer > layer.layer ||\n            (current.layer.layer == layer.layer &&\n                current.layer.priority > layer.priority)) {\n            this.layers = {\n                layer,\n                next: current,\n            };\n            return;\n        }\n        while (current.next &&\n            (current.layer.layer < layer.layer ||\n                (current.layer.layer == layer.layer &&\n                    current.layer.priority <= layer.priority))) {\n            current = current.next;\n        }\n        const item = {\n            layer,\n            next: current.next,\n        };\n        current.next = item;\n    }\n    removeLayer(layer) {\n        if (!layer)\n            return false;\n        if (!this.layers)\n            return false;\n        // this.flags |= Flags.NEEDS_REDRAW;\n        this.flags |= Flags.CELL_CHANGED;\n        if (this.layers && this.layers.layer === layer) {\n            this.layers = this.layers.next;\n            return true;\n        }\n        let prev = this.layers;\n        let current = this.layers.next;\n        while (current) {\n            if (current.layer === layer) {\n                prev.next = current.next;\n                return true;\n            }\n            prev = current;\n            current = current.next;\n        }\n        return false;\n    }\n    // MEMORY\n    storeMemory() {\n        const memory = this.memory;\n        memory.tileFlags = this.tileFlags();\n        memory.tileMechFlags = this.tileMechFlags();\n        memory.layerFlags = this.layerFlags();\n        memory.cellFlags = this.flags;\n        memory.cellMechFlags = this.mechFlags;\n        memory.tile = this.topmostTile();\n        if (this.item) {\n            memory.item = this.item;\n            memory.itemQuantity = this.item.quantity;\n        }\n        else {\n            memory.item = null;\n            memory.itemQuantity = 0;\n        }\n        memory.actor = this.actor;\n        getAppearance(this, memory.mixer);\n        if (this.actor && this.isOrWasAnyKindOfVisible()) {\n            if (this.actor.rememberedInCell &&\n                this.actor.rememberedInCell !== this) {\n                // console.log(\"remembered in cell change\");\n                this.actor.rememberedInCell.storeMemory();\n                this.actor.rememberedInCell.flags |= Flags.NEEDS_REDRAW;\n            }\n            this.actor.rememberedInCell = this;\n        }\n    }\n}\nexport function make(tile) {\n    const cell = new Cell();\n    if (tile) {\n        cell.setTile(tile);\n    }\n    return cell;\n}\nMake.cell = make;\nexport function getAppearance(cell, dest) {\n    const memory = cell.memory.mixer;\n    memory.blackOut();\n    let needDistinctness = cell.layerFlags() & LayerFlags.L_VISUALLY_DISTINCT;\n    let current = cell.layers;\n    while (current) {\n        const layer = current.layer;\n        let alpha = layer.sprite.opacity || 100;\n        if (layer.layer == Depth.LIQUID) {\n            alpha = Utils.clamp(cell.liquidVolume * 34, 20, 100);\n        }\n        else if (layer.layer == Depth.GAS) {\n            alpha = Utils.clamp(cell.gasVolume * 34, 20, 100);\n        }\n        memory.drawSprite(layer.sprite, alpha);\n        current = current.next;\n    }\n    memory.fg.multiply(cell.light);\n    memory.bg.multiply(cell.light);\n    memory.bake(!cell.isAnyKindOfVisible()); // turns off dancing if not visible\n    if (needDistinctness) {\n        Color.separate(memory.fg, memory.bg);\n    }\n    dest.drawSprite(memory);\n    return true;\n}\n","import * as GW from \"gw-utils\";\nimport * as Flags from \"./flags\";\nimport * as Map from \"./map\";\nfunction demoteCellVisibility(cell) {\n    cell.flags &= ~(Flags.Cell.WAS_ANY_KIND_OF_VISIBLE | Flags.Cell.IN_FOV);\n    if (cell.flags & Flags.Cell.VISIBLE) {\n        cell.flags &= ~Flags.Cell.VISIBLE;\n        cell.flags |= Flags.Cell.WAS_VISIBLE;\n    }\n    if (cell.flags & Flags.Cell.CLAIRVOYANT_VISIBLE) {\n        cell.flags &= ~Flags.Cell.CLAIRVOYANT_VISIBLE;\n        cell.flags |= Flags.Cell.WAS_CLAIRVOYANT_VISIBLE;\n    }\n    if (cell.flags & Flags.Cell.TELEPATHIC_VISIBLE) {\n        cell.flags &= ~Flags.Cell.TELEPATHIC_VISIBLE;\n        cell.flags |= Flags.Cell.WAS_TELEPATHIC_VISIBLE;\n    }\n}\nfunction _updateCellVisibility(cell, i, j, map) {\n    const isVisible = cell.flags & Flags.Cell.VISIBLE;\n    const wasVisible = cell.flags & Flags.Cell.WAS_VISIBLE;\n    if (isVisible && wasVisible) {\n        if (cell.lightChanged) {\n            map.redrawCell(cell);\n        }\n    }\n    else if (isVisible && !wasVisible) {\n        // if the cell became visible this move\n        if (!(cell.flags & Flags.Cell.REVEALED) && GW.data.automationActive) {\n            if (cell.item) {\n                const theItem = cell.item;\n                if (theItem.hasLayerFlag(Flags.Layer.L_INTERRUPT_WHEN_SEEN)) {\n                    GW.message.add(\"§you§ §see§ ΩitemMessageColorΩ§item§∆.\", {\n                        item: theItem,\n                        actor: GW.data.player,\n                    });\n                }\n            }\n            if (!(cell.flags & Flags.Cell.MAGIC_MAPPED) &&\n                cell.hasLayerFlag(Flags.Layer.L_INTERRUPT_WHEN_SEEN)) {\n                const tile = cell.tileWithLayerFlag(Flags.Layer.L_INTERRUPT_WHEN_SEEN);\n                if (tile) {\n                    GW.message.add(\"§you§ §see§ ΩbackgroundMessageColorΩ§item§∆.\", {\n                        actor: GW.data.player,\n                        item: tile.name,\n                    });\n                }\n            }\n        }\n        map.markRevealed(i, j);\n        map.redrawCell(cell);\n    }\n    else if (!isVisible && wasVisible) {\n        // if the cell ceased being visible this move\n        cell.storeMemory();\n        map.redrawCell(cell);\n    }\n    return isVisible;\n}\nfunction _updateCellClairyvoyance(cell, _i, _j, map) {\n    const isClairy = cell.flags & Flags.Cell.CLAIRVOYANT_VISIBLE;\n    const wasClairy = cell.flags & Flags.Cell.WAS_CLAIRVOYANT_VISIBLE;\n    if (isClairy && wasClairy) {\n        if (cell.lightChanged) {\n            map.redrawCell(cell);\n        }\n    }\n    else if (!isClairy && wasClairy) {\n        // ceased being clairvoyantly visible\n        cell.storeMemory();\n        map.redrawCell(cell);\n    }\n    else if (!wasClairy && isClairy) {\n        // became clairvoyantly visible\n        cell.flags &= ~Flags.Cell.STABLE_MEMORY;\n        map.redrawCell(cell);\n    }\n    return isClairy;\n}\nfunction _updateCellTelepathy(cell, _i, _j, map) {\n    const isTele = cell.flags & Flags.Cell.TELEPATHIC_VISIBLE;\n    const wasTele = cell.flags & Flags.Cell.WAS_TELEPATHIC_VISIBLE;\n    if (isTele && wasTele) {\n        if (cell.lightChanged) {\n            map.redrawCell(cell);\n        }\n    }\n    else if (!isTele && wasTele) {\n        // ceased being telepathically visible\n        cell.storeMemory();\n        map.redrawCell(cell);\n    }\n    else if (!wasTele && isTele) {\n        // became telepathically visible\n        if (!(cell.flags & Flags.Cell.REVEALED) &&\n            !cell.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER)) {\n            GW.data.xpxpThisTurn++;\n        }\n        cell.flags &= ~Flags.Cell.STABLE_MEMORY;\n        map.redrawCell(cell);\n    }\n    return isTele;\n}\nfunction _updateCellDetect(cell, _i, _j, map) {\n    const isMonst = cell.flags & Flags.Cell.MONSTER_DETECTED;\n    const wasMonst = cell.flags & Flags.Cell.WAS_MONSTER_DETECTED;\n    if (isMonst && wasMonst) {\n        if (cell.lightChanged) {\n            map.redrawCell(cell);\n        }\n    }\n    else if (!isMonst && wasMonst) {\n        // ceased being detected visible\n        cell.flags &= ~Flags.Cell.STABLE_MEMORY;\n        map.redrawCell(cell);\n        cell.storeMemory();\n    }\n    else if (!wasMonst && isMonst) {\n        // became detected visible\n        cell.flags &= ~Flags.Cell.STABLE_MEMORY;\n        map.redrawCell(cell);\n        cell.storeMemory();\n    }\n    return isMonst;\n}\nfunction promoteCellVisibility(cell, i, j, map) {\n    if (cell.flags & Flags.Cell.IN_FOV &&\n        map.hasVisibleLight(i, j) &&\n        !(cell.mechFlags & Flags.CellMech.DARKENED)) {\n        cell.flags |= Flags.Cell.VISIBLE;\n    }\n    if (_updateCellVisibility(cell, i, j, map))\n        return;\n    if (_updateCellClairyvoyance(cell, i, j, map))\n        return;\n    if (_updateCellTelepathy(cell, i, j, map))\n        return;\n    if (_updateCellDetect(cell, i, j, map))\n        return;\n}\nexport function initMap(map) {\n    if (!(map.flags & Map.Flags.MAP_CALC_FOV)) {\n        map.forEach((cell) => (cell.flags |= Flags.Cell.REVEALED));\n        return;\n    }\n    map.clearFlags(0, Flags.Cell.IS_WAS_ANY_KIND_OF_VISIBLE);\n}\nexport function update(map, x, y, maxRadius) {\n    if (!(map.flags & Map.Flags.MAP_CALC_FOV) || !map.fov)\n        return false;\n    if (x == map.fov.x && y == map.fov.y) {\n        if (!(map.flags & Flags.Map.MAP_FOV_CHANGED))\n            return false;\n    }\n    map.flags &= ~Flags.Map.MAP_FOV_CHANGED;\n    map.fov.x = x;\n    map.fov.y = y;\n    map.forEach(demoteCellVisibility);\n    // Calculate player's field of view (distinct from what is visible, as lighting hasn't been done yet).\n    const grid = GW.grid.alloc(map.width, map.height, 0);\n    map.calcFov(grid, x, y, maxRadius);\n    grid.forEach((v, i, j) => {\n        if (v) {\n            map.setCellFlags(i, j, Flags.Cell.IN_FOV);\n        }\n    });\n    GW.grid.free(grid);\n    map.setCellFlags(x, y, Flags.Cell.IN_FOV | Flags.Cell.VISIBLE);\n    // if (PLAYER.bonus.clairvoyance < 0) {\n    //   discoverCell(PLAYER.xLoc, PLAYER.yLoc);\n    // }\n    //\n    // if (PLAYER.bonus.clairvoyance != 0) {\n    // \tupdateClairvoyance();\n    // }\n    //\n    // updateTelepathy();\n    // updateMonsterDetection();\n    // updateLighting();\n    map.forEach(promoteCellVisibility);\n    // if (PLAYER.status.hallucinating > 0) {\n    // \tfor (theItem of DUNGEON.items) {\n    // \t\tif ((pmap[theItem.xLoc][theItem.yLoc].flags & DISCOVERED) && refreshDisplay) {\n    // \t\t\trefreshDungeonCell(theItem.xLoc, theItem.yLoc);\n    // \t\t}\n    // \t}\n    // \tfor (monst of DUNGEON.monsters) {\n    // \t\tif ((pmap[monst.xLoc][monst.yLoc].flags & DISCOVERED) && refreshDisplay) {\n    // \t\t\trefreshDungeonCell(monst.xLoc, monst.yLoc);\n    // \t\t}\n    // \t}\n    // }\n    return true;\n}\n","import { utils as Utils, random, grid as Grid, fov as Fov, flag as Flag, path as Path, color as Color, colors as COLORS, config as CONFIG, data as DATA, make as Make, sprite as Sprite, } from 'gw-utils';\nimport * as Cell from './cell';\nimport { Map as Flags, Cell as CellFlags, Tile as TileFlags, CellMech as CellMechFlags, Depth as TileLayer, Layer as LayerFlags, } from './flags';\nimport * as Light from './light';\nimport * as Layer from './entity';\nimport * as Visibility from './visibility';\nexport { Flags };\nUtils.setDefaults(CONFIG, {\n    'map.deepestLevel': 99,\n});\nexport class Map {\n    constructor(w, h, opts = {}) {\n        this.locations = {};\n        this.config = {};\n        this._actors = null;\n        this._items = null;\n        this.flags = 0;\n        this.lights = null;\n        this.fov = null;\n        this._width = w;\n        this._height = h;\n        this.cells = Grid.make(w, h, () => new Cell.Cell());\n        this.locations = opts.locations || {};\n        this.config = Object.assign({}, opts);\n        this.config.tick = this.config.tick || 100;\n        this._actors = null;\n        this._items = null;\n        this.flags = Flag.from(Flags, Flags.MAP_DEFAULT, opts.flags);\n        const ambient = opts.ambient || opts.ambientLight || opts.light || 'white';\n        this.ambientLight = Color.make(ambient);\n        if (opts.ambient || opts.ambientLight || opts.light) {\n            this.ambientLightChanged = true;\n        }\n        this.lights = null;\n        this.id = opts.id;\n        if (this.config.fov) {\n            this.flags |= Flags.MAP_CALC_FOV;\n            this.fov = { x: -1, y: -1 };\n        }\n        Light.updateLighting(this); // to set the ambient light\n        Visibility.initMap(this);\n    }\n    get width() {\n        return this._width;\n    }\n    get height() {\n        return this._height;\n    }\n    async start() { }\n    clear() {\n        this.cells.forEach((c) => c.clear());\n        this.changed = true;\n    }\n    dump(fmt) {\n        this.cells.dump(fmt || ((c) => c.dump()));\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    eachCell(fn) {\n        this.cells.forEach((c, i, j) => fn(c, i, j, this));\n    }\n    forEach(fn) {\n        this.cells.forEach((c, i, j) => fn(c, i, j, this));\n    }\n    forRect(x, y, w, h, fn) {\n        this.cells.forRect(x, y, w, h, (c, i, j) => fn(c, i, j, this));\n    }\n    eachNeighbor(x, y, fn, only4dirs = false) {\n        this.cells.eachNeighbor(x, y, (c, i, j) => fn(c, i, j, this), only4dirs);\n    }\n    randomEach(fn) {\n        this.cells.randomEach((c, i, j) => fn(c, i, j, this));\n    }\n    count(fn) {\n        let count = 0;\n        this.forEach((c, x, y, g) => {\n            if (fn(c, x, y, g)) {\n                ++count;\n            }\n        });\n        return count;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.cells.isBoundaryXY(x, y);\n    }\n    get changed() {\n        return (this.flags & Flags.MAP_CHANGED) > 0;\n    }\n    set changed(v) {\n        if (v === true) {\n            this.flags |= Flags.MAP_CHANGED;\n        }\n        else if (v === false) {\n            this.flags &= ~Flags.MAP_CHANGED;\n        }\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).flags & flag;\n    }\n    hasCellMechFlag(x, y, flag) {\n        return this.cell(x, y).mechFlags & flag;\n    }\n    hasLayerFlag(x, y, flag) {\n        return this.cell(x, y).hasLayerFlag(flag);\n    }\n    hasTileFlag(x, y, flag) {\n        return this.cell(x, y).hasTileFlag(flag);\n    }\n    hasTileMechFlag(x, y, flag) {\n        return this.cell(x, y).hasTileMechFlag(flag);\n    }\n    redrawCell(cell) {\n        // if (cell.isAnyKindOfVisible()) {\n        cell.needsRedraw = true;\n        this.flags |= Flags.MAP_CHANGED;\n        // }\n    }\n    redrawXY(x, y) {\n        const cell = this.cell(x, y);\n        this.redrawCell(cell);\n    }\n    redrawAll() {\n        this.forEach((c) => {\n            // if (c.isAnyKindOfVisible()) {\n            c.needsRedraw = true;\n            // }\n        });\n        this.changed = true;\n    }\n    drawInto(canvas, opts = {}) {\n        Light.updateLighting(this);\n        if (typeof opts === 'boolean')\n            opts = { force: opts };\n        const mixer = new Sprite.Mixer();\n        for (let x = 0; x < canvas.width; ++x) {\n            for (let y = 0; y < canvas.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.needsRedraw || opts.force) {\n                    getCellAppearance(this, x, y, mixer);\n                    const glyph = typeof mixer.ch === 'number'\n                        ? mixer.ch\n                        : canvas.toGlyph(mixer.ch);\n                    canvas.draw(x, y, glyph, mixer.fg.toInt(), mixer.bg.toInt());\n                    cell.needsRedraw = false;\n                }\n            }\n        }\n    }\n    revealAll() {\n        this.forEach((c) => {\n            c.markRevealed();\n            c.storeMemory();\n        });\n        if (DATA.player) {\n            DATA.player.invalidateCostMap();\n        }\n    }\n    markRevealed(x, y) {\n        if (!this.cell(x, y).markRevealed())\n            return;\n        if (DATA.player) {\n            DATA.player.invalidateCostMap();\n        }\n    }\n    makeVisible(v = true) {\n        if (v) {\n            this.setFlags(0, Cell.Flags.VISIBLE);\n        }\n        else {\n            this.clearFlags(0, Cell.Flags.ANY_KIND_OF_VISIBLE);\n        }\n    }\n    isVisible(x, y) {\n        return this.cell(x, y).isVisible();\n    }\n    isAnyKindOfVisible(x, y) {\n        return this.cell(x, y).isAnyKindOfVisible();\n    }\n    isOrWasAnyKindOfVisible(x, y) {\n        return this.cell(x, y).isOrWasAnyKindOfVisible();\n    }\n    isRevealed(x, y) {\n        return this.cell(x, y).isRevealed();\n    }\n    get anyLightChanged() {\n        return (this.flags & Flags.MAP_STABLE_LIGHTS) == 0;\n    }\n    set anyLightChanged(v) {\n        if (v) {\n            this.flags &= ~Flags.MAP_STABLE_LIGHTS;\n        }\n        else {\n            this.flags |= Flags.MAP_STABLE_LIGHTS;\n        }\n    }\n    get ambientLightChanged() {\n        return this.staticLightChanged;\n    }\n    set ambientLightChanged(v) {\n        this.staticLightChanged = v;\n    }\n    get staticLightChanged() {\n        return (this.flags & Flags.MAP_STABLE_GLOW_LIGHTS) == 0;\n    }\n    set staticLightChanged(v) {\n        if (v) {\n            this.flags &= ~(Flags.MAP_STABLE_GLOW_LIGHTS | Flags.MAP_STABLE_LIGHTS);\n        }\n        else {\n            this.flags |= Flags.MAP_STABLE_GLOW_LIGHTS;\n        }\n    }\n    setFlag(flag) {\n        this.flags |= flag;\n        this.changed = true;\n    }\n    setFlags(mapFlag = 0, cellFlag = 0, cellMechFlag = 0) {\n        if (mapFlag) {\n            this.flags |= mapFlag;\n        }\n        if (cellFlag || cellMechFlag) {\n            this.forEach((c) => c.setFlags(cellFlag, cellMechFlag));\n        }\n        this.changed = true;\n    }\n    clearFlag(flag) {\n        this.flags &= ~flag;\n        this.changed = true;\n    }\n    clearFlags(mapFlag = 0, cellFlag = 0, cellMechFlag = 0) {\n        if (mapFlag) {\n            this.flags &= ~mapFlag;\n        }\n        if (cellFlag || cellMechFlag) {\n            this.forEach((cell) => cell.clearFlags(cellFlag, cellMechFlag));\n        }\n        this.changed = true;\n    }\n    // setCellFlag(x: number, y: number, flag: number) {\n    //   this.cell(x, y).flags |= flag;\n    // }\n    setCellFlags(x, y, cellFlag = 0, cellMechFlag = 0) {\n        this.cell(x, y).setFlags(cellFlag, cellMechFlag);\n        this.flags |= Flags.MAP_CHANGED;\n    }\n    clearCellFlags(x, y, cellFlags = 0, cellMechFlags = 0) {\n        this.cell(x, y).clearFlags(cellFlags, cellMechFlags);\n        this.changed = true;\n    }\n    hasTile(x, y, tile) {\n        return this.cells[x][y].hasTile(tile);\n    }\n    layerFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].layerFlags(limitToPlayerKnowledge);\n    }\n    tileFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].tileFlags(limitToPlayerKnowledge);\n    }\n    tileMechFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].tileMechFlags(limitToPlayerKnowledge);\n    }\n    tileWithLayerFlag(x, y, mechFlag = 0) {\n        return this.cells[x][y].tileWithLayerFlag(mechFlag);\n    }\n    tileWithFlag(x, y, flag = 0) {\n        return this.cells[x][y].tileWithFlag(flag);\n    }\n    tileWithMechFlag(x, y, mechFlag = 0) {\n        return this.cells[x][y].tileWithMechFlag(mechFlag);\n    }\n    hasKnownTileFlag(x, y, flagMask = 0) {\n        return this.cells[x][y].memory.tileFlags & flagMask;\n    }\n    // hasTileInGroup(x, y, ...groups) { return this.cells[x][y].hasTileInGroup(...groups); }\n    // discoveredTileFlags(x: number, y: number) {\n    //   return this.cells[x][y].discoveredTileFlags();\n    // }\n    // hasDiscoveredTileFlag(x: number, y: number, flag = 0) {\n    //   return this.cells[x][y].hasDiscoveredTileFlag(flag);\n    // }\n    isClear(x, y) {\n        return this.cells[x][y].isClear();\n    }\n    isEmpty(x, y) {\n        return this.cells[x][y].isEmpty();\n    }\n    isObstruction(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isObstruction(limitToPlayerKnowledge);\n    }\n    isDoorway(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isDoorway(limitToPlayerKnowledge);\n    }\n    isSecretDoorway(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isSecretDoorway(limitToPlayerKnowledge);\n    }\n    isLiquid(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isLiquid(limitToPlayerKnowledge);\n    }\n    hasGas(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].hasGas(limitToPlayerKnowledge);\n    }\n    blocksPathing(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].blocksPathing(limitToPlayerKnowledge);\n    }\n    blocksVision(x, y) {\n        return this.cells[x][y].blocksVision();\n    }\n    isMoveableNow(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isMoveableNow(limitToPlayerKnowledge);\n    }\n    isWalkableNow(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isWalkableNow(limitToPlayerKnowledge);\n    }\n    canBeWalked(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].canBeWalked(limitToPlayerKnowledge);\n    }\n    topmostTile(x, y, skipGas = false) {\n        return this.cells[x][y].topmostTile(skipGas);\n    }\n    tileFlavor(x, y) {\n        return this.cells[x][y].tileFlavor();\n    }\n    setTile(x, y, tileId, volume = 0) {\n        return this.cell(x, y).setTile(tileId, volume, this);\n    }\n    clearCell(x, y) {\n        this.cell(x, y).clear();\n    }\n    clearCellLayersWithFlags(x, y, tileFlags, tileMechFlags = 0) {\n        const cell = this.cell(x, y);\n        cell.clearLayersWithFlags(tileFlags, tileMechFlags);\n    }\n    clearCellLayers(x, y, nullLiquid = true, nullSurface = true, nullGas = true) {\n        this.changed = true;\n        return this.cell(x, y).clearLayers(nullLiquid, nullSurface, nullGas);\n    }\n    fill(tileId, boundaryTile) {\n        let i, j;\n        if (boundaryTile === undefined) {\n            boundaryTile = tileId;\n        }\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                if (this.isBoundaryXY(i, j)) {\n                    this.setTile(i, j, boundaryTile);\n                }\n                else {\n                    this.setTile(i, j, tileId);\n                }\n            }\n        }\n    }\n    neighborCount(x, y, matchFn, only4dirs = false) {\n        let count = 0;\n        this.eachNeighbor(x, y, (...args) => {\n            if (matchFn(...args))\n                ++count;\n        }, only4dirs);\n        return count;\n    }\n    walkableArcCount(x, y) {\n        if (!this.hasXY(x, y))\n            return -1;\n        return this.cells.arcCount(x, y, (c) => c.isWalkableNow());\n    }\n    diagonalBlocked(x1, y1, x2, y2, limitToPlayerKnowledge = false) {\n        if (x1 == x2 || y1 == y2) {\n            return false; // If it's not a diagonal, it's not diagonally blocked.\n        }\n        if (this.isObstruction(x1, y2, limitToPlayerKnowledge)) {\n            return true;\n        }\n        if (this.isObstruction(x2, y1, limitToPlayerKnowledge)) {\n            return true;\n        }\n        return false;\n    }\n    fillCostGrid(costGrid, costFn) {\n        costFn =\n            costFn ||\n                ((c) => (c.isWalkableNow() ? 1 : Path.OBSTRUCTION));\n        this.cells.forEach((cell, i, j) => {\n            if (cell.isClear()) {\n                costGrid[i][j] = Path.OBSTRUCTION;\n            }\n            else {\n                costGrid[i][j] = costFn(cell, i, j, this);\n            }\n        });\n    }\n    matchingNeighbor(x, y, matcher, only4dirs = false) {\n        const maxIndex = only4dirs ? 4 : 8;\n        for (let d = 0; d < maxIndex; ++d) {\n            const dir = Utils.DIRS[d];\n            const i = x + dir[0];\n            const j = y + dir[1];\n            if (this.hasXY(i, j)) {\n                if (matcher(this.cells[i][j], i, j, this))\n                    return [i, j];\n            }\n        }\n        return [-1, -1];\n    }\n    matchingLocNear(x, y, ...args) {\n        let i, j, k;\n        let matcher = args[0];\n        let opts = args[1] || {};\n        const arg = args[0];\n        if (typeof arg !== 'function') {\n            opts = arg || args[1];\n            matcher = opts.match || Utils.TRUE;\n        }\n        const hallwaysAllowed = opts.hallways || false;\n        const blockingMap = opts.blockingMap || null;\n        const forbidLiquid = opts.liquids === false;\n        const deterministic = opts.deterministic || false;\n        const candidateLocs = [];\n        // count up the number of candidate locations\n        for (k = 0; k < Math.max(this.width, this.height) && !candidateLocs.length; k++) {\n            for (i = x - k; i <= x + k; i++) {\n                for (j = y - k; j <= y + k; j++) {\n                    if (!this.hasXY(i, j))\n                        continue;\n                    const cell = this.cell(i, j);\n                    // if ((i == x-k || i == x+k || j == y-k || j == y+k)\n                    if (Math.ceil(Utils.distanceBetween(x, y, i, j)) == k &&\n                        (!blockingMap || !blockingMap[i][j]) &&\n                        matcher(cell, i, j, this) &&\n                        (!forbidLiquid || !cell.liquid) &&\n                        (hallwaysAllowed || this.walkableArcCount(i, j) < 2)) {\n                        candidateLocs.push([i, j]);\n                    }\n                }\n            }\n        }\n        if (candidateLocs.length == 0) {\n            return [-1, -1];\n        }\n        // and pick one\n        let randIndex = 0;\n        if (deterministic) {\n            randIndex = Math.floor(candidateLocs.length / 2);\n        }\n        else {\n            randIndex = random.number(candidateLocs.length);\n        }\n        return candidateLocs[randIndex];\n    }\n    randomMatchingLoc(opts = {}) {\n        let x;\n        let y;\n        let cell;\n        if (typeof opts === 'function') {\n            opts = { match: opts };\n        }\n        const sequence = random.sequence(this.width * this.height);\n        const hallwaysAllowed = opts.hallways || false;\n        const blockingMap = opts.blockingMap || null;\n        const forbidLiquid = opts.liquids === false;\n        const matcher = opts.match || Utils.TRUE;\n        const forbidCellFlags = opts.forbidCellFlags || 0;\n        const forbidTileFlags = opts.forbidTileFlags || 0;\n        const forbidTileMechFlags = opts.forbidTileMechFlags || 0;\n        const tile = opts.tile || null;\n        let success = false;\n        let index = 0;\n        while (!success && index < sequence.length) {\n            const v = sequence[index];\n            x = v % this.width;\n            y = Math.floor(v / this.width);\n            cell = this.cell(x, y);\n            if ((!blockingMap || !blockingMap[x][y]) &&\n                (!tile || cell.hasTile(tile)) &&\n                (!forbidLiquid || !cell.liquid) &&\n                (!forbidCellFlags || !(cell.flags & forbidCellFlags)) &&\n                (!forbidTileFlags || !cell.hasTileFlag(forbidTileFlags)) &&\n                (!forbidTileMechFlags ||\n                    !cell.hasTileMechFlag(forbidTileMechFlags)) &&\n                (hallwaysAllowed || this.walkableArcCount(x, y) < 2) &&\n                matcher(cell, x, y, this)) {\n                success = true;\n            }\n            ++index;\n        }\n        if (!success) {\n            // map.debug('randomMatchingLocation', dungeonType, liquidType, terrainType, ' => FAIL');\n            return [-1, -1];\n        }\n        // map.debug('randomMatchingLocation', dungeonType, liquidType, terrainType, ' => ', x, y);\n        return [x, y];\n    }\n    // LIGHT\n    hasVisibleLight(x, y) {\n        return this.cell(x, y).hasVisibleLight();\n    }\n    addStaticLight(x, y, light) {\n        const info = { x, y, light, next: this.lights };\n        this.lights = info;\n        this.staticLightChanged = true;\n        return info;\n    }\n    removeStaticLight(x, y, light) {\n        let prev = this.lights;\n        if (!prev)\n            return;\n        function matches(info) {\n            if (info.x != x || info.y != y)\n                return false;\n            return !light || light === info.light;\n        }\n        this.staticLightChanged = true;\n        while (prev && matches(prev)) {\n            prev = this.lights = prev.next;\n        }\n        if (!prev)\n            return;\n        let current = prev.next;\n        while (current) {\n            if (matches(current)) {\n                prev.next = current.next;\n            }\n            else {\n                prev = current;\n            }\n            current = current.next;\n        }\n    }\n    eachStaticLight(fn) {\n        Utils.eachChain(this.lights, (info) => fn(info.light, info.x, info.y));\n        this.eachCell((cell, x, y) => {\n            for (let tile of cell.tiles()) {\n                if (tile.light) {\n                    fn(tile.light, x, y);\n                }\n            }\n        });\n    }\n    eachDynamicLight(fn) {\n        Utils.eachChain(this._actors, (actor) => {\n            if (actor.light)\n                fn(actor.light, actor.x, actor.y);\n        });\n    }\n    // Layers\n    addFx(x, y, anim) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        cell.addLayer(anim);\n        anim.x = x;\n        anim.y = y;\n        this.redrawCell(cell);\n        return true;\n    }\n    moveFx(x, y, anim) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        const oldCell = this.cell(anim.x, anim.y);\n        oldCell.removeLayer(anim);\n        this.redrawCell(oldCell);\n        cell.addLayer(anim);\n        this.redrawCell(cell);\n        anim.x = x;\n        anim.y = y;\n        return true;\n    }\n    removeFx(anim) {\n        const oldCell = this.cell(anim.x, anim.y);\n        oldCell.removeLayer(anim);\n        this.redrawCell(oldCell);\n        this.flags |= Flags.MAP_CHANGED;\n        return true;\n    }\n    // ACTORS\n    // will return the PLAYER if the PLAYER is at (x, y).\n    actorAt(x, y) {\n        // creature *\n        if (!this.hasXY(x, y))\n            return null;\n        const cell = this.cell(x, y);\n        return cell.actor;\n    }\n    addActor(x, y, theActor) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.actor) {\n            return false;\n        }\n        cell.actor = theActor; // adjusts the layer\n        theActor.next = this._actors;\n        this._actors = theActor;\n        const flag = theActor === DATA.player\n            ? CellFlags.HAS_PLAYER\n            : CellFlags.HAS_ANY_ACTOR;\n        cell.flags |= flag;\n        // if (theActor.flags & Flags.Actor.MK_DETECTED)\n        // {\n        // \tcell.flags |= CellFlags.MONSTER_DETECTED;\n        // }\n        if (theActor.light) {\n            this.anyLightChanged = true;\n        }\n        // If the player moves or an actor that blocks vision and the cell is visible...\n        // -- we need to update the FOV\n        if (theActor.isPlayer() ||\n            (cell.isAnyKindOfVisible() && theActor.blocksVision())) {\n            this.flags |= Flags.MAP_FOV_CHANGED;\n        }\n        theActor.x = x;\n        theActor.y = y;\n        this.redrawCell(cell);\n        return true;\n    }\n    addActorNear(x, y, theActor) {\n        const loc = this.matchingLocNear(x, y, (cell) => {\n            return !theActor.avoidsCell(cell);\n        });\n        if (!loc || loc[0] < 0) {\n            // GW.ui.message(colors.badMessageColor, 'There is no place to put the actor.');\n            return false;\n        }\n        return this.addActor(loc[0], loc[1], theActor);\n    }\n    moveActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        this.removeActor(actor);\n        if (!this.addActor(x, y, actor)) {\n            this.addActor(actor.x, actor.y, actor);\n            return false;\n        }\n        if (actor.light) {\n            this.anyLightChanged = true;\n        }\n        return true;\n    }\n    removeActor(actor) {\n        if (!this.hasXY(actor.x, actor.y))\n            return false;\n        const cell = this.cell(actor.x, actor.y);\n        if (cell.actor === actor) {\n            cell.actor = null;\n            Utils.removeFromChain(this, 'actors', actor);\n            if (actor.light) {\n                this.anyLightChanged = true;\n            }\n            // If the player moves or an actor that blocks vision and the cell is visible...\n            // -- we need to update the FOV\n            if (actor.isPlayer() ||\n                (cell.isAnyKindOfVisible() && actor.blocksVision())) {\n                this.flags |= Flags.MAP_FOV_CHANGED;\n            }\n            this.redrawCell(cell);\n            return true;\n        }\n        return false;\n    }\n    deleteActorAt(x, y) {\n        const actor = this.actorAt(x, y);\n        if (!actor)\n            return false;\n        this.removeActor(actor);\n        actor.delete();\n        return true;\n    }\n    // dormantAt(x: number, y: number) {  // creature *\n    // \tif (!(this.cell(x, y).flags & CellFlags.HAS_DORMANT_MONSTER)) {\n    // \t\treturn null;\n    // \t}\n    // \treturn this.dormantActors.find( (m) => m.x == x && m.y == y );\n    // }\n    //\n    // addDormant(x, y, actor) {\n    // \ttheActor.x = x;\n    // \ttheActor.y = y;\n    // \tthis.dormant.add(theActor);\n    // \tcell.flags |= (CellFlags.HAS_DORMANT_MONSTER);\n    // \tthis.flags |= Flags.MAP_CHANGED;\n    // \treturn true;\n    // }\n    //\n    // removeDormant(actor) {\n    // \tconst cell = this.cell(actor.x, actor.y);\n    // \tcell.flags &= ~(CellFlags.HAS_DORMANT_MONSTER);\n    // \tcell.flags |= CellFlags.NEEDS_REDRAW;\n    // \tthis.flags |= Flags.MAP_CHANGED;\n    // \tthis.dormant.remove(actor);\n    // }\n    // ITEMS\n    itemAt(x, y) {\n        const cell = this.cell(x, y);\n        return cell.item;\n    }\n    addItem(x, y, theItem) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.item) {\n            // GW.ui.message(colors.badMessageColor, 'There is already an item there.');\n            return false;\n        }\n        theItem.x = x;\n        theItem.y = y;\n        cell.item = theItem; // adjusts the layers\n        theItem.next = this._items;\n        this._items = theItem;\n        if (theItem.light) {\n            this.anyLightChanged = true;\n        }\n        this.redrawCell(cell);\n        if (theItem.isDetected() || CONFIG.D_ITEM_OMNISCIENCE) {\n            cell.flags |= CellFlags.ITEM_DETECTED;\n        }\n        return true;\n    }\n    addItemNear(x, y, theItem) {\n        const loc = this.matchingLocNear(x, y, (cell) => {\n            return !theItem.forbidsCell(cell);\n        });\n        if (!loc || loc[0] < 0) {\n            // GW.ui.message(colors.badMessageColor, 'There is no place to put the item.');\n            return false;\n        }\n        return this.addItem(loc[0], loc[1], theItem);\n    }\n    removeItem(theItem) {\n        const x = theItem.x;\n        const y = theItem.y;\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.item !== theItem)\n            return false;\n        cell.item = null;\n        Utils.removeFromChain(this, 'items', theItem);\n        if (theItem.light) {\n            this.anyLightChanged = true;\n        }\n        cell.flags &= ~(CellFlags.HAS_ITEM | CellFlags.ITEM_DETECTED);\n        this.redrawCell(cell);\n        return true;\n    }\n    // // PROMOTE\n    //\n    // async promote(x, y, mechFlag) {\n    // \tif (this.hasTileMechFlag(x, y, mechFlag)) {\n    // \t\tconst cell = this.cell(x, y);\n    // \t\tfor (let tile of cell.tiles()) {\n    // \t\t\tif (tile.mechFlags & mechFlag) {\n    // \t\t\t\tawait tile.promote(this, x, y, false);\n    // \t\t\t}\n    // \t\t}\n    // \t}\n    // }\n    gridDisruptsWalkability(blockingGrid, opts = {}) {\n        const walkableGrid = Grid.alloc(this.width, this.height);\n        let disrupts = false;\n        const gridOffsetX = opts.gridOffsetX || 0;\n        const gridOffsetY = opts.gridOffsetY || 0;\n        const bounds = opts.bounds || null; // TODO - Where is this used ???\n        // Get all walkable locations after lake added\n        this.cells.forEach((cell, i, j) => {\n            if (bounds && !bounds.contains(i, j))\n                return; // outside bounds\n            const blockingX = i + gridOffsetX;\n            const blockingY = j + gridOffsetY;\n            if (cell.isClear()) {\n                return; // not walkable\n            }\n            else if (cell.hasTileFlag(TileFlags.T_HAS_STAIRS)) {\n                if (blockingGrid.get(blockingX, blockingY)) {\n                    disrupts = true;\n                }\n                else {\n                    walkableGrid[i][j] = 1;\n                }\n            }\n            else if (cell.canBeWalked()) {\n                if (blockingGrid.get(blockingX, blockingY))\n                    return;\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        Grid.free(walkableGrid);\n        return disrupts;\n    }\n    // FOV\n    // Returns a boolean grid indicating whether each square is in the field of view of (xLoc, yLoc).\n    // forbiddenTileFlags is the set of terrain flags that will block vision (but the blocking cell itself is\n    // illuminated); forbiddenCellFlags is the set of map flags that will block vision.\n    // If cautiousOnWalls is set, we will not illuminate blocking tiles unless the tile one space closer to the origin\n    // is visible to the player; this is to prevent lights from illuminating a wall when the player is on the other\n    // side of the wall.\n    calcFov(grid, x, y, maxRadius, forbiddenCellFlags = 0, forbiddenLayerFlags = LayerFlags.L_BLOCKS_VISION) {\n        maxRadius = maxRadius || this.width + this.height;\n        grid.fill(0);\n        const map = this;\n        const FOV = new Fov.FOV({\n            isBlocked(i, j) {\n                return !!(!grid.hasXY(i, j) ||\n                    map.hasCellFlag(i, j, forbiddenCellFlags) ||\n                    map.hasLayerFlag(i, j, forbiddenLayerFlags));\n            },\n            calcRadius(x, y) {\n                return Math.sqrt(x ** 2 + y ** 2);\n            },\n            setVisible(x, y) {\n                grid[x][y] = 1;\n            },\n            hasXY(x, y) {\n                return grid.hasXY(x, y);\n            },\n        });\n        return FOV.calculate(x, y, maxRadius);\n    }\n    losFromTo(a, b) {\n        if (Utils.equalsXY(a, b))\n            return true;\n        const line = Utils.getLine(a.x, a.y, b.x, b.y);\n        if (!line.length)\n            return false;\n        return !line.some((loc) => {\n            return this.blocksVision(loc[0], loc[1]);\n        });\n    }\n    // MEMORIES\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        cell.storeMemory();\n    }\n    storeMemories() {\n        let x, y;\n        for (x = 0; x < this.width; ++x) {\n            for (y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.flags & CellFlags.ANY_KIND_OF_VISIBLE) {\n                    cell.storeMemory();\n                }\n                // cell.flags &= CellFlags.PERMANENT_CELL_FLAGS;\n                // cell.mechFlags &= CellMechFlags.PERMANENT_MECH_FLAGS;\n            }\n        }\n    }\n    // TICK\n    async activateCell(x, y, event) {\n        const cell = this.cell(x, y);\n        return await cell.activate(event, { map: this, x, y, cell });\n    }\n    async tick() {\n        // map.debug(\"tick\");\n        this.resetCellEvents();\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cells[x][y];\n                await cell.activate('tick', {\n                    map: this,\n                    x,\n                    y,\n                    cell,\n                    safe: true,\n                });\n            }\n        }\n        updateLiquid(this);\n        updateGas(this);\n    }\n    resetCellEvents() {\n        this.forEach((c) => (c.mechFlags &= ~(CellMechFlags.EVENT_FIRED_THIS_TURN |\n            CellMechFlags.EVENT_PROTECTED)));\n    }\n}\nexport function make(w, h, opts = {}, wall) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n        if (wall) {\n            opts.wall = wall;\n        }\n    }\n    const map = new Map(w, h, opts);\n    let floor = opts.tile || opts.floor || opts.floorTile;\n    if (floor === true) {\n        floor = 'FLOOR';\n    }\n    let boundary = opts.boundary || opts.wall || opts.wallTile;\n    if (boundary === true) {\n        boundary = 'WALL';\n    }\n    if (floor) {\n        map.fill(floor, boundary);\n    }\n    if (opts.visible || opts.revealed) {\n        map.makeVisible();\n        map.revealAll();\n    }\n    if (opts.revealed && !opts.visible) {\n        map.makeVisible(false);\n    }\n    if (!DATA.map) {\n        DATA.map = map;\n    }\n    return map;\n}\nMake.map = make;\nexport function from(prefab, charToTile, opts = {}) {\n    if (!Array.isArray(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    const height = prefab.length;\n    const width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n    const map = make(width, height, opts);\n    prefab.forEach((line, y) => {\n        for (let x = 0; x < width; ++x) {\n            const ch = line[x] || '.';\n            const tile = charToTile[ch] || 'FLOOR';\n            map.setTile(x, y, tile);\n        }\n    });\n    // redo this because we changed the tiles\n    if (opts.visible || opts.revealed) {\n        map.makeVisible();\n        map.revealAll();\n    }\n    if (opts.revealed && !opts.visible) {\n        map.makeVisible(false);\n    }\n    return map;\n}\nif (!COLORS.cursor) {\n    Color.install('cursor', COLORS.yellow);\n}\nif (!COLORS.path) {\n    Color.install('path', COLORS.gold);\n}\nexport function getCellAppearance(map, x, y, dest) {\n    dest.blackOut();\n    if (!map.hasXY(x, y))\n        return;\n    const cell = map.cell(x, y);\n    if (cell.isAnyKindOfVisible() &&\n        cell.flags & (CellFlags.CELL_CHANGED | CellFlags.NEEDS_REDRAW)) {\n        Cell.getAppearance(cell, dest);\n    }\n    else {\n        // if (cell.isRevealed()) {\n        dest.drawSprite(cell.memory.mixer);\n    }\n    if (cell.isVisible()) {\n        // keep here to allow for games that do not use fov to work\n    }\n    else if (!cell.isRevealed()) {\n        if (!cell.isAnyKindOfVisible())\n            dest.blackOut();\n    }\n    else if (!cell.isAnyKindOfVisible()) {\n        dest.bg.mix(COLORS.black, 30);\n        dest.fg.mix(COLORS.black, 30);\n    }\n    let needDistinctness = false;\n    if (cell.flags & (CellFlags.IS_CURSOR | CellFlags.IS_IN_PATH)) {\n        const highlight = cell.flags & CellFlags.IS_CURSOR ? COLORS.cursor : COLORS.path;\n        if (cell.hasLayerFlag(LayerFlags.L_INVERT_WHEN_HIGHLIGHTED)) {\n            Color.swap(dest.fg, dest.bg);\n        }\n        else {\n            // if (!GAME.trueColorMode || !dest.needDistinctness) {\n            // dest.fg.mix(highlight, CONFIG.cursorPathIntensity || 20);\n            // }\n            dest.bg.mix(highlight, CONFIG.cursorPathIntensity || 20);\n        }\n        needDistinctness = true;\n    }\n    if (needDistinctness) {\n        Color.separate(dest.fg, dest.bg);\n    }\n    // dest.bake();\n}\nexport function addText(map, x, y, text, fg, bg, layer) {\n    for (let ch of text) {\n        const sprite = Layer.make({\n            ch,\n            fg,\n            bg,\n            layer: layer || TileLayer.GROUND,\n            priority: 200,\n        }); // on top of ground tiles\n        const cell = map.cell(x++, y);\n        cell.addLayer(sprite);\n    }\n}\nexport function updateGas(map) {\n    if (map.flags & Flags.MAP_NO_GAS)\n        return;\n    const newVolume = Grid.alloc(map.width, map.height);\n    let hasGas = false;\n    let needsAjustment = false;\n    map.forEach((c, x, y) => {\n        let volume = c.gasVolume;\n        const gas = c.gasTile;\n        if (!volume)\n            return;\n        if (gas.dissipate) {\n            if (gas.dissipate > 10000) {\n                volume -= Math.floor(gas.dissipate / 10000);\n                if (random.chance(gas.dissipate % 10000, 10000)) {\n                    volume -= 1;\n                }\n            }\n            else if (random.chance(gas.dissipate, 10000)) {\n                volume -= 1;\n            }\n        }\n        if (volume > 0) {\n            newVolume[x][y] = volume;\n            hasGas = true;\n            if (volume > 1) {\n                needsAjustment = true;\n            }\n        }\n    });\n    if (hasGas) {\n        if (needsAjustment) {\n            const dirs = random.sequence(4).map((i) => Utils.DIRS[i]);\n            const grid = Grid.alloc(map.width, map.height);\n            // push out from my square\n            newVolume.forEach((v, x, y) => {\n                if (!v)\n                    return;\n                let adj = v;\n                if (v > 1) {\n                    let count = 1;\n                    newVolume.eachNeighbor(x, y, () => {\n                        ++count;\n                    }, true); // only 4 dirs\n                    let avg = Math.floor(v / count);\n                    let rem = v - avg * count;\n                    grid[x][y] += avg;\n                    if (rem > 0) {\n                        grid[x][y] += 1;\n                        rem -= 1;\n                    }\n                    for (let i = 0; i < dirs.length; ++i) {\n                        const dir = dirs[i];\n                        const x2 = x + dir[0];\n                        const y2 = y + dir[1];\n                        if (grid.hasXY(x2, y2)) {\n                            adj = avg;\n                            if (rem > 0) {\n                                --rem;\n                                ++adj;\n                            }\n                            grid[x2][y2] += adj;\n                        }\n                    }\n                }\n                else {\n                    grid[x][y] += v;\n                }\n            });\n            newVolume.copy(grid);\n            Grid.free(grid);\n            // newVolume.dump();\n        }\n    }\n    newVolume.forEach((v, i, j) => {\n        const cell = map.cell(i, j);\n        if (v > 0) {\n            hasGas = true;\n            if (cell.gasVolume !== v) {\n                let highVol = cell.gasVolume;\n                let highTile = cell.gasTile;\n                map.eachNeighbor(i, j, (n) => {\n                    if (n.gasVolume > highVol) {\n                        highVol = n.gasVolume;\n                        highTile = n.gasTile;\n                    }\n                });\n                if (highTile !== cell.gasTile) {\n                    cell.setTile(highTile, 0, map);\n                }\n                cell.gasVolume = v;\n                map.redrawCell(cell);\n            }\n        }\n        else if (cell.gasVolume || cell.gas) {\n            cell.clearLayer(TileLayer.GAS);\n            map.redrawCell(cell);\n        }\n    });\n    if (hasGas) {\n        map.flags &= ~Flags.MAP_NO_GAS;\n    }\n    else {\n        map.flags |= Flags.MAP_NO_GAS;\n    }\n    map.changed = true;\n    Grid.free(newVolume);\n}\nexport function updateLiquid(map) {\n    if (map.flags & Flags.MAP_NO_LIQUID)\n        return;\n    const newVolume = Grid.alloc(map.width, map.height);\n    let hasLiquid = false;\n    let needsAjustment = false;\n    map.forEach((c, x, y) => {\n        let volume = c.liquidVolume;\n        const liquid = c.liquidTile;\n        if (volume && liquid.dissipate) {\n            if (liquid.dissipate > 10000) {\n                volume -= Math.floor(liquid.dissipate / 10000);\n                if (random.chance(liquid.dissipate % 10000, 10000)) {\n                    volume -= 1;\n                }\n            }\n            else if (random.chance(liquid.dissipate, 10000)) {\n                volume -= 1;\n            }\n        }\n        if (volume > 0) {\n            newVolume[x][y] = volume;\n            hasLiquid = true;\n            if (volume > 1) {\n                needsAjustment = true;\n            }\n        }\n        else if (c.liquid) {\n            c.clearLayer(TileLayer.LIQUID);\n            map.redrawCell(c);\n        }\n    });\n    // newVolume.dump();\n    // map.dump((c) => (c.liquidVolume ? c.liquid || '!' : ' '));\n    if (hasLiquid) {\n        if (needsAjustment) {\n            map.randomEach((c, x, y) => {\n                if (c.hasLayerFlag(Layer.Flags.L_BLOCKS_LIQUID))\n                    return;\n                let highVol = 0;\n                let highX = -1;\n                let highY = -1;\n                let highTile = c.liquidTile;\n                let myVol = newVolume[x][y];\n                newVolume.eachNeighbor(x, y, (v, i, j) => {\n                    if (v <= myVol)\n                        return;\n                    if (v <= highVol)\n                        return;\n                    highVol = v;\n                    highX = i;\n                    highY = j;\n                    highTile = map.cell(i, j).liquidTile;\n                });\n                if (highVol > 1) {\n                    // guaranteed => myVol < highVol\n                    map.setTile(x, y, highTile, 0); // place tile with 0 volume - will force liquid to be same as highest volume liquid neighbor\n                    const amt = Math.floor((highVol - myVol) / 9) + 1;\n                    newVolume[x][y] += amt;\n                    newVolume[highX][highY] -= amt;\n                }\n            });\n        }\n    }\n    newVolume.forEach((v, i, j) => {\n        const cell = map.cell(i, j);\n        if (v > 0) {\n            // hasLiquid = true;\n            if (cell.liquidVolume !== v || !cell.liquid) {\n                let highVol = cell.liquidVolume;\n                let highTile = cell.liquidTile;\n                map.eachNeighbor(i, j, (n) => {\n                    if (n.liquidVolume > highVol) {\n                        highVol = n.liquidVolume;\n                        highTile = n.liquidTile;\n                    }\n                });\n                if (highTile !== cell.liquidTile) {\n                    cell.setTile(highTile, 0, map);\n                }\n                cell.liquidVolume = v;\n                map.redrawCell(cell);\n            }\n        }\n        else if (cell.liquidVolume || cell.liquid) {\n            cell.clearLayer(TileLayer.LIQUID);\n            map.redrawCell(cell);\n        }\n    });\n    if (hasLiquid) {\n        map.flags &= ~Flags.MAP_NO_LIQUID;\n    }\n    else {\n        map.flags |= Flags.MAP_NO_LIQUID;\n    }\n    map.changed = true;\n    Grid.free(newVolume);\n}\n","import * as Tile from \"./tile\";\n// These are the minimal set of tiles to make the diggers work\nTile.install(\"NULL\", {\n    ch: \"\\u2205\",\n    fg: \"white\",\n    bg: \"black\",\n    flags: \"L_BLOCKS_MOVE\",\n    name: \"eerie nothingness\",\n    article: \"an\",\n    priority: 0,\n});\nTile.install(\"FLOOR\", {\n    ch: \"\\u00b7\",\n    fg: [30, 30, 30, 20, 0, 0, 0],\n    bg: [2, 2, 10, 0, 2, 2, 0],\n    priority: 10,\n    article: \"the\",\n});\nTile.install(\"DOOR\", {\n    ch: \"+\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: \"T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT\",\n    article: \"a\",\n    activates: {\n        enter: { tile: \"DOOR_OPEN\" },\n        open: { tile: \"DOOR_OPEN_ALWAYS\" },\n    },\n});\nTile.install(\"DOOR_OPEN\", \"DOOR\", {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: \"!L_BLOCKS_ITEMS, !L_BLOCKS_VISION\",\n    name: \"open door\",\n    article: \"an\",\n    activates: {\n        tick: {\n            chance: 100 * 100,\n            tile: \"DOOR\",\n            flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\",\n        },\n        enter: null,\n        open: null,\n        close: { tile: \"DOOR\", flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\" },\n    },\n});\nTile.install(\"DOOR_OPEN_ALWAYS\", \"DOOR_OPEN\", {\n    activates: {\n        tick: null,\n        close: { tile: \"DOOR\", flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\" },\n    },\n});\nTile.install(\"UP_STAIRS\", {\n    ch: \"<\",\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: \"T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR\",\n    name: \"upward staircase\",\n    article: \"an\",\n});\nTile.install(\"DOWN_STAIRS\", {\n    ch: \">\",\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: \"T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR\",\n    name: \"downward staircase\",\n    article: \"a\",\n});\nTile.install(\"WALL\", {\n    ch: \"#\",\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: \"L_BLOCKS_EVERYTHING\",\n    article: \"a\",\n    name: \"stone wall\",\n    desc: \"A wall made from rough cut stone.\",\n    flavor: \"a rough stone wall\",\n});\nTile.install(\"LAKE\", {\n    ch: \"~\",\n    fg: [5, 8, 20, 10, 0, 4, 15, true],\n    bg: [10, 15, 41, 6, 5, 5, 5, true],\n    priority: 50,\n    flags: \"T_DEEP_WATER\",\n    name: \"deep water\",\n    article: \"the\",\n});\nTile.install(\"BRIDGE\", {\n    ch: \"=\",\n    fg: [100, 40, 40],\n    priority: 40,\n    layer: \"SURFACE\",\n    flags: \"T_BRIDGE, L_VISUALLY_DISTINCT\",\n    article: \"a\",\n    ground: \"LAKE\",\n});\n"],"names":["Depth","Fl","Flag","fl","Layer","Activation","Tile","TileMech","Cell","CellMech","Map","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_IS_WALL","DFF_BLOCKED_BY_ITEMS","DFF_BLOCKED_BY_ACTORS","DFF_NULL_SURFACE","DFF_NULL_LIQUID","DFF_NULL_GAS","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","REVEALED","MAGIC_MAPPED","ITEM_DETECTED","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","VISIBLE","CLAIRVOYANT_VISIBLE","TELEPATHIC_VISIBLE","HAS_PLAYER","HAS_ACTOR","WAS_VISIBLE","WAS_CLAIRVOYANT_VISIBLE","WAS_TELEPATHIC_VISIBLE","IN_FOV","NEEDS_REDRAW","CELL_CHANGED","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_TRAP_FREE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","MAP_STABLE_LIGHTS","MAP_STABLE_GLOW_LIGHTS","config","CONFIG","light","INTENSITY_DARK","LIGHT_COMPONENTS","Color","make","Light","[object Object]","color","range","fadeTo","pass","this","passThroughActors","id","from","radius","Range","other","copy","intensity","map","x","y","maintainShadows","isMinersLight","k","lightMultiplier","value","outerRadius","Math","ceil","bake","dispelShadows","fadeToPercent","grid","Grid","alloc","width","height","calcFov","Flags.Cell","HAS_ANY_ACTOR","Flags.Layer","overlappedFieldOfView","forCircle","v","i","j","cell","floor","Utils","distanceBetween","flags","IS_IN_SHADOW","ANY_KIND_OF_VISIBLE","free","max","args","length","cached","lights","split","t","trim","Number","parseInt","Array","isArray","Error","install","source","recordOldLights","eachCell","oldLight","lightChanged","zeroOutLights","ambientLight","_i","_j","recordGlowLights","glowLight","restoreGlowLights","updateLighting","anyLightChanged","staticLightChanged","eachStaticLight","paint","eachDynamicLight","CELL_LIT","CELL_DARK","some","isDark","updateDisplayDetail","PLAYER","DATA","player","PLAYERS_LIGHT","ERROR","JSON","stringify","arg","Object","entries","forEach","name","info","darkColor","Entity","priority","layer","sprite","GW.make","Light.make","GW.utils","first","GW.flag","Flags","layerFlags","flag","TileEvent","opts","fn","tile","item","chance","volume","spread","decrement","matchTile","needs","next","message","lightFlare","flare","flashColor","flash","messageDisplayed","emit","tileEvent","activations","event","async","spawn","activation","ctx","feat","undefined","safe","hasCellMechFlag","CellMechFlags","EVENT_FIRED_THIS_TURN","DFF_ALWAYS_FIRE","refreshCell","DFF_NO_REDRAW_CELL","abortIfBlocking","DFF_ABORT_IF_BLOCKS_MAP","isVisible","Msg","add","Tile.tiles","Make","blocking","DFF_PERMIT_BLOCKING","blocksPathing","blocksMove","DFF_TREAT_AS_BLOCKING","spawnMap","didSomething","computeSpawnMap","gridDisruptsPassability","bounds","DFF_EVACUATE_CREATURES","evacuateCreatures","DFF_EVACUATE_ITEMS","evacuateItems","DFF_NULLIFY_CELL","nullifyCells","spawnTiles","delete","DFF_PROTECTED","mechFlags","EVENT_PROTECTED","Data","gameHasEnded","actor","activate","Events","DFF_SUBSEQ_ALWAYS","DFF_SUBSEQ_EVERYWHERE","TileFlags","updateMapToShoreThisTurn","redrawXY","changed","DFF_NO_MARK_FIRED","setCellFlags","cellIsOk","hasXY","DFF_BUILD_IN_WALLS","isWall","DFF_MUST_TOUCH_WALLS","ok","eachNeighbor","c","DFF_NO_TOUCH_WALLS","containsXY","hasTile","hasLayerFlag","LayerFlags","dir","x2","y2","madeChange","startProb","probDec","fill","DFF_SPREAD_CIRCLE","random","updateCircle","_v","dist","prob","DFF_SPREAD_LINE","DIRS","number","accomplishedSomething","blockedByOtherLayers","DFF_BLOCKED_BY_OTHER_LAYERS","superpriority","DFF_SUPERPRIORITY","GAS","gasVolume","LIQUID","liquidVolume","obstructsLayer","topmostTile","setTile","removeItem","clone","addItem","nullSurface","nullLiquid","nullGas","clearCellLayers","blockingMap","monst","loc","matchingLocNear","forbidsCell","hallways","moveActor","dest","events","values","f","Layer.Entity","super","Extends","tiles","base","ch","fg","bg","opacity","tileMech","activates","flavor","desc","article","dissipate","defaultGround","assignOmitting","assign","ground","Layer.Flags","MechFlags","key","TileEvent.make","T_PATHING_BLOCKER","result","toString","getName","arguments","cursorPathIntensity","CellMemory","mixer","Sprite","Mixer","itemQuantity","cellFlags","cellMechFlags","tileFlags","tileMechFlags","nullify","_tiles","layers","_actor","_item","data","CELL_DEFAULT","machineNumber","memory","copyObject","clear","_a","GROUND","liquid","surface","SURFACE","gas","groundTile","TILES","NULL","liquidTile","surfaceTile","gasTile","IS_WAS_ANY_KIND_OF_VISIBLE","orMapped","L_LIST_IN_SIDEBAR","needsRedraw","Light.intensity","LIGHT_CHANGED","limitToPlayerKnowledge","flagMask","cellFlag","cellMechFlag","isAnyKindOfVisible","skipGas","best","bestPriority","layerFlag","tileFlag","mechFlag","useMemory","T_IS_DEEP_LIQUID","T_BRIDGE","isWalkableNow","L_SECRETLY_PASSABLE","HAS_GAS","depth","tileId","FLOOR","oldTile","oldTileId","staleLoopMap","CAUGHT_FIRE_THIS_TURN","blocksVision","oldBlocksVision","setFlag","MapFlags","MAP_FOV_CHANGED","removeLayer","addLayer","HAS_LIQUID","clearFlag","MAP_NO_LIQUID","MAP_NO_GAS","HAS_SURFACE","current","except","floorTile","clearLayer","fired","ev","Activation.spawn","activatesOn","prev","quantity","getAppearance","isOrWasAnyKindOfVisible","rememberedInCell","storeMemory","blackOut","needDistinctness","L_VISUALLY_DISTINCT","alpha","clamp","drawSprite","multiply","separate","demoteCellVisibility","WAS_ANY_KIND_OF_VISIBLE","promoteCellVisibility","hasVisibleLight","Flags.CellMech","DARKENED","wasVisible","redrawCell","GW.data","automationActive","theItem","L_INTERRUPT_WHEN_SEEN","GW.message","tileWithLayerFlag","markRevealed","_updateCellVisibility","isClairy","wasClairy","_updateCellClairyvoyance","isTele","wasTele","hasTileFlag","Flags.Tile","xpxpThisTurn","_updateCellTelepathy","isMonst","MONSTER_DETECTED","wasMonst","WAS_MONSTER_DETECTED","_updateCellDetect","initMap","Map.Flags","MAP_CALC_FOV","clearFlags","maxRadius","fov","Flags.Map","GW.grid","setDefaults","map.deepestLevel","w","h","locations","_actors","_items","_width","_height","cells","Cell.Cell","tick","MAP_DEFAULT","ambient","ambientLightChanged","Light.updateLighting","Visibility.initMap","fmt","dump","forRect","only4dirs","randomEach","count","g","isBoundaryXY","MAP_CHANGED","hasTileMechFlag","canvas","force","getCellAppearance","glyph","toGlyph","draw","toInt","invalidateCostMap","setFlags","Cell.Flags","isRevealed","mapFlag","tileWithFlag","tileWithMechFlag","isClear","isEmpty","isObstruction","isDoorway","isSecretDoorway","isLiquid","hasGas","isMoveableNow","canBeWalked","tileFlavor","clearLayersWithFlags","clearLayers","boundaryTile","matchFn","arcCount","x1","y1","costGrid","costFn","Path","OBSTRUCTION","matcher","maxIndex","d","match","TRUE","hallwaysAllowed","forbidLiquid","liquids","deterministic","candidateLocs","walkableArcCount","push","randIndex","sequence","forbidCellFlags","forbidTileFlags","forbidTileMechFlags","success","index","matches","eachChain","anim","oldCell","theActor","CellFlags","isPlayer","avoidsCell","addActor","removeActor","removeFromChain","actorAt","isDetected","D_ITEM_OMNISCIENCE","blockingGrid","walkableGrid","disrupts","gridOffsetX","gridOffsetY","contains","blockingX","blockingY","get","floodFill","forbiddenCellFlags","forbiddenLayerFlags","Fov","FOV","isBlocked","hasCellFlag","calcRadius","sqrt","calculate","a","b","equalsXY","line","getLine","resetCellEvents","updateLiquid","updateGas","wall","boundary","wallTile","visible","revealed","makeVisible","revealAll","Cell.getAppearance","mix","COLORS","black","IS_CURSOR","IS_IN_PATH","highlight","cursor","path","L_INVERT_WHEN_HIGHLIGHTED","swap","newVolume","needsAjustment","dirs","adj","avg","rem","highVol","highTile","n","TileLayer","hasLiquid","highX","highY","myVol","amt","yellow","gold","prefab","charToTile","reduce","len","text","Layer.make","enter","open","close"],"mappings":"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"}