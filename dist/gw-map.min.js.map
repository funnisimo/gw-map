{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/flags/horde.js","../js/entity/key.js","../js/entity/entity.js","../js/entity/kind.js","../js/actor/pain.js","../js/actor/stat.js","../js/actor/status.js","../js/actor/action.js","../js/actor/actor.js","../js/ai/ai.js","../js/ai/typical.js","../js/ai/wander.js","../js/ai/utils.js","../js/actor/kind.js","../js/actor/make.js","../js/actor/actions/bump.js","../js/actor/actions/standStill.js","../js/fx/fx.js","../js/actor/actions/moveDir.js","../js/actor/actions/idle.js","../js/actor/actions/pickup.js","../js/item/item.js","../js/item/kind.js","../js/item/make.js","../js/effect/effect.js","../js/effect/types/basic.js","../js/effect/types/spread.js","../js/effect/handlers/emit.js","../js/effect/handlers/message.js","../js/effect/handlers/activateMachine.js","../js/effect/handlers/tile.js","../js/effect/handlers/clear.js","../js/effect/handlers/feature.js","../js/effect/handlers/nourish.js","../js/effect/handlers/stat.js","../js/tile/tile.js","../js/tile/index.js","../js/layer/mapLayer.js","../js/layer/tileLayer.js","../js/layer/gasLayer.js","../js/layer/fireLayer.js","../js/map/cell.js","../js/draw/basic.js","../js/map/map.js","../js/map/analyze.js","../js/map/snapshot.js","../js/map/utils.js","../js/map/make.js","../js/horde/horde.js","../js/horde/make.js","../js/command/command.js","../js/command/moveDir.js","../js/command/pickup.js","../js/memory/index.js","../js/player/attribute.js","../js/player/skill.js","../js/player/scent.js","../js/player/player.js","../js/player/kind.js","../js/player/make.js","../js/game/viewport.js","../js/game/message.js","../js/game/game.js","../js/tile/tiles.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_LIST_IN_SIDEBAR\"] = Fl(13)] = \"L_LIST_IN_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_ON_MAP\"] = Fl(17)] = \"L_ON_MAP\";\n    Entity[Entity[\"DEFAULT_ACTOR\"] = Entity.L_LIST_IN_SIDEBAR] = \"DEFAULT_ACTOR\";\n    Entity[Entity[\"DEFAULT_ITEM\"] = Entity.L_LIST_IN_SIDEBAR] = \"DEFAULT_ITEM\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n    Actor[Actor[\"HAS_MEMORY\"] = Fl(1)] = \"HAS_MEMORY\";\n    Actor[Actor[\"USES_FOV\"] = Fl(2)] = \"USES_FOV\";\n    Actor[Actor[\"STABLE_COST_MAP\"] = Fl(3)] = \"STABLE_COST_MAP\";\n    Actor[Actor[\"IS_VISIBLE\"] = Fl(4)] = \"IS_VISIBLE\";\n    Actor[Actor[\"WAS_VISIBLE\"] = Fl(5)] = \"WAS_VISIBLE\";\n    Actor[Actor[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n    Item[Item[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_SHALLOW_WATER\"] = Fl(4)] = \"T_SHALLOW_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n    Tile[Tile[\"T_ANY_LIQUID\"] = Tile.T_IS_DEEP_LIQUID | Tile.T_SHALLOW_WATER] = \"T_ANY_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(0)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(1)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"KNOWN_TO_BE_SAFE\"] = Fl(2)] = \"KNOWN_TO_BE_SAFE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(14)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"STABLE_SNAPSHOT\"] = Fl(15)] = \"STABLE_SNAPSHOT\";\n    // These are to speed checks\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(16)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(17)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(18)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(19)] = \"HAS_ITEM\";\n    Cell[Cell[\"HAS_FX\"] = Fl(20)] = \"HAS_FX\";\n    Cell[Cell[\"HAS_TICK_EFFECT\"] = Fl(22)] = \"HAS_TICK_EFFECT\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(23)] = \"IS_CURSOR\";\n    Cell[Cell[\"IS_HIGHLIGHTED\"] = Fl(24)] = \"IS_HIGHLIGHTED\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_SAFE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_NEEDS_REDRAW\"] = Fl(1)] = \"MAP_NEEDS_REDRAW\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_SIDEBAR_TILES_CHANGED\"] = Fl(10)] = \"MAP_SIDEBAR_TILES_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_IGNORE_FOV\"] = Fl(12)] = \"E_IGNORE_FOV\";\n    // E_SPREAD_CIRCLE = Fl(13), // Spread in a circle around the spot (using FOV), radius calculated using spread+decrement\n    // E_SPREAD_LINE = Fl(14), // Spread in a line in one random direction\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Horde;\n(function (Horde) {\n    Horde[Horde[\"HORDE_DIES_ON_LEADER_DEATH\"] = Fl(0)] = \"HORDE_DIES_ON_LEADER_DEATH\";\n    Horde[Horde[\"HORDE_IS_SUMMONED\"] = Fl(1)] = \"HORDE_IS_SUMMONED\";\n    Horde[Horde[\"HORDE_SUMMONED_AT_DISTANCE\"] = Fl(2)] = \"HORDE_SUMMONED_AT_DISTANCE\";\n    Horde[Horde[\"HORDE_NO_PERIODIC_SPAWN\"] = Fl(4)] = \"HORDE_NO_PERIODIC_SPAWN\";\n    Horde[Horde[\"HORDE_ALLIED_WITH_PLAYER\"] = Fl(5)] = \"HORDE_ALLIED_WITH_PLAYER\";\n    Horde[Horde[\"HORDE_NEVER_OOD\"] = Fl(15)] = \"HORDE_NEVER_OOD\";\n    // Move all these to tags?\n    // HORDE_LEADER_CAPTIVE = Fl(3), // the leader is in chains and the followers are guards\n    // HORDE_MACHINE_BOSS = Fl(6), // used in machines for a boss challenge\n    // HORDE_MACHINE_WATER_MONSTER = Fl(7), // used in machines where the room floods with shallow water\n    // HORDE_MACHINE_CAPTIVE = Fl(8), // powerful captive monsters without any captors\n    // HORDE_MACHINE_STATUE = Fl(9), // the kinds of monsters that make sense in a statue\n    // HORDE_MACHINE_TURRET = Fl(10), // turrets, for hiding in walls\n    // HORDE_MACHINE_MUD = Fl(11), // bog monsters, for hiding in mud\n    // HORDE_MACHINE_KENNEL = Fl(12), // monsters that can appear in cages in kennels\n    // HORDE_VAMPIRE_FODDER = Fl(13), // monsters that are prone to capture and farming by vampires\n    // HORDE_MACHINE_LEGENDARY_ALLY = Fl(14), // legendary allies\n    // HORDE_MACHINE_THIEF = Fl(16), // monsters that can be generated in the key thief area machines\n    // HORDE_MACHINE_GOBLIN_WARREN = Fl(17), // can spawn in goblin warrens\n    // HORDE_SACRIFICE_TARGET = Fl(18), // can be the target of an assassination challenge; leader will get scary light.\n    // HORDE_MACHINE_ONLY = HORDE_MACHINE_BOSS |\n    //     HORDE_MACHINE_WATER_MONSTER |\n    //     HORDE_MACHINE_CAPTIVE |\n    //     HORDE_MACHINE_STATUE |\n    //     HORDE_MACHINE_TURRET |\n    //     HORDE_MACHINE_MUD |\n    //     HORDE_MACHINE_KENNEL |\n    //     HORDE_VAMPIRE_FODDER |\n    //     HORDE_MACHINE_LEGENDARY_ALLY |\n    //     HORDE_MACHINE_THIEF |\n    //     HORDE_MACHINE_GOBLIN_WARREN |\n    //     HORDE_SACRIFICE_TARGET,\n})(Horde || (Horde = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","import * as Flags from '../flags/entity';\nlet lastId = 0;\nexport class Entity {\n    // lastSeen: GWU.xy.Loc = [-1, -1];\n    constructor(kind) {\n        this._map = null;\n        this.key = null;\n        this.machineHome = 0;\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n        this.id = '' + ++lastId;\n    }\n    get map() {\n        return this._map;\n    }\n    addToMap(map, x, y) {\n        this.x = x;\n        this.y = y;\n        this.setEntityFlag(Flags.Entity.L_ON_MAP);\n        if (this._map === map) {\n            return false;\n        }\n        this._map = map;\n        this.kind.addToMap(this, map);\n        return true;\n    }\n    removeFromMap() {\n        this.clearEntityFlag(Flags.Entity.L_ON_MAP);\n        this.kind.removeFromMap(this);\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    isAt(x, y) {\n        return this.x === x && this.y === y;\n    }\n    clone() {\n        const other = new this.constructor(this.kind);\n        other.copy(this);\n        return other;\n    }\n    copy(other) {\n        this.depth = other.depth;\n        this.light = other.light;\n        Object.assign(this.flags, other.flags);\n        this.next = other.next;\n        this.x = other.x;\n        this.y = other.y;\n        this.kind = other.kind;\n        this.id = other.id;\n    }\n    canBeSeen() {\n        return this.kind.canBeSeen(this);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    setEntityFlag(flag) {\n        this.flags.entity |= flag;\n    }\n    clearEntityFlag(flag) {\n        this.flags.entity &= ~flag;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isKey(x, y) {\n        return this.key && this.key.matches(x, y);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(cell, this);\n    }\n    avoidsCell(cell) {\n        return this.kind.avoidsCell(cell, this);\n    }\n    getName(opts) {\n        return this.kind.getName(this, opts);\n    }\n    getDescription(opts) {\n        return this.kind.getDescription(this, opts);\n    }\n    getFlavor(opts) {\n        return this.kind.getFlavor(this, opts);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n    drawStatus(buffer, bounds) {\n        return this.kind.drawStatus(this, buffer, bounds);\n    }\n    drawInto(dest, _observer) {\n        dest.drawSprite(this.sprite);\n    }\n    toString() {\n        return `${this.constructor.name}-${this.id} @ ${this.x},${this.y}`;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity } from './entity';\nimport * as Flags from '../flags';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.requireTileFlags = 0;\n        this.forbidTileFlags = 0;\n        this.avoidTileFlags = 0;\n        this.requireTileTags = [];\n        this.forbidTileTags = [];\n        this.avoidTileTags = [];\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config.sprite ? config.sprite : config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        if (config.requireTileFlags) {\n            this.requireTileFlags = GWU.flag.from(Flags.Tile, config.requireTileFlags);\n        }\n        if (config.avoidTileFlags) {\n            this.avoidTileFlags = GWU.flag.from(Flags.Tile, config.avoidTileFlags);\n        }\n        if (config.forbidTileFlags) {\n            this.forbidTileFlags = GWU.flag.from(Flags.Tile, config.forbidTileFlags);\n        }\n        if (config.requireTileTags) {\n            if (typeof config.requireTileTags === 'string') {\n                config.requireTileTags = config.requireTileTags.split(/[,|]/g);\n            }\n            this.requireTileTags = config.requireTileTags.map((t) => t.trim());\n        }\n        if (config.avoidTileTags) {\n            if (typeof config.avoidTileTags === 'string') {\n                config.avoidTileTags = config.avoidTileTags.split(/[,|]/g);\n            }\n            this.avoidTileTags = config.avoidTileTags.map((t) => t.trim());\n        }\n        if (config.forbidTileTags) {\n            if (typeof config.forbidTileTags === 'string') {\n                config.forbidTileTags = config.forbidTileTags.split(/[,|]/g);\n            }\n            this.forbidTileTags = config.forbidTileTags.map((t) => t.trim());\n        }\n    }\n    make(opts) {\n        const entity = new Entity(this);\n        this.init(entity, opts);\n        return entity;\n    }\n    init(entity, opts = {}) {\n        if (opts.machineHome) {\n            entity.machineHome = opts.machineHome;\n        }\n    }\n    addToMap(_entity, _map) { }\n    removeFromMap(_entity) { }\n    canBeSeen(_entity) {\n        return true;\n    }\n    forbidsCell(cell, _entity) {\n        if (this.requireTileFlags &&\n            !cell.hasAllTileFlags(this.requireTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.forbidTileFlags &&\n            cell.hasTileFlag(this.forbidTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.requireTileTags.length &&\n            !cell.hasAllTileTags(this.requireTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.forbidTileTags.length &&\n            cell.hasAnyTileTag(this.forbidTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        return false;\n    }\n    avoidsCell(cell, entity) {\n        if (this.forbidsCell(cell, entity))\n            return true;\n        if (this.avoidTileFlags &&\n            cell.hasTileFlag(this.avoidTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.avoidTileTags.length &&\n            cell.hasAnyTileTag(this.avoidTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        return false;\n    }\n    getName(_entity, _opts) {\n        return this.name;\n    }\n    getDescription(_entity, _opts) {\n        return this.description;\n    }\n    getFlavor(_entity, _opts) {\n        return this.flavor;\n    }\n    getVerb(_entity, verb) {\n        return verb;\n    }\n    drawStatus(entity, buffer, bounds) {\n        if (!entity.map)\n            return 0;\n        if (entity.isDestroyed)\n            return 0;\n        const mixer = new GWU.sprite.Mixer();\n        entity.map.getAppearanceAt(entity.x, entity.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, entity.getName(), 'purple');\n        return 1;\n    }\n}\nexport function make(opts, makeOpts = {}) {\n    const kind = new EntityKind(opts);\n    return kind.make(makeOpts);\n}\n","import * as GWU from 'gw-utils';\nexport class PainMessages {\n    constructor(msgs = []) {\n        this._msgs = [];\n        msgs.forEach((m) => this.add(m));\n    }\n    add(msg) {\n        this._msgs.push(msg);\n        return this;\n    }\n    get(pct, singular = true) {\n        const index = GWU.clamp(Math.floor(pct * this._msgs.length), 0, this._msgs.length - 1);\n        const msg = this._msgs[index];\n        return this._format(msg, singular);\n    }\n    _format(msg, singular = true) {\n        return msg.replace(/\\[(\\w+)\\|?(\\w*)\\]/g, singular ? '$1' : '$2');\n    }\n}\nexport const painMessages = {};\nexport function installPain(id, pain) {\n    if (Array.isArray(pain)) {\n        pain = new PainMessages(pain);\n    }\n    painMessages[id] = pain;\n}\nexport function getPain(id) {\n    const m = painMessages[id];\n    if (!m)\n        throw new Error('No such pain message index: ' + id);\n    return m;\n}\n","import * as GWU from 'gw-utils';\nexport class Stats {\n    constructor(opts = {}) {\n        this._max = {};\n        this._rate = {};\n        this._value = {};\n        this.init(opts);\n    }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    getPct(name) {\n        const max = this.max(name);\n        return max ? Math.round((100 * this.get(name)) / max) : 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    regen(name) {\n        return this._rate[name] || null;\n    }\n    init(opts) {\n        for (let name in opts) {\n            this.set(name, opts[name]);\n        }\n    }\n    set(name, v, max) {\n        if (typeof v !== 'number') {\n            const r = GWU.range.make(v);\n            v = r.value();\n        }\n        this._value[name] = v;\n        this._max[name] = max || v;\n    }\n    gain(name, amount, allowOver = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        let v = this._value[name] + amount;\n        if (!allowOver) {\n            v = Math.min(v, this._max[name]);\n        }\n        this._value[name] = v;\n    }\n    drain(name, amount) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._value[name] = Math.max(0, this._value[name] - amount);\n    }\n    raiseMax(name, amount, raiseValue = true) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] += amount;\n        if (raiseValue) {\n            this.gain(name, amount);\n        }\n    }\n    reduceMax(name, amount, lowerValue = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] = Math.max(0, this._max[name] - amount);\n        if (lowerValue) {\n            this.drain(name, amount);\n        }\n    }\n    setRegen(name, turns, count = 1) {\n        const r = (this._rate[name] = this._rate[name] || { elapsed: 0 });\n        r.turns = turns;\n        r.count = count;\n    }\n    regenAll() {\n        for (let name in this._max) {\n            const r = this._rate[name];\n            r.elapsed += 1;\n            if (r.elapsed >= r.turns) {\n                this.gain(name, r.count);\n                r.elapsed -= r.turns;\n            }\n        }\n    }\n    restore(name, value) {\n        if (value === undefined)\n            value = this._max[name];\n        this._value[name] = value;\n    }\n    adjust(name, type, amount) {\n        amount = GWU.range.from(amount);\n        const v = amount.value();\n        const c = this.get(name);\n        if (type === 'inc') {\n            this.gain(name, amount);\n        }\n        else if (type === 'dec') {\n            this.drain(name, amount);\n        }\n        else if (type === 'set') {\n            this.set(name, amount);\n        }\n        else if (type === 'min') {\n            const v = amount.value();\n            if (this.get(name) < v) {\n                this.set(name, v);\n            }\n        }\n        else if (type === 'max') {\n            if (this.get(name) > v) {\n                this.set(name, v);\n            }\n        }\n        else {\n            throw new Error('Invalid stat adjust type: ' + type);\n        }\n        return c !== this.get(name);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Status {\n    constructor() {\n        this._set = {};\n        this._time = {};\n        this._count = {};\n        this._done = {};\n        this._value = {};\n        this.changed = null;\n    }\n    clear(name) {\n        this.clearTime(name);\n        this.clearCount(name);\n        this.setOff(name);\n        return this._update(name);\n    }\n    get(name) {\n        return this._value[name] || false;\n    }\n    has(name) {\n        return this._value[name] || false;\n    }\n    _addDone(name, done) {\n        if (done) {\n            if (!this._done[name]) {\n                this._done[name] = done;\n            }\n        }\n    }\n    /**\n     * Sets the count for a status variable.\n     * If setting the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} count The count to set.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not setting the count turned the status on.\n     */\n    setCount(name, count, done) {\n        const status = this;\n        status._count[name] = Math.max(count, status._count[name] || 0);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Increments the count for the status by the given amount (1=default)\n     * If incrementing the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} [count=1] The count to incrmeent.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not incrementing the count turned the status on.\n     */\n    increment(name, count = 1, done) {\n        if (typeof count == 'function') {\n            done = count;\n            count = 1;\n        }\n        const status = this;\n        status._count[name] = (status._count[name] || 0) + count;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Decrements the count for the status by the given amount (1=default)\n     * If decrementing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @param {number} [count=1] The count to decrement.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    decrement(name, count = 1) {\n        const status = this;\n        status._count[name] = Math.max(0, (status._count[name] || 0) - count);\n        return this._update(name);\n    }\n    /**\n     * Clears all counts from the given status.\n     * If clearing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    clearCount(name) {\n        const status = this;\n        status._count[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Turns on the given status.\n     * @param {string} name The status to adjust.\n     * @param {function} [done] The function to call when the status is turned off.\n     * @returns {boolean} True if this turns on the status. (It could be on because of a time or count).\n     */\n    setOn(name, done) {\n        const status = this;\n        status._set[name] = true;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Turns off the given status.\n     *\n     * @param {string} name The status to adjust.\n     * @returns {boolean} True if this turns off the status. (It could be on because of a time or count).\n     */\n    setOff(name) {\n        const status = this;\n        status._set[name] = false;\n        return this._update(name);\n    }\n    /**\n     * Sets the time for a status variable.\n     * If setting the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to set.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not setting the time turned the status on.\n     */\n    setTime(name, value, done) {\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        const current = status._time[name] || 0;\n        status._time[name] = Math.max(value, current);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Adds to the time for a status variable.\n     * If adding to the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to add.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not adding the time turned the status on.\n     */\n    addTime(name, value = 1, done) {\n        if (typeof value == 'function') {\n            done = value;\n            value = 1;\n        }\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        status._time[name] = (status._time[name] || 0) + value;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Removes time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to remove.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    removeTime(name, value = 1) {\n        const status = this;\n        value = GWU.range.make(value).value();\n        status._time[name] = Math.max(0, (status._time[name] || 0) - value);\n        return this._update(name);\n    }\n    /**\n     * Removes all time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    clearTime(name) {\n        const status = this;\n        status._time[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Removes time for all status variables that have time.\n     * If removing the time turns off any status (it was on),\n     * then this function returns an object with all of those statuses as keys and false as the values.  Otherwise, false.\n     * @param {Status|object} source The object to set the status on.  If object.status is set then that is where the values are updated.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean|object} false or an object with the names of the statuses that were cleared as keys and false as the values.\n     */\n    decayAllTimes(delta = 1) {\n        const status = this;\n        const cleared = {};\n        let noticed = false;\n        for (let name in status._time) {\n            if (this.removeTime(name, delta)) {\n                noticed = true;\n                cleared[name] = false;\n            }\n        }\n        return noticed ? cleared : false;\n    }\n    /**\n     * Updates the value of the status and returns whether or not this change\n     * turned the status on or off (true = change, false = no change)\n     * @param {string} name The name of the status to update\n     * @returns {boolean} True if the value was turned on or off, False otherwise.\n     */\n    _update(name) {\n        const status = this;\n        const rec = this._value;\n        let was = rec[name];\n        let value = (rec[name] =\n            status._set[name] ||\n                status._time[name] > 0 ||\n                status._count[name] > 0 ||\n                false);\n        const doneFn = this._done[name];\n        if (!value && doneFn) {\n            doneFn(this, name);\n            status._done[name] = null;\n        }\n        if (was && !value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: false');\n            return true;\n        }\n        else if (!was && value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: true');\n            return true;\n        }\n        return false;\n    }\n}\n","export const installedActions = {};\nexport function installAction(name, fn) {\n    installedActions[name.toLowerCase()] = fn;\n}\nexport function getAction(name) {\n    return installedActions[name.toLowerCase()] || null;\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { getAction } from './action';\nimport { Status } from './status';\nimport { Stats } from './stat';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.ai = {};\n        this.leader = null;\n        this.items = null; // inventory\n        this.visionDistance = 99;\n        this.data = {};\n        this._costMap = null;\n        this._goalMap = null;\n        this._mapToMe = null;\n        this.next = null; // TODO - can we get rid of this?\n        // @ts-ignore - initialized in Entity\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n        this.kind = kind;\n        this.stats = new Stats();\n        this.status = new Status();\n    }\n    copy(other) {\n        super.copy(other);\n        this.leader = other.leader;\n        this.items = other.items;\n        this.visionDistance = other.visionDistance;\n    }\n    destroy() {\n        this.setEntityFlag(Flags.Entity.L_DESTROYED);\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n        if (this._mapToMe) {\n            GWU.grid.free(this._mapToMe);\n            this._mapToMe = null;\n        }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    setActorFlag(flag) {\n        this.flags.actor |= flag;\n    }\n    clearActorFlag(flag) {\n        this.flags.actor &= ~flag;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    isDead() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    getAction(name) {\n        const action = this.kind.actions[name];\n        if (action === undefined || action === true) {\n            const main = getAction(name); // default is to do any action\n            return main || false;\n        }\n        else if (action === false) {\n            return false;\n        }\n        return action;\n    }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n    /////////////// VISIBILITY\n    becameVisible() {\n        return (this.hasActorFlag(Flags.Actor.IS_VISIBLE) &&\n            !this.hasActorFlag(Flags.Actor.WAS_VISIBLE));\n    }\n    canSee(x, y) {\n        if (x instanceof Entity.Entity) {\n            return this.canSee(x.x, x.y) && this.kind.isAbleToSee(this, x);\n        }\n        else if (this.map) {\n            if (this.isPlayer()) {\n                return this.map.fov.isDirectlyVisible(x, y);\n            }\n            if (GWU.xy.distanceBetween(this.x, this.y, x, y) >\n                this.visionDistance) {\n                return false;\n            }\n            return GWU.xy.forLineBetween(this.x, this.y, x, y, (i, j) => {\n                if (this.map.cell(i, j).blocksVision())\n                    return false;\n            });\n        }\n        else {\n            return false; // need a map or an fov\n        }\n    }\n    canSeeOrSense(x, y) {\n        if (x instanceof Entity.Entity) {\n            return (this.canSeeOrSense(x.x, x.y) &&\n                (this.kind.isAbleToSee(this, x) ||\n                    this.kind.isAbleToSense(this, x)));\n        }\n        if (this.map && this.isPlayer()) {\n            return this.map.fov.isAnyKindOfVisible(x, y);\n        }\n        return this.canSee(x, y);\n    }\n    isAbleToSee(entity) {\n        return this.kind.isAbleToSee(this, entity);\n    }\n    isAbleToSense(entity) {\n        return this.kind.isAbleToSense(this, entity);\n    }\n    ////////////////// ACTOR\n    async act(game) {\n        let startedVisible = false;\n        if (game.player.canSee(this)) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n            startedVisible = true;\n        }\n        else {\n            if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n                console.log('not visible');\n            }\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n        if (this.becameVisible()) {\n            console.log('became visible');\n            game.player.interrupt();\n        }\n        let r = 0;\n        if (this.ai && this.ai.fn) {\n            r = await this.ai.fn(game, this);\n        }\n        if (r == 0 && this.kind.ai.fn) {\n            r = await this.kind.ai.fn(game, this);\n        }\n        if (r) {\n            // did something\n            if (startedVisible || game.player.canSee(this)) {\n            }\n            return r;\n        }\n        // idle - always\n        return this.endTurn();\n    }\n    moveSpeed() {\n        return this.kind.moveSpeed;\n    }\n    startTurn() { }\n    endTurn(pct = 100) {\n        if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n            this.setActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        return Math.floor((pct * this.moveSpeed()) / 100);\n    }\n    ///////\n    willAttack(_other) {\n        return true;\n    }\n    canPass(_other) {\n        return false;\n    }\n    ////////////////// INVENTORY\n    avoidsItem(_item) {\n        return false;\n    }\n    canAddItem(_item) {\n        return false;\n    }\n    addItem(_item) { }\n    pickupItem(item, opts) {\n        return this.kind.pickupItem(this, item, opts);\n    }\n    dropItem(item, opts) {\n        return this.kind.dropItem(this, item, opts);\n    }\n    // PATHFINDING\n    addToMap(map, x, y) {\n        const mapChanged = super.addToMap(map, x, y);\n        if (mapChanged) {\n            this.clearActorFlag(Flags.Actor.STABLE_COST_MAP);\n        }\n        return mapChanged;\n    }\n    removeFromMap() {\n        super.removeFromMap();\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n        if (this._mapToMe) {\n            GWU.grid.free(this._mapToMe);\n            this._mapToMe = null;\n        }\n    }\n    /*\n    Calculates and returns the actor's move cost map.\n    Used in pathfinding.\n    */\n    costMap() {\n        if (!this.map) {\n            throw new Error('Actor must have map to calculate costMap.');\n        }\n        const staleMap = !this.hasActorFlag(Flags.Actor.STABLE_COST_MAP);\n        if (staleMap && this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (!this._costMap) {\n            this._costMap = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        else if (!staleMap) {\n            return this._costMap;\n        }\n        const kind = this.kind;\n        const map = this.map;\n        this._costMap.update((_v, x, y) => {\n            const cell = map.cell(x, y);\n            return kind.cellCost(cell, this);\n        });\n        this.setActorFlag(Flags.Actor.STABLE_COST_MAP);\n        /*\n\n            if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n            && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))\n            {\n                playerCostMap[i][j] = monsterCostMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_SACRED)) {\n                    playerCostMap[i][j] = 1;\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_LAVA_INSTA_DEATH)) {\n        monsterCostMap[i][j] = PDS_FORBIDDEN;\n        if (player.status[STATUS_LEVITATING] || !player.status[STATUS_IMMUNE_TO_FIRE]) {\n            playerCostMap[i][j] = 1;\n        } else {\n            playerCostMap[i][j] = PDS_FORBIDDEN;\n        }\n            } else {\n                if (pmap[i][j].flags & HAS_MONSTER) {\n                    monst = monsterAtLoc(i, j);\n                    if ((monst.creatureState == MONSTER_SLEEPING\n                         || monst.turnsSpentStationary > 2\n             || (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)\n                         || monst.creatureState == MONSTER_ALLY)\n                        && monst.creatureState != MONSTER_FLEEING)\n                    {\n                        playerCostMap[i][j] = 1;\n                        monsterCostMap[i][j] = PDS_FORBIDDEN;\n                        continue;\n                    }\n                }\n\n                if (cellHasTerrainFlag(i, j, (T_AUTO_DESCENT | T_IS_DF_TRAP))) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, T_IS_FIRE)) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_IMMUNE_TO_FIRE]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, (T_IS_DEEP_WATER | T_SPONTANEOUSLY_IGNITES))) {\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = 5;\n          }\n                    monsterCostMap[i][j] = 5;\n        } else if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n                   && cellHasTMFlag(i, j, TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)\n                   && !(pmap[i][j].flags & IN_FIELD_OF_VIEW))\n             {\n            // Secret door that the player can't currently see\n            playerCostMap[i][j] = 100;\n            monsterCostMap[i][j] = 1;\n                } else {\n                    playerCostMap[i][j] = monsterCostMap[i][j] = 1;\n                }\n            }\n        }\n    }\n        */\n        return this._costMap;\n    }\n    get goalMap() {\n        return this._goalMap;\n    }\n    hasGoal() {\n        return !!this._goalMap;\n    }\n    setGoal(x, y) {\n        const map = this._map;\n        if (!map)\n            throw new Error('No map to set goal with!');\n        if (!this._goalMap) {\n            this._goalMap = GWU.grid.alloc(map.width, map.height);\n        }\n        const goalMap = this._goalMap;\n        GWU.path.calculateDistances(goalMap, x, y, this.costMap());\n        return this._goalMap;\n    }\n    clearGoal() {\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n    }\n    mapToMe() {\n        if (!this.map)\n            throw new Error('No map!');\n        if (!this._mapToMe) {\n            this._mapToMe = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        if (this._mapToMe.x !== this.x || this._mapToMe.y !== this.y) {\n            GWU.path.calculateDistances(this._mapToMe, this.x, this.y, this.costMap());\n        }\n        return this._mapToMe;\n    }\n}\n","export const ais = {};\nexport function install(name, fn) {\n    ais[name] = fn;\n}\nexport function make(opts) {\n    if (typeof opts === 'string') {\n        opts = { fn: opts };\n    }\n    if (typeof opts === 'function') {\n        opts = { fn: opts };\n    }\n    if (typeof opts.fn === 'string') {\n        opts.fn = ais[opts.fn];\n    }\n    if (!opts.fn) {\n        opts.fn = ais.default;\n    }\n    return opts;\n}\n","import * as GWU from 'gw-utils';\nimport { getAction } from '../actor/action';\nimport * as AI from './ai';\nimport { wander } from './wander';\nexport class AICtx {\n    constructor(game, actor, target) {\n        this.item = null;\n        this.count = 0;\n        this.game = game;\n        this.actor = actor;\n        this.target = target || null;\n        this.distanceMap = GWU.grid.alloc(game.map.width, game.map.height);\n        if (target) {\n            const costMap = actor.costMap();\n            GWU.path.calculateDistances(this.distanceMap, target.x, target.y, costMap);\n        }\n    }\n    start() {\n        ++this.count;\n        return this;\n    }\n    done(result) {\n        --this.count;\n        if (this.count == 0) {\n            GWU.grid.free(this.distanceMap);\n        }\n        return result;\n    }\n}\n/*\nhttp://roguebasin.com/index.php/Roguelike_Intelligence_-_Stateless_AIs\n-- Typical AI\n*/\nexport async function typical(game, actor) {\n    if (actor.isDead())\n        return -1;\n    const map = actor.map;\n    if (!map)\n        return -1; // actor not on map ?!?!\n    const target = game.player;\n    const tryAttack = actor.canSee(target) && actor.willAttack(target);\n    if (tryAttack) {\n        const damagePct = 100 - actor.stats.getPct('health');\n        const morale = actor.stats.get('morale');\n        const chargeChance = 100;\n        const retreatChance = 0;\n        actor.ai.lastSawPlayer = [target.x, target.y];\n        actor.clearGoal();\n        console.log('SAW YOU!', actor.id, target.x, target.y);\n        const ctx = new AICtx(game, actor, target).start();\n        let result = 0;\n        if (damagePct > morale) {\n            if (canRunAwayFrom(game, actor, target, ctx)) {\n                result = await runAwayFrom(game, actor, target, ctx);\n            }\n            else if (canAttack(game, actor, target, ctx)) {\n                result = await attack(game, actor, target, ctx);\n            }\n            return ctx.done(result);\n        }\n        if (tooFarFrom(game, actor, target, ctx) &&\n            canAttack(game, actor, target, ctx) &&\n            canMoveToward(game, actor, target, ctx)) {\n            if (GWU.random.chance(chargeChance)) {\n                result = await moveToward(game, actor, target, ctx);\n            }\n            else {\n                result = await attack(game, actor, target, ctx);\n            }\n            return ctx.done(result);\n        }\n        if (tooCloseTo(game, actor, target, ctx) &&\n            canAttack(game, actor, target, ctx) &&\n            canMoveAwayFrom(game, actor, target, ctx)) {\n            if (GWU.random.chance(retreatChance)) {\n                result = await moveAwayFrom(game, actor, target, ctx);\n            }\n            else {\n                result = await attack(game, actor, target, ctx);\n            }\n            return ctx.done(result);\n        }\n        if (canAttack(game, actor, target, ctx)) {\n            result = await attack(game, actor, target, ctx);\n            return ctx.done(result);\n        }\n        if (tooFarFrom(game, actor, target, ctx) &&\n            canMoveToward(game, actor, target, ctx)) {\n            result = await moveToward(game, actor, target, ctx);\n            return ctx.done(result);\n        }\n        if (tooCloseTo(game, actor, target, ctx) &&\n            canMoveAwayFrom(game, actor, target, ctx)) {\n            result = await moveAwayFrom(game, actor, target, ctx);\n            return ctx.done(result);\n        }\n    }\n    // TODO - Use scent, menory, other teammates info, ...\n    else if (actor.ai.lastSawPlayer) {\n        if (!actor.hasGoal()) {\n            const loc = actor.ai.lastSawPlayer;\n            actor.setGoal(loc[0], loc[1]);\n        }\n        console.log('CHASING YOU!', actor.id, actor.goalMap.x, actor.goalMap.y);\n        const result = await moveTowardGoal(game, actor);\n        if (result) {\n            return result;\n        }\n        actor.ai.lastSawPlayer = null; // no longer\n        actor.clearGoal();\n    }\n    // check if they noticed the player scent\n    if (target.scent) {\n        const dir = target.scent.nextDir(actor.x, actor.y);\n        if (dir) {\n            console.log('tracking scent', actor.id, dir);\n            const moveDir = getAction('moveDir');\n            if (!moveDir)\n                throw new Error('No moveDir action found for Actors!');\n            const result = await moveDir(game, actor, { dir });\n            if (result)\n                return result;\n        }\n    }\n    const wanderOpt = GWU.object.firstOpt('wander', actor.ai, actor.kind.ai, false);\n    if (wanderOpt) {\n        if (actor.goalMap || // we have a current goal\n            typeof wanderOpt !== 'number' || // wander: true\n            GWU.random.chance(wanderOpt) // chance\n        ) {\n            const result = wander(game, actor);\n            if (result)\n                return result;\n        }\n        else {\n            const idle = getAction('idle');\n            if (idle) {\n                return idle(game, actor);\n            }\n        }\n    }\n    const standStill = getAction('standStill');\n    if (!standStill)\n        throw new Error('No standStill action found for actors!');\n    return standStill(game, actor);\n}\nAI.install('typical', typical);\nAI.install('default', typical);\nexport function canMoveToward(game, actor, target, ctx) {\n    // can move?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    const distanceMap = ctx.distanceMap;\n    const canMoveDiagonal = false;\n    // look for distance > current around me\n    let center = distanceMap[actor.x][actor.y];\n    let count = 0;\n    GWU.xy.eachNeighbor(actor.x, actor.y, (x, y) => {\n        if (distanceMap[x][y] < center) {\n            ++count;\n        }\n    }, canMoveDiagonal);\n    return ctx.done(count > 0);\n}\nexport async function moveToward(game, actor, target, ctx) {\n    // pathfinding?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    // distanceMap.dump();\n    const map = game.map;\n    const step = GWU.path.nextStep(ctx.distanceMap, actor.x, actor.y, (x, y) => {\n        const cell = map.cell(x, y);\n        if (!cell)\n            return true;\n        if (cell.hasActor() && cell.actor !== target)\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    });\n    let result = 0;\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        const standStill = getAction('standStill');\n        if (!standStill)\n            throw new Error('No standStill action found for actors!');\n        result = await standStill(game, actor);\n        return ctx.done(result);\n    }\n    const moveDir = getAction('moveDir');\n    if (!moveDir)\n        throw new Error('No moveDir action found for Actors!');\n    result = await moveDir(game, actor, { dir: step });\n    return ctx.done(result);\n}\nexport function canMoveAwayFrom(game, actor, target, ctx) {\n    // can move?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    const distanceMap = ctx.distanceMap;\n    const canMoveDiagonal = false;\n    // look for distance > current around me\n    let center = distanceMap[actor.x][actor.y];\n    let count = 0;\n    GWU.xy.eachNeighbor(actor.x, actor.y, (x, y) => {\n        const d = distanceMap[x][y];\n        if (d >= GWU.path.NO_PATH)\n            return;\n        if (distanceMap[x][y] > center) {\n            ++count;\n        }\n    }, canMoveDiagonal);\n    return ctx.done(count > 0);\n}\nexport async function moveAwayFrom(_game, actor, _target, _ctx) {\n    // safety/strategy?\n    // always move using safety map?\n    return actor.endTurn();\n}\nexport function canRunAwayFrom(_game, _actor, _target, _ctx) {\n    // can move?\n    return false;\n}\nexport async function runAwayFrom(_game, actor, _target, _ctx) {\n    // move toward loop if away from player\n    return actor.endTurn();\n}\nexport function canAttack(_game, actor, target, _ctx) {\n    // has attack?\n    // attack affects player?\n    // cooldown?\n    return GWU.xy.distanceFromTo(actor, target) <= 1;\n}\nexport async function attack(game, actor, target, _ctx) {\n    console.log('attack!', actor.id, target.id);\n    let attack = actor.getAction('attack');\n    if (!attack)\n        return 0;\n    return attack(game, actor, { actor: target });\n}\nexport function tooFarFrom(_game, actor, target, _ctx) {\n    // diagonal?\n    return GWU.xy.distanceFromTo(actor, target) > 1;\n}\nexport function tooCloseTo(_game, actor, target, _ctx) {\n    return GWU.xy.distanceFromTo(actor, target) < 1;\n}\n// TODO - make an action\nexport async function moveTowardGoal(game, actor) {\n    if (!actor.hasGoal())\n        return 0;\n    const nextStep = GWU.path.nextStep(actor.goalMap, actor.x, actor.y, (x, y) => {\n        return actor.map.hasActor(x, y);\n    });\n    if (!nextStep) {\n        actor.clearGoal();\n        return 0;\n    }\n    const moveDir = actor.getAction('moveDir');\n    if (!moveDir)\n        throw new Error('No moveDir action for actor!');\n    return await moveDir(game, actor, { dir: nextStep });\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { getAction } from '../actor/action';\nexport async function wander(game, actor) {\n    // Do we have a wander target?\n    let goalMap = actor.goalMap;\n    if (!goalMap) {\n        //      pick new wander target\n        const costMap = actor.costMap();\n        const loc = GWU.random.matchingLoc(costMap.width, costMap.height, (x, y) => {\n            return costMap[x][y] > 0 && costMap[x][y] !== GWU.path.NO_PATH;\n        });\n        if (!loc || loc[0] < 0 || loc[1] < 0) {\n            console.log('No wander location found!');\n            return 0;\n        }\n        //      build distance map to target\n        goalMap = actor.setGoal(loc[0], loc[1]);\n    }\n    // take the next step to the target\n    const step = GWU.path.nextStep(goalMap, actor.x, actor.y, (x, y) => {\n        if (!game.map.hasActor(x, y))\n            return false;\n        const other = game.map.actorAt(x, y);\n        if (!other) {\n            console.log(`Cell @ ${x},${y} has actor flag, but no actor.`);\n            game.map.cell(x, y).clearCellFlag(Flags.Cell.HAS_ACTOR);\n            return false;\n        }\n        return !actor.canPass(other);\n    });\n    if (!step) {\n        actor.clearGoal();\n        return 0;\n    }\n    let result = 0;\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        return 0; // did nothing\n    }\n    const moveDir = getAction('moveDir');\n    if (!moveDir)\n        throw new Error('No moveDir action found for Actors!');\n    result = await moveDir(game, actor, { dir: step });\n    return result;\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nexport function fillSafetyMap(safetyMap, actor, target) {\n    const costGrid = GWU.grid.alloc(actor.costMap());\n    GWU.path.calculateDistances(safetyMap, target.x, target.y, costGrid, true);\n    safetyMap.update((v) => v * -1); // Can set factor to be < -1 e.g. -1.2\n    actor.map.actors.forEach((a) => {\n        if (a.willAttack(actor)) {\n            costGrid[a.x][a.y] = GWU.path.FORBIDDEN; // This is why we allocate a copy\n        }\n    });\n    actor.map.eachCell((c, x, y) => {\n        if (c.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n            safetyMap[x][y] -= GWU.path.AVOIDED; // loop cells are extra good\n        }\n    });\n    GWU.path.rescan(safetyMap, costGrid, true);\n    safetyMap.update((v) => (v <= -30000 ? 30000 : v));\n    GWU.grid.free(costGrid);\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Actor } from './actor';\nimport * as AI from '../ai';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n        this.flags = {\n            actor: Flags.Actor.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.vision = {};\n        this.actions = {};\n        this.bump = ['attack'];\n        this.moveSpeed = 100;\n        if (opts.flags) {\n            this.flags.actor = GWU.flag.from(Flags.Actor, this.flags.actor, opts.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, opts.flags);\n        }\n        if (opts.vision) {\n            this.vision.normal = opts.vision;\n        }\n        this.stats = Object.assign({ health: 1, morale: 100 }, opts.stats);\n        if (opts.actions) {\n            Object.assign(this.actions, opts.actions);\n        }\n        if (opts.moveSpeed) {\n            this.moveSpeed = opts.moveSpeed;\n        }\n        this.ai = AI.make(opts.ai || 'default');\n        if (opts.bump) {\n            if (typeof opts.bump === 'string') {\n                opts.bump = opts.bump.split(/[|,]/g).map((t) => t.trim());\n            }\n            if (typeof opts.bump === 'function') {\n                opts.bump = [opts.bump];\n            }\n            if (Array.isArray(opts.bump)) {\n                this.bump = opts.bump.slice();\n            }\n        }\n        if (opts.waterOnly) {\n            this.forbidTileFlags =\n                this.forbidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            this.avoidTileFlags =\n                this.avoidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            this.requireTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n        }\n        else if (opts.lavaOnly) {\n            this.forbidTileFlags = this.forbidTileFlags & ~Flags.Tile.T_LAVA;\n            this.avoidTileFlags = this.avoidTileFlags & ~Flags.Tile.T_LAVA;\n            this.requireTileFlags |= Flags.Tile.T_LAVA;\n        }\n        else {\n            if (opts.swim) {\n                this.avoidTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n            else {\n                this.forbidTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n            if (opts.fly) {\n                this.forbidTileFlags =\n                    this.forbidTileFlags & ~Flags.Tile.T_LAVA;\n                this.avoidTileFlags = this.avoidTileFlags & ~Flags.Tile.T_LAVA;\n                this.requireTileFlags =\n                    this.requireTileFlags & ~Flags.Tile.T_LAVA;\n                this.forbidTileFlags =\n                    this.forbidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n                this.avoidTileFlags =\n                    this.avoidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n                this.requireTileFlags =\n                    this.requireTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n        }\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n        Object.assign(actor.flags, this.flags);\n        // if (options.fov) {\n        //     actor.fov = options.fov;\n        // }\n        // if (options.memory) {\n        //     actor.memory = options.memory;\n        // }\n        if (this.vision.normal) {\n            actor.visionDistance = this.vision.normal;\n        }\n        actor.stats.init(this.stats);\n    }\n    addToMap(actor, map) {\n        super.addToMap(actor, map);\n        // if (this.hasActorFlag(Flags.Actor.HAS_MEMORY)) {\n        //     actor.memory = Memory.get(actor, map);\n        // }\n        // if (this.hasActorFlag(Flags.Actor.USES_FOV)) {\n        //     actor.fov = new GWU.fov.FovSystem(map);\n        //     actor.fov.follow = actor;\n        //     if (actor.memory) {\n        //         actor.fov.callback = actor.memory;\n        //     }\n        // }\n    }\n    removeFromMap(actor) {\n        super.removeFromMap(actor);\n        // if (actor._map && actor.memory) {\n        //     Memory.store(actor, actor._map, actor.memory);\n        // }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    canSeeEntity(_actor, _entity) {\n        return true;\n    }\n    isAbleToSee(_actor, _entity) {\n        return true;\n    }\n    isAbleToSense(_actor, _entity) {\n        return true;\n    }\n    forbidsCell(cell, actor) {\n        if (super.forbidsCell(cell, actor)) {\n            return true;\n        }\n        if (cell.blocksMove())\n            return true;\n        return false;\n    }\n    avoidsCell(cell, actor) {\n        if (super.avoidsCell(cell, actor))\n            return true;\n        if (cell.blocksPathing())\n            return true;\n        return false;\n    }\n    getFlavor(actor, opts) {\n        const flavor = actor.isPlayer() ? 'yourself' : this.flavor;\n        if (opts && opts.action) {\n            return flavor + ' standing';\n        }\n        return flavor;\n    }\n    pickupItem(actor, item, _opts) {\n        if (!GWU.list.push(actor, 'items', item))\n            return false;\n        // TODO - Pickup effects\n        return true;\n    }\n    dropItem(actor, item, _opts) {\n        if (!GWU.list.remove(actor, 'items', item))\n            return false;\n        // TODO - Drop effects\n        return true;\n    }\n    cellCost(cell, actor) {\n        if (this.forbidsCell(cell, actor)) {\n            return cell.hasEntityFlag(Flags.Entity.L_BLOCKS_DIAGONAL)\n                ? GWU.path.OBSTRUCTION\n                : GWU.path.FORBIDDEN;\n        }\n        else if (this.avoidsCell(cell, actor)) {\n            return GWU.path.AVOIDED;\n        }\n        return GWU.path.OK;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ActorKind } from './kind';\nexport function make(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ActorKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ActorKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ActorKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ActorKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import { installAction } from '../action';\n// BUMP\n//\n// prefixes:\n// @ = only for player\n// + = only for ally\n// - = only for opposed\n// = = only for same kind\n// $ = use my action (if used with one of the above, this comes last)\n//\nexport async function bump(game, actor, ctx = {}) {\n    const other = ctx.actor;\n    if (other) {\n        const bumpActions = other.getBumpActions();\n        for (let action of bumpActions) {\n            if (typeof action === 'string') {\n                if (action.startsWith('$')) {\n                    const selfName = action.substring(1);\n                    let selfAction = other.getAction(selfName);\n                    if (selfAction === false) {\n                        throw new Error('Cannot have bump action for self action that actor cannot do: ' +\n                            action);\n                    }\n                    const ctx2 = Object.assign({}, ctx, { actor });\n                    const result = await selfAction(game, other, ctx2);\n                    if (result)\n                        return result;\n                }\n                else {\n                    const config = actor.getAction(action);\n                    if (config === false) {\n                        throw new Error('Cannot configure actor with bump action they cannot do: ' +\n                            action);\n                    }\n                    else {\n                        action = config;\n                    }\n                    const result = await action(game, actor, ctx);\n                    if (result)\n                        return result;\n                }\n            }\n            else {\n                const result = await action(game, actor, ctx);\n                if (result)\n                    return result;\n            }\n        }\n    }\n    const item = ctx.item;\n    if (item) {\n        // TODO - Item Actions\n    }\n    return 0;\n}\ninstallAction('bump', bump);\n","import { installAction } from '../action';\nexport async function standStill(_game, actor, _ctx) {\n    return actor.endTurn();\n}\ninstallAction('standStill', standStill);\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\n// export class SpriteFX extends FX {\n//     sprite: GWU.sprite.SpriteConfig;\n//     stepCount: number;\n//     x: number;\n//     y: number;\n//     constructor(\n//         map: Map,\n//         sprite: string | GWU.sprite.SpriteConfig,\n//         x: number,\n//         y: number,\n//         opts: SpriteFxOptions = {}\n//     ) {\n//         const count = opts.blink || 1;\n//         const duration = opts.duration || 1000;\n//         opts.speed = opts.speed || duration / (2 * count - 1);\n//         super(map, opts);\n//         if (typeof sprite === 'string') {\n//             const name = sprite;\n//             sprite = GWU.sprite.sprites[sprite];\n//             if (!sprite) throw new Error('Cannot find sprite! ' + name);\n//         }\n//         this.sprite = sprite;\n//         this.x = x || 0;\n//         this.y = y || 0;\n//         this.stepCount = 2 * count - 1;\n//     }\n//     start() {\n//         this.map.addFx(this.x, this.y, this.sprite);\n//         return super.start();\n//     }\n//     step() {\n//         --this.stepCount;\n//         if (this.stepCount <= 0) return this.stop();\n//         if (this.stepCount % 2 == 0) {\n//             this.map.removeFx(this);\n//         } else {\n//             this.map.addFx(this.x, this.y, this);\n//         }\n//     }\n//     stop(result?: any) {\n//         this.map.removeFx(this);\n//         return super.stop(result);\n//     }\n//     moveDir(dx: number, dy: number) {\n//         return this.moveTo(this.x + dx, this.y + dy);\n//     }\n//     moveTo(x: number, y: number) {\n//         this.map.moveFx(x, y, this);\n//         return true;\n//     }\n// }\nexport async function flashSprite(map, x, y, sprite, duration = 100, count = 1, animator) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ visible: true })\n        .to({ visible: false })\n        .repeat(count)\n        .repeatDelay(duration)\n        .duration(duration)\n        .onUpdate((obj) => {\n        if (obj.visible) {\n            map.addFx(x, y, entity);\n        }\n        else {\n            map.removeFx(entity);\n        }\n    });\n    // realTime\n    animator = animator || GWU.io.loop;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nGWU.sprite.install('bump', 'white', 50);\nexport async function hit(map, target, sprite, duration, animator) {\n    sprite = sprite || 'hit';\n    duration = duration || 200;\n    await flashSprite(map, target.x, target.y, sprite, duration, 1, animator);\n}\nGWU.sprite.install('hit', 'red', 50);\nexport async function miss(map, target, sprite, duration, animator) {\n    sprite = sprite || 'miss';\n    duration = duration || 200;\n    await flashSprite(map, target.x, target.y, sprite, duration, 1, animator);\n}\nGWU.sprite.install('miss', 'green', 50);\nexport async function fadeInOut(map, x, y, sprite, duration = 100, animator) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite).clone();\n    }\n    else {\n        sprite = GWU.sprite.make(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ opacity: 0 })\n        .to({ opacity: 100 })\n        .repeat(2)\n        .yoyo(true)\n        .duration(Math.floor(duration / 2))\n        .onUpdate((obj) => {\n        entity.sprite.opacity = obj.opacity;\n        map.cell(x, y).needsRedraw = true; // we changed the sprite so redraw\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n    });\n    // realTime\n    animator = animator || GWU.io.loop;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nexport async function moveSprite(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    const from = { x: GWU.xy.x(source), y: GWU.xy.y(source) };\n    map.addFx(from.x, from.y, entity);\n    let duration = opts.duration ||\n        Math.ceil(16 * (GWU.xy.maxAxisFromTo(source, target) / (opts.speed || 8)));\n    if (GWU.xy.isLoc(target)) {\n        target = { x: target[0], y: target[1] };\n    }\n    const tween = GWU.tween\n        .make(from)\n        .to(target)\n        .duration(duration)\n        .onUpdate((vals) => {\n        // tweens dont update every step, so...\n        // draw line from current pos to vals pos\n        // check each step for blocking...\n        // end at either vals or last blocking spot\n        const dest = { x: entity.x, y: entity.y };\n        const ok = GWU.xy.forLineBetween(dest.x, dest.y, vals.x, vals.y, (x, y) => {\n            if (opts.stepFn) {\n                if (opts.stepFn(x, y)) {\n                    if (!opts.stopBeforeWalls) {\n                        dest.x = x;\n                        dest.y = y;\n                    }\n                    return false;\n                }\n            }\n            else if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (!opts.stopBeforeWalls) {\n                    dest.x = x;\n                    dest.y = y;\n                }\n                return false;\n            }\n            dest.x = x;\n            dest.y = y;\n        });\n        map.moveFx(entity, dest.x, dest.y);\n        if (!ok) {\n            tween.stop();\n        }\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n        return entity;\n    });\n    const animator = opts.animator || map;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nexport function bolt(map, source, target, sprite, opts = {}) {\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport async function projectile(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    if (sprite.ch && sprite.ch.length == 4) {\n        const dir = GWU.xy.dirFromTo(source, target);\n        let index = 0;\n        if (dir[0] && dir[1]) {\n            index = 2;\n            if (dir[0] != dir[1]) {\n                // remember up is -y\n                index = 3;\n            }\n        }\n        else if (dir[0]) {\n            index = 1;\n        }\n        const ch = sprite.ch[index];\n        sprite = GWU.sprite.make(ch, sprite.fg, sprite.bg);\n    }\n    else if (sprite.ch && sprite.ch.length !== 1) {\n        throw new Error('projectile requires 4 chars - vert,horiz,diag-left,diag-right (e.g: \"|-\\\\/\")');\n    }\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport function beam(map, from, to, sprite, opts = {}) {\n    opts.fade = opts.fade || 100;\n    if (opts.stopAtWalls === undefined)\n        opts.stopAtWalls = true;\n    const line = [];\n    GWU.xy.forLineFromTo(from, to, (x, y) => {\n        if (!map.hasXY(x, y))\n            return false;\n        if (opts.stepFn && opts.stepFn(x, y))\n            return false;\n        if (opts.stopAtWalls || opts.stopBeforeWalls) {\n            if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (opts.stopBeforeWalls)\n                    return false;\n                line.push([x, y]);\n                return false;\n            }\n        }\n        line.push([x, y]);\n        return true;\n    });\n    const duration = opts.duration || Math.ceil(16 * (line.length / (opts.speed || 8)));\n    const animator = opts.animator || map;\n    const promises = [];\n    let lastIndex = -1;\n    const tween = GWU.tween\n        .make({ index: 0 })\n        .to({ index: line.length - 1 })\n        .duration(duration)\n        .onUpdate((vals) => {\n        while (lastIndex < vals.index) {\n            ++lastIndex;\n            const loc = line[lastIndex] || [-1, -1];\n            promises.push(fadeInOut(map, loc[0], loc[1], sprite, opts.fade, animator));\n        }\n    })\n        .onFinish(async () => {\n        await Promise.all(promises);\n        const loc = line[line.length - 1];\n        return { x: loc[0], y: loc[1] };\n    });\n    animator.addAnimation(tween);\n    return tween.start();\n}\nfunction isInShape(shape, cx, cy, allowCenter, x, y) {\n    const sx = Math.abs(x - cx);\n    const sy = Math.abs(y - cy);\n    if (sx == 0 && sy == 0 && !allowCenter)\n        return false;\n    switch (shape) {\n        case '+':\n            return sx == 0 || sy == 0;\n        case 'x':\n        case 'X':\n            return sx == sy;\n        case '*':\n            return sx == 0 || sy == 0 || sx == sy;\n        default:\n            return true;\n    }\n}\nfunction checkExplosionOpts(opts) {\n    opts.speed = opts.speed || 2;\n    opts.fade = opts.fade || 100;\n    opts.shape = opts.shape || 'o';\n    if (opts.center === undefined) {\n        opts.center = true;\n    }\n}\nexport function explosion(map, x, y, radius, sprite, opts = {}) {\n    checkExplosionOpts(opts);\n    opts.animator = opts.animator || map;\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const grid = GWU.grid.alloc(map.width, map.height);\n    const fov = new GWU.fov.FOV({\n        isBlocked(x, y) {\n            return map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE);\n        },\n        hasXY(x, y) {\n            return map.hasXY(x, y);\n        },\n    });\n    fov.calculate(x, y, radius, (x1, y1) => {\n        grid[x1][y1] = 1;\n    });\n    const duration = opts.duration || 32 * (radius / opts.speed);\n    const promises = [];\n    const tween = GWU.tween\n        .make({ r: 0 })\n        .to({ r: radius })\n        .duration(duration)\n        .onUpdate((vals) => {\n        const minX = Math.max(0, x - vals.r);\n        const minY = Math.max(0, y - vals.r);\n        const maxX = Math.min(map.width - 1, x + vals.r);\n        const maxY = Math.min(map.height - 1, y + vals.r);\n        for (let x1 = minX; x1 <= maxX; ++x1) {\n            for (let y1 = minY; y1 <= maxY; ++y1) {\n                if (grid[x1][y1] &&\n                    GWU.xy.distanceBetween(x, y, x1, y1) <= vals.r) {\n                    grid[x1][y1] = 0;\n                    if (isInShape(opts.shape, x, y, opts.center, x1, y1)) {\n                        promises.push(fadeInOut(map, x1, y1, sprite, opts.fade, opts.animator));\n                    }\n                }\n            }\n        }\n    })\n        .onFinish(async (_obj, success) => {\n        GWU.grid.free(grid);\n        await Promise.all(promises);\n        return success;\n    });\n    opts.animator.addAnimation(tween);\n    return tween.start();\n}\n/*\nexport function explosionFor(\n    map: Map,\n    grid: GWU.grid.NumGrid,\n    x: number,\n    y: number,\n    radius: number,\n    sprite: string | GWU.sprite.SpriteConfig,\n    opts: ExplosionOptions = {}\n) {\n    checkExplosionOpts(opts);\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    const animation = new ExplosionFX(\n        map,\n        grid,\n        x,\n        y,\n        radius,\n        sprite,\n        opts.speed,\n        opts.fade,\n        opts.shape,\n        opts.center,\n        opts.stepFn\n    );\n    return opts.playFn!(animation);\n}\n*/\n","import { installAction } from '../action';\nimport { bump } from './bump';\nimport { standStill } from './standStill';\nimport * as FX from '../../fx';\nimport * as Flags from '../../flags';\nexport async function moveDir(game, actor, ctx = {}) {\n    //\n    const step = ctx.dir;\n    if (!step)\n        throw new Error('moveDir called with no direction!');\n    const newX = actor.x + step[0];\n    const newY = actor.y + step[1];\n    const map = game.map;\n    const currentCell = map.cell(actor.x, actor.y);\n    const newCell = map.cell(newX, newY);\n    let result = 0;\n    if (actor.forbidsCell(newCell)) {\n        if (ctx.try)\n            return 0;\n        FX.hit(map, newCell, 'hit', 100);\n        actor.clearGoal();\n        return actor.endTurn();\n    }\n    if (newCell.blocksMove()) {\n        if (ctx.try)\n            return 0;\n        FX.hit(map, newCell, 'hit', 100);\n        actor.clearGoal();\n        return actor.endTurn();\n    }\n    // can we leave?\n    if (!currentCell.canRemoveActor(actor)) {\n        if (ctx.try)\n            return 0;\n        // canActorLeave must add appropriate message\n        return actor.endTurn();\n    }\n    // is there an actor there?\n    if (newCell.hasActor() || newCell.hasItem()) {\n        if (ctx.try)\n            return 0;\n        const ctx2 = { actor: newCell.actor, item: newCell.item };\n        result = await bump(game, actor, ctx2);\n        if (result)\n            return result;\n    }\n    // can we enter?\n    if (!newCell.canAddActor(actor)) {\n        if (ctx.try)\n            return 0;\n        return actor.endTurn();\n    }\n    if (!map.moveActor(actor, newX, newY)) {\n        result = await standStill(game, actor, ctx);\n        return result;\n    }\n    let rate = 100;\n    if (newCell.hasTileFlag(Flags.Tile.T_DEEP_WATER)) {\n        rate = 150;\n    }\n    result = actor.endTurn(rate);\n    return result;\n}\ninstallAction('moveDir', moveDir);\n","import * as GWU from 'gw-utils';\nimport { installAction } from '../action';\nimport { moveDir } from './moveDir';\nexport async function idle(game, actor, _ctx) {\n    if (GWU.random.chance(50)) {\n        // do nothing\n        return actor.endTurn();\n    }\n    // try to step in a random direction\n    const dirIndex = GWU.random.number(4);\n    const dir = GWU.xy.DIRS[dirIndex];\n    const result = await moveDir(game, actor, { dir, try: true });\n    if (result)\n        return result;\n    // stand still\n    return actor.endTurn();\n}\ninstallAction('idle', idle);\n","import * as GWU from 'gw-utils';\nimport { installAction } from '../action';\nexport async function pickup(game, actor, ctx = {}) {\n    const map = actor.map;\n    if (!map)\n        throw new Error('Actor not on map!');\n    const item = actor.map.itemAt(actor.x, actor.y);\n    if (!item) {\n        if (!ctx.quiet) {\n            GWU.message.addAt(actor.x, actor.y, 'Nothing to pickup.');\n        }\n        return 0;\n    }\n    if (actor.avoidsItem(item))\n        return 0;\n    const itemAction = item.getAction('pickup');\n    if (itemAction === false) {\n        if (!ctx.quiet) {\n            GWU.message.addAt(actor.x, actor.y, 'You cannot pickup %{the.item}.', {\n                item,\n            });\n        }\n        return 0;\n    }\n    else if (typeof itemAction === 'function') {\n        // You have to do everything\n        const result = await itemAction(game, actor, item);\n        if (result)\n            return result; // handled\n    }\n    // logs error messages\n    if (!actor.canAddItem(item)) {\n        return 0;\n    }\n    if (!actor.map.removeItem(item)) {\n        return 0;\n    }\n    actor.addItem(item);\n    if (!ctx.quiet) {\n        GWU.message.addAt(actor.x, actor.y, 'You pickup %{the:item}.', {\n            item,\n        });\n    }\n    return actor.endTurn();\n}\ninstallAction('pickup', pickup);\n","import { Entity } from '../entity';\nimport { Depth } from '../flags';\nexport class Item extends Entity {\n    constructor(kind) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore - initialized in constructor\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n    }\n    copy(other) {\n        super.copy(other);\n        this.quantity = other.quantity;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n    getAction(name) {\n        const action = this.kind.actions[name];\n        return action;\n    }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Item } from './item';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n        this.flags = {\n            item: Flags.Item.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.actions = {};\n        this.bump = [];\n        if (config.flags) {\n            this.flags.item = GWU.flag.from(Flags.Item, this.flags.item, config.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, config.flags);\n        }\n        if (config.actions) {\n            Object.entries(config.actions).forEach(([key, value]) => {\n                this.actions[key] = value;\n            });\n        }\n        if (config.bump) {\n            if (typeof config.bump === 'string' ||\n                typeof config.bump === 'function') {\n                config.bump = [config.bump];\n            }\n            if (Array.isArray(config.bump)) {\n                this.bump = config.bump.slice();\n            }\n        }\n        this.avoidTileFlags |= Flags.Tile.T_DEEP_WATER;\n        this.forbidTileFlags |= Flags.Tile.T_LAVA | Flags.Tile.T_AUTO_DESCENT;\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n    init(item, options = {}) {\n        super.init(item, options);\n        Object.assign(item.flags, this.flags);\n        item.quantity = options.quantity || 1;\n    }\n    avoidsCell(cell, item) {\n        if (cell.isDoor())\n            return true;\n        return super.avoidsCell(cell, item);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ItemKind } from './kind';\nexport function make(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","export const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id.toLowerCase()] = handler;\n}\nexport const effectTypes = {};\nexport function installType(id, type) {\n    effectTypes[id] = type;\n}\n// export class Effect {\n//     id = '';\n//     chance = 100 * 100; // 100%\n//     type: string; // self | bolt | beam | ball | burst | adjacent | spread\n//     aim: string; // actor | item | cell\n//     bolt: string | GWU.sprite.SpriteData | null = null;\n//     beam = false;\n//     range = 0;\n//     ball: string | GWU.sprite.SpriteData | null = null;\n//     radius = 0;\n//     center = false;\n//     effects: EffectFn[];\n//     good = false;\n//     seen = false;\n//     next: Effect | null = null;\n//     constructor(config: EffectConfig) {\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         this.aim = config.aim || 'actor';\n//         if (typeof config.chance === 'string') {\n//             // '20%' becomes 2000\n//             config.chance = Math.floor(Number.parseFloat(config.chance) * 100);\n//         }\n//         this.chance = config.chance || 100 * 100;\n//         const type = config.type || 'basic';\n//         const parts = type.split(':');\n//         if (type.startsWith('bolt') || type.startsWith('beam')) {\n//             // bolt:range:sprite\n//             this.type = parts[0];\n//             this.range = parts[1] ? Number.parseInt(parts[1]) : 99;\n//             this.bolt = parts[1] || 'missile';\n//             this.beam = type.startsWith('beam');\n//         } else if (\n//             type.startsWith('ball') ||\n//             type.startsWith('burst') ||\n//             type.startsWith('aura')\n//         ) {\n//             this.type = parts[0];\n//             this.radius = parts[1] ? Number.parseInt(parts[1]) : 2;\n//             this.range = parts[2] ? Number.parseInt(parts[2]) : 99;\n//             this.ball = parts[3] || 'explosion';\n//             this.center = !type.startsWith('aura');\n//         } else {\n//             this.type = 'basic';\n//         }\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         if (Array.isArray(config.effects)) {\n//             this.effects = config.effects.map((e) => {\n//                 if (typeof e === 'function') return e;\n//                 return effectFnFromString(e);\n//             });\n//         } else {\n//             this.effects = [];\n//             Object.entries(config.effects).forEach(([key, value]) => {\n//                 const handler = handlers[key.toLowerCase()];\n//                 if (handler) {\n//                     this.effects.push(handler(value));\n//                 } else if (typeof value === 'function') {\n//                     this.effects.push(value);\n//                 } else {\n//                     throw new Error('Unknown effect: ' + key);\n//                 }\n//             });\n//         }\n//         if (this.effects.length === 0) throw new Error('No effects!');\n//     }\n//     clone(): this {\n//         const other = new (this.constructor as new (\n//             config: EffectConfig\n//         ) => this)(this as EffectConfig);\n//         return other;\n//     }\n//     fire(map: Map.MapType, x: number, y: number, ctx: EffectCtx = {}): boolean {\n//         let didSomething = false;\n//         ctx.good = this.good;\n//         ctx.seen = this.seen;\n//         if (!this.chance || map.rng.chance(this.chance, 10000)) {\n//             // fire\n//             for (let effect of this.effects) {\n//                 if (GWU.data.gameHasEnded) break;\n//                 if (effect(map, x, y, ctx)) {\n//                     didSomething = true;\n//                 } else {\n//                     break;\n//                 }\n//             }\n//         }\n//         if (ctx.aware && didSomething) {\n//             this.seen = true;\n//         }\n//         this.good = ctx.good;\n//         return didSomething;\n//     }\n//     reset() {\n//         this.seen = false;\n//     }\n// }\n// export function effectFnFromString(e: string): EffectFn {\n//     const parts = e.split(':');\n//     if (parts.length === 0) throw new Error('Invalid effect string.');\n//     // @ts-ignore\n//     const name = parts.shift().toLowerCase();\n//     const handler = handlers[name] || null;\n//     if (!handler) {\n//         throw new Error('Failed to find effect handler: ' + name);\n//     }\n//     return handler(parts);\n// }\nexport function make(opts) {\n    if (!opts)\n        throw new Error('opts required to make effect.');\n    let config = {};\n    if (typeof opts === 'string') {\n        // Special case\n        if (opts.toLowerCase().startsWith('spread:')) {\n            const endPos = opts.indexOf(':', 8);\n            const tile = opts.substring(8, endPos);\n            config = {\n                type: 'spread:' + opts.substring(endPos),\n                effects: ['tile:' + tile],\n            };\n        }\n        else {\n            config = { type: 'basic', effects: [opts] };\n        }\n    }\n    else if (typeof opts === 'function') {\n        config = { type: 'basic', effects: [opts] };\n    }\n    else if (Array.isArray(opts)) {\n        config = { type: 'basic', effects: opts };\n    }\n    else {\n        // @ts-ignore\n        if (opts.effect) {\n            // @ts-ignore\n            opts.effects = [opts.effect];\n            delete opts.effect;\n        }\n        // object only\n        if (opts.effects) {\n            Object.assign(config, opts);\n            if (typeof config.effects === 'string') {\n                config.effects = [opts.effects];\n            }\n            else if (typeof config.effects === 'function') {\n                config.effects = [opts.effects];\n            }\n        }\n        else {\n            config.effects = {};\n            Object.entries(opts).forEach(([key, value]) => {\n                const handler = handlers[key.toLowerCase()];\n                if (handler !== undefined) {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                }\n                else if (typeof value === 'function') {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                }\n                else {\n                    // @ts-ignore\n                    config[key] = value;\n                }\n            });\n        }\n    }\n    config.type = config.type || 'basic';\n    if (typeof config.type !== 'string')\n        throw new Error('Invalid effect type: ' + JSON.stringify(config.type));\n    const typeParts = config.type.split(':').map((t) => t.trim());\n    const typeName = typeParts.shift();\n    const makeFn = effectTypes[typeName.toLowerCase()];\n    if (!makeFn)\n        throw new Error('Invalid effect type: ' + typeName);\n    const effect = makeFn(config);\n    if (Array.isArray(config.effects)) {\n        config.effects.forEach((e) => {\n            if (typeof e === 'function') {\n                effect.effects.push(e);\n            }\n            else {\n                const parts = e.split(':').map((t) => t.trim());\n                if (parts.length === 1) {\n                    const effect = installedEffects[parts[0]];\n                    if (!effect)\n                        throw new Error('Failed to find effect with id: ' + parts[0]);\n                    effect.effects.push(effect.trigger.bind(effect));\n                }\n                else {\n                    const handler = handlers[parts[0].toLowerCase()];\n                    if (!handler)\n                        throw new Error('Unknown effect: ' + parts[0]);\n                    parts.shift();\n                    effect.effects.push(handler(parts));\n                }\n            }\n        });\n    }\n    else {\n        Object.entries(config.effects).forEach(([key, value]) => {\n            const handler = handlers[key.toLowerCase()];\n            if (!handler)\n                throw new Error('Failed to find handler type: ' + key);\n            effect.effects.push(handler(value));\n        });\n    }\n    if (config.next) {\n        effect.next = make(config.next);\n    }\n    return effect;\n}\nexport function from(opts) {\n    if (!opts)\n        throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'object' && 'trigger' in opts) {\n        return opts;\n    }\n    if (typeof opts === 'string') {\n        const effect = installedEffects[opts];\n        if (effect)\n            return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\nfunction isEffect(obj) {\n    return typeof obj === 'object' && 'trigger' in obj;\n}\n//////////////////////////////\n// INSTALL\nexport const installedEffects = {};\nexport function install(id, config) {\n    const effect = isEffect(config) ? config.clone() : make(config);\n    installedEffects[id] = effect;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function resetAll() {\n    Object.values(installedEffects).forEach((e) => (e.seen = false));\n}\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nimport * as Flags from '../../flags';\nexport class BasicEffect {\n    constructor(config) {\n        this.effects = [];\n        this.chance = 100 * 100; // 100%\n        this.seen = false;\n        this.flags = 0;\n        this.next = null;\n        if (typeof config === 'object' && !Array.isArray(config)) {\n            this.flags = GWU.flag.from(Flags.Effect, config.flags);\n            if (typeof config.chance === 'string' &&\n                config.chance.endsWith('%')) {\n                this.chance = Number.parseFloat(config.chance) * 100;\n            }\n            else {\n                this.chance = Number.parseInt(config.chance || '10000');\n            }\n        }\n    }\n    clone() {\n        const other = new this.constructor();\n        other.effects = this.effects.slice();\n        other.chance = this.chance;\n        other.seen = false;\n        other.flags = this.flags;\n        other.next = this.next;\n        return other;\n    }\n    trigger(loc, ctx = {}) {\n        if (!ctx.force && this.chance) {\n            const rng = ctx.rng || loc.map.rng || GWU.random;\n            if (!rng.chance(this.chance, 10000))\n                return false;\n        }\n        let didSomething = false;\n        for (let eff of this.effects) {\n            if (eff(loc, ctx)) {\n                didSomething = true;\n            }\n        }\n        if (this.next) {\n            const nextAlways = !!(this.flags & Flags.Effect.E_NEXT_ALWAYS);\n            if (didSomething || nextAlways) {\n                return this.next.trigger(loc, ctx);\n            }\n        }\n        return didSomething;\n    }\n}\nexport function makeBasicEffect(config) {\n    if (typeof config !== 'object') {\n        return new BasicEffect();\n    }\n    return new BasicEffect(config);\n}\nEffect.installType('basic', makeBasicEffect);\n","import * as GWU from 'gw-utils';\nimport { BasicEffect } from './basic';\nimport { installType } from '../effect';\nimport * as Flags from '../../flags';\nexport function makeSpreadEffect(config) {\n    return new SpreadEffect(config);\n}\ninstallType('spread', makeSpreadEffect);\nexport class SpreadEffect extends BasicEffect {\n    constructor(config) {\n        super(config);\n        this.grow = 0;\n        this.decrement = 0;\n        this.matchTile = '';\n        if (!config) {\n            config = { grow: 0, decrement: 0, flags: 0 };\n        }\n        if (typeof config === 'string') {\n            config = config.split(':').map((t) => t.trim());\n        }\n        if (Array.isArray(config)) {\n            if (config[0].toLowerCase() === 'spread') {\n                config.shift();\n            }\n            config = {\n                grow: config[0] || '0',\n                decrement: config[1] || '100',\n                flags: config[2] || '0',\n            };\n        }\n        else if (typeof config.type === 'string' &&\n            config.type.includes(':')) {\n            const parts = config.type.split(':').map((t) => t.trim());\n            if (parts[0].toLowerCase() === 'spread') {\n                parts.shift();\n            }\n            config.grow = parts[0] || '0';\n            config.decrement = parts[1] || '100';\n            config.flags = config.flags + '|' + parts[2];\n        }\n        this.grow = Number.parseInt(config.grow || 0);\n        this.decrement = Number.parseInt(config.decrement || 100);\n        this.flags = GWU.flag.from(Flags.Effect, config.flags || 0);\n        this.matchTile = config.matchTile || '';\n    }\n    clone() {\n        const other = super.clone();\n        other.grow = this.grow;\n        other.decrement = this.decrement;\n        other.matchTile = this.matchTile;\n        return other;\n    }\n    trigger(xy, ctx = {}) {\n        const abortIfBlocking = !!(this.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n        let didSomething = false;\n        const map = xy.map;\n        const spawnMap = GWU.grid.alloc(map.width, map.height);\n        didSomething = computeSpawnMap(this, xy, spawnMap);\n        if (!didSomething) {\n            GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (abortIfBlocking && mapDisruptedBy(map, spawnMap)) {\n            GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (this.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (this.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (this.flags & Flags.Effect.E_CLEAR_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (clearCells(map, spawnMap, this.flags)) {\n                didSomething = true;\n            }\n        }\n        spawnMap.forEach((v, x, y) => {\n            if (!v)\n                return;\n            spawnMap[x][y] = 1; // convert from generations to off/on/success\n            for (let eff of this.effects) {\n                if (eff({ map, x, y }, ctx)) {\n                    didSomething = true;\n                    spawnMap[x][y] = 2;\n                }\n            }\n        });\n        if (this.next) {\n            const nextAlways = !!(this.flags & Flags.Effect.E_NEXT_ALWAYS);\n            if (didSomething || nextAlways) {\n                if (this.flags & Flags.Effect.E_NEXT_EVERYWHERE) {\n                    spawnMap.forEach((v, x, y) => {\n                        if (!v)\n                            return;\n                        if (v == 2 || nextAlways) {\n                            this.next.trigger({ map, x, y }, ctx);\n                        }\n                    });\n                }\n                else {\n                    this.next.trigger({ map, x: xy.x, y: xy.y }, ctx);\n                }\n            }\n        }\n        GWU.grid.free(spawnMap);\n        return didSomething;\n    }\n}\nexport function mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(map.width, map.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (map.cell(i, j).isStairs()) {\n                disrupts = true;\n            }\n        }\n        else if (!map.cell(i, j).blocksMove()) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGWU.grid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cell(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cell(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.matchTile && !isStart && !cell.hasTile(effect.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, loc, spawnMap) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const map = loc.map;\n    let startProb = effect.grow || 0;\n    let probDec = effect.decrement || 0;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, loc.x, loc.y, true)) {\n        return false;\n    }\n    spawnMap[loc.x][loc.y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap[a.x][a.y])\n            return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const c = map.cell(x, y);\n            return !a.forbidsCell(c);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeActor(a);\n            map.addActor(loc[0], loc[1], a);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap[i.x][i.y])\n            return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const dest = map.cell(x, y);\n            return !i.forbidsCell(dest);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(i);\n            map.addItem(loc[0], loc[1], i);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// EMIT\nexport function makeEmitHandler(config) {\n    if (Array.isArray(config))\n        config = config[0];\n    if (typeof config !== 'string')\n        throw new Error('Invalid EMIT handler config - ' + config);\n    return emitEffect.bind(undefined, config);\n}\nexport function emitEffect(id, loc, ctx) {\n    return loc.map.events.emit(id, loc, ctx);\n}\ninstallHandler('emit', makeEmitHandler);\n","import * as GWU from 'gw-utils';\nimport { installHandler } from '../effect';\n//////////////////////////////////////////////\n// MESSAGE\nexport function makeMessageHandler(src) {\n    if (Array.isArray(src))\n        src = src[0];\n    if (typeof src !== 'string') {\n        throw new Error('Need message for message effect.');\n    }\n    const info = {\n        msg: src,\n    };\n    return messageEffect.bind(undefined, info);\n}\nexport function messageEffect(info, loc, ctx) {\n    const seen = ctx.seen;\n    const msg = info.msg;\n    if (msg &&\n        msg.length &&\n        ctx.aware &&\n        !seen\n    // && map.isVisible(x, y)\n    ) {\n        GWU.message.addAt(loc.x, loc.y, msg, ctx);\n        return true;\n    }\n    return false;\n}\ninstallHandler('msg', makeMessageHandler);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// ActivateMachine\nexport function makeActivateMachine() {\n    return activateMachine.bind(undefined);\n}\nexport function activateMachine(loc, ctx) {\n    const cell = loc.map.cell(loc.x, loc.y);\n    const machine = cell.machineId;\n    if (!machine)\n        return false;\n    return loc.map.activateMachine(machine, loc.x, loc.y, ctx);\n}\ninstallHandler('activateMachine', makeActivateMachine);\n","import { installHandler } from '../effect';\nexport function makeTileHandler(src) {\n    if (!src)\n        throw new Error('Tile effect needs configuration.');\n    if (typeof src === 'string') {\n        src = { id: src };\n    }\n    else if (Array.isArray(src)) {\n        src = { id: src[0] };\n    }\n    else if (!src.id) {\n        throw new Error('Tile effect needs configuration with id.');\n    }\n    const opts = src;\n    if (opts.id.includes('!')) {\n        opts.superpriority = true;\n    }\n    if (opts.id.includes('~')) {\n        opts.blockedByActors = true;\n        opts.blockedByItems = true;\n    }\n    opts.id = opts.id.replace(/[!~]*/g, '');\n    return tileEffect.bind(opts);\n}\nexport function tileEffect(loc, ctx) {\n    this.machine = ctx.machine || 0;\n    const didSomething = loc.map.setTile(loc.x, loc.y, this.id, this);\n    return didSomething;\n}\ninstallHandler('tile', makeTileHandler);\n","import * as Flags from '../../flags';\nimport { installHandler } from '../effect';\nexport function makeClearHandler(config) {\n    let layers = 0;\n    if (!config) {\n        layers = Flags.Depth.ALL_LAYERS;\n    }\n    else if (typeof config === 'number') {\n        layers = config;\n    }\n    else if (typeof config === 'string') {\n        const parts = config.split(/[,|]/g);\n        layers = parts.reduce((out, v) => {\n            if (typeof v === 'number')\n                return out | v;\n            const depth = Flags.Depth[v] || 0;\n            return out | depth;\n        }, 0);\n    }\n    else {\n        throw new Error('Invalid config for clear effect: ' + JSON.stringify(config));\n    }\n    return clearEffect.bind(undefined, layers);\n}\nexport function clearEffect(layers, loc, _ctx) {\n    if (!layers)\n        return false;\n    const cell = loc.map.cell(loc.x, loc.y);\n    return cell.clearDepth(layers);\n}\ninstallHandler('clear', makeClearHandler);\n","import * as Effect from '../effect';\nexport function makeFeatureHandler(id) {\n    if (Array.isArray(id))\n        id = id[0];\n    if (id && typeof id !== 'string') {\n        id = id.id;\n    }\n    if (!id || !id.length)\n        throw new Error('Feature effect needs ID');\n    return featureEffect.bind(undefined, id);\n}\nexport function featureEffect(id, loc, ctx) {\n    const feat = Effect.installedEffects[id];\n    if (!feat) {\n        throw new Error('Failed to find feature: ' + id);\n    }\n    return feat.trigger(loc, ctx);\n}\nEffect.installHandler('feature', makeFeatureHandler);\nEffect.installHandler('effect', makeFeatureHandler);\nEffect.installHandler('id', makeFeatureHandler);\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nexport function makeNourishEffect(opts) {\n    if (!opts)\n        throw new Error('Invalid Nourish config.');\n    let info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.type = opts[0] || 'inc';\n        info.amount = GWU.range.make(opts[1] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(opts.amount || 1);\n    }\n    else {\n        throw new Error('Invalid Nourish config: ' + JSON.stringify(opts));\n    }\n    return nourishEffect.bind(undefined, info);\n}\nexport function nourishEffect(config, loc, _ctx) {\n    if (!config.amount)\n        return false;\n    // who am I nourishing?\n    const actor = loc.map.actorAt(loc.x, loc.y);\n    if (!actor) {\n        return false;\n    }\n    const stats = actor.stats;\n    const c = stats.get('food');\n    if (!stats.adjust('food', config.type, config.amount))\n        return false;\n    const n = stats.get('food');\n    if (n < c && n / stats.max('food') < 0.1) {\n        GWU.message.addAt(actor.x, actor.y, nourishEffect.default.pukeMsg, {\n            actor,\n        });\n    }\n    return true;\n}\nnourishEffect.default = {\n    pukeMsg: '%you vomit.',\n};\nEffect.installHandler('nourish', makeNourishEffect);\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nexport function makeStatEffect(opts) {\n    if (!opts)\n        throw new Error('Invalid Stat config.');\n    const info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.stat = opts[0];\n        info.type = opts[1] || 'inc';\n        info.amount = GWU.range.make(opts[2] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.stat = opts.stat;\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(info.amount || 1);\n    }\n    else {\n        throw new Error('Invalid stat effect configuration: ' + JSON.stringify(opts));\n    }\n    return statEffect.bind(undefined, info);\n}\nexport function statEffect(config, loc, _ctx) {\n    if (!config.amount)\n        return false;\n    // who am I nourishing?\n    const actor = loc.map.actorAt(loc.x, loc.y);\n    if (!actor) {\n        return false;\n    }\n    // sustain?\n    const stats = actor.stats;\n    if (!stats.adjust('food', config.type, config.amount))\n        return false;\n    return true;\n}\nEffect.installHandler('stat', makeStatEffect);\n","import * as GWU from 'gw-utils';\nimport { make as makeEffect } from '../effect/effect';\nimport * as Flags from '../flags';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.effects = {};\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.tags = [];\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.effects) {\n            Object.assign(this.effects, config.effects);\n        }\n        if (this.hasEffect('fire')) {\n            this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n        }\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                config.tags\n                    .split(/[,|]/)\n                    .map((t) => t.trim())\n                    .forEach((t) => {\n                    this.tags.push(t);\n                });\n            }\n            else {\n                this.tags = config.tags.slice().map((t) => t.trim());\n            }\n        }\n    }\n    hasTag(tag) {\n        return this.tags.includes(tag);\n    }\n    hasAnyTag(tags) {\n        return GWU.arraysIntersect(this.tags, tags);\n    }\n    hasAllTags(tags) {\n        return tags.every((t) => this.tags.includes(t));\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    hasEffect(name) {\n        return name in this.effects;\n    }\n    getName(arg) {\n        let opts = {};\n        if (typeof arg === 'boolean') {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription(opts) {\n        return this.description || this.getName(opts);\n    }\n    getFlavor(opts) {\n        return this.flavor || this.getName(opts);\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { effects: {}, flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const effects = {};\n    Object.assign(effects, base.effects);\n    if (options.effects) {\n        Object.entries(options.effects).forEach(([key, value]) => {\n            if (value === null) {\n                delete effects[key];\n                return;\n            }\n            if (typeof value === 'string' && !value.includes(':')) {\n                effects[key] = value;\n                return;\n            }\n            try {\n                effects[key] = makeEffect(value);\n            }\n            catch (e) {\n                throw new Error(`Failed to add effect to tile => ${key} : ${JSON.stringify(value)} : ` + e.message);\n            }\n        });\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        effects,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n        tags: options.tags || null,\n    };\n    const tile = new Tile(config);\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n// These are the minimal set of tiles to make the diggers work\nexport const NULL = install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\n// import './tiles';\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile, _opts) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n}\n","import { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts) {\n        const cell = this.map.cell(x, y);\n        return cell.setTile(tile, opts);\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // // Bookkeeping for fire, pressure plates and key-activated tiles.\n        // for (let x = 0; x < this.map.width; ++x) {\n        //     for (let y = 0; y < this.map.height; ++y) {\n        //         const cell = this.map.cell(x, y);\n        //         if (\n        //             !cell.hasCellFlag(\n        //                 Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM\n        //             ) &&\n        //             cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)\n        //         ) {\n        //             cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n        //         }\n        //     }\n        // }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    clear() {\n        this.volume.fill(0);\n    }\n    setTile(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.setTile(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.changed = true;\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n        this.changed = other.changed;\n    }\n    tick(_dt) {\n        if (!this.changed)\n            return false;\n        this.changed = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.changed = true;\n            }\n            else {\n                this.clearTile(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clearTile(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nimport * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.xy.DIRS[d];\n                        this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = Effect.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && this.map.rng.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            cell.fireEvent(event, {\n                force: true,\n            });\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as Effect from '../effect';\nGWU.color.install('cellStatusName', 'light_blue');\nexport const NEVER_SEEN = {\n    tiles: [TILE.NULL],\n    item: null,\n    actor: null,\n    flags: {\n        cell: 0,\n        entity: TILE.NULL.flags.entity,\n        tile: TILE.NULL.flags.tile,\n        tileMech: TILE.NULL.flags.tileMech,\n    },\n};\nexport class Cell {\n    constructor(map, x, y, groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.x = -1;\n        this.y = -1;\n        // toFire: Partial<Effect.EffectCtx>[] = [];\n        this.memory = null;\n        // this._entities = new CellEntities(this);\n        this.flags = { cell: Flags.Cell.NEEDS_REDRAW };\n        this.tiles = [TILE.tiles.NULL];\n        this.map = map;\n        this.x = x;\n        this.y = y;\n        this.snapshot = GWU.sprite.makeMixer();\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n        this.memory = NEVER_SEEN;\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get hasStableSnapshot() {\n        return this.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    }\n    get hasStableMemory() {\n        return this.hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    storeMemory() {\n        var _a;\n        this.setCellFlag(Flags.Cell.STABLE_MEMORY);\n        // store memory\n        this.memory = {\n            flags: {\n                cell: this.flags.cell,\n                entity: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.entity) || 0), 0),\n                tile: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.tile) || 0), 0),\n                tileMech: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.tileMech) || 0), 0),\n            },\n            tiles: this.tiles.slice(),\n            item: ((_a = this.item) === null || _a === void 0 ? void 0 : _a.clone()) || null,\n            actor: null,\n        };\n        if (this.hasItem()) {\n            const item = this.item;\n            if (item) {\n                this.memory.flags.entity |= item.flags.entity;\n            }\n        }\n        if (this.hasActor()) {\n            const actor = this.actor;\n            if (actor) {\n                this.memory.flags.entity |= actor.flags.entity;\n            }\n            this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n    }\n    clearMemory() {\n        this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT | Flags.Cell.STABLE_MEMORY);\n        this.memory = null;\n        this.needsRedraw = true;\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this.machineId = other.machineId;\n        // this._actor = other.actor;\n        // this._item = other.item;\n        this.memory = other.memory;\n        this.map = other.map;\n        this.x = other.x;\n        this.y = other.y;\n        other.getSnapshot(this.snapshot);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag, checkEntities = false) {\n        var _a, _b;\n        if (this.tiles.some((t) => t && t.flags.entity & flag))\n            return true;\n        if (!checkEntities)\n            return false;\n        if (this.hasItem()) {\n            if ((_a = this.item) === null || _a === void 0 ? void 0 : _a.hasEntityFlag(flag))\n                return true;\n        }\n        if (this.hasActor()) {\n            if ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.hasEntityFlag(flag))\n                return true;\n        }\n        return false;\n    }\n    hasAllEntityFlags(flags, checkEntities = false) {\n        return (this.entityFlags(checkEntities) & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    hasTileTag(tag) {\n        return this.tiles.some((tile) => tile && tile.hasTag(tag));\n    }\n    hasAllTileTags(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAllTags(tags);\n        });\n    }\n    hasAnyTileTag(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAnyTag(tags);\n        });\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags(withEntities = false) {\n        var _a, _b;\n        let flag = this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0);\n        if (withEntities) {\n            if (this.hasItem()) {\n                flag |= ((_a = this.item) === null || _a === void 0 ? void 0 : _a.flags.entity) || 0;\n            }\n            if (this.hasActor()) {\n                flag |= ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.flags.entity) || 0;\n            }\n        }\n        return flag;\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            if (!this.memory) {\n                this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n                this.flags.cell &= ~Flags.Cell.STABLE_SNAPSHOT;\n                this.map.needsRedraw = true;\n            }\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return this.tiles.some((t) => t && t.blocksVision());\n    }\n    blocksPathing() {\n        return (this.tiles.some((t) => t && t.blocksPathing()) &&\n            !this.tiles.some((t) => t && t.hasTileFlag(Flags.Tile.T_BRIDGE)));\n    }\n    blocksMove() {\n        return this.tiles.some((t) => t && t.blocksMove());\n    }\n    blocksEffects() {\n        return this.tiles.some((t) => t && t.blocksEffects());\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isNull() {\n        return this.tiles.every((t) => !t || t === TILE.tiles.NULL);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isDoor() {\n        return this.hasTileFlag(Flags.Tile.T_IS_DOOR);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    // hasKey(): boolean {\n    //     return this._entities.some(\n    //         (e) => !!e.key && e.key.matches(this.x, this.y)\n    //     );\n    // }\n    hasLiquid() {\n        return this.hasTileFlag(Flags.Tile.T_ANY_LIQUID);\n    }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile, opts = {}) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile)\n            return false;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (this.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && this.hasItem())\n            return false;\n        if (opts.blockedByActors && this.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && this.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const currentGround = this.depthTile(Flags.Depth.GROUND);\n            const wantGround = TILE.get(tile.groundTile);\n            if (currentGround !== wantGround) {\n                if (!this.setTile(wantGround, opts)) {\n                    return false;\n                }\n            }\n        }\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            this.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            this.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (current.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR) !==\n            tile.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR)) {\n            this.map.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            this.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.needsRedraw = true;\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.snapshot.blackOut();\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    tileWithEffect(name) {\n        return this.tiles.find((t) => t === null || t === void 0 ? void 0 : t.hasEffect(name)) || null;\n    }\n    fireEvent(event, ctx = {}) {\n        // ctx.cell = this;\n        let didSomething = false;\n        // console.log('fire event - %s', event);\n        for (const tile of this.tiles) {\n            if (!tile || !tile.effects)\n                continue;\n            const ev = tile.effects[event];\n            if (ev) {\n                const r = this._activate(ev, ctx);\n                if (r) {\n                    didSomething = true;\n                }\n            }\n        }\n        return didSomething;\n    }\n    _activate(effect, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.installedEffects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = effect.trigger(this, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    get item() {\n        return this.map.itemAt(this.x, this.y);\n    }\n    canAddItem(_item) {\n        return true;\n    }\n    canRemoveItem(_item) {\n        return true;\n    }\n    _addItem(_item) {\n        this.setCellFlag(Flags.Cell.HAS_ITEM);\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeItem(item) {\n        let hasItems = false;\n        let foundIndex = -1;\n        this.map.items.forEach((obj, index) => {\n            if (obj === item) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasItems = true;\n            }\n        });\n        if (!hasItems) {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this.map.actorAt(this.x, this.y);\n    }\n    canAddActor(_actor) {\n        return true;\n    }\n    canRemoveActor(_actor) {\n        return true;\n    }\n    _addActor(actor) {\n        this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        if (actor.isPlayer()) {\n            this.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeActor(actor) {\n        let hasActor = false;\n        let foundIndex = -1;\n        this.map.actors.forEach((obj, index) => {\n            if (obj === actor) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasActor = true;\n            }\n        });\n        if (!hasActor) {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.HAS_PLAYER);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    hasFx() {\n        return !!(this.flags.cell & Flags.Cell.HAS_FX);\n    }\n    get fx() {\n        return this.map.fxAt(this.x, this.y);\n    }\n    _addFx(_fx) {\n        this.setCellFlag(Flags.Cell.HAS_FX);\n        this.needsRedraw = true;\n    }\n    _removeFx(_fx) {\n        if (!this.fx) {\n            this.clearCellFlag(Flags.Cell.HAS_FX);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        if (this.hasActor()) {\n            const actor = this.map.actorAt(this.x, this.y);\n            if (actor && actor.sprite.ch)\n                return actor.sprite.ch;\n        }\n        if (this.hasItem()) {\n            const item = this.map.itemAt(this.x, this.y);\n            if (item && item.sprite.ch)\n                return item.sprite.ch;\n        }\n        if (this.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return '=';\n        }\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n    drawStatus(buffer, bounds) {\n        const lines = buffer.wrapText(bounds.x + 1, bounds.y, bounds.width - 1, this.getName(), 'cellStatusName');\n        return lines;\n    }\n    toString() {\n        return `Cell @ ${this.x},${this.y}`;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nconst highlightColor = GWU.color.install('highlight', [100, 100, 0]);\nexport class BasicDrawer {\n    constructor() {\n        this.scent = false;\n    }\n    drawInto(dest, map, opts = {}) {\n        const buffer = dest instanceof GWU.buffer.Buffer ? dest : dest.buffer;\n        const offsetX = opts.offsetX || 0;\n        const offsetY = opts.offsetY || 0;\n        map.clearMapFlag(Flags.Map.MAP_DANCES);\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                if (map.hasXY(x + offsetX, y + offsetY)) {\n                    const cell = map.cell(x + offsetX, y + offsetY);\n                    this.drawCell(mixer, map, cell, map.fov);\n                    buffer.drawSprite(x, y, mixer);\n                }\n            }\n        }\n    }\n    drawCell(dest, map, cell, fov) {\n        dest.blackOut();\n        // const isVisible = fov ? fov.isAnyKindOfVisible(cell.x, cell.y) : true;\n        const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (cell.needsRedraw || needSnapshot) {\n            this.getAppearance(dest, map, cell);\n            cell.putSnapshot(dest);\n            cell.needsRedraw = false;\n            cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n        else {\n            cell.getSnapshot(dest);\n            if (cell.hasCellFlag(Flags.Cell.COLORS_DANCE)) {\n                map.setMapFlag(Flags.Map.MAP_DANCES);\n            }\n        }\n        this.applyLight(dest, cell, fov);\n        let separate = false;\n        if (cell.memory) {\n            separate = !!(cell.memory.flags.entity &\n                (Flags.Entity.L_VISUALLY_DISTINCT |\n                    Flags.Entity.L_LIST_IN_SIDEBAR));\n        }\n        else {\n            separate = cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT |\n                Flags.Entity.L_LIST_IN_SIDEBAR, true);\n        }\n        if (cell.hasCellFlag(Flags.Cell.IS_CURSOR)) {\n            dest.invert();\n            dest.mix(highlightColor, 0, 25);\n            separate = true;\n        }\n        else if (cell.hasCellFlag(Flags.Cell.IS_HIGHLIGHTED)) {\n            dest.invert();\n            separate = true;\n        }\n        if (this.scent && map.player) {\n            const s = GWU.clamp(map.player.scent.get(cell.x, cell.y) * 5, 0, 50);\n            if (s) {\n                const c = GWU.color.colors.red;\n                dest.mix(c, 0, s);\n            }\n        }\n        if (separate) {\n            [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n        }\n        return true;\n    }\n    // getCellAppearance(cell: CellType, dest: GWU.sprite.Mixer) {\n    //     dest.blackOut();\n    //     const isVisible = true; // this.fov.isAnyKindOfVisible(x, y);\n    //     const isRevealed = true; // this.fov.isRevealed(x, y);\n    //     const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     if (needSnapshot || (cell.needsRedraw && isVisible)) {\n    //         this.layers.forEach((layer) => layer.putAppearance(dest, cell));\n    //         if (dest.dances) {\n    //             cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n    //         } else {\n    //             cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n    //         }\n    //         dest.bake();\n    //         cell.putSnapshot(dest);\n    //         cell.needsRedraw = false;\n    //         cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     } else {\n    //         cell.getSnapshot(dest);\n    //     }\n    //     if (isVisible) {\n    //         const light = this.light.getLight(cell.x, cell.y);\n    //         dest.multiply(light);\n    //     } else if (isRevealed) {\n    //         dest.scale(50);\n    //     } else {\n    //         dest.blackOut();\n    //     }\n    //     if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n    //         [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n    //     }\n    // }\n    getAppearance(dest, map, cell) {\n        let tiles = cell.tiles;\n        let actor = null;\n        let item = null;\n        if (cell.memory) {\n            tiles = cell.memory.tiles;\n            item = cell.memory.item;\n        }\n        else {\n            actor = cell.hasActor() ? cell.actor : null;\n            item = cell.hasItem() ? cell.item : null;\n        }\n        const ground = tiles[Flags.Depth.GROUND];\n        const surface = tiles[Flags.Depth.SURFACE];\n        const liquid = tiles[Flags.Depth.LIQUID];\n        const gas = tiles[Flags.Depth.GAS]; // How to get volume!?!?!?!\n        dest.drawSprite(ground.sprite);\n        if (surface) {\n            dest.drawSprite(surface.sprite);\n        }\n        if (liquid) {\n            dest.drawSprite(liquid.sprite);\n        }\n        if (item) {\n            item.drawInto(dest);\n        }\n        if (actor) {\n            actor.drawInto(dest);\n        }\n        if (gas) {\n            const opacity = GWU.rng.cosmetic.number(50) + 25;\n            dest.drawSprite(gas.sprite, opacity);\n        }\n        if (cell.hasFx()) {\n            const fx = map.fxAt(cell.x, cell.y);\n            if (fx)\n                dest.drawSprite(fx.sprite);\n        }\n        if (dest.dances) {\n            cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n            map.setMapFlag(Flags.Map.MAP_DANCES);\n        }\n        else {\n            cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n        }\n        dest.bake(true); // apply dancing\n    }\n    applyLight(dest, cell, fov) {\n        const isVisible = !fov || fov.isAnyKindOfVisible(cell.x, cell.y);\n        const isRevealed = !fov || fov.isRevealed(cell.x, cell.y);\n        const light = cell.map.light.getLight(cell.x, cell.y);\n        dest.multiply(light);\n        // TODO - is Clairy\n        // TODO - is Telepathy\n        if (fov && fov.isCursor(cell.x, cell.y)) {\n            dest.invert();\n        }\n        else if (!isVisible) {\n            if (isRevealed) {\n                dest.scale(70);\n            }\n            else {\n                dest.blackOut();\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport * as Layer from '../layer';\nimport * as Effect from '../effect';\nimport { BasicDrawer } from '../draw/basic';\nexport class Map {\n    constructor(width, height, opts = {}) {\n        // _memory: GWU.grid.Grid<CellMemory>;\n        // machineCount = 0;\n        // _seed = 0;\n        this.rng = GWU.rng.random;\n        // id = 'MAP';\n        this.actors = [];\n        this.items = [];\n        this.fx = [];\n        this.player = null;\n        this._animations = [];\n        this.events = new GWU.events.EventEmitter();\n        this.flags = { map: 0 };\n        this.layers = [];\n        this.properties = { seed: 0, machineCount: 0 };\n        if (opts.id) {\n            this.properties.id = opts.id;\n        }\n        this.drawer = opts.drawer || new BasicDrawer();\n        this.cells = GWU.grid.make(width, height, (x, y) => new Cell(this, x, y));\n        // this._memory = GWU.grid.make(\n        //     width,\n        //     height,\n        //     (x, y) => new CellMemory(this, x, y)\n        // );\n        if (opts.seed) {\n            this.properties.seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        if (opts.fov === undefined) {\n            opts.alwaysVisible = true;\n        }\n        else if (opts.fov === false) {\n            opts.visible = true;\n        }\n        opts.callback = this.onFovChange.bind(this);\n        this.fov = new GWU.fov.FovSystem(this, opts);\n        this.initLayers();\n        if (opts.player) {\n            this.setPlayer(opts.player);\n        }\n    }\n    get seed() {\n        return this.properties.seed;\n    }\n    set seed(v) {\n        this.properties.seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    get width() {\n        return this.cells.width;\n    }\n    get height() {\n        return this.cells.height;\n    }\n    // memory(x: number, y: number): CellMemory {\n    //     return this._memory[x][y];\n    // }\n    // knowledge(x: number, y: number): CellInfoType {\n    //     if (this.fov.isAnyKindOfVisible(x, y)) return this.cell(x,y);\n    //     return this._memory[x][y];\n    // }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n        this.addLayer(Flags.Depth.SURFACE, new Layer.FireLayer(this, 'surface'));\n        this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // items\n    hasItem(x, y) {\n        return this.cell(x, y).hasItem();\n    }\n    itemAt(x, y) {\n        return this.items.find((i) => i.isAt(x, y)) || null;\n    }\n    eachItem(cb) {\n        this.items.forEach(cb);\n    }\n    addItem(x, y, item, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        // if (!cell.canAddItem(item)) return false;\n        if (cell._addItem(item)) {\n            const index = this.items.indexOf(item);\n            if (index < 0) {\n                this.items.push(item);\n            }\n            item.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddItemEffects(item, cell);\n            }\n            if (index < 0) {\n                this.events.emit('item', this, item, true);\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddItemEffects(item, cell) {\n        if (item.key &&\n            item.key.matches(cell.x, cell.y) &&\n            cell.hasEffect('key')) {\n            cell.fireEvent('key', {\n                key: item,\n                item,\n            });\n        }\n        else if (cell.hasEffect('add_item')) {\n            cell.fireEvent('add_item', {\n                key: item,\n                item,\n            });\n        }\n    }\n    addItemNear(x, y, item, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasItem())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (item.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addItem(loc[0], loc[1], item, fireEffects);\n    }\n    removeItem(item, fireEffects = false) {\n        const cell = this.cell(item.x, item.y);\n        // if (!cell.canRemoveItem(item)) return false;\n        if (cell._removeItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, cell);\n            }\n            GWU.arrayDelete(this.items, item);\n            item.removeFromMap();\n            this.events.emit('item', this, item, false);\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveItemEffects(item, cell) {\n        if (item.isKey(cell.x, cell.y) && cell.hasEffect('no_key')) {\n            cell.fireEvent('no_key', {\n                key: item,\n                item,\n            });\n        }\n        else if (cell.hasEffect('remove_item')) {\n            cell.fireEvent('remove_item', {\n                key: item,\n                item,\n            });\n        }\n    }\n    moveItem(item, x, y, fireEffects = false) {\n        if (item.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this.cell(item.x, item.y);\n        const newCell = this.cell(x, y);\n        // if (!currentCell.canRemoveItem(item)) return false;\n        // if (!newCell.canAddItem(item)) return false;\n        currentCell._removeItem(item);\n        if (newCell._addItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, currentCell);\n                this._fireAddItemEffects(item, newCell);\n            }\n            item.addToMap(this, x, y);\n        }\n        return true;\n    }\n    //  moveItem(item: Item, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = item.x;\n    //     const oldY = item.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[item.depth] as Layer.ItemLayer;\n    //     if (!( layer.removeItem(item))) return false;\n    //     if (!( this.addItem(x, y, item))) {\n    //         layer.forceItem(item.x, item.y, item);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (item.lastSeen) {\n    //     //         this._memory[item.lastSeen.x][item.lastSeen.y].removeItem(item);\n    //     //         this.clearCellFlag(\n    //     //             item.lastSeen.x,\n    //     //             item.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         item.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.item = item;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     item.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    setPlayer(player) {\n        this.player = player;\n    }\n    actorAt(x, y) {\n        return this.actors.find((a) => a.isAt(x, y)) || null;\n    }\n    eachActor(cb) {\n        this.actors.forEach(cb);\n    }\n    addActor(x, y, actor, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (!cell.canAddActor(actor))\n            return false;\n        if (cell._addActor(actor)) {\n            const index = this.actors.indexOf(actor);\n            if (index < 0) {\n                this.actors.push(actor);\n            }\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddActorEffects(actor, cell);\n            }\n            if (index < 0) {\n                this.events.emit('actor', this, actor, true);\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddActorEffects(actor, cell) {\n        if (actor.isKey(cell.x, cell.y) && cell.hasEffect('key')) {\n            cell.fireEvent('key', {\n                key: actor,\n                actor,\n            });\n        }\n        else if (actor.isPlayer() && cell.hasEffect('add_player')) {\n            cell.fireEvent('add_player', {\n                player: actor,\n                actor,\n            });\n        }\n        else if (cell.hasEffect('add_actor')) {\n            cell.fireEvent('add_actor', {\n                actor,\n            });\n        }\n    }\n    addActorNear(x, y, actor, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasActor())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addActor(loc[0], loc[1], actor, fireEffects);\n    }\n    removeActor(actor, fireEffects = false) {\n        const cell = this.cell(actor.x, actor.y);\n        if (!cell.canRemoveActor(actor))\n            return false;\n        if (cell._removeActor(actor)) {\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, cell);\n            }\n            actor.removeFromMap();\n            GWU.arrayDelete(this.actors, actor);\n            this.events.emit('actor', this, actor, false);\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveActorEffects(actor, cell) {\n        if (actor.isKey(actor.x, actor.y) && cell.hasEffect('no_key')) {\n            cell.fireEvent('no_key', {\n                key: actor,\n                actor,\n            });\n        }\n        else if (actor.isPlayer() && cell.hasEffect('remove_player')) {\n            cell.fireEvent('remove_player', {\n                actor,\n                player: actor,\n            });\n        }\n        else if (cell.hasEffect('remove_actor')) {\n            cell.fireEvent('remove_actor', {\n                actor,\n            });\n        }\n    }\n    moveActor(actor, x, y, fireEffects = false) {\n        if (actor.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this.cell(actor.x, actor.y);\n        const newCell = this.cell(x, y);\n        // if (!currentCell.canRemoveActor(actor)) return false;\n        // if (!newCell.canAddActor(actor)) return false;\n        currentCell._removeActor(actor);\n        if (newCell._addActor(actor)) {\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, currentCell);\n                this._fireAddActorEffects(actor, newCell);\n            }\n        }\n        return true;\n    }\n    //  moveActor(actor: Actor, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = actor.x;\n    //     const oldY = actor.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[actor.depth] as Layer.ActorLayer;\n    //     if (!( layer.removeActor(actor))) return false;\n    //     if (!( layer.addActor(x, y, actor))) {\n    //         layer.forceActor(actor.x, actor.y, actor);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (actor.lastSeen) {\n    //     //         this._memory[actor.lastSeen.x][actor.lastSeen.y].removeActor(\n    //     //             actor\n    //     //         );\n    //     //         this.clearCellFlag(\n    //     //             actor.lastSeen.x,\n    //     //             actor.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         actor.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.actor = actor;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     actor.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    fxAt(x, y) {\n        return this.fx.find((i) => i.isAt(x, y)) || null;\n    }\n    eachFx(cb) {\n        this.fx.forEach(cb);\n    }\n    addFx(x, y, fx) {\n        const cell = this.get(x, y);\n        if (!cell)\n            return false;\n        fx.x = x;\n        fx.y = y;\n        cell._addFx(fx);\n        this.fx.push(fx);\n        this.events.emit('fx', this, fx, true);\n        return true;\n    }\n    moveFx(fx, x, y) {\n        const current = this.get(fx.x, fx.y);\n        const updated = this.get(x, y);\n        if (!updated)\n            return false;\n        current._removeFx(fx);\n        fx.x = x;\n        fx.y = y;\n        updated._addFx(fx);\n        return true;\n    }\n    removeFx(fx) {\n        const cell = this.get(fx.x, fx.y);\n        GWU.arrayDelete(this.fx, fx);\n        if (cell) {\n            cell._removeFx(fx);\n        }\n        this.events.emit('fx', this, fx, false);\n        return true;\n    }\n    // Information\n    // isVisible(x: number, y: number): boolean {\n    //     return this.fov.isAnyKindOfVisible(x, y);\n    // }\n    hasKey(x, y) {\n        const actor = this.actorAt(x, y);\n        if (actor && actor.isKey(x, y))\n            return true;\n        const item = this.itemAt(x, y);\n        if (item && item.isKey(x, y))\n            return true;\n        return false;\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        const getCh = (cell) => {\n            return cell.dump();\n        };\n        this.cells.dump(fmt || getCh, log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    get needsRedraw() {\n        return this.hasMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v)\n            this.setMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n        else\n            this.clearMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).hasCellFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    hasEntityFlag(x, y, flag) {\n        return this.cell(x, y).hasEntityFlag(flag);\n    }\n    hasTileFlag(x, y, flag) {\n        return this.cell(x, y).hasTileFlag(flag);\n    }\n    highlightPath(path, markCursor = true) {\n        this.clearPath();\n        path.forEach((loc) => {\n            this.setCellFlag(loc[0], loc[1], Flags.Cell.IS_HIGHLIGHTED);\n        });\n        if (markCursor && path[0]) {\n            const loc = path[0];\n            this.setCellFlag(loc[0], loc[1], Flags.Cell.IS_CURSOR);\n        }\n        this.needsRedraw = true;\n    }\n    clearPath() {\n        this.cells.forEach((c) => c.clearCellFlag(Flags.Cell.IS_CURSOR | Flags.Cell.IS_HIGHLIGHTED));\n        this.needsRedraw = true;\n    }\n    showCursor(x, y) {\n        this.clearCursor();\n        this.cell(x, y).setCellFlag(Flags.Cell.IS_CURSOR);\n        this.needsRedraw = true;\n    }\n    clearCursor() {\n        this.cells.forEach((c) => c.clearCellFlag(Flags.Cell.IS_CURSOR));\n        this.needsRedraw = true;\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        // this.fov.needsUpdate = true;\n        this.layers.forEach((l) => l.clear());\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cells[i][j];\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile\n    // useMemory = false\n    ) {\n        return this.cell(x, y).hasTile(tile);\n        // if (!useMemory) return this.cell(x, y).hasTile(tile);\n        // return this.memory(x, y).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof TILE.Tile)) {\n            const name = tile;\n            tile = TILE.get(name);\n            if (!tile)\n                throw new Error('Failed to find tile: ' + name);\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof Layer.TileLayer))\n            return false;\n        return layer.setTile(x, y, tile, opts);\n    }\n    clearTiles(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clearTiles(tile);\n    }\n    tick(dt) {\n        let didSomething = false;\n        this._animations.forEach((a) => {\n            didSomething = a.tick(dt) || didSomething;\n        });\n        this._animations = this._animations.filter((a) => a.isRunning());\n        didSomething = this.fireAll('tick') || didSomething;\n        for (let layer of this.layers) {\n            if (layer && layer.tick(dt)) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cell(x, y));\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.actors = src.actors.slice();\n        this.items = src.items.slice();\n        this.flags.map = src.flags.map;\n        // this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        this.properties = Object.assign({}, src.properties);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    fire(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.fireEvent(event, ctx);\n    }\n    fireAll(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        willFire.forEach((w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    cell.fireEvent(event, {\n                        force: true,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    activateMachine(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        cell.fireEvent('machine', ctx) || didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    // DRAW\n    drawInto(dest, opts) {\n        this.drawer.drawInto(dest, this, opts);\n    }\n    getAppearanceAt(x, y, dest) {\n        const cell = this.cell(x, y);\n        return this.drawer.drawCell(dest, this, cell);\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            // cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(cb) {\n        // TODO - Clairy, Telepathy, Detect, etc...\n        if (this.player) {\n            cb(this.player.x, this.player.y, this.player.visionDistance, GWU.fov.FovFlags.PLAYER);\n        }\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    // redrawCell(x: number, y: number): void {\n    //     // if (clearMemory) {\n    //     //     this.clearMemory(x, y);\n    //     // }\n    //     this.cell(x, y).needsRedraw = true;\n    // }\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        cell.storeMemory();\n    }\n    makeVisible(x, y) {\n        const cell = this.cell(x, y);\n        cell.clearMemory();\n    }\n    onFovChange(x, y, isVisible) {\n        if (!isVisible) {\n            this.storeMemory(x, y);\n        }\n        else {\n            this.makeVisible(x, y);\n        }\n    }\n    // Animator\n    addAnimation(a) {\n        this._animations.push(a);\n    }\n    removeAnimation(a) {\n        GWU.arrayDelete(this._animations, a);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount =\n                                                cellCount;\n                                            map.cell(i2, j2).flags.cell &=\n                                                ~Flags.Cell.IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        this.layerVersion = [];\n        this.lightVersion = 0;\n        // fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        // if (this.map.fov.changed) {\n        //     this.fovVersion = this.version;\n        //     this.map.fov.changed = false;\n        // }\n        // if (snap.version !== this.fovVersion) {\n        //     snap.map.fov.copy(this.map.fov);\n        // }\n        // layers\n        this.map.layers.forEach((layer, index) => {\n            const snapLayer = snap.map.layers[index];\n            if (layer.changed) {\n                this.layerVersion[index] = this.version;\n            }\n            if (this.layerVersion[index] !== snap.version) {\n                snapLayer.copy(layer);\n            }\n        });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        // if (snap.version < this.fovVersion || this.map.fov.changed) {\n        //     this.map.fov.copy(snap.map.fov);\n        //     this.fovVersion = snap.version;\n        // }\n        // layers\n        this.layerVersion.forEach((v, index) => {\n            if (v < snap.version)\n                return;\n            const destLayer = this.map.layers[index];\n            if (v > snap.version || destLayer.changed) {\n                const srcLayer = snap.map.layers[index];\n                destLayer.copy(srcLayer);\n                this.layerVersion[index] = snap.version;\n            }\n        });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function isHallway(map, x, y) {\n    return (GWU.xy.arcCount(x, y, (i, j) => {\n        return map.cell(i, j).isPassable();\n    }) > 1);\n}\n","import { Map } from './map';\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile === undefined) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === undefined) {\n        opts.boundary = 'WALL';\n    }\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n        map.light.update();\n    }\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    // // In case we reveal the map or make it all visible we need our memory set correctly\n    // map.cells.forEach((_c, x, y) => {\n    //     if (map.fov.isRevealed(x, y)) {\n    //         map.storeMemory(x, y, true); // with snapshot\n    //     }\n    // });\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Horde as Flags } from '../flags/horde';\nimport * as Map from '../map';\nimport * as Actor from '../actor';\nexport class Horde {\n    // requiredTile: string | null = null;\n    constructor(config) {\n        this.tags = [];\n        this.members = {};\n        // blueprintId: string | null = null;\n        this.flags = { horde: 0 };\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        this.leader = config.leader;\n        if (config.members) {\n            Object.entries(config.members).forEach(([id, range]) => {\n                this.members[id] = GWU.range.make(range);\n            });\n        }\n        this.frequency = GWU.frequency.make(config.frequency || 100);\n        // this.blueprintId = config.blueprintId || null;\n        this.flags.horde = GWU.flag.from(Flags, config.flags);\n        // if (config.requiredTile) this.requiredTile = config.requiredTile;\n    }\n    spawn(map, x = -1, y = -1, opts = {}) {\n        var _a;\n        opts.canSpawn = opts.canSpawn || GWU.TRUE;\n        opts.rng = opts.rng || map.rng;\n        opts.machine = (_a = opts.machine) !== null && _a !== void 0 ? _a : 0;\n        const leader = this._spawnLeader(map, x, y, opts);\n        if (!leader)\n            return null;\n        this._spawnMembers(leader, map, opts);\n        return leader;\n    }\n    _spawnLeader(map, x, y, opts) {\n        const leaderKind = Actor.get(this.leader);\n        if (!leaderKind) {\n            throw new Error('Failed to find leader kind = ' + this.leader);\n        }\n        if (x >= 0 && y >= 0) {\n            if (leaderKind.avoidsCell(map.cell(x, y)))\n                return null;\n        }\n        const leader = Actor.make(leaderKind, { machineHome: opts.machine });\n        if (!leader)\n            throw new Error('Failed to make horde leader - ' + this.leader);\n        if (x < 0 || y < 0) {\n            [x, y] = this._pickLeaderLoc(leader, map, opts) || [-1, -1];\n            if (x < 0 || y < 0) {\n                return null;\n            }\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addLeader(leader, map, x, y, opts)) {\n            return null;\n        }\n        return leader;\n    }\n    _addLeader(leader, map, x, y, _opts) {\n        return map.addActor(x, y, leader);\n    }\n    _addMember(member, map, x, y, leader, _opts) {\n        member.leader = leader;\n        return map.addActor(x, y, member);\n    }\n    _spawnMembers(leader, map, opts) {\n        const entries = Object.entries(this.members);\n        if (entries.length == 0)\n            return 0;\n        let count = 0;\n        entries.forEach(([kindId, countRange]) => {\n            const count = countRange.value(opts.rng);\n            for (let i = 0; i < count; ++i) {\n                this._spawnMember(kindId, map, leader, opts);\n            }\n        });\n        return count;\n    }\n    _spawnMember(kindId, map, leader, opts) {\n        const kind = Actor.get(kindId);\n        if (!kind) {\n            throw new Error('Failed to find member kind = ' + kindId);\n        }\n        const member = Actor.make(kind, { machineHome: opts.machine });\n        if (!member)\n            throw new Error('Failed to make horde member - ' + kindId);\n        const [x, y] = this._pickMemberLoc(member, map, leader, opts) || [\n            -1, -1,\n        ];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addMember(member, map, x, y, leader, opts)) {\n            return null;\n        }\n        return member;\n    }\n    _pickLeaderLoc(leader, map, opts) {\n        let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            if (!opts.canSpawn(x, y))\n                return false;\n            if (leader.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n    _pickMemberLoc(actor, map, leader, opts) {\n        let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Horde } from './horde';\nimport { Horde as Flags } from '../flags/horde';\nexport const hordes = {};\nexport function install(id, horde) {\n    if (typeof horde === 'string') {\n        horde = { leader: horde };\n    }\n    if (!(horde instanceof Horde)) {\n        horde = new Horde(horde);\n    }\n    hordes[id] = horde;\n    return horde;\n}\nexport function installAll(hordes) {\n    Object.entries(hordes).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function from(id) {\n    if (id instanceof Horde) {\n        return id;\n    }\n    if (typeof id === 'string') {\n        return hordes[id];\n    }\n    return new Horde(id);\n}\nexport function random(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n        flags: 0,\n        forbidFlags: 0,\n        depth: 0,\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    const rng = opts.rng || GWU.rng.random;\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    if (opts.flags) {\n        if (typeof opts.flags === 'string') {\n            opts.flags\n                .split(/[,|]/)\n                .map((t) => t.trim())\n                .forEach((flag) => {\n                if (flag.startsWith('!')) {\n                    const key = flag.substring(1);\n                    match.forbidFlags |= Flags[key];\n                }\n                else {\n                    match.flags |= Flags[flag];\n                }\n            });\n        }\n    }\n    if (opts.forbidFlags) {\n        match.forbidFlags = GWU.flag.from(Flags, opts.forbidFlags);\n    }\n    if (opts.depth) {\n        match.depth = opts.depth;\n    }\n    if (match.depth && opts.oodChance) {\n        while (rng.chance(opts.oodChance)) {\n            match.depth += 1;\n        }\n        match.forbidFlags |= Flags.HORDE_NEVER_OOD;\n    }\n    const matches = Object.values(hordes).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        if (match.flags && !(k.flags.horde & match.flags)) {\n            return false;\n        }\n        if (match.forbidFlags && k.flags.horde & match.forbidFlags) {\n            return false;\n        }\n        return true;\n    });\n    if (match.depth) {\n        return rng.item(matches) || null;\n    }\n    const depth = match.depth;\n    const weights = matches.map((h) => h.frequency(depth));\n    const index = rng.weighted(weights);\n    if (index < 0)\n        return null;\n    return matches[index];\n}\n","export const actions = {};\nexport function installCommand(name, fn) {\n    actions[name] = fn;\n}\nexport function getCommand(name) {\n    return actions[name];\n}\n","import { installCommand } from './command';\nimport * as Actor from '../actor';\n// COMMANDS\n// this === GAME\nexport async function moveDir(actor, e) {\n    const dir = e.dir;\n    if (!actor.map || !dir)\n        return -1;\n    return Actor.actions.moveDir(this, actor, e);\n}\ninstallCommand('moveDir', moveDir);\n","import * as GWU from 'gw-utils';\nimport { installCommand } from './command';\nexport async function pickup(actor, _ev) {\n    if (!actor.map)\n        return -1;\n    const playerAction = actor.getAction('pickup');\n    if (!playerAction) {\n        GWU.message.addAt(actor.x, actor.y, 'You cannot pickup items.');\n        return actor.endTurn();\n    }\n    else {\n        // You have to do everything\n        const result = await playerAction(this, actor);\n        if (result)\n            return result; // handled\n    }\n    // Should never get here, but...\n    const standStill = actor.getAction('standStill');\n    if (!standStill)\n        throw new Error('Actor cannot stand still.');\n    return standStill(this, actor);\n}\ninstallCommand('pickup', pickup);\n","// export * from './memory';\n// export * from './system';\nexport const empty = {};\n","/*\n    Attributes\n    ========================\n\n    To configure attributes, set the defaults:\n\n    Attribute.install(')\n\n    const attr = new Attributes(10);\n\n    attr.set('str', 10);\n    attr.set('dex', 10);\n    ...\n    attr.set('chr', 10);\n\n    // to get the current value\n    attr.get('str');\n\n    // To raise an attribute permanently\n    attr.gain('chr', 1);\n\n    // To raise an attribute temporarily\n    attr.gain('chr', 1, false);\n\n    // To lower an attribute permanently\n    attr.drain('chr', 1, true);\n\n    // to lower an attribute temporarily\n    attr.drain('chr', 1);\n\n    // to restore (remove) all temporary changes\n    attr.restore();\n\n    // to add a temporary change that can be removed by itself\n    attr.addBonus('str', 1);\n\n    // to remove the bonus\n    attr.clearBonus('str', 1);\n\n    // adjustments (bonuses) are also possible via:\n    attr.adjust('str', { bonus: 1 });\n\n    // But adjustments can also set the\n    attr.adjust('str', { fixed: 14 });      // temporarily sets base\n    attr.adjust('str', { base: 21 });       // resets the base\n    attr.adjust('str', { restore: true });  // removes all bonuses/penalties\n    attr.adjust('str', { min: 10 });        // limits value\n    attr.adjust('str', { max: 30 });        // limits value\n    attr.adjust('str', { sustain: true });  // turns off lowering values\n*/\nexport class Attributes {\n    constructor(baseValues) {\n        this._base = {};\n        this._max = {};\n        this._bonus = {};\n        this._sustain = {};\n        this._value = {};\n        this.changed = null;\n        this.init(baseValues);\n    }\n    init(baseValues) {\n        for (let k in attributes) {\n            const v = typeof baseValues === 'number' ? baseValues : attributes[k];\n            this.set(k, v);\n        }\n        if (typeof baseValues !== 'number') {\n            for (let k in baseValues) {\n                this.set(k, baseValues[k]);\n            }\n        }\n    }\n    forEach(fn) {\n        Object.keys(attributes).forEach((k) => fn(this.get(k)));\n    }\n    // modifier(name: string) {\n    //     return Math.floor((this.get(name) - 10) / 2);\n    // }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    set(name, value = 0) {\n        this._value[name] = value;\n        this._base[name] = value;\n        this._max[name] = value;\n        this._bonus[name] = [];\n        return value;\n    }\n    base(name) {\n        return this._base[name] || 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    sustain(name) {\n        return this._sustain[name] || false;\n    }\n    gain(name, delta, raiseMax = true) {\n        if (delta < 0 && this._sustain[name])\n            return 0;\n        this._base[name] += delta;\n        if (raiseMax && this._base[name] > this._max[name]) {\n            this._max[name] = this._base[name];\n        }\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    drain(name, loss, lowerMax = false) {\n        if (loss < 0)\n            loss = -loss;\n        const changed = this.gain(name, -loss, false);\n        if (changed && lowerMax) {\n            this._max[name] = this._base[name];\n        }\n        return changed;\n    }\n    restore(name) {\n        this._base[name] = this._max[name];\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    addBonus(name, bonus) {\n        return this._addBonus(name, { bonus });\n    }\n    _addBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        if (this._value[name] === undefined) {\n            this.set(name, 0);\n        }\n        this._bonus[name].push(bonus);\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    clearBonus(name, bonus) {\n        return this._clearBonus(name, { bonus });\n    }\n    _clearBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        let arr = this._bonus[name] || [];\n        let key = JSON.stringify(bonus);\n        let index = arr.findIndex((o) => {\n            return JSON.stringify(o) == key;\n        });\n        if (index > -1) {\n            arr.splice(index, 1);\n            let old = this.get(name);\n            return this._calcValue(name) - old;\n        }\n        return 0;\n    }\n    _calcValue(name) {\n        let allAdjustments = {};\n        this._bonus[name].forEach((adj) => this._applyAdjustment(allAdjustments, adj));\n        this._sustain[name] = allAdjustments.sustain || false;\n        let value = this._base[name] || 0;\n        if (allAdjustments.fixed !== undefined) {\n            value = allAdjustments.fixed;\n        }\n        else {\n            value += allAdjustments.bonus || 0;\n            if (allAdjustments.min !== undefined) {\n                value = Math.max(allAdjustments.min, value);\n            }\n            if (allAdjustments.max !== undefined) {\n                value = Math.min(allAdjustments.max, value);\n            }\n        }\n        return (this._value[name] = value);\n    }\n    adjust(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.gain(name, adj.base);\n        }\n        else if (adj.restore) {\n            delta = this.restore(name);\n            if (delta == 0)\n                delta = undefined;\n        }\n        else {\n            delta = this._addBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    clearAdjustment(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.drain(name, adj.base, true);\n        }\n        else if (adj.restore) {\n            // do nothing...\n        }\n        else {\n            delta = this._clearBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    _applyAdjustment(total, opts) {\n        if (opts.bonus) {\n            total.bonus = (total.bonus || 0) + opts.bonus;\n        }\n        if (opts.fixed !== undefined) {\n            total.fixed = Math.max(total.fixed || 0, opts.fixed);\n        }\n        if (opts.min !== undefined) {\n            total.min = Math.max(total.min || 0, opts.min);\n        }\n        if (opts.max !== undefined) {\n            total.max = Math.max(total.max || 0, opts.max);\n        }\n        if (opts.sustain !== undefined) {\n            total.sustain = opts.sustain;\n        }\n    }\n}\nexport const attributes = {};\nexport function installAttribute(attr) {\n    if (typeof attr === 'string') {\n        attributes[attr] = 0;\n        return;\n    }\n    // clear existing\n    Object.keys(attributes).forEach((k) => {\n        delete attributes[k];\n    });\n    Object.assign(attributes, attr);\n}\nexport function makeAttributes(defaults) {\n    return new Attributes(defaults);\n}\n/*\nfunction adjust(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = undefined;\n        if (a.base) {\n            delta = being.attributes.addBase(a.name, a.base);\n        } else if (a.restore) {\n            delta = being.attributes.restoreBase(a.name);\n            if (delta == 0) delta = undefined;\n        } else {\n            delta = being.attributes.addBonus(a.name, a);\n        }\n        if (delta !== undefined) {\n            out[a.name] = delta;\n        }\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n\n    return results;\n};\n\n function clearAdjustment(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = 0;\n        delta += being.attributes.clearBonus(a.name, a);\n\n        out[a.name] = delta;\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n    return results;\n};\n\nRUT.Attribute.rollAttributes = function (opts = {}) {\n    let dice = [];\n    let total = 0;\n\n    if (RUT.Calc.isValue(opts)) opts = { value: opts };\n    Object.defaults(opts, RUT.Config.Attribute.rollAttributes);\n\n    let attributes = RUT.Config.Attributes;\n\n    let min_average = Math.max(opts.min_average - 5, 0);\n    let max_average = Math.min(opts.max_average - 5, RUT.Config.ATTRIBUTE_MAX);\n\n    let min_total = min_average * attributes.length;\n    let max_total = max_average * attributes.length;\n\n    do {\n        total = 0;\n        dice = [];\n        for (let i = 0; i < 18; ++i) {\n            dice.push(RUT.RNG.rollDie(3 + (i % 3)));\n            total += dice[i];\n        }\n    } while (total <= min_total || total > max_total);\n\n    let values = attributes.reduce((out, name, i) => {\n        let index = 3 * i;\n        let value = 5 + dice[index] + dice[index + 1] + dice[index + 2];\n        if (opts.value) {\n            value = RUT.Calc.calc(opts.value);\n        } else if (opts[name]) {\n            value = RUT.Calc.calc(opts[name]);\n        }\n        out[name] = value;\n        return out;\n    }, {});\n    return values;\n};\nRUT.Config.Attribute.rollAttributes = { min_average: 11, max_average: 14 };\n*/\n/*\nexport function normalize_adjustment(args: ) {\n    if (args.length == 3) {\n        let opts = args[2];\n        if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        let name = `${args[0]}.${args[1]}`;\n        return [Object.assign({ name }, opts)];\n    }\n    if (args.length == 2) {\n        let opts = args[1];\n        if (opts === true || opts === false) {\n            opts = { has: opts };\n        } else if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        return [Object.assign({ name: args[0] }, opts)];\n    }\n\n    let opts = args[0];\n    if (opts.name) {\n        return [opts];\n    }\n    if (opts.attribute) {\n        opts.name = opts.attribute;\n        return [opts];\n    }\n    if (opts.restore) {\n        if (opts.restore == 'all') {\n            return RUT.Attributes.map((a) => {\n                return { name: a, restore: true };\n            });\n        }\n        return [{ name: opts.restore, restore: true }];\n    }\n    if (opts.skill) {\n        opts.name = opts.skill;\n        return [opts];\n    }\n    if (opts.stat) {\n        opts.name = opts.stat;\n        return [opts];\n    }\n    if (opts.save) {\n        opts.name = opts.save;\n        return [opts];\n    }\n    // if (opts.saves) {\n    //   opts.name = opts.saves;\n    //   return [opts];\n    // }\n    if (opts.ability) {\n        opts.name = opts.ability;\n        return [opts];\n    }\n\n    // now we assume that each key is for a separate skill...\n    return Object.keys(opts).reduce((out, key) => {\n        let opt = opts[key];\n        if (key == 'reset' || key == 'restore') {\n            if (typeof opt == 'string') opt = [opt];\n            opt.forEach((a) => {\n                out.push({ name: a, restore: true });\n            });\n        } else {\n            if (typeof opt == 'number' || Array.isArray(opt)) {\n                opt = { bonus: opt };\n            } else if (opt === true || opt === false) {\n                opt = { has: opt };\n            } else if (opt == 'reset' || opt == 'restore') {\n                opt = { restore: true };\n            } else if (opt == 'sustain') {\n                opt = { sustain: true };\n            }\n            out.push(Object.assign({ name: key }, opt));\n        }\n        return out;\n    }, []);\n}\n*/\n","/*\nSkills\n\nSkills generally fall into 2 categories - binary and progressive.\n\n\n// Create a skills object\nconst skills = new Skills();\n\n// set skills\nskills.set('diving', true); // = { has: true, level: 0 }\nskills.set('diving', 10); // = { has: true, level: 10 }\n\nskills.remove('diving'); // {}\n\n// adjustments\nskills.adjust('diving', { bonus: 1 });\nskills.adjust('diving', { disadvantage: true });\nskills.adjust('diving', { advantage: 3 });\nskills.adjust('diving', { fixed: 10 });\nskills.adjust('diving', { critical: 5 });\n\n\n\n\n\n*/\nclass Skill {\n    constructor(name) {\n        this.name = name;\n    }\n    get has() {\n        return this._bool('_has');\n    }\n    get level() {\n        return this._int('_level');\n    }\n    get disadvantage() {\n        return this._bool('_disadvantage');\n    }\n    get advantage() {\n        return this._bool('_advantage');\n    }\n    get fixed() {\n        return this._int('_fixed');\n    }\n    get bonus() {\n        const b = this._int('_bonus') || 0;\n        if (!this._parent)\n            return b;\n        return b + this._parent.bonus;\n    }\n    get succeed() {\n        return this._bool('_succeed');\n    }\n    get fail() {\n        return this._bool('_fail');\n    }\n    set(value) {\n        if (value === false) {\n            this._has = false;\n            this._level = 0;\n        }\n        else {\n            this._has = true;\n            this._level = value === true ? 0 : value;\n        }\n    }\n    _value(name) {\n        if (this[name] !== undefined) {\n            // @ts-ignore\n            return this[name];\n        }\n        if (this._parent) {\n            // @ts-ignore\n            return this._parent._value(name);\n        }\n        return undefined;\n    }\n    _bool(name) {\n        return !!this._value(name);\n    }\n    _int(name) {\n        return this._value(name);\n    }\n    adjust(adj) {\n        Object.entries(adj).forEach(([key, value]) => {\n            key = '_' + key;\n            if (value === undefined)\n                return;\n            if (key === '_fixed') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = Math.max(value, this._fixed || 0);\n            }\n            else if (key === '_bonus') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = value + (this._bonus || 0);\n            }\n            // @ts-ignore\n            this[key] = value;\n        });\n    }\n    clear(adj) {\n        Object.keys(adj).forEach((key) => {\n            key = '_' + key;\n            // @ts-ignore\n            if (this[key] !== undefined) {\n                // @ts-ignore\n                this[key] = undefined;\n            }\n        });\n    }\n}\nexport class Skills {\n    constructor(vals = {}) {\n        this._skills = {};\n        Object.entries(vals).forEach(([key, value]) => {\n            this.set(key, value);\n        });\n    }\n    set(name, value) {\n        const s = this.get(name);\n        s.set(value);\n        return s;\n    }\n    get(name) {\n        let s = this._skills[name];\n        if (s)\n            return s;\n        s = this._skills[name] = new Skill(name);\n        const index = name.lastIndexOf('.');\n        if (index > 0) {\n            s._parent = this.get(name.substring(0, index));\n        }\n        else {\n            s.set(false);\n        }\n        return s;\n    }\n    adjust(name, adj) {\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        let s = this.get(name);\n        s.adjust(adj);\n        return s;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Scent {\n    constructor(player) {\n        this._player = player;\n    }\n    get(x, y) {\n        if (!this._data)\n            return 0;\n        return this._data[x][y];\n    }\n    clear() {\n        if (!this._player.map)\n            return;\n        if (this._data)\n            GWU.grid.free(this._data);\n        this._data = GWU.grid.alloc(this._player.map.width, this._player.map.height);\n    }\n    update() {\n        if (!this._player.map)\n            return;\n        const scent = this._player.data.scent || 10;\n        this._data[this._player.x][this._player.y] = scent;\n        const updated = GWU.grid.alloc(this._data.width, this._data.height);\n        const map = this._player.map;\n        this._data.forEach((v, x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.blocksMove())\n                return;\n            let highest = v;\n            GWU.xy.eachNeighbor(x, y, (x1, y1) => {\n                if (!this._data.hasXY(x1, y1))\n                    return;\n                const v1 = this._data[x1][y1];\n                if (v1 > highest) {\n                    highest = v1;\n                }\n            }, true);\n            const delta = cell.hasLiquid() ? 3 : 1;\n            updated[x][y] = Math.max(0, highest - delta);\n        });\n        GWU.grid.free(this._data);\n        this._data = updated;\n    }\n    nextDir(x, y) {\n        const v = this._data[x][y] || 0;\n        if (!v)\n            return null;\n        let highest = v;\n        let highestLoc = [];\n        GWU.xy.eachNeighbor(x, y, (x1, y1) => {\n            if (!this._data.hasXY(x1, y1))\n                return;\n            const v1 = this._data[x1][y1];\n            if (v1 == highest) {\n                highestLoc.push([x1, y1]);\n            }\n            else if (v1 > highest) {\n                highestLoc = [[x1, y1]];\n                highest = v1;\n            }\n        }, false);\n        if (!highestLoc.length)\n            return null;\n        const loc = GWU.random.item(highestLoc);\n        loc[0] = loc[0] - x;\n        loc[1] = loc[1] - y;\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Actor } from '../actor';\nimport { Scent } from './scent';\nimport * as Flags from '../flags';\nexport class Player extends Actor {\n    constructor(kind) {\n        super(kind);\n        this.scent = new Scent(this);\n    }\n    interrupt() {\n        this.clearGoal();\n    }\n    endTurn(pct = 100) {\n        if (this.map) {\n            if (this.map.fov.update()) {\n                this.clearActorFlag(Flags.Actor.STABLE_COST_MAP);\n            }\n            this.scent.update();\n        }\n        return super.endTurn(pct);\n    }\n    addToMap(map, x, y) {\n        if (!super.addToMap(map, x, y))\n            return false;\n        this.scent.clear();\n        return true;\n    }\n    setGoal(x, y) {\n        const map = this._map;\n        if (!map)\n            throw new Error('No map to set goal with!');\n        if (!this._goalMap) {\n            this._goalMap = GWU.grid.alloc(map.width, map.height);\n        }\n        const goalMap = this._goalMap;\n        const mapToPlayer = this.mapToMe();\n        if (mapToPlayer[x][y] < 0 ||\n            mapToPlayer[x][y] >= GWU.path.NO_PATH ||\n            !map.fov.isRevealed(x, y)) {\n            let loc = GWU.path.getClosestValidLocation(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y));\n            loc = loc || [this.x, this.y];\n            x = loc[0];\n            y = loc[1];\n        }\n        GWU.path.calculateDistances(goalMap, x, y, this.costMap());\n        return this._goalMap;\n    }\n    nextGoalStep() {\n        const map = this.map;\n        if (!map)\n            return null;\n        const goalMap = this.goalMap;\n        const step = GWU.path.nextStep(goalMap, this.x, this.y, (x, y) => map.hasActor(x, y) && map.actorAt(x, y) !== this);\n        return step;\n    }\n    pathTo(...args) {\n        let x = args[0];\n        let y = args[1];\n        if (args.length === 1) {\n            x = args[0].x;\n            y = args[0].y;\n        }\n        const map = this.map;\n        if (!map)\n            return null;\n        const mapToPlayer = this.mapToMe();\n        if (mapToPlayer[x][y] < 0 ||\n            mapToPlayer[x][y] >= GWU.path.NO_PATH ||\n            !map.fov.isRevealed(x, y)) {\n            const loc = GWU.path.getClosestValidLocation(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y));\n            if (!loc)\n                return null;\n            x = loc[0];\n            y = loc[1];\n        }\n        const path = GWU.path.getPath(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y), true);\n        return path;\n    }\n}\nPlayer.default = {\n    ch: '@',\n    fg: 'white',\n    name: 'You',\n    swim: true,\n};\n","import * as GWU from 'gw-utils';\nimport * as Actor from '../actor';\nimport * as Skills from './skill';\nimport * as Attributes from './attribute';\nimport { Player } from './player';\nimport * as Flags from '../flags';\nexport class PlayerKind extends Actor.ActorKind {\n    constructor(opts = {}) {\n        super((() => {\n            if (!opts.sprite) {\n                opts.ch = opts.ch || Player.default.ch;\n                opts.fg = opts.fg || Player.default.fg;\n            }\n            if (!opts.name) {\n                opts.name = Player.default.name;\n            }\n            if (opts.swim === undefined) {\n                opts.swim = Player.default.swim;\n            }\n            return opts;\n        })());\n        this.flags.actor |= Flags.Actor.IS_PLAYER;\n        this.attributes = new Attributes.Attributes(opts.attributes || {});\n        this.skills = new Skills.Skills(opts.skills || {});\n    }\n    make(options) {\n        const actor = new Player(this);\n        this.init(actor, options);\n        return actor;\n    }\n    cellCost(cell, player) {\n        const map = cell.map;\n        if (!map.fov.isRevealed(cell.x, cell.y))\n            return GWU.path.FORBIDDEN;\n        return super.cellCost(cell, player);\n    }\n}\n","import { PlayerKind } from './kind';\nimport * as Actor from '../actor';\nexport function make(id, makeOptions) {\n    let kind;\n    if (typeof id === 'string') {\n        // @ts-ignore\n        kind = Actor.get(id);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + id);\n        if (!(kind instanceof PlayerKind))\n            throw new Error('Not a player kind.');\n    }\n    else if (id instanceof PlayerKind) {\n        kind = id;\n    }\n    else {\n        kind = makeKind(id);\n    }\n    return kind.make(makeOptions);\n}\nexport function install(id, kind) {\n    if (kind instanceof PlayerKind) {\n        Actor.kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    Actor.kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof PlayerKind)\n        return id;\n    const k = Actor.kinds[id];\n    if (k && !(k instanceof PlayerKind)) {\n        throw new Error('No a player kind.');\n    }\n    return k;\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new PlayerKind(config);\n}\n","import * as GWU from 'gw-utils';\nimport { Player } from '../player/player';\nimport * as Flags from '../flags';\nexport class Viewport {\n    constructor(opts) {\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this._subject = null;\n        this.player = null;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.snap = opts.snap || false;\n        this.center = opts.center || false;\n        this.filter = opts.filter || null;\n        this.lockX = opts.lock || opts.lockX || false;\n        this.lockY = opts.lock || opts.lockY || false;\n        this.scent = opts.scent || false;\n    }\n    get subject() {\n        return this._subject;\n    }\n    set subject(subject) {\n        this.center = !!subject;\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n        }\n        this._subject = subject;\n        if (subject && subject instanceof Player) {\n            this.player = subject;\n        }\n        else {\n            this.player = null;\n        }\n    }\n    set lock(v) {\n        this.lockX = v;\n        this.lockY = v;\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(map, x, y) {\n        this.center = true;\n        this.subject = { x, y, map };\n    }\n    showMap(map, x = 0, y = 0) {\n        this.subject = { x, y, map };\n        this.offsetX = x;\n        this.offsetY = y;\n        this.center = false;\n        this.snap = false;\n    }\n    updateOffset() {\n        if (!this._subject) {\n            this.offsetX = 0;\n            this.offsetY = 0;\n            return;\n        }\n        const subject = this._subject;\n        const map = subject.map;\n        const bounds = map;\n        if (subject && map.hasXY(subject.x, subject.y)) {\n            if (this.snap) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (subject.x < left || subject.x > right) {\n                    left = this.offsetX = subject.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (subject.y < top || subject.y > bottom) {\n                    top = this.offsetY = subject.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= subject.x) {\n                    this.offsetX = Math.max(0, subject.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= subject.x) {\n                    this.offsetX = Math.min(subject.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= subject.y) {\n                    this.offsetY = Math.max(0, subject.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= subject.y) {\n                    this.offsetY = Math.min(subject.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this.center) {\n                this.offsetX = subject.x - this.halfWidth();\n                this.offsetY = subject.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = subject.x;\n                this.offsetY = subject.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    draw(buffer) {\n        if (!this._subject)\n            return false;\n        const map = this._subject.map;\n        if (!map || !map.needsRedraw)\n            return false;\n        const fov = map.fov;\n        buffer.blackOutRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, this.bg);\n        if (!this._subject) {\n            return false;\n        }\n        this.updateOffset();\n        const drawer = map.drawer;\n        drawer.scent = this.scent;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, map, cell, fov);\n                }\n                else {\n                    mixer.draw(' ', this.bg, this.bg); // blackOut\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n        return true;\n    }\n    tick(_dt) {\n        if (!this._subject)\n            return false;\n        const map = this._subject.map;\n        if (!map)\n            return false;\n        if (!map.hasMapFlag(Flags.Map.MAP_DANCES) || !GWU.cosmetic.chance(10)) {\n            return false;\n        }\n        map.eachCell((c) => {\n            if (c.hasCellFlag(Flags.Cell.COLORS_DANCE) &&\n                map.fov.isAnyKindOfVisible(c.x, c.y) &&\n                GWU.cosmetic.chance(2)) {\n                c.needsRedraw = true;\n            }\n        });\n        map.needsRedraw = true;\n        return true;\n    }\n    mousemove(ev) {\n        if (!this.bounds.contains(ev.x, ev.y))\n            return false;\n        if (!this.player)\n            return false;\n        const map = this.player.map;\n        if (!map)\n            return false;\n        return this.showPath(this.toInnerX(ev.x), this.toInnerY(ev.y));\n    }\n    click(ev) {\n        if (!this.bounds.contains(ev.x, ev.y))\n            return false;\n        if (!this.player)\n            return false;\n        if (this.player.hasGoal()) {\n            this.player.clearGoal();\n        }\n        else {\n            this.player.setGoal(this.toInnerX(ev.x), this.toInnerY(ev.y));\n        }\n        return true;\n    }\n    showPath(x, y) {\n        if (!this.player)\n            return false;\n        const map = this.player.map;\n        if (!map)\n            return false;\n        // if (!this.player.hasGoal()) return false;\n        // console.log('mouse', ev.x, ev.y);\n        const path = this.player.pathTo(x, y);\n        if (path) {\n            map.highlightPath(path, true);\n        }\n        else {\n            map.clearPath();\n        }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Messages {\n    constructor(opts) {\n        this.needsDraw = true;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'darkest_gray');\n        this.fg = GWU.color.from(opts.fg || 'purple');\n        if (!this.bounds.height)\n            throw new Error('Must provde a height for messages widget.');\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: opts.archive || 40,\n            match: () => {\n                this.needsDraw = true;\n            },\n        });\n    }\n    clear() {\n        this.cache.clear();\n        this.needsDraw = true;\n    }\n    click(e, game) {\n        if (!this.bounds.contains(e))\n            return false;\n        return this.showArchive(game);\n    }\n    draw(buffer) {\n        if (!this.needsDraw)\n            return false;\n        this.needsDraw = false;\n        const isOnTop = this.bounds.y < 10;\n        // black out the message area\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', this.bg, this.bg);\n        this.cache.forEach((line, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = localY + this.bounds.y;\n            buffer.drawText(this.bounds.x, y, line, this.fg);\n            if (confirmed && this.bg) {\n                buffer.mix(this.bg, 50, this.bounds.x, y, this.bounds.width, 1);\n            }\n        });\n        return true;\n    }\n    showArchive(game) {\n        if (this.cache.length <= this.bounds.height)\n            return false;\n        return showArchive(this, game);\n    }\n}\nexport class MessageArchive extends GWU.widget.Widget {\n    constructor(layer, source) {\n        super(layer, {\n            id: 'ARCHIVE',\n            tag: 'messages',\n            height: source.bounds.height,\n            width: source.bounds.width,\n            x: 0,\n            y: 0,\n            tabStop: true,\n            depth: 100, // I'm on top\n        });\n        this.mode = 'forward';\n        this._timeout = null;\n        this.source = source;\n        this.isOnTop = this.source.bounds.y < 10;\n        this.bounds.height = this.isOnTop\n            ? layer.height - source.bounds.y\n            : source.bounds.bottom;\n        this.totalCount = Math.min(source.cache.length, this.isOnTop\n            ? layer.height - this.source.bounds.top\n            : this.source.bounds.bottom);\n        this.shown = source.bounds.height;\n        this._timeout = this.layer.setTimeout(() => this._forward(), 16);\n        // confirm them as they are right now...\n        this.source.cache.confirmAll();\n    }\n    contains() {\n        return true; // Eat all mouse activity\n    }\n    finish() {\n        this.layer.finish();\n    }\n    keypress(e) {\n        return this.click(e);\n    }\n    click(_e) {\n        if (this.mode === 'ack') {\n            this.mode = 'reverse';\n            this.layer.needsDraw = true;\n            if (this._timeout) {\n                this.layer.clearTimeout(this._timeout);\n            }\n            this._timeout = this.layer.setTimeout(() => this._reverse(), 16);\n        }\n        else if (this.mode === 'reverse') {\n            this.finish();\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n            if (this._timeout) {\n                this.layer.clearTimeout(this._timeout);\n                this._timeout = null;\n            }\n            this.layer.needsDraw = true;\n        }\n        return true;\n    }\n    _forward() {\n        // console.log('forward');\n        ++this.shown;\n        this._timeout = null;\n        this.layer.needsDraw = true;\n        if (this.shown < this.totalCount) {\n            this._timeout = this.layer.setTimeout(() => this._forward(), 16);\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n        }\n        return true;\n    }\n    _reverse() {\n        // console.log('reverse');\n        --this.shown;\n        this._timeout = null;\n        if (this.shown <= this.source.bounds.height) {\n            this.finish();\n        }\n        else {\n            this.layer.needsDraw = true;\n            this._timeout = this.layer.setTimeout(() => this._reverse(), 16);\n        }\n        return true;\n    }\n    _draw(buffer) {\n        let fadePercent = 0;\n        // let reverse = this.mode === 'reverse';\n        // Count the number of lines in the archive.\n        // let totalMessageCount = this.totalCount;\n        const isOnTop = this.isOnTop;\n        const dbuf = buffer;\n        const fg = GWU.color.from(this.source.fg);\n        // const dM = reverse ? -1 : 1;\n        // const startM = reverse ? totalMessageCount : this.bounds.height;\n        // const endM = reverse\n        //     ? this.bounds.height + dM + 1\n        //     : totalMessageCount + dM;\n        const startY = isOnTop\n            ? this.shown - 1\n            : this.bounds.bottom - this.shown;\n        const endY = isOnTop ? 0 : this.bounds.bottom - 1;\n        const dy = isOnTop ? -1 : 1;\n        dbuf.fillRect(this.source.bounds.x, Math.min(startY, endY), this.bounds.width, this.shown, ' ', this._used.bg, this._used.bg);\n        this.source.cache.forEach((line, _confirmed, j) => {\n            const y = startY + j * dy;\n            if (isOnTop) {\n                if (y < endY)\n                    return;\n            }\n            else if (y > endY)\n                return;\n            fadePercent = Math.floor((50 * j) / this.shown);\n            const fgColor = fg.mix(this._used.bg, fadePercent);\n            dbuf.drawText(this.source.bounds.x, y, line, fgColor, this._used.bg);\n        });\n        if (this.mode === 'ack') {\n            const y = this.isOnTop ? 0 : dbuf.height - 1;\n            const x = this.source.bounds.x > 8\n                ? this.source.bounds.x - 8 // to left of box\n                : Math.min(this.source.bounds.x + this.bounds.width, // just to right of box\n                dbuf.width - 8 // But definitely on the screen - overwrite some text if necessary\n                );\n            dbuf.wrapText(x, y, 8, '--DONE--', this._used.bg, this._used.fg);\n        }\n        return true;\n    }\n}\nexport async function showArchive(widget, game) {\n    const layer = new GWU.widget.WidgetLayer(game.ui);\n    // @ts-ignore\n    const w = new MessageArchive(layer, widget);\n    await layer.run();\n}\n","import * as GWU from 'gw-utils';\nimport * as Command from '../command';\nimport * as Actor from '../actor';\nimport * as Viewport from './viewport';\nimport * as Message from './message';\nexport class Game {\n    constructor(opts) {\n        this.result = undefined;\n        this.mouse = false;\n        this.fov = false;\n        this.scent = false;\n        this.running = false;\n        this.keymap = {};\n        this.ui = opts.ui || new GWU.ui.UI(opts);\n        this._makeMap = opts.makeMap;\n        this._makePlayer = opts.makePlayer;\n        this._startMap = opts.startMap;\n        if (opts.keymap) {\n            Object.assign(this.keymap, opts.keymap);\n        }\n        if (opts.mouse) {\n            this.mouse = true;\n        }\n        if (typeof opts.messages === 'number') {\n            opts.messages = { length: opts.messages };\n        }\n        opts.viewport = opts.viewport || {};\n        const _opts = opts;\n        _opts.viewport.x = 0;\n        _opts.viewport.y = 0;\n        _opts.viewport.width = this.ui.width;\n        _opts.viewport.height = this.ui.height;\n        this._initMenu(_opts);\n        this._initSidebar(_opts);\n        if (opts.messages !== undefined)\n            this._initMessages(_opts);\n        this._initFlavor(_opts);\n        this._initViewport(_opts);\n    }\n    _initMenu(_opts) { }\n    _initSidebar(_opts) { }\n    _initMessages(opts) {\n        const messOpts = opts.messages || {};\n        messOpts.length = messOpts.length || messOpts.y || 4;\n        if (messOpts.length < 0) {\n            // bottom\n            const viewInit = opts.viewport;\n            messOpts.x = viewInit.x;\n            messOpts.y = this.ui.height + messOpts.length; // length < 0\n            messOpts.width = viewInit.width;\n            messOpts.height = -messOpts.length;\n            opts.viewport.height -= messOpts.height;\n        }\n        else {\n            // top\n            const viewInit = opts.viewport;\n            messOpts.x = viewInit.x;\n            messOpts.y = viewInit.y;\n            messOpts.width = viewInit.width;\n            messOpts.height = messOpts.length;\n            viewInit.y += messOpts.length;\n            viewInit.height -= messOpts.length;\n        }\n        this.messages = new Message.Messages(messOpts);\n    }\n    _initFlavor(_opts) { }\n    _initViewport(opts) {\n        const viewOpts = opts.viewport || {};\n        const viewInit = viewOpts;\n        viewInit.lock = true;\n        this.viewport = new Viewport.Viewport(viewInit);\n    }\n    async start() {\n        this.layer = new GWU.ui.Layer(this.ui);\n        this.buffer = this.layer.buffer;\n        this.io = this.layer.io;\n        this.running = true;\n        this.scheduler = new GWU.scheduler.Scheduler();\n        this.messages.clear();\n        this.map = this._makeMap.call(this, 0);\n        this.player = this._makePlayer.call(this);\n        this.map.setPlayer(this.player);\n        this.viewport.subject = this.player;\n        this._startMap.call(this, this.map, this.player);\n        if (this.scent) {\n            this.map.drawer.scent = this.scent;\n        }\n        this.map.actors.forEach((a) => {\n            this.scheduler.push(a, a.moveSpeed());\n        });\n        this.map.fov.update();\n        this.draw();\n        while (this.running) {\n            await this.animate();\n            await this.runTurn();\n        }\n        return this.result;\n    }\n    draw() {\n        this.viewport.draw(this.buffer);\n        this.messages.draw(this.buffer);\n        if (this.buffer.changed) {\n            this.buffer.render();\n        }\n        this.buffer.changed = false;\n    }\n    finish(result) {\n        this.running = false;\n        this.layer.finish();\n        this.result = result;\n    }\n    async runTurn() {\n        const actor = this.scheduler.pop();\n        if (!actor) {\n            this.finish();\n            return;\n        }\n        let nextTime = 0;\n        while (nextTime === 0) {\n            if (actor === this.player) {\n                nextTime = await this.playerTurn(actor);\n            }\n            else if ('act' in actor) {\n                nextTime = await actor.act(this);\n            }\n            else if ('tick' in actor) {\n                nextTime = await actor.tick(); // dt === 100 -- TODO\n            }\n            this.draw();\n        }\n        if (nextTime >= 0) {\n            this.scheduler.push(actor, nextTime);\n        }\n    }\n    async animate() {\n        if (!this.layer.io._tweens.length)\n            return;\n        const timer = setInterval(() => {\n            const tick = GWU.io.makeTickEvent(16);\n            this.layer.io.enqueue(tick);\n        }, 16);\n        while (this.layer.io._tweens.length) {\n            const ev = await this.layer.io.nextTick();\n            if (ev && ev.dt) {\n                this.layer.io._tweens.forEach((a) => a && a.tick(ev.dt));\n                this.layer.io._tweens = this.layer.io._tweens.filter((a) => a && a.isRunning());\n            }\n            this.draw();\n        }\n        clearInterval(timer);\n    }\n    async playerTurn(player) {\n        let done = 0;\n        const timer = setInterval(() => {\n            const tick = GWU.io.makeTickEvent(16);\n            // console.log('-tick', Date.now());\n            this.layer.io.enqueue(tick);\n        }, 16);\n        let elapsed = 0;\n        while (!done && this.running) {\n            const ev = await this.layer.io.nextEvent(-1);\n            if (ev) {\n                if (ev.type === GWU.io.KEYPRESS) {\n                    this.map.clearPath();\n                    if (this.player.hasGoal()) {\n                        this.player.clearGoal();\n                    }\n                    else {\n                        const handler = GWU.io.handlerFor(ev, this.keymap);\n                        if (handler) {\n                            if (typeof handler === 'string') {\n                                const action = Command.getCommand(handler);\n                                if (action) {\n                                    done = await action.call(this, player, ev);\n                                }\n                            }\n                            else if (typeof handler === 'function') {\n                                done = await handler.call(this, player, ev);\n                            }\n                        }\n                    }\n                }\n                else if (ev.type === GWU.io.TICK) {\n                    this.layer.tick(ev); // timeouts\n                    elapsed += ev.dt || 16;\n                    if (this.viewport.tick(ev.dt)) {\n                        this.draw();\n                    }\n                    // console.log('-- event', elapsed);\n                }\n                else if (this.mouse && ev.type === GWU.io.MOUSEMOVE) {\n                    if (this.viewport.mousemove(ev)) {\n                        this.draw();\n                    }\n                }\n                else if (this.mouse && ev.type === GWU.io.CLICK) {\n                    // console.log('click', ev.x, ev.y);\n                    this.viewport.click(ev);\n                }\n            }\n            if (elapsed < 50) {\n                continue;\n            }\n            elapsed -= 50;\n            if (this.player.hasGoal()) {\n                const step = this.player.nextGoalStep();\n                if (!step) {\n                    this.player.clearGoal();\n                }\n                else {\n                    const action = Actor.getAction('moveDir');\n                    if (!action)\n                        throw new Error('Failed to find moveDir action.');\n                    done = await action(this, this.player, { dir: step });\n                    if (done && this.player.hasGoal()) {\n                        const goalMap = this.player.goalMap;\n                        this.viewport.showPath(goalMap.x, goalMap.y);\n                    }\n                }\n            }\n        }\n        clearInterval(timer);\n        return done;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Tile from './tile';\nimport '../effect/handlers';\nimport '../effect/types';\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([30, 30, 30]).rand(20, 0, 0, 0),\n    bg: GWU.color.from([2, 2, 10]).rand(0, 2, 2, 0),\n    priority: 10,\n    article: 'the',\n    flavor: 'the stone floor',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: 'TILE:DOOR_OPEN',\n        open: 'TILE:DOOR_OPEN_ALWAYS',\n    },\n    flavor: 'a closed door',\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            effects: 'TILE:DOOR~!',\n        },\n        enter: null,\n        open: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('UP_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'upward staircase',\n    article: 'an',\n    effects: {\n        player: 'EMIT:UP_STAIRS',\n    },\n    flavor: 'stairs leading upwards',\n});\nTile.install('DOWN_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'downward staircase',\n    article: 'a',\n    effects: {\n        player: 'EMIT:DOWN_STAIRS',\n    },\n    flavor: 'downward leading stairs',\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'a very hard wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: GWU.color.from([25, 28, 60]).dance(20, 0, 4, 15),\n    bg: GWU.color.from([10, 15, 41]).dance(20, 5, 5, 5),\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n    flavor: 'some deep water',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([5, 8, 10]).dance(10, 0, 4, 15),\n    bg: GWU.color.from([10, 30, 30]).dance(6, 0, 10, 10),\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    flags: 'T_SHALLOW_WATER',\n    // depth: 'LIQUID', // 'SURFACE'?\n    flavor: 'some shallow water',\n});\nTile.install('BRIDGE', {\n    ch: '\\u2630',\n    fg: [80, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n    flavor: 'a bridge',\n});\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_LIST_IN_SIDEBAR","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","T_IS_DEEP_LIQUID","T_SHALLOW_WATER","TileMech","Cell","NEEDS_REDRAW","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_SAFE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Horde","KeyInfo","[object Object]","x","y","disposable","this","lastId","kind","_map","key","machineHome","depth","light","flags","entity","next","id","map","setEntityFlag","Flags.Entity","L_ON_MAP","addToMap","clearEntityFlag","removeFromMap","sprite","isDestroyed","hasEntityFlag","L_DESTROYED","other","constructor","copy","Object","assign","canBeSeen","tag","tags","includes","matches","cell","forbidsCell","avoidsCell","opts","getName","getDescription","getFlavor","verb","getVerb","buffer","bounds","drawStatus","dest","_observer","drawSprite","name","EntityKind","config","requireTileFlags","forbidTileFlags","avoidTileFlags","requireTileTags","forbidTileTags","avoidTileTags","flavor","description","make","split","t","trim","slice","from","Flags.Tile","init","_entity","hasAllTileFlags","hasTileFlag","T_BRIDGE","length","hasAllTileTags","hasAnyTileTag","_opts","mixer","Mixer","getAppearanceAt","wrapText","width","makeOpts","PainMessages","msgs","_msgs","forEach","m","add","msg","push","pct","singular","index","clamp","Math","floor","_format","replace","painMessages","Stats","_max","_rate","_value","max","round","get","set","v","range","value","amount","allowOver","min","raiseValue","gain","lowerValue","drain","turns","count","r","elapsed","undefined","type","c","Error","Status","_set","_time","_count","_done","changed","clearTime","clearCount","setOff","_update","done","_addDone","current","delta","status","cleared","noticed","removeTime","rec","was","doneFn","installedActions","installAction","fn","toLowerCase","getAction","Entity.Entity","super","ai","leader","items","visionDistance","data","_costMap","_goalMap","_mapToMe","actor","Flags.Depth","ACTOR","stats","grid","free","hasActorFlag","Flags.Actor","IS_PLAYER","action","actions","bump","IS_VISIBLE","WAS_VISIBLE","canSee","isAbleToSee","isPlayer","fov","isDirectlyVisible","xy","distanceBetween","forLineBetween","i","j","blocksVision","canSeeOrSense","isAbleToSense","isAnyKindOfVisible","game","startedVisible","player","setActorFlag","console","log","clearActorFlag","becameVisible","interrupt","endTurn","moveSpeed","_other","_item","item","pickupItem","dropItem","mapChanged","STABLE_COST_MAP","staleMap","alloc","height","update","_v","cellCost","goalMap","path","calculateDistances","costMap","ais","install","default","AICtx","target","distanceMap","result","async","typical","isDead","willAttack","damagePct","getPct","morale","chargeChance","retreatChance","lastSawPlayer","clearGoal","ctx","start","canAttack","attack","tooFarFrom","canMoveToward","random","chance","moveToward","tooCloseTo","canMoveAwayFrom","moveAwayFrom","hasGoal","loc","setGoal","moveTowardGoal","scent","dir","nextDir","moveDir","wanderOpt","object","firstOpt","matchingLoc","NO_PATH","step","nextStep","hasActor","actorAt","canPass","clearCellFlag","Flags.Cell","wander","idle","standStill","center","eachNeighbor","blocksMove","_game","_target","_ctx","distanceFromTo","safetyMap","costGrid","actors","a","FORBIDDEN","eachCell","hasCellFlag","AVOIDED","rescan","_actor","ActorKind","Entity.EntityKind","DEFAULT","DEFAULT_ACTOR","vision","normal","health","AI.make","Array","isArray","waterOnly","lavaOnly","swim","fly","options","blocksPathing","list","remove","OBSTRUCTION","OK","info","makeOptions","makeKind","kinds","randomKind","match","forbidTags","startsWith","substring","values","filter","k","arraysIntersect","rng","bumpActions","getBumpActions","selfName","selfAction","ctx2","flashSprite","duration","animator","Entity.make","addFx","tween","visible","to","repeat","repeatDelay","onUpdate","obj","removeFx","io","loop","addAnimation","hit","fadeInOut","clone","opacity","yoyo","needsRedraw","onFinish","moveSprite","source","ceil","maxAxisFromTo","speed","isLoc","vals","ok","stepFn","stopBeforeWalls","moveFx","stop","isInShape","shape","cx","cy","allowCenter","sx","abs","sy","ch","dirFromTo","fg","bg","fade","stopAtWalls","line","forLineFromTo","hasXY","promises","lastIndex","Promise","all","radius","checkExplosionOpts","FOV","isBlocked","calculate","x1","y1","minX","minY","maxX","maxY","_obj","success","newX","newY","currentCell","newCell","try","FX.hit","canRemoveActor","hasItem","canAddActor","moveActor","rate","dirIndex","number","DIRS","pickup","itemAt","quiet","message","addAt","avoidsItem","itemAction","canAddItem","removeItem","addItem","pain","JSON","stringify","made","quantity","ITEM","ItemKind","Flags.Item","entries","isDoor","handlers","installHandler","handler","effectTypes","installType","endPos","indexOf","tile","effects","effect","typeName","shift","makeFn","e","parts","installedEffects","trigger","bind","BasicEffect","seen","Flags.Effect","endsWith","Number","parseFloat","parseInt","force","didSomething","eff","nextAlways","E_NEXT_ALWAYS","makeBasicEffect","makeSpreadEffect","SpreadEffect","grow","decrement","matchTile","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","spawnMap","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","E_NEXT_EVERYWHERE","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","isStairs","first","floodFill","cellIsOk","isStart","EVENT_PROTECTED","blocksEffects","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","E_NO_TOUCH_WALLS","hasTile","x2","y2","madeChange","startProb","probDec","fill","clearAll","clear","clearDepth","GAS","LIQUID","SURFACE","GROUND","blockingMap","eachActor","matchingLocNear","removeActor","addActor","eachItem","makeEmitHandler","emitEffect","events","emit","makeMessageHandler","src","messageEffect","aware","makeActivateMachine","activateMachine","machine","machineId","makeTileHandler","superpriority","blockedByActors","blockedByItems","tileEffect","setTile","makeClearHandler","layers","reduce","out","ALL_LAYERS","clearEffect","makeFeatureHandler","featureEffect","feat","Effect.installedEffects","makeNourishEffect","nourishEffect","adjust","n","pukeMsg","makeStatEffect","stat","statEffect","_a","_b","_c","_d","dissipate","priority","groundTile","article","tileMech","hasEffect","T_IS_FLAMMABLE","every","T_PATHING_BLOCKER","arg","color","toString","_e","_f","base","extends","tiles","text","search","makeEffect","Flags.TileMech","args","NULL","MapLayer","properties","_x","_y","_tile","_dt","TileLayer","GasLayer","volume","depthTile","startingVolume","spread","d","clearTile","total","highestVolume","startingTile","highestTile","updateCellVolume","ObjectFlags","TileFlags","TileMechFlags","CellFlags","FireLayer","CAUGHT_FIRE_THIS_TURN","exposeToFire","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","Effect.from","fire","hasTileMechFlag","TM_EXPLOSIVE_PROMOTE","x0","y0","event","fireEvent","NEVER_SEEN","TILE.NULL","chokeCount","memory","TILE.tiles","snapshot","makeMixer","TILE.get","hasStableSnapshot","STABLE_SNAPSHOT","hasStableMemory","setCellFlag","getSnapshot","checkEntities","some","entityFlags","tileFlags","tileMechFlags","hasTag","hasAllTags","hasAnyTag","withEntities","CHANGED","TILE.Tile","highestPriorityTile","cb","find","TILE.flags","T_BLOCKS_OTHER_LAYERS","hasAllEntityFlags","T_IS_DOOR","L_BLOCKS_EVERYTHING","L_SECRETLY_PASSABLE","T_ANY_LIQUID","blocksLayer","blockedByOtherLayers","highestPriority","currentGround","wantGround","glowLightChanged","setMapFlag","Flags.Map","MAP_SIDEBAR_TILES_CHANGED","blackOut","tileFlag","tileMechFlag","ev","_activate","hasItems","foundIndex","HAS_FX","fx","fxAt","_fx","highlightColor","BasicDrawer","Buffer","offsetX","offsetY","clearMapFlag","MAP_DANCES","drawCell","needSnapshot","getAppearance","putSnapshot","COLORS_DANCE","applyLight","separate","L_VISUALLY_DISTINCT","IS_CURSOR","invert","mix","IS_HIGHLIGHTED","s","colors","red","ground","surface","liquid","gas","drawInto","cosmetic","hasFx","dances","bake","isVisible","isRevealed","getLight","multiply","isCursor","scale","_animations","EventEmitter","seed","machineCount","drawer","cells","LightSystem","alwaysVisible","callback","onFovChange","FovSystem","initLayers","setPlayer","addLayer","Layer.TileLayer","Layer.FireLayer","Layer.GasLayer","layer","isAt","fireEffects","_addItem","_fireAddItemEffects","_removeItem","_fireRemoveItemEffects","arrayDelete","isKey","hasPlayer","_addActor","_fireAddActorEffects","_removeActor","_fireRemoveActorEffects","_addFx","updated","_removeFx","fmt","dump","hasMapFlag","MAP_NEEDS_REDRAW","markCursor","clearPath","clearCursor","l","boundary","isBoundaryXY","clearTiles","dt","tick","isRunning","fireAll","willFire","EVENT_FIRED_THIS_TURN","promoteChance","w","originX","originY","eachGlowLight","_cb","FovFlags","PLAYER","isDark","storeMemory","clearMemory","makeVisible","updateChokepoints","updateCounts","passMap","passableArcCount","oldX","CLOCK_DIRS","oldY","cellCount","floodFillCount","i2","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","up","left","designationSurvives","Snapshot","version","isHallway","arcCount","isPassable","h","updateChokeCounts","layerVersion","lightVersion","cellVersion","snap","srcCell","snapLayer","destCell","destLayer","srcLayer","prefab","charToTile","isStringArray","len","members","horde","frequency","Flags","canSpawn","TRUE","_spawnLeader","_spawnMembers","leaderKind","Actor.get","Actor.make","_pickLeaderLoc","_addLeader","member","kindId","countRange","_spawnMember","_pickMemberLoc","_addMember","Map.isHallway","hordes","forbidFlags","oodChance","HORDE_NEVER_OOD","weights","weighted","installCommand","getCommand","Actor.actions.moveDir","_ev","playerAction","Attributes","baseValues","_base","_bonus","_sustain","attributes","keys","raiseMax","old","_calcValue","loss","lowerMax","bonus","_addBonus","_clearBonus","arr","findIndex","o","splice","allAdjustments","adj","_applyAdjustment","sustain","fixed","restore","Skill","has","_bool","level","_int","disadvantage","advantage","b","_parent","succeed","fail","_has","_level","_fixed","Skills","_skills","lastIndexOf","Scent","_player","_data","highest","v1","hasLiquid","highestLoc","Player","mapToPlayer","mapToMe","getClosestValidLocation","getPath","PlayerKind","Actor.ActorKind","Attributes.Attributes","skills","Skills.Skills","attr","defaults","Actor.kinds","Viewport","_subject","Bounds","lockX","lock","lockY","subject","halfWidth","halfHeight","right","top","bottom","edgeX","edgeY","thirdW","thirdH","blackOutRect","updateOffset","mapX","mapY","draw","contains","showPath","toInnerX","toInnerY","pathTo","highlightPath","Messages","needsDraw","cache","MessageCache","archive","showArchive","isOnTop","fillRect","confirmed","drawText","MessageArchive","widget","Widget","tabStop","mode","_timeout","totalCount","shown","setTimeout","_forward","confirmAll","finish","click","clearTimeout","_reverse","fadePercent","dbuf","endY","dy","_used","_confirmed","fgColor","WidgetLayer","ui","run","mouse","running","keymap","UI","_makeMap","makeMap","_makePlayer","makePlayer","_startMap","startMap","messages","viewport","_initMenu","_initSidebar","_initMessages","_initFlavor","_initViewport","messOpts","viewInit","Message.Messages","Viewport.Viewport","Layer","scheduler","Scheduler","call","animate","runTurn","render","nextTime","playerTurn","act","_tweens","timer","setInterval","makeTickEvent","enqueue","nextTick","clearInterval","nextEvent","KEYPRESS","handlerFor","Command.getCommand","TICK","MOUSEMOVE","mousemove","CLICK","nextGoalStep","Actor.getAction","rand","enter","open","close","dance"],"mappings":"qjBAAWA,UACX,SAAWA,GACPA,EAAMA,EAAkB,YAAK,GAAK,aAClCA,EAAMA,EAAc,OAAI,GAAK,SAC7BA,EAAMA,EAAe,QAAI,GAAK,UAC9BA,EAAMA,EAAY,KAAI,GAAK,OAC3BA,EAAMA,EAAa,MAAI,GAAK,QAC5BA,EAAMA,EAAc,OAAI,GAAK,SAC7BA,EAAMA,EAAW,IAAI,GAAK,MAC1BA,EAAMA,EAAU,GAAI,GAAK,KACzBA,EAAMA,EAAU,GAAI,GAAK,KAT7B,CAUGA,IAAUA,EAAQ,KCVrB,MAAMC,EAAKC,EAAIC,KAAKC,GACb,IAAIC,GACX,SAAWA,GAEPA,EAAOA,EAAoB,YAAIJ,EAAG,IAAM,cACxCI,EAAOA,EAA4B,oBAAIJ,EAAG,IAAM,sBAChDI,EAAOA,EAAsB,cAAIJ,EAAG,IAAM,gBAC1CI,EAAOA,EAAwB,gBAAIJ,EAAG,IAAM,kBAC5CI,EAAOA,EAAyB,iBAAIJ,EAAG,IAAM,mBAC7CI,EAAOA,EAAwB,gBAAIJ,EAAG,IAAM,kBAC5CI,EAAOA,EAAqB,aAAIJ,EAAG,IAAM,eACzCI,EAAOA,EAAuB,eAAIJ,EAAG,IAAM,iBAC3CI,EAAOA,EAAwB,gBAAIJ,EAAG,KAAO,kBAC7CI,EAAOA,EAAyB,iBAAIJ,EAAG,IAAM,mBAC7CI,EAAOA,EAA0B,kBAAIJ,EAAG,KAAO,oBAC/CI,EAAOA,EAA8B,sBAAIJ,EAAG,KAAO,wBACnDI,EAAOA,EAA0B,kBAAIJ,EAAG,KAAO,oBAC/CI,EAAOA,EAA4B,oBAAIJ,EAAG,KAAO,sBACjDI,EAAOA,EAAwB,gBAAIJ,EAAG,KAAO,kBAC7CI,EAAOA,EAAkC,0BAAIJ,EAAG,KAAO,4BACvDI,EAAOA,EAAiB,SAAIJ,EAAG,KAAO,WACtCI,EAAOA,EAAsB,cAAIA,EAAOC,mBAAqB,gBAC7DD,EAAOA,EAAqB,aAAIA,EAAOC,mBAAqB,eAC5DD,EAAOA,EAA4B,oBAAIA,EAAOE,eAC1CF,EAAOG,iBACPH,EAAOI,aACPJ,EAAOK,gBACPL,EAAOM,iBACPN,EAAOO,iBAAmB,sBAC9BP,EAAOA,EAAuB,eAAIA,EAAOQ,cAAgBR,EAAOS,iBAAmB,iBACnFT,EAAOA,EAAwB,gBAAIA,EAAOQ,eAAiB,kBAC3DR,EAAOA,EAA2B,mBAAIA,EAAOQ,eAAiB,qBAC9DR,EAAOA,EAAqB,aAAIA,EAAOQ,cACnCR,EAAOS,gBACPT,EAAOK,gBACPL,EAAOI,aACPJ,EAAOM,iBACPN,EAAOU,mBAAqB,eAChCV,EAAOA,EAA4B,oBAAIA,EAAOW,aAC1CX,EAAOE,eACPF,EAAOO,gBACPP,EAAOG,kBAAoB,sBAvCnC,CAwCGH,IAAWA,EAAS,KC1CvB,MAAMJ,EAAKC,EAAIC,KAAKC,GACb,IAAIa,ECFAC,GDGX,SAAWD,GACPA,EAAMA,EAAiB,UAAIhB,EAAG,IAAM,YACpCgB,EAAMA,EAAkB,WAAIhB,EAAG,IAAM,aACrCgB,EAAMA,EAAgB,SAAIhB,EAAG,IAAM,WACnCgB,EAAMA,EAAuB,gBAAIhB,EAAG,IAAM,kBAC1CgB,EAAMA,EAAkB,WAAIhB,EAAG,IAAM,aACrCgB,EAAMA,EAAmB,YAAIhB,EAAG,IAAM,cACtCgB,EAAMA,EAAe,QAAI,GAAK,UAPlC,CAQGA,IAAUA,EAAQ,KCVrB,SAAWC,GACPA,EAAKA,EAAc,QAAI,GAAK,UADhC,CAEGA,IAASA,EAAO,KCFnB,MAAMjB,EAAKC,EAAIC,KAAKC,GAGb,IAAIe,GACX,SAAWA,GACPA,EAAKA,EAAe,SAAIlB,EAAG,IAAM,WACjCkB,EAAKA,EAAqB,eAAIlB,EAAG,IAAM,iBACvCkB,EAAKA,EAAa,OAAIlB,EAAG,IAAM,SAC/BkB,EAAKA,EAAmB,aAAIlB,EAAG,IAAM,eACrCkB,EAAKA,EAAsB,gBAAIlB,EAAG,IAAM,kBACxCkB,EAAKA,EAAqB,eAAIlB,EAAG,IAAM,iBACvCkB,EAAKA,EAA8B,wBAAIlB,EAAG,IAAM,0BAChDkB,EAAKA,EAAgB,UAAIlB,EAAG,IAAM,YAClCkB,EAAKA,EAA0B,oBAAIlB,EAAG,IAAM,sBAC5CkB,EAAKA,EAAkB,YAAIlB,EAAG,IAAM,cACpCkB,EAAKA,EAAgB,UAAIlB,EAAG,KAAO,YACnCkB,EAAKA,EAAe,SAAIlB,EAAG,KAAO,WAClCkB,EAAKA,EAAkB,YAAIlB,EAAG,KAAO,cACrCkB,EAAKA,EAAoB,cAAIlB,EAAG,KAAO,gBACvCkB,EAAKA,EAAe,SAAIlB,EAAG,KAAO,WAClCkB,EAAKA,EAAgB,UAAIlB,EAAG,KAAO,YACnCkB,EAAKA,EAA0B,oBAAIlB,EAAG,KAAO,sBAC7CkB,EAAKA,EAAkB,YAAIlB,EAAG,KAAO,cACrCkB,EAAKA,EAAiB,WAAIlB,EAAG,KAAO,aACpCkB,EAAKA,EAAsB,gBAAIlB,EAAG,KAAO,kBACzCkB,EAAKA,EAAuB,iBAAIlB,EAAG,KAAO,mBAC1CkB,EAAKA,EAA4B,sBAAIlB,EAAG,KAAO,wBAC/CkB,EAAKA,EAAmB,aAAIA,EAAKC,YAAcD,EAAKE,cAAgBF,EAAKG,UAAY,eACrFH,EAAKA,EAAwB,kBAAIA,EAAKI,eAClCJ,EAAKK,OACLL,EAAKM,aACLN,EAAKO,wBACLP,EAAKQ,cAAgB,oBACzBR,EAAKA,EAAwB,kBAAIA,EAAKI,eAClCJ,EAAKS,UACLT,EAAKK,OACLL,EAAKM,aACLN,EAAKU,UACLV,EAAKO,wBACLP,EAAKW,aAAe,oBACxBX,EAAKA,EAA6B,uBAAIA,EAAKI,eACvCJ,EAAKK,OACLL,EAAKM,aACLN,EAAKO,yBAA2B,yBACpCP,EAAKA,EAAyB,mBAAIA,EAAKI,eACnCJ,EAAKS,UACLT,EAAKK,OACLL,EAAKM,aACLN,EAAKO,yBAA2B,qBACpCP,EAAKA,EAAsB,gBAAIA,EAAKI,eAAiBJ,EAAKS,UAAYT,EAAKK,OAASL,EAAKM,cAAgB,kBACzGN,EAAKA,EAAoB,cAAIA,EAAKM,aAAeN,EAAKK,QAAU,gBAChEL,EAAKA,EAAuB,iBAAIA,EAAKI,eAAiBJ,EAAKK,OAASL,EAAKM,cAAgB,mBAWzFN,EAAKA,EAAuB,iBAAIA,EAAKK,OAASL,EAAKI,eAAiBJ,EAAKM,cAAgB,mBACzFN,EAAKA,EAAmB,aAAIA,EAAKY,iBAAmBZ,EAAKa,iBAAmB,eA3DhF,CA4DGb,IAASA,EAAO,KChEnB,MAAMlB,EAAKC,EAAIC,KAAKC,GAGb,IAAI6B,GACX,SAAWA,GAePA,EAASA,EAAsB,YAAIhC,EAAG,IAAM,cAC5CgC,EAASA,EAAgC,sBAAIhC,EAAG,KAAO,wBACvDgC,EAASA,EAAqC,2BAAIhC,EAAG,KAAO,6BAC5DgC,EAASA,EAA+B,qBAAIhC,EAAG,KAAO,uBACtDgC,EAASA,EAAsC,4BAAIhC,EAAG,KAAO,8BAnBjE,CA2BGgC,IAAaA,EAAW,KC/B3B,MAAMhC,EAAKC,EAAIC,KAAKC,GAGb,IAAI8B,GACX,SAAWA,GACPA,EAAKA,EAA+B,yBAAIjC,EAAG,IAAM,2BACjDiC,EAAKA,EAAyB,mBAAIjC,EAAG,IAAM,qBAC3CiC,EAAKA,EAAuB,iBAAIjC,EAAG,IAAM,mBACzCiC,EAAKA,EAA4B,sBAAIjC,EAAG,IAAM,wBAC9CiC,EAAKA,EAA4B,sBAAIjC,EAAG,IAAM,wBAC9CiC,EAAKA,EAAsB,gBAAIjC,EAAG,IAAM,kBACxCiC,EAAKA,EAAiB,WAAIjC,EAAG,IAAM,aACnCiC,EAAKA,EAAoB,cAAIjC,EAAG,IAAM,gBACtCiC,EAAKA,EAAmB,aAAIjC,EAAG,IAAM,eACrCiC,EAAKA,EAAyB,mBAAIjC,EAAG,IAAM,qBAC3CiC,EAAKA,EAAyB,mBAAIjC,EAAG,KAAO,qBAC5CiC,EAAKA,EAAkB,YAAIjC,EAAG,KAAO,cACrCiC,EAAKA,EAAmB,aAAIjC,EAAG,KAAO,eACtCiC,EAAKA,EAAoB,cAAIjC,EAAG,KAAO,gBACvCiC,EAAKA,EAAsB,gBAAIjC,EAAG,KAAO,kBAEzCiC,EAAKA,EAAiB,WAAIjC,EAAG,KAAO,aACpCiC,EAAKA,EAAgB,UAAIjC,EAAG,KAAO,YACnCiC,EAAKA,EAA0B,oBAAIjC,EAAG,KAAO,sBAC7CiC,EAAKA,EAAe,SAAIjC,EAAG,KAAO,WAClCiC,EAAKA,EAAa,OAAIjC,EAAG,KAAO,SAChCiC,EAAKA,EAAsB,gBAAIjC,EAAG,KAAO,kBACzCiC,EAAKA,EAAgB,UAAIjC,EAAG,KAAO,YACnCiC,EAAKA,EAAqB,eAAIjC,EAAG,KAAO,iBACxCiC,EAAKA,EAAe,SAAIjC,EAAG,KAAO,WAClCiC,EAAKA,EAAyB,mBAAIjC,EAAG,KAAO,qBAC5CiC,EAAKA,EAAiB,WAAIjC,EAAG,KAAO,aACpCiC,EAAKA,EAAmB,aAAIjC,EAAG,KAAO,eACtCiC,EAAKA,EAAc,QAAIA,EAAKC,cAAgB,UAC5CD,EAAKA,EAAoB,cAAIA,EAAKE,mBAAqBF,EAAKG,oBAAsB,gBAClFH,EAAKA,EAA2B,qBAAIA,EAAKI,SACrCJ,EAAKK,oBACLL,EAAKM,cACLN,EAAKO,mBACLP,EAAKQ,yBACLR,EAAKS,iBACLT,EAAKU,WACLV,EAAKW,cACLX,EAAKY,aACLZ,EAAKa,cACLb,EAAKc,aAAe,uBACxBd,EAAKA,EAAoB,cAAIA,EAAKe,WAAaf,EAAKgB,WAAa,gBACjEhB,EAAKA,EAAqB,eAAIA,EAAKI,SAAWJ,EAAKiB,eAAiB,iBACpEjB,EAAKA,EAAmB,aAAIA,EAAKC,cAAgB,eA5CrD,CA6CGD,IAASA,EAAO,KCjDnB,MAAMjC,EAAKC,EAAIC,KAAKC,GAGb,IAAIgD,GACX,SAAWA,GACPA,EAAIA,EAAiB,YAAInD,EAAG,IAAM,cAClCmD,EAAIA,EAAsB,iBAAInD,EAAG,IAAM,mBACvCmD,EAAIA,EAAoB,eAAInD,EAAG,IAAM,iBACrCmD,EAAIA,EAAqB,gBAAInD,EAAG,IAAM,kBACtCmD,EAAIA,EAAmB,cAAInD,EAAG,IAAM,gBACpCmD,EAAIA,EAAgB,WAAInD,EAAG,IAAM,aACjCmD,EAAIA,EAAkB,aAAInD,EAAG,IAAM,eACnCmD,EAAIA,EAAqB,gBAAInD,EAAG,IAAM,kBACtCmD,EAAIA,EAAgB,WAAInD,EAAG,IAAM,aACjCmD,EAAIA,EAA+B,0BAAInD,EAAG,KAAO,4BACjDmD,EAAIA,EAAiB,YAAI,GAAK,cAXlC,CAYGA,IAAQA,EAAM,KChBjB,MAAMnD,EAAKC,EAAIC,KAAKC,GAGb,IAAIiD,GACX,SAAWA,GAEPA,EAAOA,EAAsB,cAAIpD,EAAG,IAAM,gBAC1CoD,EAAOA,EAA0B,kBAAIpD,EAAG,IAAM,oBAC9CoD,EAAOA,EAAgB,QAAIpD,EAAG,IAAM,UACpCoD,EAAOA,EAAwB,gBAAIpD,EAAG,IAAM,kBAG5CoD,EAAOA,EAAoB,YAAIpD,EAAG,IAAM,cAExCoD,EAAOA,EAA4B,oBAAIpD,EAAG,IAAM,sBAChDoD,EAAOA,EAA0B,kBAAIpD,EAAG,IAAM,oBAC9CoD,EAAOA,EAA8B,sBAAIpD,EAAG,IAAM,wBAClDoD,EAAOA,EAA2B,mBAAIpD,EAAG,IAAM,qBAC/CoD,EAAOA,EAA4B,oBAAIpD,EAAG,IAAM,sBAChDoD,EAAOA,EAAkC,0BAAIpD,EAAG,KAAO,4BACvDoD,EAAOA,EAAwB,gBAAIpD,EAAG,KAAO,kBAC7CoD,EAAOA,EAAqB,aAAIpD,EAAG,KAAO,eAG1CoD,EAAOA,EAA6B,qBAAIpD,EAAG,KAAO,uBAClDoD,EAAOA,EAAyB,iBAAIpD,EAAG,KAAO,mBAC9CoD,EAAOA,EAAyB,iBAAIpD,EAAG,KAAO,mBAC9CoD,EAAOA,EAA2B,mBAAIpD,EAAG,KAAO,qBAChDoD,EAAOA,EAAyB,iBAAIpD,EAAG,KAAO,mBAC9CoD,EAAOA,EAAuB,eAAIpD,EAAG,KAAO,iBAC5CoD,EAAOA,EAAwB,gBAAIpD,EAAG,KAAO,kBAC7CoD,EAAOA,EAAuB,eAAIpD,EAAG,KAAO,iBAC5CoD,EAAOA,EAAoB,YAAIpD,EAAG,KAAO,cACzCoD,EAAOA,EAAqB,aAAIpD,EAAG,KAAO,eAC1CoD,EAAOA,EAAqB,aAAIA,EAAOC,eACnCD,EAAOE,gBACPF,EAAOG,eACPH,EAAOI,aAAe,eAC1BJ,EAAOA,EAAwB,gBAAIA,EAAOK,mBAAqBL,EAAOM,qBAAuB,kBAG7FN,EAAOA,EAAmC,2BAAIpD,EAAG,KAAO,6BACxDoD,EAAOA,EAA8B,sBAAIpD,EAAG,KAAO,wBACnDoD,EAAOA,EAAyB,iBAAIpD,EAAG,KAAO,mBAvClD,CAwCGoD,IAAWA,EAAS,KC5CvB,MAAMpD,EAAKC,EAAIC,KAAKC,GACb,IAAIwD,GACX,SAAWA,GACPA,EAAMA,EAAkC,2BAAI3D,EAAG,IAAM,6BACrD2D,EAAMA,EAAyB,kBAAI3D,EAAG,IAAM,oBAC5C2D,EAAMA,EAAkC,2BAAI3D,EAAG,IAAM,6BACrD2D,EAAMA,EAA+B,wBAAI3D,EAAG,IAAM,0BAClD2D,EAAMA,EAAgC,yBAAI3D,EAAG,IAAM,2BACnD2D,EAAMA,EAAuB,gBAAI3D,EAAG,KAAO,kBAN/C,CAiCG2D,IAAUA,EAAQ,uQCnCd,MAAMC,EACTC,YAAYC,EAAGC,EAAGC,GACdC,KAAKH,EAAIA,EACTG,KAAKF,EAAIA,EACTE,KAAKD,WAAaA,EAEtBH,QAAQC,EAAGC,GACP,OAAOE,KAAKH,IAAMA,GAAKG,KAAKF,IAAMA,GCP1C,IAAIG,EAAS,EACN,MAAM9D,EAETyD,YAAYM,GACRF,KAAKG,KAAO,KACZH,KAAKI,IAAM,KACXJ,KAAKK,YAAc,EACnBL,KAAKM,MAAQ,EACbN,KAAKO,MAAQ,KACbP,KAAKQ,MAAQ,CAAEC,OAAQ,GACvBT,KAAKU,KAAO,KACZV,KAAKH,GAAK,EACVG,KAAKF,GAAK,EACVE,KAAKE,KAAOA,EACZF,KAAKW,GAAK,MAAOV,EAErBW,UACI,OAAOZ,KAAKG,KAEhBP,SAASgB,EAAKf,EAAGC,GAIb,OAHAE,KAAKH,EAAIA,EACTG,KAAKF,EAAIA,EACTE,KAAKa,cAAcC,EAAaC,UAC5Bf,KAAKG,OAASS,IAGlBZ,KAAKG,KAAOS,EACZZ,KAAKE,KAAKc,SAAShB,KAAMY,IAClB,GAEXhB,gBACII,KAAKiB,gBAAgBH,EAAaC,UAClCf,KAAKE,KAAKgB,cAAclB,MAE5BmB,aACI,OAAOnB,KAAKE,KAAKiB,OAErBC,kBACI,OAAOpB,KAAKqB,cAAcP,EAAaQ,aAE3C1B,KAAKC,EAAGC,GACJ,OAAOE,KAAKH,IAAMA,GAAKG,KAAKF,IAAMA,EAEtCF,QACI,MAAM2B,EAAQ,IAAIvB,KAAKwB,YAAYxB,KAAKE,MAExC,OADAqB,EAAME,KAAKzB,MACJuB,EAEX3B,KAAK2B,GACDvB,KAAKM,MAAQiB,EAAMjB,MACnBN,KAAKO,MAAQgB,EAAMhB,MACnBmB,OAAOC,OAAO3B,KAAKQ,MAAOe,EAAMf,OAChCR,KAAKU,KAAOa,EAAMb,KAClBV,KAAKH,EAAI0B,EAAM1B,EACfG,KAAKF,EAAIyB,EAAMzB,EACfE,KAAKE,KAAOqB,EAAMrB,KAClBF,KAAKW,GAAKY,EAAMZ,GAEpBf,YACI,OAAOI,KAAKE,KAAK0B,UAAU5B,MAE/BJ,UACII,KAAKQ,MAAMC,QAAUK,EAAaQ,YAEtC1B,cAAc3D,GACV,SAAU+D,KAAKQ,MAAMC,OAASxE,GAElC2D,kBAAkBY,GACd,OAAQR,KAAKQ,MAAMC,OAASD,KAAWA,EAE3CZ,cAAc3D,GACV+D,KAAKQ,MAAMC,QAAUxE,EAEzB2D,gBAAgB3D,GACZ+D,KAAKQ,MAAMC,SAAWxE,EAE1B2D,OAAOiC,GACH,OAAO7B,KAAKE,KAAK4B,KAAKC,SAASF,GAEnCjC,aACI,OAAOI,KAAKqB,cAAcP,EAAanE,eAE3CiD,eACI,OAAOI,KAAKqB,cAAcP,EAAalE,iBAE3CgD,gBACI,OAAOI,KAAKqB,cAAcP,EAAanE,eAE3CiD,gBACI,OAAOI,KAAKqB,cAAcP,EAAarE,kBAE3CmD,MAAMC,EAAGC,GACL,OAAOE,KAAKI,KAAOJ,KAAKI,IAAI4B,QAAQnC,EAAGC,GAE3CF,YAAYqC,GACR,OAAOjC,KAAKE,KAAKgC,YAAYD,EAAMjC,MAEvCJ,WAAWqC,GACP,OAAOjC,KAAKE,KAAKiC,WAAWF,EAAMjC,MAEtCJ,QAAQwC,GACJ,OAAOpC,KAAKE,KAAKmC,QAAQrC,KAAMoC,GAEnCxC,eAAewC,GACX,OAAOpC,KAAKE,KAAKoC,eAAetC,KAAMoC,GAE1CxC,UAAUwC,GACN,OAAOpC,KAAKE,KAAKqC,UAAUvC,KAAMoC,GAErCxC,QAAQ4C,GACJ,OAAOxC,KAAKE,KAAKuC,QAAQzC,KAAMwC,GAEnC5C,WAAW8C,EAAQC,GACf,OAAO3C,KAAKE,KAAK0C,WAAW5C,KAAM0C,EAAQC,GAE9C/C,SAASiD,EAAMC,GACXD,EAAKE,WAAW/C,KAAKmB,QAEzBvB,WACI,MAAO,GAAGI,KAAKwB,YAAYwB,QAAQhD,KAAKW,QAAQX,KAAKH,KAAKG,KAAKF,KCrHhE,MAAMmD,EACTrD,YAAYsD,GACRlD,KAAK8B,KAAO,GACZ9B,KAAKmD,iBAAmB,EACxBnD,KAAKoD,gBAAkB,EACvBpD,KAAKqD,eAAiB,EACtBrD,KAAKsD,gBAAkB,GACvBtD,KAAKuD,eAAiB,GACtBvD,KAAKwD,cAAgB,GACrBxD,KAAKW,GAAKuC,EAAOvC,IAAMuC,EAAOF,KAC9BhD,KAAKgD,KAAOE,EAAOF,KACnBhD,KAAKyD,OAASP,EAAOO,QAAUzD,KAAKgD,KACpChD,KAAK0D,YAAcR,EAAOQ,aAAe1D,KAAKyD,OAC9CzD,KAAKmB,OAASnF,EAAImF,OAAOwC,KAAKT,EAAO/B,OAAS+B,EAAO/B,OAAS+B,GAC1DA,EAAOpB,OACoB,iBAAhBoB,EAAOpB,KACd9B,KAAK8B,KAAOoB,EAAOpB,KAAK8B,MAAM,QAAQhD,KAAKiD,GAAMA,EAAEC,SAGnD9D,KAAK8B,KAAOoB,EAAOpB,KAAKiC,SAG5Bb,EAAOC,mBACPnD,KAAKmD,iBAAmBnH,EAAIC,KAAK+H,KAAKC,EAAYf,EAAOC,mBAEzDD,EAAOG,iBACPrD,KAAKqD,eAAiBrH,EAAIC,KAAK+H,KAAKC,EAAYf,EAAOG,iBAEvDH,EAAOE,kBACPpD,KAAKoD,gBAAkBpH,EAAIC,KAAK+H,KAAKC,EAAYf,EAAOE,kBAExDF,EAAOI,kBAC+B,iBAA3BJ,EAAOI,kBACdJ,EAAOI,gBAAkBJ,EAAOI,gBAAgBM,MAAM,UAE1D5D,KAAKsD,gBAAkBJ,EAAOI,gBAAgB1C,KAAKiD,GAAMA,EAAEC,UAE3DZ,EAAOM,gBAC6B,iBAAzBN,EAAOM,gBACdN,EAAOM,cAAgBN,EAAOM,cAAcI,MAAM,UAEtD5D,KAAKwD,cAAgBN,EAAOM,cAAc5C,KAAKiD,GAAMA,EAAEC,UAEvDZ,EAAOK,iBAC8B,iBAA1BL,EAAOK,iBACdL,EAAOK,eAAiBL,EAAOK,eAAeK,MAAM,UAExD5D,KAAKuD,eAAiBL,EAAOK,eAAe3C,KAAKiD,GAAMA,EAAEC,UAGjElE,KAAKwC,GACD,MAAM3B,EAAS,IAAItE,EAAO6D,MAE1B,OADAA,KAAKkE,KAAKzD,EAAQ2B,GACX3B,EAEXb,KAAKa,EAAQ2B,EAAO,IACZA,EAAK/B,cACLI,EAAOJ,YAAc+B,EAAK/B,aAGlCT,SAASuE,EAAShE,IAClBP,cAAcuE,IACdvE,UAAUuE,GACN,OAAO,EAEXvE,YAAYqC,EAAMkC,GACd,SAAInE,KAAKmD,kBACJlB,EAAKmC,gBAAgBpE,KAAKmD,mBAC1BlB,EAAKoC,YAAYJ,EAAWK,gBAG7BtE,KAAKoD,kBACLnB,EAAKoC,YAAYrE,KAAKoD,kBACrBnB,EAAKoC,YAAYJ,EAAWK,gBAG7BtE,KAAKsD,gBAAgBiB,QACpBtC,EAAKuC,eAAexE,KAAKsD,kBACzBrB,EAAKoC,YAAYJ,EAAWK,eAG7BtE,KAAKuD,eAAegB,SACpBtC,EAAKwC,cAAczE,KAAKuD,iBACvBtB,EAAKoC,YAAYJ,EAAWK,aAKrC1E,WAAWqC,EAAMxB,GACb,QAAIT,KAAKkC,YAAYD,EAAMxB,QAEvBT,KAAKqD,iBACLpB,EAAKoC,YAAYrE,KAAKqD,iBACrBpB,EAAKoC,YAAYJ,EAAWK,eAG7BtE,KAAKwD,cAAce,SACnBtC,EAAKwC,cAAczE,KAAKwD,gBACvBvB,EAAKoC,YAAYJ,EAAWK,YAKrC1E,QAAQuE,EAASO,GACb,OAAO1E,KAAKgD,KAEhBpD,eAAeuE,EAASO,GACpB,OAAO1E,KAAK0D,YAEhB9D,UAAUuE,EAASO,GACf,OAAO1E,KAAKyD,OAEhB7D,QAAQuE,EAAS3B,GACb,OAAOA,EAEX5C,WAAWa,EAAQiC,EAAQC,GACvB,IAAKlC,EAAOG,IACR,OAAO,EACX,GAAIH,EAAOW,YACP,OAAO,EACX,MAAMuD,EAAQ,IAAI3I,EAAImF,OAAOyD,MAI7B,OAHAnE,EAAOG,IAAIiE,gBAAgBpE,EAAOZ,EAAGY,EAAOX,EAAG6E,GAC/CjC,EAAOK,WAAWJ,EAAO9C,EAAI,EAAG8C,EAAO7C,EAAG6E,GAC1CjC,EAAOoC,SAASnC,EAAO9C,EAAI,EAAG8C,EAAO7C,EAAG6C,EAAOoC,MAAQ,EAAGtE,EAAO4B,UAAW,UACrE,GAGR,SAASsB,EAAKvB,EAAM4C,EAAW,IAElC,OADa,IAAI/B,EAAWb,GAChBuB,KAAKqB,6DFzHd,SAAqBnF,EAAGC,EAAGC,GAC9B,OAAO,IAAIJ,EAAQE,EAAGC,EAAGC,mCGXtB,MAAMkF,EACTrF,YAAYsF,EAAO,IACflF,KAAKmF,MAAQ,GACbD,EAAKE,SAASC,GAAMrF,KAAKsF,IAAID,KAEjCzF,IAAI2F,GAEA,OADAvF,KAAKmF,MAAMK,KAAKD,GACTvF,KAEXJ,IAAI6F,EAAKC,GAAW,GAChB,MAAMC,EAAQ3J,EAAI4J,MAAMC,KAAKC,MAAML,EAAMzF,KAAKmF,MAAMZ,QAAS,EAAGvE,KAAKmF,MAAMZ,OAAS,GAC9EgB,EAAMvF,KAAKmF,MAAMQ,GACvB,OAAO3F,KAAK+F,QAAQR,EAAKG,GAE7B9F,QAAQ2F,EAAKG,GAAW,GACpB,OAAOH,EAAIS,QAAQ,qBAAsBN,EAAW,KAAO,OAG5D,MAAMO,EAAe,GClBrB,MAAMC,EACTtG,YAAYwC,EAAO,IACfpC,KAAKmG,KAAO,GACZnG,KAAKoG,MAAQ,GACbpG,KAAKqG,OAAS,GACdrG,KAAKkE,KAAK9B,GAEdxC,IAAIoD,GACA,OAAOhD,KAAKqG,OAAOrD,IAAS,EAEhCpD,OAAOoD,GACH,MAAMsD,EAAMtG,KAAKsG,IAAItD,GACrB,OAAOsD,EAAMT,KAAKU,MAAO,IAAMvG,KAAKwG,IAAIxD,GAASsD,GAAO,EAE5D1G,IAAIoD,GACA,OAAOhD,KAAKmG,KAAKnD,IAAS,EAE9BpD,MAAMoD,GACF,OAAOhD,KAAKoG,MAAMpD,IAAS,KAE/BpD,KAAKwC,GACD,IAAK,IAAIY,KAAQZ,EACbpC,KAAKyG,IAAIzD,EAAMZ,EAAKY,IAG5BpD,IAAIoD,EAAM0D,EAAGJ,GACT,GAAiB,iBAANI,EAAgB,CAEvBA,EADU1K,EAAI2K,MAAMhD,KAAK+C,GACnBE,QAEV5G,KAAKqG,OAAOrD,GAAQ0D,EACpB1G,KAAKmG,KAAKnD,GAAQsD,GAAOI,EAE7B9G,KAAKoD,EAAM6D,EAAQC,GAAY,GACL,iBAAXD,IACPA,EAAS7K,EAAI2K,MAAMC,MAAMC,IAE7B,IAAIH,EAAI1G,KAAKqG,OAAOrD,GAAQ6D,EACvBC,IACDJ,EAAIb,KAAKkB,IAAIL,EAAG1G,KAAKmG,KAAKnD,KAE9BhD,KAAKqG,OAAOrD,GAAQ0D,EAExB9G,MAAMoD,EAAM6D,GACc,iBAAXA,IACPA,EAAS7K,EAAI2K,MAAMC,MAAMC,IAE7B7G,KAAKqG,OAAOrD,GAAQ6C,KAAKS,IAAI,EAAGtG,KAAKqG,OAAOrD,GAAQ6D,GAExDjH,SAASoD,EAAM6D,EAAQG,GAAa,GACV,iBAAXH,IACPA,EAAS7K,EAAI2K,MAAMC,MAAMC,IAE7B7G,KAAKmG,KAAKnD,IAAS6D,EACfG,GACAhH,KAAKiH,KAAKjE,EAAM6D,GAGxBjH,UAAUoD,EAAM6D,EAAQK,GAAa,GACX,iBAAXL,IACPA,EAAS7K,EAAI2K,MAAMC,MAAMC,IAE7B7G,KAAKmG,KAAKnD,GAAQ6C,KAAKS,IAAI,EAAGtG,KAAKmG,KAAKnD,GAAQ6D,GAC5CK,GACAlH,KAAKmH,MAAMnE,EAAM6D,GAGzBjH,SAASoD,EAAMoE,EAAOC,EAAQ,GAC1B,MAAMC,EAAKtH,KAAKoG,MAAMpD,GAAQhD,KAAKoG,MAAMpD,IAAS,CAAEuE,QAAS,GAC7DD,EAAEF,MAAQA,EACVE,EAAED,MAAQA,EAEdzH,WACI,IAAK,IAAIoD,KAAQhD,KAAKmG,KAAM,CACxB,MAAMmB,EAAItH,KAAKoG,MAAMpD,GACrBsE,EAAEC,SAAW,EACTD,EAAEC,SAAWD,EAAEF,QACfpH,KAAKiH,KAAKjE,EAAMsE,EAAED,OAClBC,EAAEC,SAAWD,EAAEF,QAI3BxH,QAAQoD,EAAM4D,QACIY,IAAVZ,IACAA,EAAQ5G,KAAKmG,KAAKnD,IACtBhD,KAAKqG,OAAOrD,GAAQ4D,EAExBhH,OAAOoD,EAAMyE,EAAMZ,GAEf,MAAMH,GADNG,EAAS7K,EAAI2K,MAAM3C,KAAK6C,IACPD,QACXc,EAAI1H,KAAKwG,IAAIxD,GACnB,GAAa,QAATyE,EACAzH,KAAKiH,KAAKjE,EAAM6D,QAEf,GAAa,QAATY,EACLzH,KAAKmH,MAAMnE,EAAM6D,QAEhB,GAAa,QAATY,EACLzH,KAAKyG,IAAIzD,EAAM6D,QAEd,GAAa,QAATY,EAAgB,CACrB,MAAMf,EAAIG,EAAOD,QACb5G,KAAKwG,IAAIxD,GAAQ0D,GACjB1G,KAAKyG,IAAIzD,EAAM0D,OAGlB,CAAA,GAAa,QAATe,EAML,MAAM,IAAIE,MAAM,6BAA+BF,GAL3CzH,KAAKwG,IAAIxD,GAAQ0D,GACjB1G,KAAKyG,IAAIzD,EAAM0D,GAMvB,OAAOgB,IAAM1H,KAAKwG,IAAIxD,IClHvB,MAAM4E,EACThI,cACII,KAAK6H,KAAO,GACZ7H,KAAK8H,MAAQ,GACb9H,KAAK+H,OAAS,GACd/H,KAAKgI,MAAQ,GACbhI,KAAKqG,OAAS,GACdrG,KAAKiI,QAAU,KAEnBrI,MAAMoD,GAIF,OAHAhD,KAAKkI,UAAUlF,GACfhD,KAAKmI,WAAWnF,GAChBhD,KAAKoI,OAAOpF,GACLhD,KAAKqI,QAAQrF,GAExBpD,IAAIoD,GACA,OAAOhD,KAAKqG,OAAOrD,KAAS,EAEhCpD,IAAIoD,GACA,OAAOhD,KAAKqG,OAAOrD,KAAS,EAEhCpD,SAASoD,EAAMsF,GACPA,IACKtI,KAAKgI,MAAMhF,KACZhD,KAAKgI,MAAMhF,GAAQsF,IAe/B1I,SAASoD,EAAMqE,EAAOiB,GAIlB,OAHetI,KACR+H,OAAO/E,GAAQ6C,KAAKS,IAAIe,EADhBrH,KAC8B+H,OAAO/E,IAAS,GAC7DhD,KAAKuI,SAASvF,EAAMsF,GACbtI,KAAKqI,QAAQrF,GAaxBpD,UAAUoD,EAAMqE,EAAQ,EAAGiB,GACH,mBAATjB,IACPiB,EAAOjB,EACPA,EAAQ,GAKZ,OAHerH,KACR+H,OAAO/E,IADChD,KACe+H,OAAO/E,IAAS,GAAKqE,EACnDrH,KAAKuI,SAASvF,EAAMsF,GACbtI,KAAKqI,QAAQrF,GAYxBpD,UAAUoD,EAAMqE,EAAQ,GAGpB,OAFerH,KACR+H,OAAO/E,GAAQ6C,KAAKS,IAAI,GADhBtG,KAC2B+H,OAAO/E,IAAS,GAAKqE,GACxDrH,KAAKqI,QAAQrF,GAWxBpD,WAAWoD,GAGP,OAFehD,KACR+H,OAAO/E,GAAQ,EACfhD,KAAKqI,QAAQrF,GAQxBpD,MAAMoD,EAAMsF,GAIR,OAHetI,KACR6H,KAAK7E,IAAQ,EACpBhD,KAAKuI,SAASvF,EAAMsF,GACbtI,KAAKqI,QAAQrF,GAQxBpD,OAAOoD,GAGH,OAFehD,KACR6H,KAAK7E,IAAQ,EACbhD,KAAKqI,QAAQrF,GAaxBpD,QAAQoD,EAAM4D,EAAO0B,GAKjB1B,EAAQ5K,EAAI2K,MAAMhD,KAAKiD,GAAOA,QAC9B,MAAM4B,EALSxI,KAKQ8H,MAAM9E,IAAS,EAGtC,OARehD,KAMR8H,MAAM9E,GAAQ6C,KAAKS,IAAIM,EAAO4B,GACrCxI,KAAKuI,SAASvF,EAAMsF,GACbtI,KAAKqI,QAAQrF,GAaxBpD,QAAQoD,EAAM4D,EAAQ,EAAG0B,GACD,mBAAT1B,IACP0B,EAAO1B,EACPA,EAAQ,GASZ,OAHAA,EAAQ5K,EAAI2K,MAAMhD,KAAKiD,GAAOA,QAJf5G,KAKR8H,MAAM9E,IALEhD,KAKc8H,MAAM9E,IAAS,GAAK4D,EACjD5G,KAAKuI,SAASvF,EAAMsF,GACbtI,KAAKqI,QAAQrF,GAUxBpD,WAAWoD,EAAM4D,EAAQ,GAIrB,OAFAA,EAAQ5K,EAAI2K,MAAMhD,KAAKiD,GAAOA,QADf5G,KAER8H,MAAM9E,GAAQ6C,KAAKS,IAAI,GAFftG,KAE0B8H,MAAM9E,IAAS,GAAK4D,GACtD5G,KAAKqI,QAAQrF,GASxBpD,UAAUoD,GAGN,OAFehD,KACR8H,MAAM9E,GAAQ,EACdhD,KAAKqI,QAAQrF,GAUxBpD,cAAc6I,EAAQ,GAClB,MAAMC,EAAS1I,KACT2I,EAAU,GAChB,IAAIC,GAAU,EACd,IAAK,IAAI5F,KAAQ0F,EAAOZ,MAChB9H,KAAK6I,WAAW7F,EAAMyF,KACtBG,GAAU,EACVD,EAAQ3F,IAAQ,GAGxB,QAAO4F,GAAUD,EAQrB/I,QAAQoD,GACJ,MAAM0F,EAAS1I,KACT8I,EAAM9I,KAAKqG,OACjB,IAAI0C,EAAMD,EAAI9F,GACV4D,EAASkC,EAAI9F,GACb0F,EAAOb,KAAK7E,IACR0F,EAAOZ,MAAM9E,GAAQ,GACrB0F,EAAOX,OAAO/E,GAAQ,IACtB,EACR,MAAMgG,EAAShJ,KAAKgI,MAAMhF,GAK1B,OAJK4D,GAASoC,IACVA,EAAOhJ,KAAMgD,GACb0F,EAAOV,MAAMhF,GAAQ,OAErB+F,IAAQnC,KAMFmC,IAAOnC,MALT5G,KAAKiI,SACLjI,KAAKiI,QAAQjI,KAAMgD,IAEhB,IC5OZ,MAAMiG,EAAmB,GACzB,SAASC,EAAclG,EAAMmG,GAChCF,EAAiBjG,EAAKoG,eAAiBD,EAEpC,SAASE,EAAUrG,GACtB,OAAOiG,EAAiBjG,EAAKoG,gBAAkB,KCC5C,MAAMrM,UAAcuM,EACvB1J,YAAYM,GACRqJ,MAAMrJ,GACNF,KAAKwJ,GAAK,GACVxJ,KAAKyJ,OAAS,KACdzJ,KAAK0J,MAAQ,KACb1J,KAAK2J,eAAiB,GACtB3J,KAAK4J,KAAO,GACZ5J,KAAK6J,SAAW,KAChB7J,KAAK8J,SAAW,KAChB9J,KAAK+J,SAAW,KAChB/J,KAAKU,KAAO,KAEZV,KAAKQ,MAAMwJ,MAAQ,EACnBhK,KAAKM,MAAQ2J,EAAYC,MACzBlK,KAAKE,KAAOA,EACZF,KAAKmK,MAAQ,IAAIjE,EACjBlG,KAAK0I,OAAS,IAAId,EAEtBhI,KAAK2B,GACDgI,MAAM9H,KAAKF,GACXvB,KAAKyJ,OAASlI,EAAMkI,OACpBzJ,KAAK0J,MAAQnI,EAAMmI,MACnB1J,KAAK2J,eAAiBpI,EAAMoI,eAEhC/J,UACII,KAAKa,cAAcC,EAAaQ,aAC5BtB,KAAK6J,WACL7N,EAAIoO,KAAKC,KAAKrK,KAAK6J,UACnB7J,KAAK6J,SAAW,MAEhB7J,KAAK8J,WACL9N,EAAIoO,KAAKC,KAAKrK,KAAK8J,UACnB9J,KAAK8J,SAAW,MAEhB9J,KAAK+J,WACL/N,EAAIoO,KAAKC,KAAKrK,KAAK+J,UACnB/J,KAAK+J,SAAW,MAGxBnK,aAAa3D,GACT,SAAU+D,KAAKQ,MAAMwJ,MAAQ/N,GAEjC2D,iBAAiBY,GACb,OAAQR,KAAKQ,MAAMwJ,MAAQxJ,KAAWA,EAE1CZ,aACI,OAAOI,KAAKQ,MAAMwJ,MAEtBpK,aAAa3D,GACT+D,KAAKQ,MAAMwJ,OAAS/N,EAExB2D,eAAe3D,GACX+D,KAAKQ,MAAMwJ,QAAU/N,EAEzB2D,WACI,OAAOI,KAAKsK,aAAaC,EAAYC,WAEzC5K,SACI,OAAOI,KAAKqB,cAAcP,EAAaQ,aAE3C1B,UAAUoD,GACN,MAAMyH,EAASzK,KAAKE,KAAKwK,QAAQ1H,GACjC,QAAewE,IAAXiD,IAAmC,IAAXA,EAAiB,CAEzC,OADapB,EAAUrG,KACR,EAEd,OAAe,IAAXyH,GAGFA,EAEX7K,iBACI,OAAOI,KAAKE,KAAKyK,KAGrB/K,gBACI,OAAQI,KAAKsK,aAAaC,EAAYK,cACjC5K,KAAKsK,aAAaC,EAAYM,aAEvCjL,OAAOC,EAAGC,GACN,OAAID,aAAayJ,EACNtJ,KAAK8K,OAAOjL,EAAEA,EAAGA,EAAEC,IAAME,KAAKE,KAAK6K,YAAY/K,KAAMH,KAEvDG,KAAKY,MACNZ,KAAKgL,WACEhL,KAAKY,IAAIqK,IAAIC,kBAAkBrL,EAAGC,KAEzC9D,EAAImP,GAAGC,gBAAgBpL,KAAKH,EAAGG,KAAKF,EAAGD,EAAGC,GAC1CE,KAAK2J,iBAGF3N,EAAImP,GAAGE,eAAerL,KAAKH,EAAGG,KAAKF,EAAGD,EAAGC,GAAG,CAACwL,EAAGC,KACnD,GAAIvL,KAAKY,IAAIqB,KAAKqJ,EAAGC,GAAGC,eACpB,OAAO,MAOvB5L,cAAcC,EAAGC,GACb,OAAID,aAAayJ,EACLtJ,KAAKyL,cAAc5L,EAAEA,EAAGA,EAAEC,KAC7BE,KAAKE,KAAK6K,YAAY/K,KAAMH,IACzBG,KAAKE,KAAKwL,cAAc1L,KAAMH,IAEtCG,KAAKY,KAAOZ,KAAKgL,WACVhL,KAAKY,IAAIqK,IAAIU,mBAAmB9L,EAAGC,GAEvCE,KAAK8K,OAAOjL,EAAGC,GAE1BF,YAAYa,GACR,OAAOT,KAAKE,KAAK6K,YAAY/K,KAAMS,GAEvCb,cAAca,GACV,OAAOT,KAAKE,KAAKwL,cAAc1L,KAAMS,GAGzCb,UAAUgM,GACN,IAAIC,GAAiB,EACjBD,EAAKE,OAAOhB,OAAO9K,OACnBA,KAAK+L,aAAaxB,EAAYK,YAC9BiB,GAAiB,IAGb7L,KAAKsK,aAAaC,EAAYK,aAC9BoB,QAAQC,IAAI,eAEhBjM,KAAKkM,eAAe3B,EAAYK,aAEhC5K,KAAKmM,kBACLH,QAAQC,IAAI,kBACZL,EAAKE,OAAOM,aAEhB,IAAI9E,EAAI,EAOR,OANItH,KAAKwJ,IAAMxJ,KAAKwJ,GAAGL,KACnB7B,QAAUtH,KAAKwJ,GAAGL,GAAGyC,EAAM5L,OAEtB,GAALsH,GAAUtH,KAAKE,KAAKsJ,GAAGL,KACvB7B,QAAUtH,KAAKE,KAAKsJ,GAAGL,GAAGyC,EAAM5L,OAEhCsH,GAEIuE,GAAkBD,EAAKE,OAAOhB,OAAO9K,MAElCsH,GAGJtH,KAAKqM,UAEhBzM,YACI,OAAOI,KAAKE,KAAKoM,UAErB1M,aACAA,QAAQ6F,EAAM,KAOV,OANIzF,KAAKsK,aAAaC,EAAYK,YAC9B5K,KAAK+L,aAAaxB,EAAYM,aAG9B7K,KAAKkM,eAAe3B,EAAYM,aAE7BhF,KAAKC,MAAOL,EAAMzF,KAAKsM,YAAe,KAGjD1M,WAAW2M,GACP,OAAO,EAEX3M,QAAQ2M,GACJ,OAAO,EAGX3M,WAAW4M,GACP,OAAO,EAEX5M,WAAW4M,GACP,OAAO,EAEX5M,QAAQ4M,IACR5M,WAAW6M,EAAMrK,GACb,OAAOpC,KAAKE,KAAKwM,WAAW1M,KAAMyM,EAAMrK,GAE5CxC,SAAS6M,EAAMrK,GACX,OAAOpC,KAAKE,KAAKyM,SAAS3M,KAAMyM,EAAMrK,GAG1CxC,SAASgB,EAAKf,EAAGC,GACb,MAAM8M,EAAarD,MAAMvI,SAASJ,EAAKf,EAAGC,GAI1C,OAHI8M,GACA5M,KAAKkM,eAAe3B,EAAYsC,iBAE7BD,EAEXhN,gBACI2J,MAAMrI,gBACFlB,KAAK6J,WACL7N,EAAIoO,KAAKC,KAAKrK,KAAK6J,UACnB7J,KAAK6J,SAAW,MAEhB7J,KAAK8J,WACL9N,EAAIoO,KAAKC,KAAKrK,KAAK8J,UACnB9J,KAAK8J,SAAW,MAEhB9J,KAAK+J,WACL/N,EAAIoO,KAAKC,KAAKrK,KAAK+J,UACnB/J,KAAK+J,SAAW,MAOxBnK,UACI,IAAKI,KAAKY,IACN,MAAM,IAAI+G,MAAM,6CAEpB,MAAMmF,GAAY9M,KAAKsK,aAAaC,EAAYsC,iBAKhD,GAJIC,GAAY9M,KAAK6J,WACjB7N,EAAIoO,KAAKC,KAAKrK,KAAK6J,UACnB7J,KAAK6J,SAAW,MAEf7J,KAAK6J,UAGL,IAAKiD,EACN,OAAO9M,KAAK6J,cAHZ7J,KAAK6J,SAAW7N,EAAIoO,KAAK2C,MAAM/M,KAAKY,IAAImE,MAAO/E,KAAKY,IAAIoM,QAK5D,MAAM9M,EAAOF,KAAKE,KACZU,EAAMZ,KAAKY,IAwEjB,OAvEAZ,KAAK6J,SAASoD,QAAO,CAACC,EAAIrN,EAAGC,KACzB,MAAMmC,EAAOrB,EAAIqB,KAAKpC,EAAGC,GACzB,OAAOI,EAAKiN,SAASlL,EAAMjC,SAE/BA,KAAK+L,aAAaxB,EAAYsC,iBAmEvB7M,KAAK6J,SAEhBuD,cACI,OAAOpN,KAAK8J,SAEhBlK,UACI,QAASI,KAAK8J,SAElBlK,QAAQC,EAAGC,GACP,MAAMc,EAAMZ,KAAKG,KACjB,IAAKS,EACD,MAAM,IAAI+G,MAAM,4BACf3H,KAAK8J,WACN9J,KAAK8J,SAAW9N,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,SAElD,MAAMI,EAAUpN,KAAK8J,SAErB,OADA9N,EAAIqR,KAAKC,mBAAmBF,EAASvN,EAAGC,EAAGE,KAAKuN,WACzCvN,KAAK8J,SAEhBlK,YACQI,KAAK8J,WACL9N,EAAIoO,KAAKC,KAAKrK,KAAK8J,UACnB9J,KAAK8J,SAAW,MAGxBlK,UACI,IAAKI,KAAKY,IACN,MAAM,IAAI+G,MAAM,WAOpB,OANK3H,KAAK+J,WACN/J,KAAK+J,SAAW/N,EAAIoO,KAAK2C,MAAM/M,KAAKY,IAAImE,MAAO/E,KAAKY,IAAIoM,SAExDhN,KAAK+J,SAASlK,IAAMG,KAAKH,GAAKG,KAAK+J,SAASjK,IAAME,KAAKF,GACvD9D,EAAIqR,KAAKC,mBAAmBtN,KAAK+J,SAAU/J,KAAKH,EAAGG,KAAKF,EAAGE,KAAKuN,WAE7DvN,KAAK+J,UCpVb,MAAMyD,EAAM,GACZ,SAASC,EAAQzK,EAAMmG,GAC1BqE,EAAIxK,GAAQmG,EAET,SAASxF,EAAKvB,GAajB,MAZoB,iBAATA,IACPA,EAAO,CAAE+G,GAAI/G,IAEG,mBAATA,IACPA,EAAO,CAAE+G,GAAI/G,IAEM,iBAAZA,EAAK+G,KACZ/G,EAAK+G,GAAKqE,EAAIpL,EAAK+G,KAElB/G,EAAK+G,KACN/G,EAAK+G,GAAKqE,EAAIE,SAEXtL,ECbJ,MAAMuL,EACT/N,YAAYgM,EAAM5B,EAAO4D,GAOrB,GANA5N,KAAKyM,KAAO,KACZzM,KAAKqH,MAAQ,EACbrH,KAAK4L,KAAOA,EACZ5L,KAAKgK,MAAQA,EACbhK,KAAK4N,OAASA,GAAU,KACxB5N,KAAK6N,YAAc7R,EAAIoO,KAAK2C,MAAMnB,EAAKhL,IAAImE,MAAO6G,EAAKhL,IAAIoM,QACvDY,EAAQ,CACR,MAAML,EAAUvD,EAAMuD,UACtBvR,EAAIqR,KAAKC,mBAAmBtN,KAAK6N,YAAaD,EAAO/N,EAAG+N,EAAO9N,EAAGyN,IAG1E3N,QAEI,QADEI,KAAKqH,MACArH,KAEXJ,KAAKkO,GAKD,QAJE9N,KAAKqH,MACW,GAAdrH,KAAKqH,OACLrL,EAAIoO,KAAKC,KAAKrK,KAAK6N,aAEhBC,GAORC,eAAeC,EAAQpC,EAAM5B,GAChC,GAAIA,EAAMiE,SACN,OAAQ,EAEZ,IADYjE,EAAMpJ,IAEd,OAAQ,EACZ,MAAMgN,EAAShC,EAAKE,OAEpB,GADkB9B,EAAMc,OAAO8C,IAAW5D,EAAMkE,WAAWN,GAC5C,CACX,MAAMO,EAAY,IAAMnE,EAAMG,MAAMiE,OAAO,UACrCC,EAASrE,EAAMG,MAAM3D,IAAI,UACzB8H,EAAe,IACfC,EAAgB,EACtBvE,EAAMR,GAAGgF,cAAgB,CAACZ,EAAO/N,EAAG+N,EAAO9N,GAC3CkK,EAAMyE,YACNzC,QAAQC,IAAI,WAAYjC,EAAMrJ,GAAIiN,EAAO/N,EAAG+N,EAAO9N,GACnD,MAAM4O,EAAM,IAAIf,EAAM/B,EAAM5B,EAAO4D,GAAQe,QAC3C,IAAIb,EAAS,EACb,GAAIK,EAAYE,EAOZ,OAHSO,EAAUhD,EAAM5B,EAAO4D,KAC5BE,QAAee,EAAOjD,EAAM5B,EAAO4D,IAEhCc,EAAIpG,KAAKwF,GAEpB,GAAIgB,EAAWlD,EAAM5B,EAAO4D,IACxBgB,EAAUhD,EAAM5B,EAAO4D,IACvBmB,EAAcnD,EAAM5B,EAAO4D,EAAQc,GAOnC,OALIZ,EADA9R,EAAIgT,OAAOC,OAAOX,SACHY,EAAWtD,EAAM5B,EAAO4D,EAAQc,SAGhCG,EAAOjD,EAAM5B,EAAO4D,GAEhCc,EAAIpG,KAAKwF,GAEpB,GAAIqB,EAAWvD,EAAM5B,EAAO4D,IACxBgB,EAAUhD,EAAM5B,EAAO4D,IACvBwB,EAAgBxD,EAAM5B,EAAO4D,EAAQc,GAOrC,OALIZ,EADA9R,EAAIgT,OAAOC,OAAOV,SACHc,EAAazD,EAAM5B,SAGnB6E,EAAOjD,EAAM5B,EAAO4D,GAEhCc,EAAIpG,KAAKwF,GAEpB,GAAIc,EAAUhD,EAAM5B,EAAO4D,GAEvB,OADAE,QAAee,EAAOjD,EAAM5B,EAAO4D,GAC5Bc,EAAIpG,KAAKwF,GAEpB,GAAIgB,EAAWlD,EAAM5B,EAAO4D,IACxBmB,EAAcnD,EAAM5B,EAAO4D,EAAQc,GAEnC,OADAZ,QAAeoB,EAAWtD,EAAM5B,EAAO4D,EAAQc,GACxCA,EAAIpG,KAAKwF,GAEpB,GAAIqB,EAAWvD,EAAM5B,EAAO4D,IACxBwB,EAAgBxD,EAAM5B,EAAO4D,EAAQc,GAErC,OADAZ,QAAeuB,EAAazD,EAAM5B,GAC3B0E,EAAIpG,KAAKwF,QAInB,GAAI9D,EAAMR,GAAGgF,cAAe,CAC7B,IAAKxE,EAAMsF,UAAW,CAClB,MAAMC,EAAMvF,EAAMR,GAAGgF,cACrBxE,EAAMwF,QAAQD,EAAI,GAAIA,EAAI,IAE9BvD,QAAQC,IAAI,eAAgBjC,EAAMrJ,GAAIqJ,EAAMoD,QAAQvN,EAAGmK,EAAMoD,QAAQtN,GACrE,MAAMgO,QAAe2B,EAAe7D,EAAM5B,GAC1C,GAAI8D,EACA,OAAOA,EAEX9D,EAAMR,GAAGgF,cAAgB,KACzBxE,EAAMyE,YAGV,GAAIb,EAAO8B,MAAO,CACd,MAAMC,EAAM/B,EAAO8B,MAAME,QAAQ5F,EAAMnK,EAAGmK,EAAMlK,GAChD,GAAI6P,EAAK,CACL3D,QAAQC,IAAI,iBAAkBjC,EAAMrJ,GAAIgP,GACxC,MAAME,EAAUxG,EAAU,WAC1B,IAAKwG,EACD,MAAM,IAAIlI,MAAM,uCACpB,MAAMmG,QAAe+B,EAAQjE,EAAM5B,EAAO,CAAE2F,IAAAA,IAC5C,GAAI7B,EACA,OAAOA,GAGnB,MAAMgC,EAAY9T,EAAI+T,OAAOC,SAAS,SAAUhG,EAAMR,GAAIQ,EAAM9J,KAAKsJ,IAAI,GACzE,GAAIsG,EACA,GAAI9F,EAAMoD,SACe,iBAAd0C,GACP9T,EAAIgT,OAAOC,OAAOa,GACpB,CACE,MAAMhC,EC/HXC,eAAsBnC,EAAM5B,GAE/B,IAAIoD,EAAUpD,EAAMoD,QACpB,IAAKA,EAAS,CAEV,MAAMG,EAAUvD,EAAMuD,UAChBgC,EAAMvT,EAAIgT,OAAOiB,YAAY1C,EAAQxI,MAAOwI,EAAQP,QAAQ,CAACnN,EAAGC,IAC3DyN,EAAQ1N,GAAGC,GAAK,GAAKyN,EAAQ1N,GAAGC,KAAO9D,EAAIqR,KAAK6C,UAE3D,IAAKX,GAAOA,EAAI,GAAK,GAAKA,EAAI,GAAK,EAE/B,OADAvD,QAAQC,IAAI,6BACL,EAGXmB,EAAUpD,EAAMwF,QAAQD,EAAI,GAAIA,EAAI,IAGxC,MAAMY,EAAOnU,EAAIqR,KAAK+C,SAAShD,EAASpD,EAAMnK,EAAGmK,EAAMlK,GAAG,CAACD,EAAGC,KAC1D,IAAK8L,EAAKhL,IAAIyP,SAASxQ,EAAGC,GACtB,OAAO,EACX,MAAMyB,EAAQqK,EAAKhL,IAAI0P,QAAQzQ,EAAGC,GAClC,OAAKyB,GAKGyI,EAAMuG,QAAQhP,IAJlByK,QAAQC,IAAI,UAAUpM,KAAKC,mCAC3B8L,EAAKhL,IAAIqB,KAAKpC,EAAGC,GAAG0Q,cAAcC,EAAWzR,YACtC,MAIf,IAAKmR,EAED,OADAnG,EAAMyE,YACC,EAEX,IAAIX,EAAS,EACb,IAAKqC,GAAoB,GAAXA,EAAK,IAAsB,GAAXA,EAAK,GAC/B,OAAO,EAEX,MAAMN,EAAUxG,EAAU,WAC1B,IAAKwG,EACD,MAAM,IAAIlI,MAAM,uCAEpB,OADAmG,QAAe+B,EAAQjE,EAAM5B,EAAO,CAAE2F,IAAKQ,IACpCrC,EDuFgB4C,CAAO9E,EAAM5B,GAC5B,GAAI8D,EACA,OAAOA,MAEV,CACD,MAAM6C,EAAOtH,EAAU,QACvB,GAAIsH,EACA,OAAOA,EAAK/E,EAAM5B,GAI9B,MAAM4G,EAAavH,EAAU,cAC7B,IAAKuH,EACD,MAAM,IAAIjJ,MAAM,0CACpB,OAAOiJ,EAAWhF,EAAM5B,GAIrB,SAAS+E,EAAcnD,EAAM5B,EAAO4D,EAAQc,GAG/C,MAAMb,GADNa,GAAOA,GAAO,IAAIf,EAAM/B,EAAM5B,EAAO4D,IAASe,SACtBd,YAGxB,IAAIgD,EAAShD,EAAY7D,EAAMnK,GAAGmK,EAAMlK,GACpCuH,EAAQ,EAMZ,OALArL,EAAImP,GAAG2F,aAAa9G,EAAMnK,EAAGmK,EAAMlK,GAAG,CAACD,EAAGC,KAClC+N,EAAYhO,GAAGC,GAAK+Q,KAClBxJ,KANc,GASjBqH,EAAIpG,KAAKjB,EAAQ,GAErB0G,eAAemB,EAAWtD,EAAM5B,EAAO4D,EAAQc,GAElDA,GAAOA,GAAO,IAAIf,EAAM/B,EAAM5B,EAAO4D,IAASe,QAE9C,MAAM/N,EAAMgL,EAAKhL,IACXuP,EAAOnU,EAAIqR,KAAK+C,SAAS1B,EAAIb,YAAa7D,EAAMnK,EAAGmK,EAAMlK,GAAG,CAACD,EAAGC,KAClE,MAAMmC,EAAOrB,EAAIqB,KAAKpC,EAAGC,GACzB,OAAKmC,OAEDA,EAAKoO,YAAcpO,EAAK+H,QAAU4D,MAElC3L,EAAK8O,iBAIb,IAAIjD,EAAS,EACb,IAAKqC,GAAoB,GAAXA,EAAK,IAAsB,GAAXA,EAAK,GAAU,CACzC,MAAMS,EAAavH,EAAU,cAC7B,IAAKuH,EACD,MAAM,IAAIjJ,MAAM,0CAEpB,OADAmG,QAAe8C,EAAWhF,EAAM5B,GACzB0E,EAAIpG,KAAKwF,GAEpB,MAAM+B,EAAUxG,EAAU,WAC1B,IAAKwG,EACD,MAAM,IAAIlI,MAAM,uCAEpB,OADAmG,QAAe+B,EAAQjE,EAAM5B,EAAO,CAAE2F,IAAKQ,IACpCzB,EAAIpG,KAAKwF,GAEb,SAASsB,EAAgBxD,EAAM5B,EAAO4D,EAAQc,GAGjD,MAAMb,GADNa,GAAOA,GAAO,IAAIf,EAAM/B,EAAM5B,EAAO4D,IAASe,SACtBd,YAGxB,IAAIgD,EAAShD,EAAY7D,EAAMnK,GAAGmK,EAAMlK,GACpCuH,EAAQ,EASZ,OARArL,EAAImP,GAAG2F,aAAa9G,EAAMnK,EAAGmK,EAAMlK,GAAG,CAACD,EAAGC,KAC5B+N,EAAYhO,GAAGC,IAChB9D,EAAIqR,KAAK6C,SAEdrC,EAAYhO,GAAGC,GAAK+Q,KAClBxJ,KATc,GAYjBqH,EAAIpG,KAAKjB,EAAQ,GAErB0G,eAAesB,EAAa2B,EAAOhH,EAAOiH,EAASC,GAGtD,OAAOlH,EAAMqC,UAUV,SAASuC,EAAUoC,EAAOhH,EAAO4D,EAAQsD,GAI5C,OAAOlV,EAAImP,GAAGgG,eAAenH,EAAO4D,IAAW,EAE5CG,eAAec,EAAOjD,EAAM5B,EAAO4D,EAAQsD,GAC9ClF,QAAQC,IAAI,UAAWjC,EAAMrJ,GAAIiN,EAAOjN,IACxC,IAAIkO,EAAS7E,EAAMX,UAAU,UAC7B,OAAKwF,EAEEA,EAAOjD,EAAM5B,EAAO,CAAEA,MAAO4D,IADzB,EAGR,SAASkB,EAAWkC,EAAOhH,EAAO4D,EAAQsD,GAE7C,OAAOlV,EAAImP,GAAGgG,eAAenH,EAAO4D,GAAU,EAE3C,SAASuB,EAAW6B,EAAOhH,EAAO4D,EAAQsD,GAC7C,OAAOlV,EAAImP,GAAGgG,eAAenH,EAAO4D,GAAU,EAG3CG,eAAe0B,EAAe7D,EAAM5B,GACvC,IAAKA,EAAMsF,UACP,OAAO,EACX,MAAMc,EAAWpU,EAAIqR,KAAK+C,SAASpG,EAAMoD,QAASpD,EAAMnK,EAAGmK,EAAMlK,GAAG,CAACD,EAAGC,IAC7DkK,EAAMpJ,IAAIyP,SAASxQ,EAAGC,KAEjC,IAAKsQ,EAED,OADApG,EAAMyE,YACC,EAEX,MAAMoB,EAAU7F,EAAMX,UAAU,WAChC,IAAKwG,EACD,MAAM,IAAIlI,MAAM,gCACpB,aAAakI,EAAQjE,EAAM5B,EAAO,CAAE2F,IAAKS,MA/GlC,UAAWpC,KACX,UAAWA,qDEjJf,SAAuBoD,EAAWpH,EAAO4D,GAC5C,MAAMyD,EAAWrV,EAAIoO,KAAK2C,MAAM/C,EAAMuD,WACtCvR,EAAIqR,KAAKC,mBAAmB8D,EAAWxD,EAAO/N,EAAG+N,EAAO9N,EAAGuR,GAAU,GACrED,EAAUnE,QAAQvG,IAAW,EAALA,IACxBsD,EAAMpJ,IAAI0Q,OAAOlM,SAASmM,IAClBA,EAAErD,WAAWlE,KACbqH,EAASE,EAAE1R,GAAG0R,EAAEzR,GAAK9D,EAAIqR,KAAKmE,cAGtCxH,EAAMpJ,IAAI6Q,UAAS,CAAC/J,EAAG7H,EAAGC,KAClB4H,EAAEgK,YAAYjB,EAAW/R,cACzB0S,EAAUvR,GAAGC,IAAM9D,EAAIqR,KAAKsE,YAGpC3V,EAAIqR,KAAKuE,OAAOR,EAAWC,GAAU,GACrCD,EAAUnE,QAAQvG,GAAOA,IAAM,IAAQ,IAAQA,IAC/C1K,EAAIoO,KAAKC,KAAKgH,0HFqMX,SAAwBL,EAAOa,EAAQZ,EAASC,GAEnD,OAAO,eAEJnD,eAA2BiD,EAAOhH,EAAOiH,EAASC,GAErD,OAAOlH,EAAMqC,6EGxNV,MAAMyF,UAAkBC,EAC3BnS,YAAYwC,GACRmH,MAAMnH,GACNpC,KAAKQ,MAAQ,CACTwJ,MAAOO,EAAYyH,QACnBvR,OAAQK,EAAamR,eAEzBjS,KAAKkS,OAAS,GACdlS,KAAK0K,QAAU,GACf1K,KAAK2K,KAAO,CAAC,UACb3K,KAAKsM,UAAY,IACblK,EAAK5B,QACLR,KAAKQ,MAAMwJ,MAAQhO,EAAIC,KAAK+H,KAAKuG,EAAavK,KAAKQ,MAAMwJ,MAAO5H,EAAK5B,OACrER,KAAKQ,MAAMC,OAASzE,EAAIC,KAAK+H,KAAKlD,EAAcd,KAAKQ,MAAMC,OAAQ2B,EAAK5B,QAExE4B,EAAK8P,SACLlS,KAAKkS,OAAOC,OAAS/P,EAAK8P,QAE9BlS,KAAKmK,MAAQzI,OAAOC,OAAO,CAAEyQ,OAAQ,EAAG/D,OAAQ,KAAOjM,EAAK+H,OACxD/H,EAAKsI,SACLhJ,OAAOC,OAAO3B,KAAK0K,QAAStI,EAAKsI,SAEjCtI,EAAKkK,YACLtM,KAAKsM,UAAYlK,EAAKkK,WAE1BtM,KAAKwJ,GAAK6I,EAAQjQ,EAAKoH,IAAM,WACzBpH,EAAKuI,OACoB,iBAAdvI,EAAKuI,OACZvI,EAAKuI,KAAOvI,EAAKuI,KAAK/G,MAAM,SAAShD,KAAKiD,GAAMA,EAAEC,UAE7B,mBAAd1B,EAAKuI,OACZvI,EAAKuI,KAAO,CAACvI,EAAKuI,OAElB2H,MAAMC,QAAQnQ,EAAKuI,QACnB3K,KAAK2K,KAAOvI,EAAKuI,KAAK5G,UAG1B3B,EAAKoQ,WACLxS,KAAKoD,gBACDpD,KAAKoD,iBAAmBa,EAAWpG,iBACvCmC,KAAKqD,eACDrD,KAAKqD,gBAAkBY,EAAWpG,iBACtCmC,KAAKmD,kBAAoBc,EAAWpG,kBAE/BuE,EAAKqQ,UACVzS,KAAKoD,gBAAkBpD,KAAKoD,iBAAmBa,EAAW3G,OAC1D0C,KAAKqD,eAAiBrD,KAAKqD,gBAAkBY,EAAW3G,OACxD0C,KAAKmD,kBAAoBc,EAAW3G,SAGhC8E,EAAKsQ,KACL1S,KAAKqD,gBAAkBY,EAAWpG,iBAGlCmC,KAAKoD,iBAAmBa,EAAWpG,iBAEnCuE,EAAKuQ,MACL3S,KAAKoD,gBACDpD,KAAKoD,iBAAmBa,EAAW3G,OACvC0C,KAAKqD,eAAiBrD,KAAKqD,gBAAkBY,EAAW3G,OACxD0C,KAAKmD,iBACDnD,KAAKmD,kBAAoBc,EAAW3G,OACxC0C,KAAKoD,gBACDpD,KAAKoD,iBAAmBa,EAAWpG,iBACvCmC,KAAKqD,eACDrD,KAAKqD,gBAAkBY,EAAWpG,iBACtCmC,KAAKmD,iBACDnD,KAAKmD,kBAAoBc,EAAWpG,mBAIpD+B,KAAKgT,GACD,MAAM5I,EAAQ,IAAIjN,EAAMiD,MAExB,OADAA,KAAKkE,KAAK8F,EAAO4I,GACV5I,EAEXpK,KAAKoK,EAAO4I,EAAU,IAClBrJ,MAAMrF,KAAK8F,EAAO4I,GAClBlR,OAAOC,OAAOqI,EAAMxJ,MAAOR,KAAKQ,OAO5BR,KAAKkS,OAAOC,SACZnI,EAAML,eAAiB3J,KAAKkS,OAAOC,QAEvCnI,EAAMG,MAAMjG,KAAKlE,KAAKmK,OAE1BvK,SAASoK,EAAOpJ,GACZ2I,MAAMvI,SAASgJ,EAAOpJ,GAY1BhB,cAAcoK,GACVT,MAAMrI,cAAc8I,GAKxBpK,aAAa3D,GACT,SAAU+D,KAAKQ,MAAMwJ,MAAQ/N,GAEjC2D,aAAaiS,EAAQ1N,GACjB,OAAO,EAEXvE,YAAYiS,EAAQ1N,GAChB,OAAO,EAEXvE,cAAciS,EAAQ1N,GAClB,OAAO,EAEXvE,YAAYqC,EAAM+H,GACd,QAAIT,MAAMrH,YAAYD,EAAM+H,MAGxB/H,EAAK8O,aAIbnR,WAAWqC,EAAM+H,GACb,QAAIT,MAAMpH,WAAWF,EAAM+H,MAEvB/H,EAAK4Q,gBAIbjT,UAAUoK,EAAO5H,GACb,MAAMqB,EAASuG,EAAMgB,WAAa,WAAahL,KAAKyD,OACpD,OAAIrB,GAAQA,EAAKqI,OACNhH,EAAS,YAEbA,EAEX7D,WAAWoK,EAAOyC,EAAM/H,GACpB,QAAK1I,EAAI8W,KAAKtN,KAAKwE,EAAO,QAASyC,GAKvC7M,SAASoK,EAAOyC,EAAM/H,GAClB,QAAK1I,EAAI8W,KAAKC,OAAO/I,EAAO,QAASyC,GAKzC7M,SAASqC,EAAM+H,GACX,OAAIhK,KAAKkC,YAAYD,EAAM+H,GAChB/H,EAAKZ,cAAcP,EAAajE,mBACjCb,EAAIqR,KAAK2F,YACThX,EAAIqR,KAAKmE,UAEVxR,KAAKmC,WAAWF,EAAM+H,GACpBhO,EAAIqR,KAAKsE,QAEb3V,EAAIqR,KAAK4F,ICvKjB,SAAStP,EAAKuP,EAAMC,GACvB,IAAIjT,EACJ,GAAoB,iBAATgT,GAGP,GADAhT,EAAOsG,GAAI0M,IACNhT,EACD,MAAM,IAAIyH,MAAM,8BAAgCuL,QAGpDhT,EADKgT,aAAgBpB,EACdoB,EAGAE,GAASF,GAEpB,OAAOhT,EAAKyD,KAAKwP,GAQd,MAAME,GAAQ,GAWd,SAAS7M,GAAI7F,GAChB,OAAIA,aAAcmR,EACPnR,EACJ0S,GAAM1S,GAEV,SAASyS,GAASF,GACrB,MAAMhQ,EAASxB,OAAOC,OAAO,GAAIuR,GACjC,OAAO,IAAIpB,EAAU5O,GAElB,SAASoQ,GAAWlR,EAAO,IAC9B,MAAMmR,EAAQ,CACVzR,KAAM,GACN0R,WAAY,IAEI,iBAATpR,IACPA,EAAO,CACHN,KAAMM,IAGW,iBAAdA,EAAKN,KACZM,EAAKN,KACA8B,MAAM,SACNhD,KAAKiD,GAAMA,EAAEC,SACbsB,SAASvB,IACNA,EAAE4P,WAAW,KACbF,EAAMC,WAAWhO,KAAK3B,EAAE6P,UAAU,GAAG5P,QAGrCyP,EAAMzR,KAAK0D,KAAK3B,MAInByO,MAAMC,QAAQnQ,EAAKN,QACxByR,EAAMzR,KAAOM,EAAKN,KAAKiC,SAEI,iBAApB3B,EAAKoR,WACZD,EAAMC,WAAapR,EAAKoR,WAAW5P,MAAM,SAAShD,KAAKiD,GAAMA,EAAEC,SAE1DwO,MAAMC,QAAQnQ,EAAKoR,cACxBD,EAAMC,WAAapR,EAAKoR,WAAWzP,SAEvC,MAAM/B,EAAUN,OAAOiS,OAAON,IAAOO,QAAQC,KACrCN,EAAMzR,KAAKyC,SAAWvI,EAAI8X,gBAAgBP,EAAMzR,KAAM+R,EAAE/R,UAExDyR,EAAMC,aAAcxX,EAAI8X,gBAAgBP,EAAMC,WAAYK,EAAE/R,SAKpE,OADYM,EAAK2R,KAAO/X,EAAI+X,IAAI/E,QACrBvC,KAAKzK,IAAY,KC1EzB+L,eAAepD,GAAKiB,EAAM5B,EAAO0E,EAAM,IAC1C,MAAMnN,EAAQmN,EAAI1E,MAClB,GAAIzI,EAAO,CACP,MAAMyS,EAAczS,EAAM0S,iBAC1B,IAAK,IAAIxJ,KAAUuJ,EACf,GAAsB,iBAAXvJ,EACP,GAAIA,EAAOgJ,WAAW,KAAM,CACxB,MAAMS,EAAWzJ,EAAOiJ,UAAU,GAClC,IAAIS,EAAa5S,EAAM8H,UAAU6K,GACjC,IAAmB,IAAfC,EACA,MAAM,IAAIxM,MAAM,iEACZ8C,GAER,MAAM2J,EAAO1S,OAAOC,OAAO,GAAI+M,EAAK,CAAE1E,MAAAA,IAChC8D,QAAeqG,EAAWvI,EAAMrK,EAAO6S,GAC7C,GAAItG,EACA,OAAOA,MAEV,CACD,MAAM5K,EAAS8G,EAAMX,UAAUoB,GAC/B,IAAe,IAAXvH,EACA,MAAM,IAAIyE,MAAM,2DACZ8C,GAGJA,EAASvH,EAEb,MAAM4K,QAAerD,EAAOmB,EAAM5B,EAAO0E,GACzC,GAAIZ,EACA,OAAOA,MAGd,CACD,MAAMA,QAAerD,EAAOmB,EAAM5B,EAAO0E,GACzC,GAAIZ,EACA,OAAOA,GAQvB,OAJaY,EAAIjC,KAIV,ECpDJsB,eAAe6C,GAAWI,EAAOhH,EAAOkH,GAC3C,OAAOlH,EAAMqC,UCoDV0B,eAAesG,GAAYzT,EAAKf,EAAGC,EAAGqB,EAAQmT,EAAW,IAAKjN,EAAQ,EAAGkN,GACtD,iBAAXpT,IACPA,EAASnF,EAAImF,OAAO6C,KAAK7C,IAE7B,MAAMV,EAAS+T,EAAY,CAAExR,KAAM,KAAM7B,OAAAA,IACzCP,EAAI6T,MAAM5U,EAAGC,EAAGW,GAChB,MAAMiU,EAAQ1Y,EAAI0Y,MACb/Q,KAAK,CAAEgR,SAAS,IAChBC,GAAG,CAAED,SAAS,IACdE,OAAOxN,GACPyN,YAAYR,GACZA,SAASA,GACTS,UAAUC,IACPA,EAAIL,QACJ/T,EAAI6T,MAAM5U,EAAGC,EAAGW,GAGhBG,EAAIqU,SAASxU,MAMrB,OAFA8T,EAAWA,GAAYvY,EAAIkZ,GAAGC,MACrBC,aAAaV,GACfA,EAAM/F,QAGVZ,eAAesH,GAAIzU,EAAKgN,EAAQzM,EAAQmT,EAAUC,GACrDpT,EAASA,GAAU,MACnBmT,EAAWA,GAAY,UACjBD,GAAYzT,EAAKgN,EAAO/N,EAAG+N,EAAO9N,EAAGqB,EAAQmT,EAAU,EAAGC,GAS7DxG,eAAeuH,GAAU1U,EAAKf,EAAGC,EAAGqB,EAAQmT,EAAW,IAAKC,GAO/D,MAAM9T,EAAS+T,EAAY,CAAExR,KAAM,KAAM7B,OALrCA,EADkB,iBAAXA,EACEnF,EAAImF,OAAO6C,KAAK7C,GAAQoU,QAGxBvZ,EAAImF,OAAOwC,KAAKxC,KAG7BP,EAAI6T,MAAM5U,EAAGC,EAAGW,GAChB,MAAMiU,EAAQ1Y,EAAI0Y,MACb/Q,KAAK,CAAE6R,QAAS,IAChBZ,GAAG,CAAEY,QAAS,MACdX,OAAO,GACPY,MAAK,GACLnB,SAASzO,KAAKC,MAAMwO,EAAW,IAC/BS,UAAUC,IACXvU,EAAOU,OAAOqU,QAAUR,EAAIQ,QAC5B5U,EAAIqB,KAAKpC,EAAGC,GAAG4V,aAAc,KAE5BC,UAAS,KACV/U,EAAIqU,SAASxU,MAKjB,OAFA8T,EAAWA,GAAYvY,EAAIkZ,GAAGC,MACrBC,aAAaV,GACfA,EAAM/F,QAEVZ,eAAe6H,GAAWhV,EAAKiV,EAAQjI,EAAQzM,EAAQiB,EAAO,IAC3C,iBAAXjB,IACPA,EAASnF,EAAImF,OAAO6C,KAAK7C,IAE7B,MAAMV,EAAS+T,EAAY,CAAExR,KAAM,KAAM7B,OAAAA,IACnC6C,EAAO,CAAEnE,EAAG7D,EAAImP,GAAGtL,EAAEgW,GAAS/V,EAAG9D,EAAImP,GAAGrL,EAAE+V,IAChDjV,EAAI6T,MAAMzQ,EAAKnE,EAAGmE,EAAKlE,EAAGW,GAC1B,IAAI6T,EAAWlS,EAAKkS,UAChBzO,KAAKiQ,KAAW9Z,EAAImP,GAAG4K,cAAcF,EAAQjI,IAAWxL,EAAK4T,OAAS,GAA5D,IACVha,EAAImP,GAAG8K,MAAMrI,KACbA,EAAS,CAAE/N,EAAG+N,EAAO,GAAI9N,EAAG8N,EAAO,KAEvC,MAAM8G,EAAQ1Y,EAAI0Y,MACb/Q,KAAKK,GACL4Q,GAAGhH,GACH0G,SAASA,GACTS,UAAUmB,IAKX,MAAMrT,EAAO,CAAEhD,EAAGY,EAAOZ,EAAGC,EAAGW,EAAOX,GAChCqW,EAAKna,EAAImP,GAAGE,eAAexI,EAAKhD,EAAGgD,EAAK/C,EAAGoW,EAAKrW,EAAGqW,EAAKpW,GAAG,CAACD,EAAGC,KACjE,GAAIsC,EAAKgU,QACL,GAAIhU,EAAKgU,OAAOvW,EAAGC,GAKf,OAJKsC,EAAKiU,kBACNxT,EAAKhD,EAAIA,EACTgD,EAAK/C,EAAIA,IAEN,OAGV,GAAIc,EAAIS,cAAcxB,EAAGC,EAAGgB,EAAanE,eAK1C,OAJKyF,EAAKiU,kBACNxT,EAAKhD,EAAIA,EACTgD,EAAK/C,EAAIA,IAEN,EAEX+C,EAAKhD,EAAIA,EACTgD,EAAK/C,EAAIA,KAEbc,EAAI0V,OAAO7V,EAAQoC,EAAKhD,EAAGgD,EAAK/C,GAC3BqW,GACDzB,EAAM6B,UAGTZ,UAAS,KACV/U,EAAIqU,SAASxU,GACNA,KAIX,OAFiB2B,EAAKmS,UAAY3T,GACzBwU,aAAaV,GACfA,EAAM/F,QA0EjB,SAAS6H,GAAUC,EAAOC,EAAIC,EAAIC,EAAa/W,EAAGC,GAC9C,MAAM+W,EAAKhR,KAAKiR,IAAIjX,EAAI6W,GAClBK,EAAKlR,KAAKiR,IAAIhX,EAAI6W,GACxB,GAAU,GAANE,GAAiB,GAANE,IAAYH,EACvB,OAAO,EACX,OAAQH,GACJ,IAAK,IACD,OAAa,GAANI,GAAiB,GAANE,EACtB,IAAK,IACL,IAAK,IACD,OAAOF,GAAME,EACjB,IAAK,IACD,OAAa,GAANF,GAAiB,GAANE,GAAWF,GAAME,EACvC,QACI,OAAO,GF7MnB7N,EAAc,OAAQyB,ICnDtBzB,EAAc,aAAc0H,MC2ExBzP,OAAOsM,QAAQ,OAAQ,QAAS,MAMhCtM,OAAOsM,QAAQ,MAAO,MAAO,MAM7BtM,OAAOsM,QAAQ,OAAQ,QAAS,oEAL7BM,eAAoBnN,EAAKgN,EAAQzM,EAAQmT,EAAUC,GACtDpT,EAASA,GAAU,OACnBmT,EAAWA,GAAY,UACjBD,GAAYzT,EAAKgN,EAAO/N,EAAG+N,EAAO9N,EAAGqB,EAAQmT,EAAU,EAAGC,oCAqF7D,SAAc3T,EAAKiV,EAAQjI,EAAQzM,EAAQiB,EAAO,IACrD,OAAOwT,GAAWhV,EAAKiV,EAAQjI,EAAQzM,EAAQiB,eAE5C2L,eAA0BnN,EAAKiV,EAAQjI,EAAQzM,EAAQiB,EAAO,IAIjE,GAHsB,iBAAXjB,IACPA,EAASnF,EAAImF,OAAO6C,KAAK7C,IAEzBA,EAAO6V,IAA0B,GAApB7V,EAAO6V,GAAGzS,OAAa,CACpC,MAAMoL,EAAM3T,EAAImP,GAAG8L,UAAUpB,EAAQjI,GACrC,IAAIjI,EAAQ,EACRgK,EAAI,IAAMA,EAAI,IACdhK,EAAQ,EACJgK,EAAI,IAAMA,EAAI,KAEdhK,EAAQ,IAGPgK,EAAI,KACThK,EAAQ,GAEZ,MAAMqR,EAAK7V,EAAO6V,GAAGrR,GACrBxE,EAASnF,EAAImF,OAAOwC,KAAKqT,EAAI7V,EAAO+V,GAAI/V,EAAOgW,SAE9C,GAAIhW,EAAO6V,IAA2B,IAArB7V,EAAO6V,GAAGzS,OAC5B,MAAM,IAAIoD,MAAM,gFAEpB,OAAOiO,GAAWhV,EAAKiV,EAAQjI,EAAQzM,EAAQiB,SAE5C,SAAcxB,EAAKoD,EAAM4Q,EAAIzT,EAAQiB,EAAO,IAC/CA,EAAKgV,KAAOhV,EAAKgV,MAAQ,SACA5P,IAArBpF,EAAKiV,cACLjV,EAAKiV,aAAc,GACvB,MAAMC,EAAO,GACbtb,EAAImP,GAAGoM,cAAcvT,EAAM4Q,GAAI,CAAC/U,EAAGC,MAC1Bc,EAAI4W,MAAM3X,EAAGC,OAEdsC,EAAKgU,SAAUhU,EAAKgU,OAAOvW,EAAGC,OAE9BsC,EAAKiV,aAAejV,EAAKiU,kBACrBzV,EAAIS,cAAcxB,EAAGC,EAAGgB,EAAanE,gBACjCyF,EAAKiU,iBAETiB,EAAK9R,KAAK,CAAC3F,EAAGC,KADH,IAKnBwX,EAAK9R,KAAK,CAAC3F,EAAGC,KACP,OAEX,MAAMwU,EAAWlS,EAAKkS,UAAYzO,KAAKiQ,KAAWwB,EAAK/S,QAAUnC,EAAK4T,OAAS,GAAnC,IACtCzB,EAAWnS,EAAKmS,UAAY3T,EAC5B6W,EAAW,GACjB,IAAIC,GAAa,EACjB,MAAMhD,EAAQ1Y,EAAI0Y,MACb/Q,KAAK,CAAEgC,MAAO,IACdiP,GAAG,CAAEjP,MAAO2R,EAAK/S,OAAS,IAC1B+P,SAASA,GACTS,UAAUmB,IACX,KAAOwB,EAAYxB,EAAKvQ,OAAO,GACzB+R,EACF,MAAMnI,EAAM+H,EAAKI,IAAc,EAAE,GAAI,GACrCD,EAASjS,KAAK8P,GAAU1U,EAAK2O,EAAI,GAAIA,EAAI,GAAIpO,EAAQiB,EAAKgV,KAAM7C,QAGnEoB,UAAS5H,gBACJ4J,QAAQC,IAAIH,GAClB,MAAMlI,EAAM+H,EAAKA,EAAK/S,OAAS,GAC/B,MAAO,CAAE1E,EAAG0P,EAAI,GAAIzP,EAAGyP,EAAI,OAG/B,OADAgF,EAASa,aAAaV,GACfA,EAAM/F,mBA2BV,SAAmB/N,EAAKf,EAAGC,EAAG+X,EAAQ1W,EAAQiB,EAAO,KAR5D,SAA4BA,GACxBA,EAAK4T,MAAQ5T,EAAK4T,OAAS,EAC3B5T,EAAKgV,KAAOhV,EAAKgV,MAAQ,IACzBhV,EAAKqU,MAAQrU,EAAKqU,OAAS,SACPjP,IAAhBpF,EAAKyO,SACLzO,EAAKyO,QAAS,GAIlBiH,CAAmB1V,GACnBA,EAAKmS,SAAWnS,EAAKmS,UAAY3T,EAEX,iBAAXO,IACPA,EAASnF,EAAImF,OAAO6C,KAAK7C,IAE7B,MAAMiJ,EAAOpO,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,QAC/B,IAAIhR,EAAIiP,IAAI8M,IAAI,CACxBC,UAAS,CAACnY,EAAGC,IACFc,EAAIS,cAAcxB,EAAGC,EAAGgB,EAAanE,eAEhD6a,MAAK,CAAC3X,EAAGC,IACEc,EAAI4W,MAAM3X,EAAGC,KAGxBmY,UAAUpY,EAAGC,EAAG+X,GAAQ,CAACK,EAAIC,KAC7B/N,EAAK8N,GAAIC,GAAM,KAEnB,MAAM7D,EAAWlS,EAAKkS,UAAkBuD,EAASzV,EAAK4T,MAApB,GAC5ByB,EAAW,GACX/C,EAAQ1Y,EAAI0Y,MACb/Q,KAAK,CAAE2D,EAAG,IACVsN,GAAG,CAAEtN,EAAGuQ,IACRvD,SAASA,GACTS,UAAUmB,IACX,MAAMkC,EAAOvS,KAAKS,IAAI,EAAGzG,EAAIqW,EAAK5O,GAC5B+Q,EAAOxS,KAAKS,IAAI,EAAGxG,EAAIoW,EAAK5O,GAC5BgR,EAAOzS,KAAKkB,IAAInG,EAAImE,MAAQ,EAAGlF,EAAIqW,EAAK5O,GACxCiR,EAAO1S,KAAKkB,IAAInG,EAAIoM,OAAS,EAAGlN,EAAIoW,EAAK5O,GAC/C,IAAK,IAAI4Q,EAAKE,EAAMF,GAAMI,IAAQJ,EAC9B,IAAK,IAAIC,EAAKE,EAAMF,GAAMI,IAAQJ,EAC1B/N,EAAK8N,GAAIC,IACTnc,EAAImP,GAAGC,gBAAgBvL,EAAGC,EAAGoY,EAAIC,IAAOjC,EAAK5O,IAC7C8C,EAAK8N,GAAIC,GAAM,EACX3B,GAAUpU,EAAKqU,MAAO5W,EAAGC,EAAGsC,EAAKyO,OAAQqH,EAAIC,IAC7CV,EAASjS,KAAK8P,GAAU1U,EAAKsX,EAAIC,EAAIhX,EAAQiB,EAAKgV,KAAMhV,EAAKmS,eAM5EoB,UAAS5H,MAAOyK,EAAMC,KACvBzc,EAAIoO,KAAKC,KAAKD,SACRuN,QAAQC,IAAIH,GACXgB,KAGX,OADArW,EAAKmS,SAASa,aAAaV,GACpBA,EAAM/F,WC1TVZ,eAAe8B,GAAQjE,EAAM5B,EAAO0E,EAAM,IAE7C,MAAMyB,EAAOzB,EAAIiB,IACjB,IAAKQ,EACD,MAAM,IAAIxI,MAAM,qCACpB,MAAM+Q,EAAO1O,EAAMnK,EAAIsQ,EAAK,GACtBwI,EAAO3O,EAAMlK,EAAIqQ,EAAK,GACtBvP,EAAMgL,EAAKhL,IACXgY,EAAchY,EAAIqB,KAAK+H,EAAMnK,EAAGmK,EAAMlK,GACtC+Y,EAAUjY,EAAIqB,KAAKyW,EAAMC,GAC/B,IAAI7K,EAAS,EACb,GAAI9D,EAAM9H,YAAY2W,GAClB,OAAInK,EAAIoK,IACG,GACXC,GAAOnY,EAAKiY,EAAS,MAAO,KAC5B7O,EAAMyE,YACCzE,EAAMqC,WAEjB,GAAIwM,EAAQ9H,aACR,OAAIrC,EAAIoK,IACG,GACXC,GAAOnY,EAAKiY,EAAS,MAAO,KAC5B7O,EAAMyE,YACCzE,EAAMqC,WAGjB,IAAKuM,EAAYI,eAAehP,GAC5B,OAAI0E,EAAIoK,IACG,EAEJ9O,EAAMqC,UAGjB,GAAIwM,EAAQxI,YAAcwI,EAAQI,UAAW,CACzC,GAAIvK,EAAIoK,IACJ,OAAO,EACX,MAAM1E,EAAO,CAAEpK,MAAO6O,EAAQ7O,MAAOyC,KAAMoM,EAAQpM,MAEnD,GADAqB,QAAenD,GAAKiB,EAAM5B,EAAOoK,GAC7BtG,EACA,OAAOA,EAGf,IAAK+K,EAAQK,YAAYlP,GACrB,OAAI0E,EAAIoK,IACG,EACJ9O,EAAMqC,UAEjB,IAAKzL,EAAIuY,UAAUnP,EAAO0O,EAAMC,GAE5B,OADA7K,QAAe8C,GAAWhF,EAAM5B,GACzB8D,EAEX,IAAIsL,EAAO,IAKX,OAJIP,EAAQxU,YAAYJ,EAAW1G,gBAC/B6b,EAAO,KAEXtL,EAAS9D,EAAMqC,QAAQ+M,GAChBtL,EC1DJC,eAAe4C,GAAK/E,EAAM5B,EAAOkH,GACpC,GAAIlV,EAAIgT,OAAOC,OAAO,IAElB,OAAOjF,EAAMqC,UAGjB,MAAMgN,EAAWrd,EAAIgT,OAAOsK,OAAO,GAC7B3J,EAAM3T,EAAImP,GAAGoO,KAAKF,GAClBvL,QAAe+B,GAAQjE,EAAM5B,EAAO,CAAE2F,IAAAA,EAAKmJ,KAAK,IACtD,OAAIhL,GAGG9D,EAAMqC,UCbV0B,eAAeyL,GAAO5N,EAAM5B,EAAO0E,EAAM,IAE5C,IADY1E,EAAMpJ,IAEd,MAAM,IAAI+G,MAAM,qBACpB,MAAM8E,EAAOzC,EAAMpJ,IAAI6Y,OAAOzP,EAAMnK,EAAGmK,EAAMlK,GAC7C,IAAK2M,EAID,OAHKiC,EAAIgL,OACL1d,EAAI2d,QAAQC,MAAM5P,EAAMnK,EAAGmK,EAAMlK,EAAG,sBAEjC,EAEX,GAAIkK,EAAM6P,WAAWpN,GACjB,OAAO,EACX,MAAMqN,EAAarN,EAAKpD,UAAU,UAClC,IAAmB,IAAfyQ,EAMA,OALKpL,EAAIgL,OACL1d,EAAI2d,QAAQC,MAAM5P,EAAMnK,EAAGmK,EAAMlK,EAAG,iCAAkC,CAClE2M,KAAAA,IAGD,EAEN,GAA0B,mBAAfqN,EAA2B,CAEvC,MAAMhM,QAAegM,EAAWlO,EAAM5B,EAAOyC,GAC7C,GAAIqB,EACA,OAAOA,EAGf,OAAK9D,EAAM+P,WAAWtN,IAGjBzC,EAAMpJ,IAAIoZ,WAAWvN,IAG1BzC,EAAMiQ,QAAQxN,GACTiC,EAAIgL,OACL1d,EAAI2d,QAAQC,MAAM5P,EAAMnK,EAAGmK,EAAMlK,EAAG,0BAA2B,CAC3D2M,KAAAA,IAGDzC,EAAMqC,WAXF,EF+BfnD,EAAc,UAAW2G,IC9CzB3G,EAAc,OAAQyH,IC4BtBzH,EAAc,SAAUsQ,oLhBzBjB,SAAqB7Y,EAAIuZ,GACxB5H,MAAMC,QAAQ2H,KACdA,EAAO,IAAIjV,EAAaiV,IAE5BjU,EAAatF,GAAMuZ,WAEhB,SAAiBvZ,GACpB,MAAM0E,EAAIY,EAAatF,GACvB,IAAK0E,EACD,MAAM,IAAIsC,MAAM,+BAAiChH,GACrD,OAAO0E,0DUZJ,SAAoBjD,EAAM+Q,GAC7B,MAAMjT,EAAOoT,GAAWlR,GACxB,IAAKlC,EACD,MAAM,IAAIyH,MAAM,uCAAyCwS,KAAKC,UAAUhY,IAC5E,OAAOlC,EAAKyD,KAAKwP,qBAGd,SAAiBxS,EAAIT,GACxB,GAAIA,aAAgB4R,EAEhB,OADAuB,GAAM1S,GAAMT,EACLA,EAEX,MAAMma,EAAOjH,GAASlT,GAGtB,OAFAma,EAAK1Z,GAAKA,EACV0S,GAAM1S,GAAM0Z,EACLA,qFO/BJ,MAAMrd,WAAab,EACtByD,YAAYM,GACRqJ,MAAMrJ,GACNF,KAAKsa,SAAW,EAChBta,KAAKU,KAAO,KAEZV,KAAKQ,MAAMiM,KAAO,EAClBzM,KAAKM,MAAQxE,EAAMye,KACnBva,KAAKE,KAAOA,EAEhBN,KAAK2B,GACDgI,MAAM9H,KAAKF,GACXvB,KAAKsa,SAAW/Y,EAAM+Y,SAE1B1a,YACI,OAAOI,KAAKQ,MAAMiM,KAEtB7M,YAAY3D,GACR,SAAU+D,KAAKQ,MAAMiM,KAAOxQ,GAEhC2D,gBAAgBY,GACZ,OAAQR,KAAKQ,MAAMiM,KAAOjM,KAAWA,EAEzCZ,UAAUoD,GAEN,OADehD,KAAKE,KAAKwK,QAAQ1H,GAGrCpD,iBACI,OAAOI,KAAKE,KAAKyK,MC1BlB,MAAM6P,WAAiBzI,EAC1BnS,YAAYsD,GACRqG,MAAMrG,GACNlD,KAAKQ,MAAQ,CACTiM,KAAMgO,EAAWzI,QACjBvR,OAAQK,EAAamR,eAEzBjS,KAAK0K,QAAU,GACf1K,KAAK2K,KAAO,GACRzH,EAAO1C,QACPR,KAAKQ,MAAMiM,KAAOzQ,EAAIC,KAAK+H,KAAKyW,EAAYza,KAAKQ,MAAMiM,KAAMvJ,EAAO1C,OACpER,KAAKQ,MAAMC,OAASzE,EAAIC,KAAK+H,KAAKlD,EAAcd,KAAKQ,MAAMC,OAAQyC,EAAO1C,QAE1E0C,EAAOwH,SACPhJ,OAAOgZ,QAAQxX,EAAOwH,SAAStF,SAAQ,EAAEhF,EAAKwG,MAC1C5G,KAAK0K,QAAQtK,GAAOwG,KAGxB1D,EAAOyH,OACoB,iBAAhBzH,EAAOyH,MACS,mBAAhBzH,EAAOyH,OACdzH,EAAOyH,KAAO,CAACzH,EAAOyH,OAEtB2H,MAAMC,QAAQrP,EAAOyH,QACrB3K,KAAK2K,KAAOzH,EAAOyH,KAAK5G,UAGhC/D,KAAKqD,gBAAkBY,EAAW1G,aAClCyC,KAAKoD,iBAAmBa,EAAW3G,OAAS2G,EAAW5G,eAE3DuC,KAAKgT,GACD,MAAMnG,EAAO,IAAIzP,GAAKgD,MAEtB,OADAA,KAAKkE,KAAKuI,EAAMmG,GACTnG,EAEX7M,KAAK6M,EAAMmG,EAAU,IACjBrJ,MAAMrF,KAAKuI,EAAMmG,GACjBlR,OAAOC,OAAO8K,EAAKjM,MAAOR,KAAKQ,OAC/BiM,EAAK6N,SAAW1H,EAAQ0H,UAAY,EAExC1a,WAAWqC,EAAMwK,GACb,QAAIxK,EAAK0Y,UAEFpR,MAAMpH,WAAWF,EAAMwK,ICvB/B,MAAM4G,GAAQ,GAWd,SAAS7M,GAAI7F,GAChB,OAAIA,aAAc6Z,GACP7Z,EACJ0S,GAAM1S,GAEV,SAASyS,GAASF,GACrB,MAAMhQ,EAASxB,OAAOC,OAAO,GAAIuR,GACjC,OAAO,IAAIsH,GAAStX,GAEjB,SAASoQ,GAAWlR,EAAO,IAC9B,MAAMmR,EAAQ,CACVzR,KAAM,GACN0R,WAAY,IAEI,iBAATpR,IACPA,EAAO,CACHN,KAAMM,IAGW,iBAAdA,EAAKN,KACZM,EAAKN,KACA8B,MAAM,SACNhD,KAAKiD,GAAMA,EAAEC,SACbsB,SAASvB,IACNA,EAAE4P,WAAW,KACbF,EAAMC,WAAWhO,KAAK3B,EAAE6P,UAAU,GAAG5P,QAGrCyP,EAAMzR,KAAK0D,KAAK3B,MAInByO,MAAMC,QAAQnQ,EAAKN,QACxByR,EAAMzR,KAAOM,EAAKN,KAAKiC,SAEI,iBAApB3B,EAAKoR,WACZD,EAAMC,WAAapR,EAAKoR,WAAW5P,MAAM,SAAShD,KAAKiD,GAAMA,EAAEC,SAE1DwO,MAAMC,QAAQnQ,EAAKoR,cACxBD,EAAMC,WAAapR,EAAKoR,WAAWzP,SAEvC,MAAM/B,EAAUN,OAAOiS,OAAON,IAAOO,QAAQC,KACrCN,EAAMzR,KAAKyC,SAAWvI,EAAI8X,gBAAgBP,EAAMzR,KAAM+R,EAAE/R,UAExDyR,EAAMC,aAAcxX,EAAI8X,gBAAgBP,EAAMC,WAAYK,EAAE/R,SAKpE,OADYM,EAAK2R,KAAO/X,EAAI+X,IAAI/E,QACrBvC,KAAKzK,IAAY,mEAlFzB,SAAckR,EAAMC,GACvB,IAAIjT,EACJ,GAAoB,iBAATgT,GAGP,GADAhT,EAAOsG,GAAI0M,IACNhT,EACD,MAAM,IAAIyH,MAAM,8BAAgCuL,QAGpDhT,EADKgT,aAAgBsH,GACdtH,EAGAE,GAASF,GAEpB,OAAOhT,EAAKyD,KAAKwP,eAEd,SAAoB/Q,EAAM+Q,GAC7B,MAAMjT,EAAOoT,GAAWlR,GACxB,IAAKlC,EACD,MAAM,IAAIyH,MAAM,uCAAyCwS,KAAKC,UAAUhY,IAC5E,OAAOlC,EAAKyD,KAAKwP,qBAGd,SAAiBxS,EAAIT,GACxB,GAAIA,aAAgBsa,GAEhB,OADAnH,GAAM1S,GAAMT,EACLA,EAEX,MAAMma,EAAOjH,GAASlT,GAGtB,OAFAma,EAAK1Z,GAAKA,EACV0S,GAAM1S,GAAM0Z,EACLA,sCCjCJ,MAAMO,GAAW,GACjB,SAASC,GAAela,EAAIma,GAC/BF,GAASja,EAAGyI,eAAiB0R,EAE1B,MAAMC,GAAc,GACpB,SAASC,GAAYra,EAAI8G,GAC5BsT,GAAYpa,GAAM8G,EAqHf,SAAS9D,GAAKvB,GACjB,IAAKA,EACD,MAAM,IAAIuF,MAAM,iCACpB,IAAIzE,EAAS,GACb,GAAoB,iBAATd,EAEP,GAAIA,EAAKgH,cAAcqK,WAAW,WAAY,CAC1C,MAAMwH,EAAS7Y,EAAK8Y,QAAQ,IAAK,GAC3BC,EAAO/Y,EAAKsR,UAAU,EAAGuH,GAC/B/X,EAAS,CACLuE,KAAM,UAAYrF,EAAKsR,UAAUuH,GACjCG,QAAS,CAAC,QAAUD,SAIxBjY,EAAS,CAAEuE,KAAM,QAAS2T,QAAS,CAAChZ,QAGnB,mBAATA,EACZc,EAAS,CAAEuE,KAAM,QAAS2T,QAAS,CAAChZ,IAE/BkQ,MAAMC,QAAQnQ,GACnBc,EAAS,CAAEuE,KAAM,QAAS2T,QAAShZ,IAI/BA,EAAKiZ,SAELjZ,EAAKgZ,QAAU,CAAChZ,EAAKiZ,eACdjZ,EAAKiZ,QAGZjZ,EAAKgZ,SACL1Z,OAAOC,OAAOuB,EAAQd,IACQ,iBAAnBc,EAAOkY,SAGiB,mBAAnBlY,EAAOkY,WAFnBlY,EAAOkY,QAAU,CAAChZ,EAAKgZ,YAO3BlY,EAAOkY,QAAU,GACjB1Z,OAAOgZ,QAAQtY,GAAMgD,SAAQ,EAAEhF,EAAKwG,WAEhBY,IADAoT,GAASxa,EAAIgJ,gBAKH,mBAAVxC,EAFZ1D,EAAOkY,QAAQhb,GAAOwG,EAQtB1D,EAAO9C,GAAOwG,OAM9B,GADA1D,EAAOuE,KAAOvE,EAAOuE,MAAQ,QACF,iBAAhBvE,EAAOuE,KACd,MAAM,IAAIE,MAAM,wBAA0BwS,KAAKC,UAAUlX,EAAOuE,OACpE,MACM6T,EADYpY,EAAOuE,KAAK7D,MAAM,KAAKhD,KAAKiD,GAAMA,EAAEC,SAC3ByX,QACrBC,EAAST,GAAYO,EAASlS,eACpC,IAAKoS,EACD,MAAM,IAAI7T,MAAM,wBAA0B2T,GAC9C,MAAMD,EAASG,EAAOtY,GAmCtB,OAlCIoP,MAAMC,QAAQrP,EAAOkY,SACrBlY,EAAOkY,QAAQhW,SAASqW,IACpB,GAAiB,mBAANA,EACPJ,EAAOD,QAAQ5V,KAAKiW,OAEnB,CACD,MAAMC,EAAQD,EAAE7X,MAAM,KAAKhD,KAAKiD,GAAMA,EAAEC,SACxC,GAAqB,IAAjB4X,EAAMnX,OAAc,CACpB,MAAM8W,EAASM,GAAiBD,EAAM,IACtC,IAAKL,EACD,MAAM,IAAI1T,MAAM,kCAAoC+T,EAAM,IAC9DL,EAAOD,QAAQ5V,KAAK6V,EAAOO,QAAQC,KAAKR,QAEvC,CACD,MAAMP,EAAUF,GAASc,EAAM,GAAGtS,eAClC,IAAK0R,EACD,MAAM,IAAInT,MAAM,mBAAqB+T,EAAM,IAC/CA,EAAMH,QACNF,EAAOD,QAAQ5V,KAAKsV,EAAQY,SAMxCha,OAAOgZ,QAAQxX,EAAOkY,SAAShW,SAAQ,EAAEhF,EAAKwG,MAC1C,MAAMkU,EAAUF,GAASxa,EAAIgJ,eAC7B,IAAK0R,EACD,MAAM,IAAInT,MAAM,gCAAkCvH,GACtDib,EAAOD,QAAQ5V,KAAKsV,EAAQlU,OAGhC1D,EAAOxC,OACP2a,EAAO3a,KAAOiD,GAAKT,EAAOxC,OAEvB2a,EAEJ,SAASrX,GAAK5B,GACjB,IAAKA,EACD,MAAM,IAAIuF,MAAM,4CACpB,GAAoB,iBAATvF,GAAqB,YAAaA,EACzC,OAAOA,EAEX,GAAoB,iBAATA,EAAmB,CAC1B,MAAMiZ,EAASM,GAAiBvZ,GAChC,GAAIiZ,EACA,OAAOA,EACX,MAAM,IAAI1T,MAAM,oBAAsBvF,GAE1C,OAAOuB,GAAKvB,GAOT,MAAMuZ,GAAmB,GACzB,SAASlO,GAAQ9M,EAAIuC,GACxB,MAAMmY,EANgB,iBADRrG,EAOU9R,IANU,YAAa8R,EAMb9R,EAAOqS,QAAU5R,GAAKT,GAP5D,IAAkB8R,EASd,OADA2G,GAAiBhb,GAAM0a,EAChBA,ECxPJ,MAAMS,GACTlc,YAAYsD,GACRlD,KAAKob,QAAU,GACfpb,KAAKiP,OAAS,IACdjP,KAAK+b,MAAO,EACZ/b,KAAKQ,MAAQ,EACbR,KAAKU,KAAO,KACU,iBAAXwC,GAAwBoP,MAAMC,QAAQrP,KAC7ClD,KAAKQ,MAAQxE,EAAIC,KAAK+H,KAAKgY,EAAc9Y,EAAO1C,OACnB,iBAAlB0C,EAAO+L,QACd/L,EAAO+L,OAAOgN,SAAS,KACvBjc,KAAKiP,OAA4C,IAAnCiN,OAAOC,WAAWjZ,EAAO+L,QAGvCjP,KAAKiP,OAASiN,OAAOE,SAASlZ,EAAO+L,QAAU,UAI3DrP,QACI,MAAM2B,EAAQ,IAAIvB,KAAKwB,YAMvB,OALAD,EAAM6Z,QAAUpb,KAAKob,QAAQrX,QAC7BxC,EAAM0N,OAASjP,KAAKiP,OACpB1N,EAAMwa,MAAO,EACbxa,EAAMf,MAAQR,KAAKQ,MACnBe,EAAMb,KAAOV,KAAKU,KACXa,EAEX3B,QAAQ2P,EAAKb,EAAM,IACf,IAAKA,EAAI2N,OAASrc,KAAKiP,OAAQ,CAE3B,KADYP,EAAIqF,KAAOxE,EAAI3O,IAAImT,KAAO/X,EAAIgT,QACjCC,OAAOjP,KAAKiP,OAAQ,KACzB,OAAO,EAEf,IAAIqN,GAAe,EACnB,IAAK,IAAIC,KAAOvc,KAAKob,QACbmB,EAAIhN,EAAKb,KACT4N,GAAe,GAGvB,GAAItc,KAAKU,KAAM,CACX,MAAM8b,KAAgBxc,KAAKQ,MAAQwb,EAAaS,eAChD,GAAIH,GAAgBE,EAChB,OAAOxc,KAAKU,KAAKkb,QAAQrM,EAAKb,GAGtC,OAAO4N,GAGR,SAASI,GAAgBxZ,GAC5B,MAAsB,iBAAXA,EACA,IAAI4Y,GAER,IAAIA,GAAY5Y,GCnDpB,SAASyZ,GAAiBzZ,GAC7B,OAAO,IAAI0Z,GAAa1Z,MDoDT,QAASwZ,IClD5B1B,GAAY,SAAU2B,IACf,MAAMC,WAAqBd,GAC9Blc,YAAYsD,GAWR,GAVAqG,MAAMrG,GACNlD,KAAK6c,KAAO,EACZ7c,KAAK8c,UAAY,EACjB9c,KAAK+c,UAAY,GACZ7Z,IACDA,EAAS,CAAE2Z,KAAM,EAAGC,UAAW,EAAGtc,MAAO,IAEvB,iBAAX0C,IACPA,EAASA,EAAOU,MAAM,KAAKhD,KAAKiD,GAAMA,EAAEC,UAExCwO,MAAMC,QAAQrP,GACkB,WAA5BA,EAAO,GAAGkG,eACVlG,EAAOqY,QAEXrY,EAAS,CACL2Z,KAAM3Z,EAAO,IAAM,IACnB4Z,UAAW5Z,EAAO,IAAM,MACxB1C,MAAO0C,EAAO,IAAM,UAGvB,GAA2B,iBAAhBA,EAAOuE,MACnBvE,EAAOuE,KAAK1F,SAAS,KAAM,CAC3B,MAAM2Z,EAAQxY,EAAOuE,KAAK7D,MAAM,KAAKhD,KAAKiD,GAAMA,EAAEC,SACnB,WAA3B4X,EAAM,GAAGtS,eACTsS,EAAMH,QAEVrY,EAAO2Z,KAAOnB,EAAM,IAAM,IAC1BxY,EAAO4Z,UAAYpB,EAAM,IAAM,MAC/BxY,EAAO1C,MAAQ0C,EAAO1C,MAAQ,IAAMkb,EAAM,GAE9C1b,KAAK6c,KAAOX,OAAOE,SAASlZ,EAAO2Z,MAAQ,GAC3C7c,KAAK8c,UAAYZ,OAAOE,SAASlZ,EAAO4Z,WAAa,KACrD9c,KAAKQ,MAAQxE,EAAIC,KAAK+H,KAAKgY,EAAc9Y,EAAO1C,OAAS,GACzDR,KAAK+c,UAAY7Z,EAAO6Z,WAAa,GAEzCnd,QACI,MAAM2B,EAAQgI,MAAMgM,QAIpB,OAHAhU,EAAMsb,KAAO7c,KAAK6c,KAClBtb,EAAMub,UAAY9c,KAAK8c,UACvBvb,EAAMwb,UAAY/c,KAAK+c,UAChBxb,EAEX3B,QAAQuL,EAAIuD,EAAM,IACd,MAAMsO,KAAqBhd,KAAKQ,MAAQwb,EAAaiB,uBACrD,IAAIX,GAAe,EACnB,MAAM1b,EAAMuK,EAAGvK,IACTsc,EAAWlhB,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,QAE/C,GADAsP,EAAea,GAAgBnd,KAAMmL,EAAI+R,IACpCZ,EAED,OADAtgB,EAAIoO,KAAKC,KAAK6S,IACP,EAEX,GAAIF,GAAmBI,GAAexc,EAAKsc,GAEvC,OADAlhB,EAAIoO,KAAKC,KAAK6S,IACP,EA+BX,GA7BIld,KAAKQ,MAAQwb,EAAaqB,sBAEtBC,GAAkB1c,EAAKsc,KACvBZ,GAAe,GAGnBtc,KAAKQ,MAAQwb,EAAauB,kBAEtBC,GAAc5c,EAAKsc,KACnBZ,GAAe,GAGnBtc,KAAKQ,MAAQwb,EAAayB,cAEtBC,GAAW9c,EAAKsc,EAAUld,KAAKQ,SAC/B8b,GAAe,GAGvBY,EAAS9X,SAAQ,CAACsB,EAAG7G,EAAGC,KACpB,GAAK4G,EAAL,CAEAwW,EAASrd,GAAGC,GAAK,EACjB,IAAK,IAAIyc,KAAOvc,KAAKob,QACbmB,EAAI,CAAE3b,IAAAA,EAAKf,EAAAA,EAAGC,EAAAA,GAAK4O,KACnB4N,GAAe,EACfY,EAASrd,GAAGC,GAAK,OAIzBE,KAAKU,KAAM,CACX,MAAM8b,KAAgBxc,KAAKQ,MAAQwb,EAAaS,gBAC5CH,GAAgBE,KACZxc,KAAKQ,MAAQwb,EAAa2B,kBAC1BT,EAAS9X,SAAQ,CAACsB,EAAG7G,EAAGC,KACf4G,IAEI,GAALA,GAAU8V,IACVxc,KAAKU,KAAKkb,QAAQ,CAAEhb,IAAAA,EAAKf,EAAAA,EAAGC,EAAAA,GAAK4O,MAKzC1O,KAAKU,KAAKkb,QAAQ,CAAEhb,IAAAA,EAAKf,EAAGsL,EAAGtL,EAAGC,EAAGqL,EAAGrL,GAAK4O,IAKzD,OADA1S,EAAIoO,KAAKC,KAAK6S,GACPZ,GAGR,SAASc,GAAexc,EAAKgd,EAAcC,EAAiB,EAAGC,EAAiB,GACnF,MAAMC,EAAe/hB,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,QACnD,IAAIgR,GAAW,EAEfhiB,EAAImP,GAAG8S,QAAQrd,EAAImE,MAAOnE,EAAIoM,QAAQ,CAAC1B,EAAGC,KACtC,MAAM2S,EAAQ5S,EAAIuS,EACZM,EAAQ5S,EAAIuS,EACdF,EAAapX,IAAI0X,EAAOC,GACpBvd,EAAIqB,KAAKqJ,EAAGC,GAAG6S,aACfJ,GAAW,GAGTpd,EAAIqB,KAAKqJ,EAAGC,GAAGwF,eACrBgN,EAAazS,GAAGC,GAAK,MAG7B,IAAI8S,GAAQ,EACZ,IAAK,IAAI/S,EAAI,EAAGA,EAAIyS,EAAahZ,QAAUiZ,IAAY1S,EACnD,IAAK,IAAIC,EAAI,EAAGA,EAAIwS,EAAa/Q,SAAWgR,IAAYzS,EAC1B,GAAtBwS,EAAazS,GAAGC,KACZ8S,GACAN,EAAaO,UAAUhT,EAAGC,EAAG,EAAG,GAChC8S,GAAQ,GAGRL,GAAW,GAQ3B,OADAhiB,EAAIoO,KAAKC,KAAK0T,GACPC,EAGX,SAASO,GAASlD,EAAQza,EAAKf,EAAGC,EAAG0e,GACjC,IAAK5d,EAAI4W,MAAM3X,EAAGC,GACd,OAAO,EACX,MAAMmC,EAAOrB,EAAIqB,KAAKpC,EAAGC,GACzB,GAAImC,EAAKyP,YAAYjB,EAAWgO,iBAC5B,OAAO,EACX,GAAIxc,EAAKyc,kBAAoBrD,EAAO0B,YAAcyB,EAC9C,OAAO,EAEX,GAAInD,EAAO7a,MAAQwb,EAAa2C,kBAC5B,IAAK/d,EAAIqB,KAAKpC,EAAGC,GAAG8e,SAChB,OAAO,OAEV,GAAIvD,EAAO7a,MAAQwb,EAAa6C,mBAAoB,CACrD,IAAI1I,GAAK,EAMT,GALAna,EAAImP,GAAG2F,aAAajR,EAAGC,GAAG,CAACwL,EAAGC,KACtB3K,EAAIqB,KAAKqJ,EAAGC,GAAGqT,WACfzI,GAAK,MAEV,IACEA,EACD,OAAO,OAEV,GAAIkF,EAAO7a,MAAQwb,EAAa8C,iBAAkB,CACnD,IAAI3I,GAAK,EACT,GAAIvV,EAAIqB,KAAKpC,EAAGC,GAAG8e,SACf,OAAO,EAMX,GALA5iB,EAAImP,GAAG2F,aAAajR,EAAGC,GAAG,CAACwL,EAAGC,KACtB3K,EAAIqB,KAAKqJ,EAAGC,GAAGqT,WACfzI,GAAK,MAEV,IACEA,EACD,OAAO,EAGf,QAAIkF,EAAO0B,YAAcyB,IAAYvc,EAAK8c,QAAQ1D,EAAO0B,YAKtD,SAASI,GAAgB9B,EAAQ9L,EAAK2N,GACzC,IAAI5R,EAAGC,EAAGoE,EAAK9L,EAAGmb,EAAIC,EAClBC,EAKJ,MAAMte,EAAM2O,EAAI3O,IAChB,IAAIue,EAAY9D,EAAOwB,MAAQ,EAC3BuC,EAAU/D,EAAOyB,WAAa,EAElC,GADAI,EAASmC,KAAK,IACTd,GAASlD,EAAQza,EAAK2O,EAAI1P,EAAG0P,EAAIzP,GAAG,GACrC,OAAO,EAEXod,EAAS3N,EAAI1P,GAAG0P,EAAIzP,GAAK+D,EAAI,EAC7B,IAAIwD,EAAQ,EACZ,GAAI8X,EAQA,IAPAD,GAAa,EACTC,GAAa,MACbC,EAAUA,GAAW,KAErBA,GAAW,IACXA,EAAUD,GAEPD,GAAcC,EAAY,GAAG,CAGhC,IAFAD,GAAa,EACbrb,IACKyH,EAAI,EAAGA,EAAI1K,EAAImE,MAAOuG,IACvB,IAAKC,EAAI,EAAGA,EAAI3K,EAAIoM,OAAQzB,IACxB,GAAI2R,EAAS5R,GAAGC,IAAM1H,EAAI,EACtB,IAAK8L,EAAM,EAAGA,EAAM,EAAGA,IACnBqP,EAAK1T,EAAItP,EAAImP,GAAGoO,KAAK5J,GAAK,GAC1BsP,EAAK1T,EAAIvP,EAAImP,GAAGoO,KAAK5J,GAAK,GACtBuN,EAAS1F,MAAMwH,EAAIC,KAClB/B,EAAS8B,GAAIC,IACdre,EAAImT,IAAI9E,OAAOkQ,IACfZ,GAASlD,EAAQza,EAAKoe,EAAIC,GAAI,KAC9B/B,EAAS8B,GAAIC,GAAMpb,EACnBqb,GAAa,IACX7X,GAMtB8X,GAAaC,EAGrB,OAAO/X,EAAQ,EAEZ,SAASqW,GAAW9c,EAAKsc,EAAU1c,EAAQ,GAC9C,IAAI8b,GAAe,EACnB,MAAMgD,GAAY9e,EAAQwb,EAAayB,gBAAkBzB,EAAayB,aAwBtE,OAvBAP,EAAS9X,SAAQ,CAACsB,EAAG4E,EAAGC,KACpB,IAAK7E,EACD,OACJ,MAAMzE,EAAOrB,EAAIqB,KAAKqJ,EAAGC,GACrB+T,EACArd,EAAKsd,SAGD/e,EAAQwb,EAAazc,aACrB0C,EAAKud,WAAWvV,EAAYwV,KAE5Bjf,EAAQwb,EAAa1c,gBACrB2C,EAAKud,WAAWvV,EAAYyV,QAE5Blf,EAAQwb,EAAa3c,iBACrB4C,EAAKud,WAAWvV,EAAY0V,SAE5Bnf,EAAQwb,EAAa5c,gBACrB6C,EAAKud,WAAWvV,EAAY2V,SAGpCtD,GAAe,KAEZA,EAEJ,SAASgB,GAAkB1c,EAAKif,GACnC,IAAIvD,GAAe,EAmBnB,OAlBA1b,EAAIkf,WAAWvO,IACX,IAAKsO,EAAYtO,EAAE1R,GAAG0R,EAAEzR,GACpB,OACJ,MAAMyP,EAAM3O,EAAImT,IAAIgM,gBAAgBxO,EAAE1R,EAAG0R,EAAEzR,GAAG,CAACD,EAAGC,KAC9C,IAAKc,EAAI4W,MAAM3X,EAAGC,GACd,OAAO,EACX,GAAI+f,EAAYhgB,GAAGC,GACf,OAAO,EACX,MAAM4H,EAAI9G,EAAIqB,KAAKpC,EAAGC,GACtB,OAAQyR,EAAErP,YAAYwF,MAEtB6H,GAAOA,EAAI,IAAM,GAAKA,EAAI,IAAM,IAChC3O,EAAIof,YAAYzO,GAChB3Q,EAAIqf,SAAS1Q,EAAI,GAAIA,EAAI,GAAIgC,GAE7B+K,GAAe,MAGhBA,EAEJ,SAASkB,GAAc5c,EAAKif,GAC/B,IAAIvD,GAAe,EAmBnB,OAlBA1b,EAAIsf,UAAU5U,IACV,IAAKuU,EAAYvU,EAAEzL,GAAGyL,EAAExL,GACpB,OACJ,MAAMyP,EAAM3O,EAAImT,IAAIgM,gBAAgBzU,EAAEzL,EAAGyL,EAAExL,GAAG,CAACD,EAAGC,KAC9C,IAAKc,EAAI4W,MAAM3X,EAAGC,GACd,OAAO,EACX,GAAI+f,EAAYhgB,GAAGC,GACf,OAAO,EACX,MAAM+C,EAAOjC,EAAIqB,KAAKpC,EAAGC,GACzB,OAAQwL,EAAEpJ,YAAYW,MAEtB0M,GAAOA,EAAI,IAAM,GAAKA,EAAI,IAAM,IAChC3O,EAAIoZ,WAAW1O,GACf1K,EAAIqZ,QAAQ1K,EAAI,GAAIA,EAAI,GAAIjE,GAE5BgR,GAAe,MAGhBA,ECtTJ,SAAS6D,GAAgBjd,GAG5B,GAFIoP,MAAMC,QAAQrP,KACdA,EAASA,EAAO,IACE,iBAAXA,EACP,MAAM,IAAIyE,MAAM,iCAAmCzE,GACvD,OAAOkd,GAAWvE,UAAKrU,EAAWtE,GAE/B,SAASkd,GAAWzf,EAAI4O,EAAKb,GAChC,OAAOa,EAAI3O,IAAIyf,OAAOC,KAAK3f,EAAI4O,EAAKb,GCPjC,SAAS6R,GAAmBC,GAG/B,GAFIlO,MAAMC,QAAQiO,KACdA,EAAMA,EAAI,IACK,iBAARA,EACP,MAAM,IAAI7Y,MAAM,oCAEpB,MAAMuL,EAAO,CACT3N,IAAKib,GAET,OAAOC,GAAc5E,UAAKrU,EAAW0L,GAElC,SAASuN,GAAcvN,EAAM3D,EAAKb,GACrC,MAAMqN,EAAOrN,EAAIqN,KACXxW,EAAM2N,EAAK3N,IACjB,UAAIA,GACAA,EAAIhB,QACJmK,EAAIgS,QACH3E,KAGD/f,EAAI2d,QAAQC,MAAMrK,EAAI1P,EAAG0P,EAAIzP,EAAGyF,EAAKmJ,IAC9B,GCtBR,SAASiS,KACZ,OAAOC,GAAgB/E,UAAKrU,GAEzB,SAASoZ,GAAgBrR,EAAKb,GACjC,MACMmS,EADOtR,EAAI3O,IAAIqB,KAAKsN,EAAI1P,EAAG0P,EAAIzP,GAChBghB,UACrB,QAAKD,GAEEtR,EAAI3O,IAAIggB,gBAAgBC,EAAStR,EAAI1P,EAAG0P,EAAIzP,EAAG4O,GCVnD,SAASqS,GAAgBP,GAC5B,IAAKA,EACD,MAAM,IAAI7Y,MAAM,oCACpB,GAAmB,iBAAR6Y,EACPA,EAAM,CAAE7f,GAAI6f,QAEX,GAAIlO,MAAMC,QAAQiO,GACnBA,EAAM,CAAE7f,GAAI6f,EAAI,SAEf,IAAKA,EAAI7f,GACV,MAAM,IAAIgH,MAAM,4CAEpB,MAAMvF,EAAOoe,EASb,OARIpe,EAAKzB,GAAGoB,SAAS,OACjBK,EAAK4e,eAAgB,GAErB5e,EAAKzB,GAAGoB,SAAS,OACjBK,EAAK6e,iBAAkB,EACvB7e,EAAK8e,gBAAiB,GAE1B9e,EAAKzB,GAAKyB,EAAKzB,GAAGqF,QAAQ,SAAU,IAC7Bmb,GAAWtF,KAAKzZ,GAEpB,SAAS+e,GAAW5R,EAAKb,GAC5B1O,KAAK6gB,QAAUnS,EAAImS,SAAW,EAE9B,OADqBtR,EAAI3O,IAAIwgB,QAAQ7R,EAAI1P,EAAG0P,EAAIzP,EAAGE,KAAKW,GAAIX,MCxBzD,SAASqhB,GAAiBne,GAC7B,IAAIoe,EAAS,EACb,GAAKpe,EAGA,GAAsB,iBAAXA,EACZoe,EAASpe,MAER,CAAA,GAAsB,iBAAXA,EAUZ,MAAM,IAAIyE,MAAM,oCAAsCwS,KAAKC,UAAUlX,IARrEoe,EADcpe,EAAOU,MAAM,SACZ2d,QAAO,CAACC,EAAK9a,KACxB,GAAiB,iBAANA,EACP,OAAO8a,EAAM9a,EAEjB,OAAO8a,GADOvX,EAAYvD,IAAM,KAEjC,QAZH4a,EAASrX,EAAYwX,WAiBzB,OAAOC,GAAY7F,UAAKrU,EAAW8Z,GAEhC,SAASI,GAAYJ,EAAQ/R,EAAK2B,GACrC,IAAKoQ,EACD,OAAO,EAEX,OADa/R,EAAI3O,IAAIqB,KAAKsN,EAAI1P,EAAG0P,EAAIzP,GACzB0f,WAAW8B,GC3BpB,SAASK,GAAmBhhB,GAM/B,GALI2R,MAAMC,QAAQ5R,KACdA,EAAKA,EAAG,IACRA,GAAoB,iBAAPA,IACbA,EAAKA,EAAGA,KAEPA,IAAOA,EAAG4D,OACX,MAAM,IAAIoD,MAAM,2BACpB,OAAOia,GAAc/F,UAAKrU,EAAW7G,GAElC,SAASihB,GAAcjhB,EAAI4O,EAAKb,GACnC,MAAMmT,EAAOC,GAAwBnhB,GACrC,IAAKkhB,EACD,MAAM,IAAIla,MAAM,2BAA6BhH,GAEjD,OAAOkhB,EAAKjG,QAAQrM,EAAKb,GCdtB,SAASqT,GAAkB3f,GAC9B,IAAKA,EACD,MAAM,IAAIuF,MAAM,2BACpB,IAAIuL,EAAO,GAIX,GAHoB,iBAAT9Q,IACPA,EAAOA,EAAKwB,MAAM,KAAKhD,KAAKiD,GAAMA,EAAEC,UAEpCwO,MAAMC,QAAQnQ,GACd8Q,EAAKzL,KAAOrF,EAAK,IAAM,MACvB8Q,EAAKrM,OAAS7K,EAAI2K,MAAMhD,KAAKvB,EAAK,IAAM,OAEvC,CAAA,IAAIA,EAAKqF,OAAQrF,EAAKyE,OAKvB,MAAM,IAAIc,MAAM,2BAA6BwS,KAAKC,UAAUhY,IAJ5D8Q,EAAKzL,KAAOrF,EAAKqF,MAAQ,MACzByL,EAAKrM,OAAS7K,EAAI2K,MAAMhD,KAAKvB,EAAKyE,QAAU,GAKhD,OAAOmb,GAAcnG,UAAKrU,EAAW0L,GAElC,SAAS8O,GAAc9e,EAAQqM,EAAK2B,GACvC,IAAKhO,EAAO2D,OACR,OAAO,EAEX,MAAMmD,EAAQuF,EAAI3O,IAAI0P,QAAQf,EAAI1P,EAAG0P,EAAIzP,GACzC,IAAKkK,EACD,OAAO,EAEX,MAAMG,EAAQH,EAAMG,MACdzC,EAAIyC,EAAM3D,IAAI,QACpB,IAAK2D,EAAM8X,OAAO,OAAQ/e,EAAOuE,KAAMvE,EAAO2D,QAC1C,OAAO,EACX,MAAMqb,EAAI/X,EAAM3D,IAAI,QAMpB,OALI0b,EAAIxa,GAAKwa,EAAI/X,EAAM7D,IAAI,QAAU,IACjCtK,EAAI2d,QAAQC,MAAM5P,EAAMnK,EAAGmK,EAAMlK,EAAGkiB,GAActU,QAAQyU,QAAS,CAC/DnY,MAAAA,KAGD,ECtCJ,SAASoY,GAAehgB,GAC3B,IAAKA,EACD,MAAM,IAAIuF,MAAM,wBACpB,MAAMuL,EAAO,GAIb,GAHoB,iBAAT9Q,IACPA,EAAOA,EAAKwB,MAAM,KAAKhD,KAAKiD,GAAMA,EAAEC,UAEpCwO,MAAMC,QAAQnQ,GACd8Q,EAAKmP,KAAOjgB,EAAK,GACjB8Q,EAAKzL,KAAOrF,EAAK,IAAM,MACvB8Q,EAAKrM,OAAS7K,EAAI2K,MAAMhD,KAAKvB,EAAK,IAAM,OAEvC,CAAA,IAAIA,EAAKqF,OAAQrF,EAAKyE,OAMvB,MAAM,IAAIc,MAAM,sCAAwCwS,KAAKC,UAAUhY,IALvE8Q,EAAKmP,KAAOjgB,EAAKigB,KACjBnP,EAAKzL,KAAOrF,EAAKqF,MAAQ,MACzByL,EAAKrM,OAAS7K,EAAI2K,MAAMhD,KAAKuP,EAAKrM,QAAU,GAKhD,OAAOyb,GAAWzG,UAAKrU,EAAW0L,GAE/B,SAASoP,GAAWpf,EAAQqM,EAAK2B,GACpC,IAAKhO,EAAO2D,OACR,OAAO,EAEX,MAAMmD,EAAQuF,EAAI3O,IAAI0P,QAAQf,EAAI1P,EAAG0P,EAAIzP,GACzC,IAAKkK,EACD,OAAO,EAIX,QADcA,EAAMG,MACT8X,OAAO,OAAQ/e,EAAOuE,KAAMvE,EAAO2D,QPrBlDgU,GAAe,OAAQsF,ICgBvBtF,GAAe,MAAO0F,IChBtB1F,GAAe,kBAAmB8F,ICgBlC9F,GAAe,OAAQkG,ICCvBlG,GAAe,QAASwG,OCZF,UAAWM,OACX,SAAUA,OACV,KAAMA,ICsB5BK,GAActU,QAAU,CACpByU,QAAS,kBAES,UAAWJ,OCPX,OAAQK,+JVuNvB,SAAoBhH,GACvB1Z,OAAOgZ,QAAQU,GAAShW,SAAQ,EAAEzE,EAAIuC,MAClCuK,GAAQ9M,EAAIuC,gBAGb,WACHxB,OAAOiS,OAAOgI,IAAkBvW,SAASqW,GAAOA,EAAEM,MAAO,ycWhQtD,MAAM9e,GACT2C,YAAYsD,GACR,IAAIqf,EAAIC,EAAIC,EAAIC,EAChB1iB,KAAK2F,OAAS,EACd3F,KAAK2iB,UAAY,IACjB3iB,KAAKob,QAAU,GACfpb,KAAK4iB,SAAW,GAChB5iB,KAAKM,MAAQ,EACbN,KAAKO,MAAQ,KACbP,KAAK6iB,WAAa,KAClB7iB,KAAK8B,KAAO,GACZ9B,KAAKW,GAAKuC,EAAOvC,IAAM,MACvBX,KAAK2iB,UAAwC,QAA3BJ,EAAKrf,EAAOyf,iBAA8B,IAAPJ,EAAgBA,EAAKviB,KAAK2iB,UAC/E3iB,KAAK4iB,SAAsC,QAA1BJ,EAAKtf,EAAO0f,gBAA6B,IAAPJ,EAAgBA,EAAKxiB,KAAK4iB,SAC7E5iB,KAAKM,MAAgC,QAAvBmiB,EAAKvf,EAAO5C,aAA0B,IAAPmiB,EAAgBA,EAAKziB,KAAKM,MACvEN,KAAKO,MAAQ2C,EAAO3C,OAAS,KAC7BP,KAAK6iB,WAAa3f,EAAO2f,YAAc,KACvC7iB,KAAKmB,OAASnF,EAAImF,OAAOwC,KAAKT,GAC9BlD,KAAKgD,KAAOE,EAAOF,MAAQ,OAC3BhD,KAAK0D,YAAcR,EAAOQ,aAAe1D,KAAKgD,KAC9ChD,KAAKyD,OAASP,EAAOO,QAAUzD,KAAKgD,KACpChD,KAAK8iB,QAAoC,QAAzBJ,EAAKxf,EAAO4f,eAA4B,IAAPJ,EAAgBA,EAAK,KACtE1iB,KAAKQ,MAAQ0C,EAAO1C,OAAS,CAAEC,OAAQ,EAAG0a,KAAM,EAAG4H,SAAU,GACzD7f,EAAOkY,SACP1Z,OAAOC,OAAO3B,KAAKob,QAASlY,EAAOkY,SAEnCpb,KAAKgjB,UAAU,UACfhjB,KAAKQ,MAAM2a,MAAQlX,EAAWgf,gBAE9B/f,EAAOpB,OACoB,iBAAhBoB,EAAOpB,KACdoB,EAAOpB,KACF8B,MAAM,QACNhD,KAAKiD,GAAMA,EAAEC,SACbsB,SAASvB,IACV7D,KAAK8B,KAAK0D,KAAK3B,MAInB7D,KAAK8B,KAAOoB,EAAOpB,KAAKiC,QAAQnD,KAAKiD,GAAMA,EAAEC,UAIzDlE,OAAOiC,GACH,OAAO7B,KAAK8B,KAAKC,SAASF,GAE9BjC,UAAUkC,GACN,OAAO9F,EAAI8X,gBAAgB9T,KAAK8B,KAAMA,GAE1ClC,WAAWkC,GACP,OAAOA,EAAKohB,OAAOrf,GAAM7D,KAAK8B,KAAKC,SAAS8B,KAEhDjE,cAAc3D,GACV,SAAU+D,KAAKQ,MAAMC,OAASxE,GAElC2D,YAAY3D,GACR,SAAU+D,KAAKQ,MAAM2a,KAAOlf,GAEhC2D,gBAAgB3D,GACZ,SAAU+D,KAAKQ,MAAMuiB,SAAW9mB,GAEpC2D,kBAAkB3D,GACd,OAAQ+D,KAAKQ,MAAMC,OAASxE,KAAUA,EAE1C2D,gBAAgB3D,GACZ,OAAQ+D,KAAKQ,MAAM2a,KAAOlf,KAAUA,EAExC2D,oBAAoB3D,GAChB,OAAQ+D,KAAKQ,MAAMuiB,SAAW9mB,KAAUA,EAE5C2D,eACI,SAAUI,KAAKQ,MAAMC,OAASK,EAAalE,iBAE/CgD,aACI,SAAUI,KAAKQ,MAAMC,OAASK,EAAanE,eAE/CiD,gBACI,OAAQI,KAAK+Q,cAAgB/Q,KAAKqE,YAAYJ,EAAWkf,mBAE7DvjB,gBACI,SAAUI,KAAKQ,MAAMC,OAASK,EAAarE,kBAE/CmD,UAAUoD,GACN,OAAOA,KAAQhD,KAAKob,QAExBxb,QAAQwjB,GACJ,IAAIhhB,EAAO,GAUX,GATmB,kBAARghB,GAGa,iBAARA,EAFZhhB,EAAK0gB,QAAUM,EAKVA,IACLhhB,EAAOghB,IAENhhB,EAAK0gB,UAAY1gB,EAAKihB,MACvB,OAAOrjB,KAAKgD,KAChB,IAAI8K,EAAS9N,KAAKgD,KAClB,GAAIZ,EAAKihB,MAAO,CACZ,IAAIA,EAAQjhB,EAAKihB,OACE,IAAfjhB,EAAKihB,QACLA,EAAQrjB,KAAKmB,OAAO+V,IAAM,SAET,iBAAVmM,IACPA,EAAQrnB,EAAIqnB,MAAMrf,KAAKqf,GAAOC,YAElCxV,EAAS,IAAIuV,KAASrjB,KAAKgD,QAE/B,GAAIZ,EAAK0gB,QAAS,CAIdhV,GAHsC,iBAAjB1L,EAAK0gB,QACpB1gB,EAAK0gB,QACL9iB,KAAK8iB,SAAW,KACH,IAAMhV,EAE7B,OAAOA,EAEXlO,eAAewC,GACX,OAAOpC,KAAK0D,aAAe1D,KAAKqC,QAAQD,GAE5CxC,UAAUwC,GACN,OAAOpC,KAAKyD,QAAUzD,KAAKqC,QAAQD,IAGpC,SAASuB,GAAKiP,GACjB,IAAI2P,EAAIC,EAAIC,EAAIC,EAAIa,EAAIC,EACxB,IAAIC,EAAO,CAAErI,QAAS,GAAI5a,MAAO,GAAIW,OAAQ,GAAIyhB,SAAU,IAC3D,GAAIhQ,EAAQ8Q,UACRD,EAAOE,GAAM/Q,EAAQ8Q,UAChBD,GACD,MAAM,IAAI9b,MAAM,6BAA+BiL,EAAQ8Q,SAE/D,IAAId,EAAWa,EAAKb,SACpB,GAAgC,iBAArBhQ,EAAQgQ,SAAuB,CACtC,IAAIgB,EAAOhR,EAAQgQ,SAAS5c,QAAQ,KAAM,IACtCL,EAAQie,EAAKC,OAAO,QACxB,GAAa,GAATle,EACAid,EAAWa,EAAKb,SAAW1G,OAAOE,SAASwH,QAE1C,IAAc,GAAVje,EACL,GAA+B,GAA3Bie,EAAKC,OAAO,YAAkB,CAC9B,MAAM1I,EAAOwI,GAAMC,GACnB,IAAKzI,EACD,MAAM,IAAIxT,MAAM,sCAAwCic,EAAO,KACnEhB,EAAWzH,EAAKyH,cAGhBA,EAAW1G,OAAOE,SAASwH,OAG9B,CACD,MAAMjjB,EAAKijB,EAAKlQ,UAAU,EAAG/N,GACvB8C,EAAQyT,OAAOE,SAASwH,EAAKlQ,UAAU/N,IACvCwV,EAAOwI,GAAMhjB,GACnB,IAAKwa,EACD,MAAM,IAAIxT,MAAM,sCAAwChH,EAAK,KACjEiiB,EAAWzH,EAAKyH,SAAWna,aAGLjB,IAArBoL,EAAQgQ,WACbA,EAAWhQ,EAAQgQ,UAEvB,MAAMxH,EAAU,GAChB1Z,OAAOC,OAAOyZ,EAASqI,EAAKrI,SACxBxI,EAAQwI,SACR1Z,OAAOgZ,QAAQ9H,EAAQwI,SAAShW,SAAQ,EAAEhF,EAAKwG,MAC3C,GAAc,OAAVA,EAIJ,GAAqB,iBAAVA,GAAuBA,EAAM7E,SAAS,KAIjD,IACIqZ,EAAQhb,GAAO0jB,GAAWld,GAE9B,MAAO6U,GACH,MAAM,IAAI9T,MAAM,mCAAmCvH,OAAS+Z,KAAKC,UAAUxT,QAAc6U,EAAE9B,cAP3FyB,EAAQhb,GAAOwG,cAJRwU,EAAQhb,MAe3B,MAAMI,EAAQ,CACVC,OAAQzE,EAAIC,KAAK+H,KAAKlD,EAAc2iB,EAAKjjB,MAAMC,OAAQmS,EAAQpS,OAC/D2a,KAAMnf,EAAIC,KAAK+H,KAAKC,EAAYwf,EAAKjjB,MAAM2a,KAAMvI,EAAQpS,OACzDuiB,SAAU/mB,EAAIC,KAAK+H,KAAK+f,EAAgBN,EAAKjjB,MAAMuiB,SAAUnQ,EAAQpS,QAEzE,IAAIF,EAAQmjB,EAAKnjB,OAAS,EACtBsS,EAAQtS,QAEJA,EADyB,iBAAlBsS,EAAQtS,MACP2J,EAAY2I,EAAQtS,OAGpBsS,EAAQtS,OAGxB,IAAIC,EAAQkjB,EAAKljB,MACbqS,EAAQrS,MACRA,EAAQvE,EAAIuE,MAAMoD,KAAKiP,EAAQrS,OAER,OAAlBqS,EAAQrS,QACbA,EAAQ,MAEZ,MAAM2C,EAAS,CACXvC,GAAIiS,EAAQjS,GACZH,MAAAA,EACAmiB,UAAwC,QAA5BJ,EAAK3P,EAAQ+P,iBAA8B,IAAPJ,EAAgBA,EAAKkB,EAAKd,UAC1EvH,QAAAA,EACAwH,SAAAA,EACAtiB,MAAOA,EACPC,MAAAA,EACAsiB,WAAYjQ,EAAQiQ,YAAc,KAClC7L,GAA0B,QAArBwL,EAAK5P,EAAQoE,UAAuB,IAAPwL,EAAgBA,EAAKiB,EAAKtiB,OAAO6V,GACnEE,GAA0B,QAArBuL,EAAK7P,EAAQsE,UAAuB,IAAPuL,EAAgBA,EAAKgB,EAAKtiB,OAAO+V,GACnEC,GAA0B,QAArBuL,EAAK9P,EAAQuE,UAAuB,IAAPuL,EAAgBA,EAAKe,EAAKtiB,OAAOgW,GACnE3B,QAAoC,QAA1B+N,EAAK3Q,EAAQ4C,eAA4B,IAAP+N,EAAgBA,EAAKE,EAAKtiB,OAAOqU,QAC7ExS,KAAM4P,EAAQ5P,MAAQygB,EAAKzgB,KAC3BU,YAAakP,EAAQlP,aAAe+f,EAAK/f,YACzCD,OAAQmP,EAAQnP,QAAUggB,EAAKhgB,OAC/Bqf,QAAoC,QAA1BU,EAAK5Q,EAAQkQ,eAA4B,IAAPU,EAAgBA,EAAKC,EAAKX,QACtEhhB,KAAM8Q,EAAQ9Q,MAAQ,MAG1B,OADa,IAAI7E,GAAKiG,GAGnB,MAAMygB,GAAQ,GACR/L,GAAM,GACZ,SAASpR,GAAI7F,GAChB,OAAIA,aAAc1D,GACP0D,EACO,iBAAPA,EACAgjB,GAAMhjB,IAAO,KACjBiX,GAAIjX,IAAO,KAEf,SAAS8M,GAAQ9M,KAAOqjB,GAC3B,IAAIpR,EAAUoR,EAAK,GACA,GAAfA,EAAKzf,SACLqO,EAAUoR,EAAK,GACfpR,EAAQ8Q,QAAUM,EAAK,IAE3BpR,EAAQjS,GAAKA,EACb,MAAMwa,EAAOxX,GAAKiP,GAIlB,OAHAuI,EAAKxV,MAAQiS,GAAIrT,OACjBqT,GAAIpS,KAAK2V,GACTwI,GAAMhjB,GAAMwa,EACLA,EAQJ,MAAM8I,GAAOxW,GAAQ,OAAQ,CAChCuJ,GAAI,IACJE,GAAI,QACJC,GAAI,QACJ3W,MAAO,gBACPwC,KAAM,oBACN8f,QAAS,KACTF,SAAU,ICtQDpiB,GAAQ,MAAEvD,EAAMc,SAAAA,8GDyPtB,SAAoB4lB,GACvBjiB,OAAOgZ,QAAQiJ,GAAOve,SAAQ,EAAEzE,EAAIuC,MAChCuK,GAAQ9M,EAAIuC,iBE5Pb,MAAMghB,GACTtkB,YAAYgB,EAAKoC,EAAO,SACpBhD,KAAKiI,SAAU,EACfjI,KAAKY,IAAMA,EACXZ,KAAKM,OAAS,EACdN,KAAKmkB,WAAa,GAClBnkB,KAAKgD,KAAOA,EAEhBpD,KAAK2M,IACL3M,SACAA,QAAQwkB,EAAIC,EAAIC,EAAO5f,GACnB,OAAO,EAEX9E,UAAUwkB,EAAIC,GACV,OAAO,EAEXzkB,SAASwkB,EAAIC,EAAIxS,GACb,OAAO,EAEXjS,WAAWwkB,EAAIC,EAAIxS,GACf,OAAO,EAEXjS,YAAYiS,GACR,OAAO,EAEXjS,QAAQwkB,EAAIC,EAAI7X,GACZ,OAAO,EAEX5M,UAAUwkB,EAAIC,EAAI7X,GACd,OAAO,EAEX5M,WAAW4M,GACP,OAAO,EAGX5M,KAAK2kB,GACD,OAAO,GCnCR,MAAMC,WAAkBN,GAC3BtkB,YAAYgB,EAAKoC,EAAO,QACpBuG,MAAM3I,EAAKoC,GAEfpD,QAAQC,EAAGC,EAAGqb,EAAM/Y,GAEhB,OADapC,KAAKY,IAAIqB,KAAKpC,EAAGC,GAClBshB,QAAQjG,EAAM/Y,GAE9BxC,UAAUC,EAAGC,GAET,OADaE,KAAKY,IAAIqB,KAAKpC,EAAGC,GAClB0f,WAAWxf,KAAKM,OAEhCV,KAAK2kB,GAgBD,OAAO,GC1BR,MAAME,WAAiBD,GAC1B5kB,YAAYgB,EAAKoC,EAAO,OACpBuG,MAAM3I,EAAKoC,GACXhD,KAAK0kB,OAAS1oB,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,OAAQ,GAExDpN,QACII,KAAK0kB,OAAOrF,KAAK,GAErBzf,QAAQC,EAAGC,EAAGqb,EAAM/Y,EAAO,IACvB,IAAKA,EAAKsiB,OACN,OAAO,EAEX,OADa1kB,KAAKY,IAAIqB,KAAKpC,EAAGC,GACrB6kB,UAAUxJ,EAAK7a,SAAW6a,GAC/Bnb,KAAK0kB,OAAO7kB,GAAGC,IAAMsC,EAAKsiB,QACnB,KAENnb,MAAM6X,QAAQvhB,EAAGC,EAAGqb,EAAM/Y,KAG/BpC,KAAK0kB,OAAO7kB,GAAGC,GAAKsC,EAAKsiB,OACzB1kB,KAAKiI,SAAU,GACR,GAEXrI,UAAUC,EAAGC,GAET,QADaE,KAAKY,IAAIqB,KAAKpC,EAAGC,GACrB0f,WAAWxf,KAAKM,SACrBN,KAAK0kB,OAAO7kB,GAAGC,GAAK,GACb,GAIfF,KAAK2B,GACDvB,KAAK0kB,OAAOjjB,KAAKF,EAAMmjB,QACvB1kB,KAAKiI,QAAU1G,EAAM0G,QAEzBrI,KAAK2kB,GACD,IAAKvkB,KAAKiI,QACN,OAAO,EACXjI,KAAKiI,SAAU,EACf,MAAM2c,EAAiB5kB,KAAK0kB,OAO5B,OANA1kB,KAAK0kB,OAAS1oB,EAAIoO,KAAK2C,MAAM/M,KAAKY,IAAImE,MAAO/E,KAAKY,IAAIoM,QAEtDhN,KAAK2iB,UAAUiC,GAEf5kB,KAAK6kB,OAAOD,GACZ5oB,EAAIoO,KAAKC,KAAKua,IACP,EAEXhlB,UAAU8kB,GACNA,EAAOzX,QAAO,CAACvG,EAAG7G,EAAGC,KACjB,IAAK4G,EACD,OAAO,EACX,MAAMyU,EAAOnb,KAAKY,IAAIqB,KAAKpC,EAAGC,GAAG6kB,UAAU3kB,KAAKM,OAChD,GAAI6a,GAAQA,EAAKwH,UAAW,CACxB,IAAImC,EAAIjf,KAAKS,IAAI,GAAMI,EAAIyU,EAAKwH,UAAa,KAC7Cjc,EAAIb,KAAKS,IAAI,EAAGI,EAAIoe,GAQxB,OANIpe,EACA1G,KAAKiI,SAAU,EAGfjI,KAAK+kB,UAAUllB,EAAGC,GAEf4G,KAGf9G,YAAY8kB,GACR,OAAO7e,KAAKC,MAA6B,GAAvBD,KAAKkB,IAAI2d,EAAQ,KAEvC9kB,iBAAiBC,EAAGC,EAAG8kB,GACnB,IAAII,EAAQ,EACR3d,EAAQ,EACR4d,EAAgB,EACpB,MAAMhjB,EAAOjC,KAAKY,IAAIqB,KAAKpC,EAAGC,GAC9B,IAAIolB,EAAejjB,EAAK0iB,UAAU3kB,KAAKM,OACnC6kB,EAAcD,EAClB,GAAIjjB,EAAKZ,cAAcP,EAAavE,cAKhC,OAJAyD,KAAK0kB,OAAO7kB,GAAGC,GAAK,OAChB8kB,EAAe/kB,GAAGC,IAClBE,KAAK+kB,UAAUllB,EAAGC,IAI1B,IAAK,IAAIwL,EAAIzF,KAAKS,IAAI,EAAGzG,EAAI,GAAIyL,EAAIzF,KAAKkB,IAAIlH,EAAI,EAAG+kB,EAAe7f,SAAUuG,EAC1E,IAAK,IAAIC,EAAI1F,KAAKS,IAAI,EAAGxG,EAAI,GAAIyL,EAAI1F,KAAKkB,IAAIjH,EAAI,EAAG8kB,EAAe5X,UAAWzB,EAAG,CAC9E,MAAM7E,EAAIke,EAAetZ,GAAGC,GACvBtJ,EAAKZ,cAAcP,EAAavE,kBAC/B8K,EACEX,EAAIue,IACJA,EAAgBve,EAChBye,EAAcnlB,KAAKY,IAAIqB,KAAKqJ,EAAGC,GAAGoZ,UAAU3kB,KAAKM,SAGzD0kB,GAASte,EAGjB,MAAMA,EAAIb,KAAKC,MAAe,GAARkf,EAAc3d,GAAS,GAC7CrH,KAAK0kB,OAAO7kB,GAAGC,GAAK4G,EAChBA,EAAI,GAAKye,IACJD,GAAgBA,IAAiBC,GAClCljB,EAAKmf,QAAQ+D,IAGjBze,EAAI,IACJzE,EAAKyT,aAAc,GAG3B9V,OAAOglB,GACH,IAAK,IAAI/kB,EAAI,EAAGA,EAAI+kB,EAAe7f,QAASlF,EACxC,IAAK,IAAIC,EAAI,EAAGA,EAAI8kB,EAAe5X,SAAUlN,EACzCE,KAAKolB,iBAAiBvlB,EAAGC,EAAG8kB,IC7G5C,MAAM9oB,GAAQmO,EACRob,GAAcvkB,EACdwkB,GAAYrhB,EACZshB,GAAgBxB,EAChByB,GAAY/U,EACX,MAAMgV,WAAkBjB,GAC3B5kB,YAAYgB,EAAKoC,EAAO,QACpBuG,MAAM3I,EAAKoC,GAEfpD,KAAK2kB,GAGD,IAAK,IAAI1kB,EAAI,EAAGA,EAAIG,KAAKY,IAAImE,QAASlF,EAClC,IAAK,IAAIC,EAAI,EAAGA,EAAIE,KAAKY,IAAIoM,SAAUlN,EAAG,CACzBE,KAAKY,IAAIqB,KAAKpC,EAAGC,GACzB0Q,cAAcgV,GAAUE,uBAIrC,IAAK,IAAI7lB,EAAI,EAAGA,EAAIG,KAAKY,IAAImE,QAASlF,EAClC,IAAK,IAAIC,EAAI,EAAGA,EAAIE,KAAKY,IAAIoM,SAAUlN,EAAG,CACtC,MAAMmC,EAAOjC,KAAKY,IAAIqB,KAAKpC,EAAGC,GAC9B,GAAImC,EAAKoC,YAAYihB,GAAU3nB,cACzBsE,EAAKzB,MAAMyB,KAAOujB,GAAUE,uBAAwB,CACtD1lB,KAAK2lB,aAAa9lB,EAAGC,GAAG,GACxB,IAAK,IAAIglB,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,MAAMnV,EAAM3T,EAAImP,GAAGoO,KAAKuL,GACxB9kB,KAAK2lB,aAAa9lB,EAAI8P,EAAI,GAAI7P,EAAI6P,EAAI,MAKtD,OAAO,EAEX/P,aAAaC,EAAGC,EAAG8lB,GAAe,GAC9B,IAAIC,EAAiB,EAAGC,EAA4B,EAAGC,EAAyB,EAC5EC,GAAc,EAAOC,GAAqB,EAC9C,MAAMhkB,EAAOjC,KAAKY,IAAIqB,KAAKpC,EAAGC,GAC9B,IAAKmC,EAAKoC,YAAYihB,GAAUrC,gBAC5B,OAAO,EAoBX,GAjBAhhB,EAAKikB,UAAU/K,IACPA,EAAK9W,YAAYihB,GAAUa,sBAC3BhL,EAAKyH,SAAWkD,IAChBA,EAA4B3K,EAAKyH,aAIzC3gB,EAAKikB,UAAU/K,IACX,GAAIA,EAAK3a,MAAM2a,KAAOmK,GAAUrC,iBAC3B9H,EAAK7a,QAAUxE,GAAM2jB,KAClBtE,EAAKyH,UAAYkD,GAA4B,CACjD,MAAMzK,EAAS+K,GAAYjL,EAAKC,QAAQiL,MACpChL,GAAUA,EAAOpM,OAAS4W,IAC1BA,EAAiBxK,EAAOpM,YAIhC2W,GACCC,GAAkB7lB,KAAKY,IAAImT,IAAI9E,OAAO4W,EAAgB,KAAS,CAEhEG,GAAc,EAEV/jB,EAAKqkB,gBAAgBf,GAAcgB,wBACnCvqB,EAAImP,GAAG2F,aAAajR,EAAGC,GAAG,CAAC0mB,EAAIC,KAC3B,MAAMvE,EAAIliB,KAAKY,IAAIqB,KAAKukB,EAAIC,IACxBvE,EAAE7gB,cAAcgkB,GAAY9oB,eAC5B2lB,EAAE7d,YAAYihB,GAAU3nB,YACxBukB,EAAEoE,gBAAgBf,GAAcgB,0BAC9BR,KAGNA,GAA0B,IAC1BE,GAAqB,IAG7B,IAAIS,EAAQ,OACRT,GAAsBhkB,EAAK+gB,UAAU,aACrC0D,EAAQ,WAWZzkB,EAAK0kB,UAAUD,EAAO,CAClBrK,OAAO,IAEXpa,EAAKyT,aAAc,EAEvB,OAAOsQ,8FC/FX3C,MAAM5V,QAAQ,iBAAkB,cAC7B,MAAMmZ,GAAa,CACtBjD,MAAO,CAACkD,IACRpa,KAAM,KACNzC,MAAO,KACPxJ,MAAO,CACHyB,KAAM,EACNxB,OAAQomB,GAAUrmB,MAAMC,OACxB0a,KAAM0L,GAAUrmB,MAAM2a,KACtB4H,SAAU8D,GAAUrmB,MAAMuiB,WAG3B,MAAM/kB,GACT4B,YAAYgB,EAAKf,EAAGC,EAAG+iB,GAcnB,GAbA7iB,KAAK8mB,WAAa,EAClB9mB,KAAK8gB,UAAY,EACjB9gB,KAAKH,GAAK,EACVG,KAAKF,GAAK,EAEVE,KAAK+mB,OAAS,KAEd/mB,KAAKQ,MAAQ,CAAEyB,KAAMwO,EAAWxS,cAChC+B,KAAK2jB,MAAQ,CAACqD,GAAW/C,MACzBjkB,KAAKY,IAAMA,EACXZ,KAAKH,EAAIA,EACTG,KAAKF,EAAIA,EACTE,KAAKinB,SAAWjrB,EAAImF,OAAO+lB,YACvBrE,EAAY,CACZ,MAAM1H,EAAOgM,GAAStE,GACtB7iB,KAAKohB,QAAQjG,GAEjBnb,KAAK+mB,OAASH,GAElBhnB,YAAYiD,GACRA,EAAKpB,KAAKzB,KAAKinB,UAEnBrnB,YAAY4gB,GACRxgB,KAAKinB,SAASxlB,KAAK+e,GAEvB4G,wBACI,OAAOpnB,KAAK0R,YAAYjB,EAAW4W,iBAEvCC,sBACI,OAAOtnB,KAAK0R,YAAYjB,EAAWnS,eAEvCsB,cACI,IAAI2iB,EAcJ,GAbAviB,KAAKunB,YAAY9W,EAAWnS,eAE5B0B,KAAK+mB,OAAS,CACVvmB,MAAO,CACHyB,KAAMjC,KAAKQ,MAAMyB,KACjBxB,OAAQT,KAAK2jB,MAAMpC,QAAO,CAACC,EAAKrG,IAASqG,IAAQrG,MAAAA,OAAmC,EAASA,EAAK3a,MAAMC,SAAW,IAAI,GACvH0a,KAAMnb,KAAK2jB,MAAMpC,QAAO,CAACC,EAAKrG,IAASqG,IAAQrG,MAAAA,OAAmC,EAASA,EAAK3a,MAAM2a,OAAS,IAAI,GACnH4H,SAAU/iB,KAAK2jB,MAAMpC,QAAO,CAACC,EAAKrG,IAASqG,IAAQrG,MAAAA,OAAmC,EAASA,EAAK3a,MAAMuiB,WAAa,IAAI,IAE/HY,MAAO3jB,KAAK2jB,MAAM5f,QAClB0I,MAA4B,QAApB8V,EAAKviB,KAAKyM,YAAyB,IAAP8V,OAAgB,EAASA,EAAGhN,UAAY,KAC5EvL,MAAO,MAEPhK,KAAKiZ,UAAW,CAChB,MAAMxM,EAAOzM,KAAKyM,KACdA,IACAzM,KAAK+mB,OAAOvmB,MAAMC,QAAUgM,EAAKjM,MAAMC,QAG/C,GAAIT,KAAKqQ,WAAY,CACjB,MAAMrG,EAAQhK,KAAKgK,MACfA,IACAhK,KAAK+mB,OAAOvmB,MAAMC,QAAUuJ,EAAMxJ,MAAMC,QAE5CT,KAAKwQ,cAAcC,EAAW4W,kBAGtCznB,cACII,KAAKwQ,cAAcC,EAAW4W,gBAAkB5W,EAAWnS,eAC3D0B,KAAK+mB,OAAS,KACd/mB,KAAK0V,aAAc,EAEvB9V,KAAK2B,GACDG,OAAOC,OAAO3B,KAAKQ,MAAOe,EAAMf,OAChCR,KAAK8mB,WAAavlB,EAAMulB,WACxB9mB,KAAK2jB,MAAMpf,OAAShD,EAAMoiB,MAAMpf,OAChC,IAAK,IAAI+G,EAAI,EAAGA,EAAItL,KAAK2jB,MAAMpf,SAAU+G,EACrCtL,KAAK2jB,MAAMrY,GAAK/J,EAAMoiB,MAAMrY,GAEhCtL,KAAK8gB,UAAYvf,EAAMuf,UAGvB9gB,KAAK+mB,OAASxlB,EAAMwlB,OACpB/mB,KAAKY,IAAMW,EAAMX,IACjBZ,KAAKH,EAAI0B,EAAM1B,EACfG,KAAKF,EAAIyB,EAAMzB,EACfyB,EAAMimB,YAAYxnB,KAAKinB,UAE3BrnB,YAAY3D,GACR,SAAU+D,KAAKQ,MAAMyB,KAAOhG,GAEhC2D,YAAY3D,GACR+D,KAAKQ,MAAMyB,MAAQhG,EAEvB2D,cAAc3D,GACV+D,KAAKQ,MAAMyB,OAAShG,EAExB2D,cAAc3D,EAAMwrB,GAAgB,GAChC,IAAIlF,EAAIC,EACR,QAAIxiB,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,GAAKA,EAAErD,MAAMC,OAASxE,OAE5CwrB,OAEDznB,KAAKiZ,aACoB,QAApBsJ,EAAKviB,KAAKyM,YAAyB,IAAP8V,OAAgB,EAASA,EAAGlhB,cAAcpF,SAG3E+D,KAAKqQ,cACqB,QAArBmS,EAAKxiB,KAAKgK,aAA0B,IAAPwY,OAAgB,EAASA,EAAGnhB,cAAcpF,MAKpF2D,kBAAkBY,EAAOinB,GAAgB,GACrC,OAAQznB,KAAK2nB,YAAYF,GAAiBjnB,IAAUA,EAExDZ,YAAY3D,GACR,OAAO+D,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,GAAKA,EAAErD,MAAM2a,KAAOlf,IAEtD2D,gBAAgBY,GACZ,OAAQR,KAAK4nB,YAAcpnB,IAAUA,EAEzCZ,gBAAgB3D,GACZ,OAAO+D,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,GAAKA,EAAErD,MAAMuiB,SAAW9mB,IAE1D2D,oBAAoBY,GAChB,OAAQR,KAAK6nB,gBAAkBrnB,IAAUA,EAE7CZ,WAAWiC,GACP,OAAO7B,KAAK2jB,MAAM+D,MAAMvM,GAASA,GAAQA,EAAK2M,OAAOjmB,KAEzDjC,eAAekC,GACX,OAAO9B,KAAK2jB,MAAM+D,MAAMvM,GACbA,GAAQA,EAAK4M,WAAWjmB,KAGvClC,cAAckC,GACV,OAAO9B,KAAK2jB,MAAM+D,MAAMvM,GACbA,GAAQA,EAAK6M,UAAUlmB,KAGtClC,YACI,OAAOI,KAAKQ,MAAMyB,KAEtBrC,YAAYqoB,GAAe,GACvB,IAAI1F,EAAIC,EACR,IAAIvmB,EAAO+D,KAAK2jB,MAAMpC,QAAO,CAACC,EAAK3d,IAAM2d,GAAO3d,EAAIA,EAAErD,MAAMC,OAAS,IAAI,GASzE,OARIwnB,IACIjoB,KAAKiZ,YACLhd,IAA8B,QAApBsmB,EAAKviB,KAAKyM,YAAyB,IAAP8V,OAAgB,EAASA,EAAG/hB,MAAMC,SAAW,GAEnFT,KAAKqQ,aACLpU,IAA+B,QAArBumB,EAAKxiB,KAAKgK,aAA0B,IAAPwY,OAAgB,EAASA,EAAGhiB,MAAMC,SAAW,IAGrFxE,EAEX2D,YACI,OAAOI,KAAK2jB,MAAMpC,QAAO,CAACC,EAAK3d,IAAM2d,GAAO3d,EAAIA,EAAErD,MAAM2a,KAAO,IAAI,GAEvEvb,gBACI,OAAOI,KAAK2jB,MAAMpC,QAAO,CAACC,EAAK3d,IAAM2d,GAAO3d,EAAIA,EAAErD,MAAMuiB,SAAW,IAAI,GAE3ErN,kBACI,SAAU1V,KAAKQ,MAAMyB,KAAOwO,EAAWxS,cAE3CyX,gBAAgBhP,GACRA,EACK1G,KAAK+mB,SACN/mB,KAAKQ,MAAMyB,MAAQwO,EAAWxS,aAC9B+B,KAAKQ,MAAMyB,OAASwO,EAAW4W,gBAC/BrnB,KAAKY,IAAI8U,aAAc,GAI3B1V,KAAKQ,MAAMyB,OAASwO,EAAWxS,aAGvCgK,cACI,SAAUjI,KAAKQ,MAAMyB,KAAOwO,EAAWyX,SAE3CtoB,cAAcU,GACV,MAAM6a,EAAOnb,KAAK2jB,MAAMrjB,GACxB,OAAO6a,EAAOA,EAAKyH,SAAWoE,GAAW/C,KAAKrB,SAElDhjB,kBACI,OAAOI,KAAK2jB,MAAMpC,QAAO,CAACC,EAAK3d,IAAMgC,KAAKS,IAAIkb,EAAK3d,EAAIA,EAAE+e,SAAW,IAAIoE,GAAW/C,KAAKrB,UAE5FhjB,UAAUU,GACN,OAAON,KAAK2jB,MAAMrjB,IAAU,KAEhCV,QAAQub,GACJ,OAAKA,GAECA,aAAgBgN,KAClBhN,EAAOgM,GAAShM,IAEbnb,KAAK2jB,MAAM5hB,SAASoZ,IAJhBnb,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,IAMtCjE,aAAaU,GACT,MAAMuD,EAAI7D,KAAK2jB,MAAMrjB,GACrB,QAASuD,GAAKA,IAAMmjB,GAAW/C,KAEnCrkB,sBACI,OAAOI,KAAK2jB,MAAMpC,QAAO,CAACC,EAAKrG,IACtBA,GAEDA,EAAKyH,UAAYpB,EAAIoB,SACdzH,EAFAqG,GAIZwF,GAAW/C,MAElB9I,WACI,OAAOnb,KAAKooB,sBAEhBxoB,SAASyoB,GACLroB,KAAK2jB,MAAMve,SAASvB,GAAMA,GAAKwkB,EAAGxkB,KAEtCjE,mBAAmB3D,GACf,OAAO+D,KAAK2jB,MAAM2E,MAAMzkB,GAAMA,GAAKA,EAAErD,MAAMC,OAASxE,KAAS,KAEjE2D,aAAa3D,GACT,OAAO+D,KAAK2jB,MAAM2E,MAAMzkB,GAAMA,GAAKA,EAAErD,MAAM2a,KAAOlf,KAAS,KAE/D2D,iBAAiB3D,GACb,OAAO+D,KAAK2jB,MAAM2E,MAAMzkB,GAAMA,GAAKA,EAAErD,MAAMuiB,SAAW9mB,KAAS,KAEnE2D,eACI,OAAOI,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,GAAKA,EAAE2H,iBAEzC5L,gBACI,OAAQI,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,GAAKA,EAAEgP,oBACjC7S,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,GAAKA,EAAEQ,YAAYJ,EAAWK,YAE9D1E,aACI,OAAOI,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,GAAKA,EAAEkN,eAEzCnR,gBACI,OAAOI,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,GAAKA,EAAE6a,kBAEzC9e,YAAYU,GACR,OAAON,KAAK2jB,MAAM+D,MAAM7jB,GAAMA,MACvBA,EAAErD,MAAM2a,KAAOoN,GAAWtrB,KAAKurB,wBAClC3kB,EAAEvD,OAASA,IAGnBV,SACI,OAAOI,KAAK2jB,MAAMT,OAAOrf,IAAOA,GAAKA,IAAMmjB,GAAW/C,OAE1DrkB,aACI,OAAQI,KAAK+Q,aAEjBnR,SACI,OAAOI,KAAKyoB,kBAAkB3nB,EAAahE,cAE/C8C,SACI,OAAOI,KAAKqE,YAAYJ,EAAWykB,WAEvC9oB,WACI,OAAOI,KAAKqE,YAAYJ,EAAWxG,cAEvCmC,UAEI,OAASI,KAAKqB,cAAcP,EAAa6nB,uBACpC3oB,KAAKqE,YAAYJ,EAAWkf,mBAErCvjB,aACI,OAAOI,KAAK0R,YAAYjB,EAAW7R,cAEvCgB,qBACI,OAAOI,KAAKqB,cAAcP,EAAa8nB,qBAO3ChpB,YACI,OAAOI,KAAKqE,YAAYJ,EAAW4kB,cAKvCjpB,QAAQub,EAAM/Y,EAAO,IACjB,KAAM+Y,aAAgBgN,KAClBhN,EAAOgM,GAAShM,KAEZ,OAAO,EAEf,MAAM3S,EAAUxI,KAAK2jB,MAAMxI,EAAK7a,QAAU0mB,GAAW/C,KACrD,GAAIzb,IAAY2S,EACZ,OAAO,EACX,IAAK/Y,EAAK4e,eAMFxY,EAAQoa,SAAWzH,EAAKyH,SACxB,OAAO,EAGf,GAAI5iB,KAAK8oB,YAAY3N,EAAK7a,OACtB,OAAO,EACX,GAAI8B,EAAK8e,gBAAkBlhB,KAAKiZ,UAC5B,OAAO,EACX,GAAI7W,EAAK6e,iBAAmBjhB,KAAKqQ,WAC7B,OAAO,EACX,GAAIjO,EAAK2mB,sBAAwB/oB,KAAKgpB,kBAAoB7N,EAAKyH,SAC3D,OAAO,EAEX,GAAIzH,EAAK7a,MAAQ2J,EAAY2V,QAAUzE,EAAK0H,WAAY,CACpD,MAAMoG,EAAgBjpB,KAAK2kB,UAAU1a,EAAY2V,QAC3CsJ,EAAa/B,GAAShM,EAAK0H,YACjC,GAAIoG,IAAkBC,IACblpB,KAAKohB,QAAQ8H,EAAY9mB,GAC1B,OAAO,EA8BnB,OA1BApC,KAAK2jB,MAAMxI,EAAK7a,OAAS6a,EACzBnb,KAAK0V,aAAc,EACfyF,EAAK9Z,cAAcP,EAAaxE,mBAChC0D,KAAKwf,WAAWvV,EAAY0V,SAE5Bvd,EAAKye,UACL7gB,KAAK8gB,UAAY1e,EAAKye,SAEtBrY,EAAQjI,QAAU4a,EAAK5a,QACvBP,KAAKY,IAAIL,MAAM4oB,kBAAmB,GAElC3gB,EAAQnH,cAAcP,EAAa1E,qBACnC+e,EAAK9Z,cAAcP,EAAa1E,oBAChC4D,KAAKY,IAAIwoB,WAAWC,EAAUC,2BAE9BnO,EAAK9W,YAAYJ,EAAWtG,YAC5BqC,KAAKunB,YAAY9W,EAAWiV,wBAUzB,EAEX9lB,WAAWub,GACPnb,KAAK2jB,MAAM,GAAKqD,GAAW/C,KAC3B,IAAK,IAAI3Y,EAAI,EAAGA,EAAItL,KAAK2jB,MAAMpf,SAAU+G,EACrCtL,KAAK2jB,MAAMrY,GAAK,KAEhB6P,GACAnb,KAAKohB,QAAQjG,GAEjBnb,KAAK0V,aAAc,EAEvB9V,MAAMub,GACFnb,KAAK2jB,MAAQ,CAACqD,GAAW/C,MACzBjkB,KAAKQ,MAAMyB,KAAO,EAClBjC,KAAK0V,aAAc,EACnB1V,KAAK8mB,WAAa,EAClB9mB,KAAK8gB,UAAY,EACb3F,GACAnb,KAAKohB,QAAQjG,GAEjBnb,KAAKinB,SAASsC,WAElB3pB,WAAWU,GACP,OAAa,GAATA,GACAN,KAAK2jB,MAAM,GAAKqD,GAAW/C,KAC3BjkB,KAAK0V,aAAc,GACZ,GAEoB,OAAtB1V,KAAK2jB,MAAMrjB,KAChBN,KAAK2jB,MAAMrjB,GAAS,KACpBN,KAAK0V,aAAc,GACZ,GAIf9V,qBAAqB4pB,EAAUC,EAAe,GAC1C,IAAK,IAAIne,EAAI,EAAGA,EAAItL,KAAK2jB,MAAMpf,SAAU+G,EAAG,CACxC,MAAM6P,EAAOnb,KAAK2jB,MAAMrY,GACnB6P,IAEAA,EAAK9W,YAAYmlB,KAElBC,IAAiBtO,EAAKmL,gBAAgBmD,IAE1CzpB,KAAKwf,WAAWlU,MAIxB1L,cAAcyoB,GACVroB,KAAK2jB,MAAMve,SAAS+V,IACZA,GAAQA,EAAK5a,OACb8nB,EAAGlN,EAAK5a,UAIpBX,eAAeoD,GACX,OAAOhD,KAAK2jB,MAAM2E,MAAMzkB,GAAMA,MAAAA,OAA6B,EAASA,EAAEmf,UAAUhgB,MAAU,KAE9FpD,UAAU8mB,EAAOhY,EAAM,IAEnB,IAAI4N,GAAe,EAEnB,IAAK,MAAMnB,KAAQnb,KAAK2jB,MAAO,CAC3B,IAAKxI,IAASA,EAAKC,QACf,SACJ,MAAMsO,EAAKvO,EAAKC,QAAQsL,GACxB,GAAIgD,EAAI,CACM1pB,KAAK2pB,UAAUD,EAAIhb,KAEzB4N,GAAe,IAI3B,OAAOA,EAEX1c,UAAUyb,EAAQ3M,GACQ,iBAAX2M,IACPA,EAASyG,GAAwBzG,IAErC,IAAIiB,GAAe,EAMnB,OALIjB,IAEAiB,EAAejB,EAAOO,QAAQ5b,KAAM0O,IAGjC4N,EAEX1c,UAAUoD,GACN,IAAK,IAAImY,KAAQnb,KAAK2jB,MAClB,GAAIxI,GAAQA,EAAK6H,UAAUhgB,GACvB,OAAO,EAEf,OAAO,EAGXpD,UACI,OAAOI,KAAK0R,YAAYjB,EAAWrS,UAEvCqO,WACI,OAAOzM,KAAKY,IAAI6Y,OAAOzZ,KAAKH,EAAGG,KAAKF,GAExCF,WAAW4M,GACP,OAAO,EAEX5M,cAAc4M,GACV,OAAO,EAEX5M,SAAS4M,GAIL,OAHAxM,KAAKunB,YAAY9W,EAAWrS,UAC5B4B,KAAK0V,aAAc,GAEZ,EAEX9V,YAAY6M,GACR,IAAImd,GAAW,EACXC,GAAc,EAYlB,OAXA7pB,KAAKY,IAAI8I,MAAMtE,SAAQ,CAAC4P,EAAKrP,KACrBqP,IAAQvI,EACRod,EAAalkB,EAERqP,EAAInV,IAAMG,KAAKH,GAAKmV,EAAIlV,IAAME,KAAKF,IACxC8pB,GAAW,MAGdA,GACD5pB,KAAKwQ,cAAcC,EAAWrS,YAE9ByrB,EAAa,KAEjB7pB,KAAK0V,aAAc,GAEZ,GAGX9V,WACI,OAAOI,KAAK0R,YAAYjB,EAAWzR,WAEvCY,YACI,OAAOI,KAAK0R,YAAYjB,EAAW1R,YAEvCiL,YACI,OAAOhK,KAAKY,IAAI0P,QAAQtQ,KAAKH,EAAGG,KAAKF,GAEzCF,YAAYiS,GACR,OAAO,EAEXjS,eAAeiS,GACX,OAAO,EAEXjS,UAAUoK,GAON,OANAhK,KAAKunB,YAAY9W,EAAWzR,WACxBgL,EAAMgB,YACNhL,KAAKunB,YAAY9W,EAAW1R,YAEhCiB,KAAK0V,aAAc,GAEZ,EAEX9V,aAAaoK,GACT,IAAIqG,GAAW,EACXwZ,GAAc,EAYlB,OAXA7pB,KAAKY,IAAI0Q,OAAOlM,SAAQ,CAAC4P,EAAKrP,KACtBqP,IAAQhL,EACR6f,EAAalkB,EAERqP,EAAInV,IAAMG,KAAKH,GAAKmV,EAAIlV,IAAME,KAAKF,IACxCuQ,GAAW,MAGdA,GACDrQ,KAAKwQ,cAAcC,EAAWzR,UAAYyR,EAAW1R,cAErD8qB,EAAa,KAEjB7pB,KAAK0V,aAAc,GAEZ,GAEX9V,QACI,SAAUI,KAAKQ,MAAMyB,KAAOwO,EAAWqZ,QAE3CC,SACI,OAAO/pB,KAAKY,IAAIopB,KAAKhqB,KAAKH,EAAGG,KAAKF,GAEtCF,OAAOqqB,GACHjqB,KAAKunB,YAAY9W,EAAWqZ,QAC5B9pB,KAAK0V,aAAc,EAEvB9V,UAAUqqB,GACDjqB,KAAK+pB,IACN/pB,KAAKwQ,cAAcC,EAAWqZ,QAElC9pB,KAAK0V,aAAc,EAEvB9V,iBACI,OAAOI,KAAKooB,sBAAsB1kB,YAEtC9D,YACI,OAAOI,KAAKooB,sBAAsB3kB,OAEtC7D,QAAQwC,EAAO,IACX,OAAOpC,KAAKooB,sBAAsB/lB,QAAQD,GAE9CxC,OACI,GAAII,KAAKqQ,WAAY,CACjB,MAAMrG,EAAQhK,KAAKY,IAAI0P,QAAQtQ,KAAKH,EAAGG,KAAKF,GAC5C,GAAIkK,GAASA,EAAM7I,OAAO6V,GACtB,OAAOhN,EAAM7I,OAAO6V,GAE5B,GAAIhX,KAAKiZ,UAAW,CAChB,MAAMxM,EAAOzM,KAAKY,IAAI6Y,OAAOzZ,KAAKH,EAAGG,KAAKF,GAC1C,GAAI2M,GAAQA,EAAKtL,OAAO6V,GACpB,OAAOvK,EAAKtL,OAAO6V,GAE3B,OAAIhX,KAAKqE,YAAYJ,EAAWK,UACrB,IAEJtE,KAAKooB,sBAAsBjnB,OAAO6V,IAAM,IAEnDpX,WAAW8C,EAAQC,GAEf,OADcD,EAAOoC,SAASnC,EAAO9C,EAAI,EAAG8C,EAAO7C,EAAG6C,EAAOoC,MAAQ,EAAG/E,KAAKqC,UAAW,kBAG5FzC,WACI,MAAO,UAAUI,KAAKH,KAAKG,KAAKF,KCpkBxC,MAAMoqB,GAAiBluB,EAAIqnB,MAAM5V,QAAQ,YAAa,CAAC,IAAK,IAAK,IAC1D,MAAM0c,GACTvqB,cACII,KAAK0P,OAAQ,EAEjB9P,SAASiD,EAAMjC,EAAKwB,EAAO,IACvB,MAAMM,EAASG,aAAgB7G,EAAI0G,OAAO0nB,OAASvnB,EAAOA,EAAKH,OACzD2nB,EAAUjoB,EAAKioB,SAAW,EAC1BC,EAAUloB,EAAKkoB,SAAW,EAChC1pB,EAAI2pB,aAAalB,EAAUmB,YAC3B,MAAM7lB,EAAQ,IAAI3I,EAAImF,OAAOyD,MAC7B,IAAK,IAAI/E,EAAI,EAAGA,EAAI6C,EAAOqC,QAASlF,EAChC,IAAK,IAAIC,EAAI,EAAGA,EAAI4C,EAAOsK,SAAUlN,EACjC,GAAIc,EAAI4W,MAAM3X,EAAIwqB,EAASvqB,EAAIwqB,GAAU,CACrC,MAAMroB,EAAOrB,EAAIqB,KAAKpC,EAAIwqB,EAASvqB,EAAIwqB,GACvCtqB,KAAKyqB,SAAS9lB,EAAO/D,EAAKqB,EAAMrB,EAAIqK,KACpCvI,EAAOK,WAAWlD,EAAGC,EAAG6E,IAKxC/E,SAASiD,EAAMjC,EAAKqB,EAAMgJ,GACtBpI,EAAK0mB,WAEL,MAAMmB,GAAgBzoB,EAAKyP,YAAYjB,EAAW4W,iBAC9CplB,EAAKyT,aAAegV,GACpB1qB,KAAK2qB,cAAc9nB,EAAMjC,EAAKqB,GAC9BA,EAAK2oB,YAAY/nB,GACjBZ,EAAKyT,aAAc,EACnBzT,EAAKslB,YAAY9W,EAAW4W,mBAG5BplB,EAAKulB,YAAY3kB,GACbZ,EAAKyP,YAAYjB,EAAWoa,eAC5BjqB,EAAIwoB,WAAWC,EAAUmB,aAGjCxqB,KAAK8qB,WAAWjoB,EAAMZ,EAAMgJ,GAC5B,IAAI8f,GAAW,EAmBf,GAjBIA,EADA9oB,EAAK8kB,UACS9kB,EAAK8kB,OAAOvmB,MAAMC,QAC3BK,EAAakqB,oBACVlqB,EAAa1E,oBAGV6F,EAAKZ,cAAcP,EAAakqB,oBACvClqB,EAAa1E,mBAAmB,GAEpC6F,EAAKyP,YAAYjB,EAAWwa,YAC5BpoB,EAAKqoB,SACLroB,EAAKsoB,IAAIjB,GAAgB,EAAG,IAC5Ba,GAAW,GAEN9oB,EAAKyP,YAAYjB,EAAW2a,kBACjCvoB,EAAKqoB,SACLH,GAAW,GAEX/qB,KAAK0P,OAAS9O,EAAIkL,OAAQ,CAC1B,MAAMuf,EAAIrvB,EAAI4J,MAA6C,EAAvChF,EAAIkL,OAAO4D,MAAMlJ,IAAIvE,EAAKpC,EAAGoC,EAAKnC,GAAQ,EAAG,IACjE,GAAIurB,EAAG,CACH,MAAM3jB,EAAI1L,EAAIqnB,MAAMiI,OAAOC,IAC3B1oB,EAAKsoB,IAAIzjB,EAAG,EAAG2jB,IAMvB,OAHIN,KACCloB,EAAKqU,GAAIrU,EAAKsU,IAAMnb,EAAIqnB,MAAM0H,SAASloB,EAAKqU,GAAIrU,EAAKsU,MAEnD,EAiCXvX,cAAciD,EAAMjC,EAAKqB,GACrB,IAAI0hB,EAAQ1hB,EAAK0hB,MACb3Z,EAAQ,KACRyC,EAAO,KACPxK,EAAK8kB,QACLpD,EAAQ1hB,EAAK8kB,OAAOpD,MACpBlX,EAAOxK,EAAK8kB,OAAOta,OAGnBzC,EAAQ/H,EAAKoO,WAAapO,EAAK+H,MAAQ,KACvCyC,EAAOxK,EAAKgX,UAAYhX,EAAKwK,KAAO,MAExC,MAAM+e,EAAS7H,EAAM1Z,EAAY2V,QAC3B6L,EAAU9H,EAAM1Z,EAAY0V,SAC5B+L,EAAS/H,EAAM1Z,EAAYyV,QAC3BiM,EAAMhI,EAAM1Z,EAAYwV,KAc9B,GAbA5c,EAAKE,WAAWyoB,EAAOrqB,QACnBsqB,GACA5oB,EAAKE,WAAW0oB,EAAQtqB,QAExBuqB,GACA7oB,EAAKE,WAAW2oB,EAAOvqB,QAEvBsL,GACAA,EAAKmf,SAAS/oB,GAEdmH,GACAA,EAAM4hB,SAAS/oB,GAEf8oB,EAAK,CACL,MAAMnW,EAAUxZ,EAAI+X,IAAI8X,SAASvS,OAAO,IAAM,GAC9CzW,EAAKE,WAAW4oB,EAAIxqB,OAAQqU,GAEhC,GAAIvT,EAAK6pB,QAAS,CACd,MAAM/B,EAAKnpB,EAAIopB,KAAK/nB,EAAKpC,EAAGoC,EAAKnC,GAC7BiqB,GACAlnB,EAAKE,WAAWgnB,EAAG5oB,QAEvB0B,EAAKkpB,QACL9pB,EAAKslB,YAAY9W,EAAWoa,cAC5BjqB,EAAIwoB,WAAWC,EAAUmB,aAGzBvoB,EAAKuO,cAAcC,EAAWoa,cAElChoB,EAAKmpB,MAAK,GAEdpsB,WAAWiD,EAAMZ,EAAMgJ,GACnB,MAAMghB,GAAahhB,GAAOA,EAAIU,mBAAmB1J,EAAKpC,EAAGoC,EAAKnC,GACxDosB,GAAcjhB,GAAOA,EAAIihB,WAAWjqB,EAAKpC,EAAGoC,EAAKnC,GACjDS,EAAQ0B,EAAKrB,IAAIL,MAAM4rB,SAASlqB,EAAKpC,EAAGoC,EAAKnC,GACnD+C,EAAKupB,SAAS7rB,GAGV0K,GAAOA,EAAIohB,SAASpqB,EAAKpC,EAAGoC,EAAKnC,GACjC+C,EAAKqoB,SAECe,IACFC,EACArpB,EAAKypB,MAAM,IAGXzpB,EAAK0mB,aC7Jd,MAAMrqB,GACTU,YAAYmF,EAAOiI,EAAQ5K,EAAO,IAI9BpC,KAAK+T,IAAM/X,EAAI+X,IAAI/E,OAEnBhP,KAAKsR,OAAS,GACdtR,KAAK0J,MAAQ,GACb1J,KAAK+pB,GAAK,GACV/pB,KAAK8L,OAAS,KACd9L,KAAKusB,YAAc,GACnBvsB,KAAKqgB,OAAS,IAAIrkB,EAAIqkB,OAAOmM,aAC7BxsB,KAAKQ,MAAQ,CAAEI,IAAK,GACpBZ,KAAKshB,OAAS,GACdthB,KAAKmkB,WAAa,CAAEsI,KAAM,EAAGC,aAAc,GACvCtqB,EAAKzB,KACLX,KAAKmkB,WAAWxjB,GAAKyB,EAAKzB,IAE9BX,KAAK2sB,OAASvqB,EAAKuqB,QAAU,IAAIxC,GACjCnqB,KAAK4sB,MAAQ5wB,EAAIoO,KAAKzG,KAAKoB,EAAOiI,GAAQ,CAACnN,EAAGC,IAAM,IAAI9B,GAAKgC,KAAMH,EAAGC,KAMlEsC,EAAKqqB,OACLzsB,KAAKmkB,WAAWsI,KAAOrqB,EAAKqqB,KAC5BzsB,KAAK+T,IAAM/X,EAAI+X,IAAIpQ,KAAKvB,EAAKqqB,OAEjCzsB,KAAKO,MAAQ,IAAIvE,EAAIuE,MAAMssB,YAAY7sB,KAAMoC,QAC5BoF,IAAbpF,EAAK6I,IACL7I,EAAK0qB,eAAgB,GAEH,IAAb1qB,EAAK6I,MACV7I,EAAKuS,SAAU,GAEnBvS,EAAK2qB,SAAW/sB,KAAKgtB,YAAYnR,KAAK7b,MACtCA,KAAKiL,IAAM,IAAIjP,EAAIiP,IAAIgiB,UAAUjtB,KAAMoC,GACvCpC,KAAKktB,aACD9qB,EAAK0J,QACL9L,KAAKmtB,UAAU/qB,EAAK0J,QAG5B2gB,WACI,OAAOzsB,KAAKmkB,WAAWsI,KAE3BA,SAAS/lB,GACL1G,KAAKmkB,WAAWsI,KAAO/lB,EACvB1G,KAAK+T,IAAM/X,EAAI+X,IAAIpQ,KAAK+C,GAE5B3B,YACI,OAAO/E,KAAK4sB,MAAM7nB,MAEtBiI,aACI,OAAOhN,KAAK4sB,MAAM5f,OAUtBpN,aACII,KAAKotB,SAASnjB,EAAY2V,OAAQ,IAAIyN,GAAgBrtB,KAAM,WAC5DA,KAAKotB,SAASnjB,EAAY0V,QAAS,IAAI2N,GAAgBttB,KAAM,YAC7DA,KAAKotB,SAASnjB,EAAYwV,IAAK,IAAI8N,GAAevtB,KAAM,QAE5DJ,SAASU,EAAOktB,GACS,iBAAVltB,IACPA,EAAQ2J,EAAY3J,IAExBktB,EAAMltB,MAAQA,EACdN,KAAKshB,OAAOhhB,GAASktB,EAEzB5tB,YAAYU,GAIR,GAHqB,iBAAVA,IACPA,EAAQ2J,EAAY3J,KAEnBA,EACD,MAAM,IAAIqH,MAAM,4CACb3H,KAAKshB,OAAOhhB,GAEvBV,SAASU,GAIL,MAHqB,iBAAVA,IACPA,EAAQ2J,EAAY3J,IAEjBN,KAAKshB,OAAOhhB,IAAU,KAEjCV,MAAMC,EAAGC,GACL,OAAOE,KAAK4sB,MAAMpV,MAAM3X,EAAGC,GAE/BF,aAAaC,EAAGC,GACZ,OAAY,GAALD,GAAe,GAALC,GAAUD,GAAKG,KAAK+E,MAAQ,GAAKjF,GAAKE,KAAKgN,OAAS,EAEzEpN,KAAKC,EAAGC,GACJ,OAAOE,KAAK4sB,MAAM/sB,GAAGC,GAEzBF,IAAIC,EAAGC,GACH,OAAOE,KAAK4sB,MAAMpmB,IAAI3G,EAAGC,GAE7BF,SAASyoB,GACLroB,KAAK4sB,MAAMxnB,SAAQ,CAACnD,EAAMpC,EAAGC,IAAMuoB,EAAGpmB,EAAMpC,EAAGC,EAAGE,QAGtDJ,QAAQC,EAAGC,GACP,OAAOE,KAAKiC,KAAKpC,EAAGC,GAAGmZ,UAE3BrZ,OAAOC,EAAGC,GACN,OAAOE,KAAK0J,MAAM4e,MAAMhd,GAAMA,EAAEmiB,KAAK5tB,EAAGC,MAAO,KAEnDF,SAASyoB,GACLroB,KAAK0J,MAAMtE,QAAQijB,GAEvBzoB,QAAQC,EAAGC,EAAG2M,EAAMihB,GAAc,GAC9B,IAAK1tB,KAAKwX,MAAM3X,EAAGC,GACf,OAAO,EACX,MAAMmC,EAAOjC,KAAKiC,KAAKpC,EAAGC,GAE1B,GAAImC,EAAK0rB,SAASlhB,GAAO,CACrB,MAAM9G,EAAQ3F,KAAK0J,MAAMwR,QAAQzO,GAWjC,OAVI9G,EAAQ,GACR3F,KAAK0J,MAAMlE,KAAKiH,GAEpBA,EAAKzL,SAAShB,KAAMH,EAAGC,GACnB4tB,GACA1tB,KAAK4tB,oBAAoBnhB,EAAMxK,GAE/B0D,EAAQ,GACR3F,KAAKqgB,OAAOC,KAAK,OAAQtgB,KAAMyM,GAAM,IAElC,EAEX,OAAO,EAEX7M,oBAAoB6M,EAAMxK,GAClBwK,EAAKrM,KACLqM,EAAKrM,IAAI4B,QAAQC,EAAKpC,EAAGoC,EAAKnC,IAC9BmC,EAAK+gB,UAAU,OACf/gB,EAAK0kB,UAAU,MAAO,CAClBvmB,IAAKqM,EACLA,KAAAA,IAGCxK,EAAK+gB,UAAU,aACpB/gB,EAAK0kB,UAAU,WAAY,CACvBvmB,IAAKqM,EACLA,KAAAA,IAIZ7M,YAAYC,EAAGC,EAAG2M,EAAMihB,GAAc,GAClC,MAAMne,EAAMvP,KAAK+T,IAAIgM,gBAAgBlgB,EAAGC,GAAG,CAACwL,EAAGC,KAC3C,IAAKvL,KAAKwX,MAAMlM,EAAGC,GACf,OAAO,EACX,MAAMtJ,EAAOjC,KAAKiC,KAAKqJ,EAAGC,GAC1B,OAAItJ,EAAKgX,aAELhX,EAAK8O,eAELtE,EAAKtK,WAAWF,OAIxB,SAAKsN,GAAOA,EAAI,GAAK,IAEdvP,KAAKia,QAAQ1K,EAAI,GAAIA,EAAI,GAAI9C,EAAMihB,GAE9C9tB,WAAW6M,EAAMihB,GAAc,GAC3B,MAAMzrB,EAAOjC,KAAKiC,KAAKwK,EAAK5M,EAAG4M,EAAK3M,GAEpC,QAAImC,EAAK4rB,YAAYphB,KACbihB,GACA1tB,KAAK8tB,uBAAuBrhB,EAAMxK,GAEtCjG,EAAI+xB,YAAY/tB,KAAK0J,MAAO+C,GAC5BA,EAAKvL,gBACLlB,KAAKqgB,OAAOC,KAAK,OAAQtgB,KAAMyM,GAAM,IAC9B,GAIf7M,uBAAuB6M,EAAMxK,GACrBwK,EAAKuhB,MAAM/rB,EAAKpC,EAAGoC,EAAKnC,IAAMmC,EAAK+gB,UAAU,UAC7C/gB,EAAK0kB,UAAU,SAAU,CACrBvmB,IAAKqM,EACLA,KAAAA,IAGCxK,EAAK+gB,UAAU,gBACpB/gB,EAAK0kB,UAAU,cAAe,CAC1BvmB,IAAKqM,EACLA,KAAAA,IAIZ7M,SAAS6M,EAAM5M,EAAGC,EAAG4tB,GAAc,GAC/B,GAAIjhB,EAAK7L,MAAQZ,KACb,MAAM,IAAI2H,MAAM,0BACpB,MAAMiR,EAAc5Y,KAAKiC,KAAKwK,EAAK5M,EAAG4M,EAAK3M,GACrC+Y,EAAU7Y,KAAKiC,KAAKpC,EAAGC,GAW7B,OARA8Y,EAAYiV,YAAYphB,GACpBoM,EAAQ8U,SAASlhB,KACbihB,IACA1tB,KAAK8tB,uBAAuBrhB,EAAMmM,GAClC5Y,KAAK4tB,oBAAoBnhB,EAAMoM,IAEnCpM,EAAKzL,SAAShB,KAAMH,EAAGC,KAEpB,EAsCXF,UAAUC,EAAGC,GACT,OAAOE,KAAKiC,KAAKpC,EAAGC,GAAGmuB,YAE3BruB,UAAUkM,GACN9L,KAAK8L,OAASA,EAElBlM,QAAQC,EAAGC,GACP,OAAOE,KAAKsR,OAAOgX,MAAM/W,GAAMA,EAAEkc,KAAK5tB,EAAGC,MAAO,KAEpDF,UAAUyoB,GACNroB,KAAKsR,OAAOlM,QAAQijB,GAExBzoB,SAASC,EAAGC,EAAGkK,EAAO0jB,GAAc,GAChC,IAAK1tB,KAAKwX,MAAM3X,EAAGC,GACf,OAAO,EACX,MAAMmC,EAAOjC,KAAKiC,KAAKpC,EAAGC,GAC1B,IAAKmC,EAAKiX,YAAYlP,GAClB,OAAO,EACX,GAAI/H,EAAKisB,UAAUlkB,GAAQ,CACvB,MAAMrE,EAAQ3F,KAAKsR,OAAO4J,QAAQlR,GAWlC,OAVIrE,EAAQ,GACR3F,KAAKsR,OAAO9L,KAAKwE,GAErBA,EAAMhJ,SAAShB,KAAMH,EAAGC,GACpB4tB,GACA1tB,KAAKmuB,qBAAqBnkB,EAAO/H,GAEjC0D,EAAQ,GACR3F,KAAKqgB,OAAOC,KAAK,QAAStgB,KAAMgK,GAAO,IAEpC,EAEX,OAAO,EAEXpK,qBAAqBoK,EAAO/H,GACpB+H,EAAMgkB,MAAM/rB,EAAKpC,EAAGoC,EAAKnC,IAAMmC,EAAK+gB,UAAU,OAC9C/gB,EAAK0kB,UAAU,MAAO,CAClBvmB,IAAK4J,EACLA,MAAAA,IAGCA,EAAMgB,YAAc/I,EAAK+gB,UAAU,cACxC/gB,EAAK0kB,UAAU,aAAc,CACzB7a,OAAQ9B,EACRA,MAAAA,IAGC/H,EAAK+gB,UAAU,cACpB/gB,EAAK0kB,UAAU,YAAa,CACxB3c,MAAAA,IAIZpK,aAAaC,EAAGC,EAAGkK,EAAO0jB,GAAc,GACpC,MAAMne,EAAMvP,KAAK+T,IAAIgM,gBAAgBlgB,EAAGC,GAAG,CAACwL,EAAGC,KAC3C,IAAKvL,KAAKwX,MAAMlM,EAAGC,GACf,OAAO,EACX,MAAMtJ,EAAOjC,KAAKiC,KAAKqJ,EAAGC,GAC1B,OAAItJ,EAAKoO,cAELpO,EAAK8O,eAEL/G,EAAM7H,WAAWF,OAIzB,SAAKsN,GAAOA,EAAI,GAAK,IAEdvP,KAAKigB,SAAS1Q,EAAI,GAAIA,EAAI,GAAIvF,EAAO0jB,GAEhD9tB,YAAYoK,EAAO0jB,GAAc,GAC7B,MAAMzrB,EAAOjC,KAAKiC,KAAK+H,EAAMnK,EAAGmK,EAAMlK,GACtC,QAAKmC,EAAK+W,eAAehP,OAErB/H,EAAKmsB,aAAapkB,KACd0jB,GACA1tB,KAAKquB,wBAAwBrkB,EAAO/H,GAExC+H,EAAM9I,gBACNlF,EAAI+xB,YAAY/tB,KAAKsR,OAAQtH,GAC7BhK,KAAKqgB,OAAOC,KAAK,QAAStgB,KAAMgK,GAAO,IAChC,IAIfpK,wBAAwBoK,EAAO/H,GACvB+H,EAAMgkB,MAAMhkB,EAAMnK,EAAGmK,EAAMlK,IAAMmC,EAAK+gB,UAAU,UAChD/gB,EAAK0kB,UAAU,SAAU,CACrBvmB,IAAK4J,EACLA,MAAAA,IAGCA,EAAMgB,YAAc/I,EAAK+gB,UAAU,iBACxC/gB,EAAK0kB,UAAU,gBAAiB,CAC5B3c,MAAAA,EACA8B,OAAQ9B,IAGP/H,EAAK+gB,UAAU,iBACpB/gB,EAAK0kB,UAAU,eAAgB,CAC3B3c,MAAAA,IAIZpK,UAAUoK,EAAOnK,EAAGC,EAAG4tB,GAAc,GACjC,GAAI1jB,EAAMpJ,MAAQZ,KACd,MAAM,IAAI2H,MAAM,0BACpB,MAAMiR,EAAc5Y,KAAKiC,KAAK+H,EAAMnK,EAAGmK,EAAMlK,GACvC+Y,EAAU7Y,KAAKiC,KAAKpC,EAAGC,GAW7B,OARA8Y,EAAYwV,aAAapkB,GACrB6O,EAAQqV,UAAUlkB,KAClBA,EAAMhJ,SAAShB,KAAMH,EAAGC,GACpB4tB,IACA1tB,KAAKquB,wBAAwBrkB,EAAO4O,GACpC5Y,KAAKmuB,qBAAqBnkB,EAAO6O,MAGlC,EAuCXjZ,KAAKC,EAAGC,GACJ,OAAOE,KAAK+pB,GAAGzB,MAAMhd,GAAMA,EAAEmiB,KAAK5tB,EAAGC,MAAO,KAEhDF,OAAOyoB,GACHroB,KAAK+pB,GAAG3kB,QAAQijB,GAEpBzoB,MAAMC,EAAGC,EAAGiqB,GACR,MAAM9nB,EAAOjC,KAAKwG,IAAI3G,EAAGC,GACzB,QAAKmC,IAEL8nB,EAAGlqB,EAAIA,EACPkqB,EAAGjqB,EAAIA,EACPmC,EAAKqsB,OAAOvE,GACZ/pB,KAAK+pB,GAAGvkB,KAAKukB,GACb/pB,KAAKqgB,OAAOC,KAAK,KAAMtgB,KAAM+pB,GAAI,IAC1B,GAEXnqB,OAAOmqB,EAAIlqB,EAAGC,GACV,MAAM0I,EAAUxI,KAAKwG,IAAIujB,EAAGlqB,EAAGkqB,EAAGjqB,GAC5ByuB,EAAUvuB,KAAKwG,IAAI3G,EAAGC,GAC5B,QAAKyuB,IAEL/lB,EAAQgmB,UAAUzE,GAClBA,EAAGlqB,EAAIA,EACPkqB,EAAGjqB,EAAIA,EACPyuB,EAAQD,OAAOvE,IACR,GAEXnqB,SAASmqB,GACL,MAAM9nB,EAAOjC,KAAKwG,IAAIujB,EAAGlqB,EAAGkqB,EAAGjqB,GAM/B,OALA9D,EAAI+xB,YAAY/tB,KAAK+pB,GAAIA,GACrB9nB,GACAA,EAAKusB,UAAUzE,GAEnB/pB,KAAKqgB,OAAOC,KAAK,KAAMtgB,KAAM+pB,GAAI,IAC1B,EAMXnqB,OAAOC,EAAGC,GACN,MAAMkK,EAAQhK,KAAKsQ,QAAQzQ,EAAGC,GAC9B,GAAIkK,GAASA,EAAMgkB,MAAMnuB,EAAGC,GACxB,OAAO,EACX,MAAM2M,EAAOzM,KAAKyZ,OAAO5Z,EAAGC,GAC5B,SAAI2M,IAAQA,EAAKuhB,MAAMnuB,EAAGC,IAI9BF,MAAMyoB,GACF,OAAOroB,KAAK4sB,MAAMvlB,OAAM,CAACpF,EAAMpC,EAAGC,IAAMuoB,EAAGpmB,EAAMpC,EAAGC,EAAGE,QAE3DJ,KAAK6uB,EAAKxiB,EAAMD,QAAQC,KAIpBjM,KAAK4sB,MAAM8B,KAAKD,GAHF,CAACxsB,GACJA,EAAKysB,QAEcziB,GAGlCrM,WAAW3D,GACP,SAAU+D,KAAKQ,MAAMI,IAAM3E,GAE/B2D,WAAW3D,GACP+D,KAAKQ,MAAMI,KAAO3E,EAEtB2D,aAAa3D,GACT+D,KAAKQ,MAAMI,MAAQ3E,EAEvByZ,kBACI,OAAO1V,KAAK2uB,WAAWtF,EAAUuF,kBAErClZ,gBAAgBhP,GACRA,EACA1G,KAAKopB,WAAWC,EAAUuF,kBAE1B5uB,KAAKuqB,aAAalB,EAAUuF,kBAEpChvB,YAAYC,EAAGC,EAAG7D,GACd,OAAO+D,KAAKiC,KAAKpC,EAAGC,GAAG4R,YAAYzV,GAEvC2D,YAAYC,EAAGC,EAAG7D,GACd+D,KAAKiC,KAAKpC,EAAGC,GAAGynB,YAAYtrB,GAEhC2D,cAAcC,EAAGC,EAAG7D,GAChB+D,KAAKiC,KAAKpC,EAAGC,GAAG0Q,cAAcvU,GAElC2D,cAAcC,EAAGC,EAAG7D,GAChB,OAAO+D,KAAKiC,KAAKpC,EAAGC,GAAGuB,cAAcpF,GAEzC2D,YAAYC,EAAGC,EAAG7D,GACd,OAAO+D,KAAKiC,KAAKpC,EAAGC,GAAGuE,YAAYpI,GAEvC2D,cAAcyN,EAAMwhB,GAAa,GAK7B,GAJA7uB,KAAK8uB,YACLzhB,EAAKjI,SAASmK,IACVvP,KAAKunB,YAAYhY,EAAI,GAAIA,EAAI,GAAIkB,EAAW2a,mBAE5CyD,GAAcxhB,EAAK,GAAI,CACvB,MAAMkC,EAAMlC,EAAK,GACjBrN,KAAKunB,YAAYhY,EAAI,GAAIA,EAAI,GAAIkB,EAAWwa,WAEhDjrB,KAAK0V,aAAc,EAEvB9V,YACII,KAAK4sB,MAAMxnB,SAASsC,GAAMA,EAAE8I,cAAcC,EAAWwa,UAAYxa,EAAW2a,kBAC5EprB,KAAK0V,aAAc,EAEvB9V,WAAWC,EAAGC,GACVE,KAAK+uB,cACL/uB,KAAKiC,KAAKpC,EAAGC,GAAGynB,YAAY9W,EAAWwa,WACvCjrB,KAAK0V,aAAc,EAEvB9V,cACII,KAAK4sB,MAAMxnB,SAASsC,GAAMA,EAAE8I,cAAcC,EAAWwa,aACrDjrB,KAAK0V,aAAc,EAEvB9V,QACII,KAAKO,MAAM4oB,kBAAmB,EAE9BnpB,KAAKshB,OAAOlc,SAAS4pB,GAAMA,EAAEzP,UAEjC3f,UAAUC,EAAGC,EAAGqb,GACCnb,KAAKiC,KAAKpC,EAAGC,GACrByf,MAAMpE,GAGfvb,KAAKub,EAAM8T,GAGP,IAAI3jB,EAAGC,EACP,IAHA4P,EAAOgM,GAAShM,GAChB8T,EAAW9H,GAAS8H,GAAY9T,GAE3B7P,EAAI,EAAGA,EAAItL,KAAK+E,QAASuG,EAC1B,IAAKC,EAAI,EAAGA,EAAIvL,KAAKgN,SAAUzB,EAAG,CACjBvL,KAAK4sB,MAAMthB,GAAGC,GACtBgU,MAAMvf,KAAKkvB,aAAa5jB,EAAGC,GAAK0jB,EAAW9T,IAI5Dvb,QAAQC,EAAGC,EAAGqb,GAGV,OAAOnb,KAAKiC,KAAKpC,EAAGC,GAAGif,QAAQ5D,GAInCvb,UAAUC,EAAGC,EAAGqb,GACZ,OAAOnb,KAAKohB,QAAQvhB,EAAGC,EAAGqb,EAAM,CAAE6F,eAAe,IAErDphB,QAAQC,EAAGC,EAAGqb,EAAM/Y,GAChB,KAAM+Y,aAAgBgN,IAAY,CAC9B,MAAMnlB,EAAOmY,EAEb,KADAA,EAAOgM,GAASnkB,IAEZ,MAAM,IAAI2E,MAAM,wBAA0B3E,IAErC,IAATZ,IACAA,EAAO,CAAE4e,eAAe,IAE5B,MAAM1gB,EAAQ6a,EAAK7a,OAAS,EACtBktB,EAAQxtB,KAAKshB,OAAOhhB,IAAUN,KAAKshB,OAAO,GAChD,OAAMkM,aAAiBH,IAEhBG,EAAMpM,QAAQvhB,EAAGC,EAAGqb,EAAM/Y,GAErCxC,WAAWC,EAAGC,EAAGqb,GACAnb,KAAKiC,KAAKpC,EAAGC,GACrBqvB,WAAWhU,GAEpBvb,KAAKwvB,GACD,IAAI9S,GAAe,EACnBtc,KAAKusB,YAAYnnB,SAASmM,IACtB+K,EAAe/K,EAAE8d,KAAKD,IAAO9S,KAEjCtc,KAAKusB,YAAcvsB,KAAKusB,YAAY3Y,QAAQrC,GAAMA,EAAE+d,cACpDhT,EAAetc,KAAKuvB,QAAQ,SAAWjT,EACvC,IAAK,IAAIkR,KAASxtB,KAAKshB,OACfkM,GAASA,EAAM6B,KAAKD,KACpB9S,GAAe,GAGvB,OAAOA,EAEX1c,KAAK4gB,GACD,GAAIxgB,KAAKwB,cAAgBgf,EAAIhf,YACzB,MAAM,IAAImG,MAAM,mCACpB,GAAI3H,KAAK+E,QAAUyb,EAAIzb,OAAS/E,KAAKgN,SAAWwT,EAAIxT,OAChD,MAAM,IAAIrF,MAAM,kCACpB3H,KAAK4sB,MAAMxnB,SAAQ,CAACsC,EAAG7H,EAAGC,KACtB4H,EAAEjG,KAAK+e,EAAIve,KAAKpC,EAAGC,OAEvBE,KAAKshB,OAAOlc,SAAQ,CAAC4pB,EAAG1uB,KACpB0uB,EAAEvtB,KAAK+e,EAAIc,OAAOhhB,OAEtBN,KAAKsR,OAASkP,EAAIlP,OAAOvN,QACzB/D,KAAK0J,MAAQ8W,EAAI9W,MAAM3F,QACvB/D,KAAKQ,MAAMI,IAAM4f,EAAIhgB,MAAMI,IAE3BZ,KAAKO,MAAMkB,KAAK+e,EAAIjgB,OACpBP,KAAK+T,IAAMyM,EAAIzM,IACf/T,KAAKmkB,WAAaziB,OAAOC,OAAO,GAAI6e,EAAI2D,YAE5CvkB,QAEI,MAAM2B,EAAQ,IAAIvB,KAAKwB,YAAYxB,KAAK+E,MAAO/E,KAAKgN,QAEpD,OADAzL,EAAME,KAAKzB,MACJuB,EAEX3B,KAAK8mB,EAAO7mB,EAAGC,EAAG4O,EAAM,IAEpB,OADa1O,KAAKiC,KAAKpC,EAAGC,GACd6mB,UAAUD,EAAOhY,GAEjC9O,QAAQ8mB,EAAOhY,EAAM,IAEjB,MAAM8gB,EAAWxzB,EAAIoO,KAAK2C,MAAM/M,KAAK+E,MAAO/E,KAAKgN,QAqDjD,OAnDAhN,KAAK4sB,MAAMxnB,SAAQ,CAACnD,EAAMpC,EAAGC,KACzBmC,EAAKuO,cAAcC,EAAWgf,sBAAwBhf,EAAWgO,iBACjExc,EAAKikB,UAAU/K,IACX,MAAMuO,EAAKvO,EAAKC,QAAQsL,GACxB,IAAKgD,EACD,OACJ,MAAMrO,EAAS+K,GAAYsD,GAC3B,IAAKrO,EACD,OACJ,IAAIqU,EAAgB,EAEhBrU,EAAOpM,OAAS,GAChBygB,EAAgB,EAChB1zB,EAAImP,GAAG2F,aAAajR,EAAGC,GAAG,CAACwL,EAAGC,KAC1B,MAAM2W,EAAIliB,KAAKiC,KAAKqJ,EAAGC,GAClB2W,EAAE7gB,cAAcP,EAAarE,mBAC9BylB,EAAEyC,UAAUxJ,EAAK7a,QACb2B,EAAK0iB,UAAUxJ,EAAK7a,QACvB4hB,EAAExQ,YAAYjB,EAAWiV,yBAE1BgK,IAAkB,EAAIrU,EAAOpM,WAElC,IAGHygB,EAAgBrU,EAAOpM,QAAU,KAEhChN,EAAKyP,YAAYjB,EAAWiV,wBAC7B1lB,KAAK+T,IAAI9E,OAAOygB,EAAe,OAC/BF,EAAS3vB,GAAGC,IAAM9D,EAAIC,KAAKC,GAAGif,EAAK7a,cAM/CoO,EAAI2N,OAAQ,EACZmT,EAASpqB,SAAQ,CAACuqB,EAAG9vB,EAAGC,KACpB,IAAK6vB,EACD,OACJ,MAAM1tB,EAAOjC,KAAKiC,KAAKpC,EAAGC,GAC1B,IAAImC,EAAKyP,YAAYjB,EAAWgf,uBAEhC,IAAK,IAAInvB,EAAQ,EAAGA,GAAS2J,EAAYwV,MAAOnf,EACxCqvB,EAAI3zB,EAAIC,KAAKC,GAAGoE,IAChB2B,EAAK0kB,UAAUD,EAAO,CAClBrK,OAAO,OAKvBrgB,EAAIoO,KAAKC,KAAKmlB,IArDK,EAwDvB5vB,gBAAgBkhB,EAAW8O,EAASC,EAASnhB,EAAM,IAC/C,IAAI4N,GAAe,EACnB5N,EAAIkhB,QAAUA,EACdlhB,EAAImhB,QAAUA,EACd,IAAK,IAAIhwB,EAAI,EAAGA,EAAIG,KAAK+E,QAASlF,EAC9B,IAAK,IAAIC,EAAI,EAAGA,EAAIE,KAAKgN,SAAUlN,EAAG,CAClC,MAAMmC,EAAOjC,KAAKiC,KAAKpC,EAAGC,GACtBmC,EAAK6e,YAAcA,IAEnB7e,EAAK+gB,UAAU,aACf1G,EACIra,EAAK0kB,UAAU,UAAWjY,IAAQ4N,IAIlD,OAAOA,EAGX1c,SAASiD,EAAMT,GACXpC,KAAK2sB,OAAOf,SAAS/oB,EAAM7C,KAAMoC,GAErCxC,gBAAgBC,EAAGC,EAAG+C,GAClB,MAAMZ,EAAOjC,KAAKiC,KAAKpC,EAAGC,GAC1B,OAAOE,KAAK2sB,OAAOlC,SAAS5nB,EAAM7C,KAAMiC,GAG5CrC,SAASC,EAAGC,GACR,OAAOE,KAAKiC,KAAKpC,EAAGC,GAAGuQ,WAE3BzQ,cAAcyoB,GACVroB,KAAK4sB,MAAMxnB,SAAQ,CAACnD,EAAMpC,EAAGC,KACzBmC,EAAK6tB,eAAevvB,GAAU8nB,EAAGxoB,EAAGC,EAAGS,QAI/CX,iBAAiBmwB,IAEjBnwB,aAAayoB,GAELroB,KAAK8L,QACLuc,EAAGroB,KAAK8L,OAAOjM,EAAGG,KAAK8L,OAAOhM,EAAGE,KAAK8L,OAAOnC,eAAgB3N,EAAIiP,IAAI+kB,SAASC,QAGtFrwB,kBACI,OAAOI,KAAKO,MAAM0H,QAEtBrI,gBAAgBC,EAAGC,GACf,OAAQE,KAAKO,MAAM2vB,OAAOrwB,EAAGC,GAEjCF,aAAaC,EAAGC,GACZ,OAAOE,KAAKiC,KAAKpC,EAAGC,GAAG0L,eAQ3B5L,YAAYC,EAAGC,GACEE,KAAKiC,KAAKpC,EAAGC,GACrBqwB,cAETvwB,YAAYC,EAAGC,GACEE,KAAKiC,KAAKpC,EAAGC,GACrBswB,cAETxwB,YAAYC,EAAGC,EAAGmsB,GACTA,EAIDjsB,KAAKqwB,YAAYxwB,EAAGC,GAHpBE,KAAKmwB,YAAYtwB,EAAGC,GAO5BF,aAAa2R,GACTvR,KAAKusB,YAAY/mB,KAAK+L,GAE1B3R,gBAAgB2R,GACZvV,EAAI+xB,YAAY/tB,KAAKusB,YAAahb,ICjvBnC,SAAS+e,GAAkB1vB,EAAK2vB,GACnC,MAAMC,EAAUx0B,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,QACxC5C,EAAOpO,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,QAC3C,IAAK,IAAI1B,EAAI,EAAGA,EAAI1K,EAAImE,MAAOuG,IAC3B,IAAK,IAAIC,EAAI,EAAGA,EAAI3K,EAAIoM,OAAQzB,IAAK,CACjC,MAAMtJ,EAAOrB,EAAIqB,KAAKqJ,EAAGC,IACpBtJ,EAAK4Q,kBAAmB5Q,EAAK8O,cAC7B9O,EAAKZ,cAAcgkB,EAAYuD,qBAMhC4H,EAAQllB,GAAGC,GAAK,EAJhBilB,EAAQllB,GAAGC,GAAK,EAQ5B,IAAIklB,EAEJ,IAAK,IAAInlB,EAAI,EAAGA,EAAIklB,EAAQzrB,MAAQ,EAAGuG,IACnC,IAAK,IAAIC,EAAI,EAAGA,EAAIilB,EAAQxjB,OAAS,EAAGzB,IAEpC,GADA3K,EAAIqB,KAAKqJ,EAAGC,GAAG/K,MAAMyB,OAASwO,EAAW9R,cACrC6xB,EAAQllB,GAAGC,MACT3K,EAAIqB,KAAKqJ,EAAGC,GAAG/K,MAAMyB,KAAOwO,EAAW/R,YAAa,CACtD+xB,EAAmB,EACnB,IAAK,IAAI9gB,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAM+gB,EAAOplB,EAAItP,EAAImP,GAAGwlB,YAAYhhB,EAAM,GAAK,GAAG,GAC5CihB,EAAOrlB,EAAIvP,EAAImP,GAAGwlB,YAAYhhB,EAAM,GAAK,GAAG,GAC5C+I,EAAOpN,EAAItP,EAAImP,GAAGwlB,WAAWhhB,GAAK,GAClCgJ,EAAOpN,EAAIvP,EAAImP,GAAGwlB,WAAWhhB,GAAK,GACxC,IAAK/O,EAAI4W,MAAMkB,EAAMC,IACjB6X,EAAQ9X,GAAMC,MACb/X,EAAI4W,MAAMkZ,EAAME,IACbJ,EAAQE,GAAME,OACZH,EAAmB,EAAG,EAClBD,EAAQllB,EAAI,GAAGC,IAAOilB,EAAQllB,EAAI,GAAGC,MACrCilB,EAAQllB,GAAGC,EAAI,IAAOilB,EAAQllB,GAAGC,EAAI,MACvC3K,EAAIqB,KAAKqJ,EAAGC,GAAG/K,MAAMyB,MACjBwO,EAAW9R,eAEnB,QAOxB,GAAI4xB,EAAc,CASd,IAAK,IAAIjlB,EAAI,EAAGA,EAAI1K,EAAImE,MAAOuG,IAC3B,IAAK,IAAIC,EAAI,EAAGA,EAAI3K,EAAIoM,OAAQzB,IAC5B3K,EAAIqB,KAAKqJ,EAAGC,GAAGub,WAAa,IAQpC,IAAK,IAAIxb,EAAI,EAAGA,EAAI1K,EAAImE,MAAOuG,IAC3B,IAAK,IAAIC,EAAI,EAAGA,EAAI3K,EAAIoM,OAAQzB,IAAK,CACjC,MAAMtJ,EAAOrB,EAAIqB,KAAKqJ,EAAGC,GACzB,GAAIilB,EAAQllB,GAAGC,IACXtJ,EAAKzB,MAAMyB,KAAOwO,EAAW9R,cAC7B,IAAK,IAAIgR,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAM+I,EAAOpN,EAAItP,EAAImP,GAAGoO,KAAK5J,GAAK,GAC5BgJ,EAAOpN,EAAIvP,EAAImP,GAAGoO,KAAK5J,GAAK,GAClC,GAAI/O,EAAI4W,MAAMkB,EAAMC,IAChB6X,EAAQ9X,GAAMC,MACZ/X,EAAIqB,KAAKyW,EAAMC,GAAMnY,MAAMyB,KACzBwO,EAAW9R,eAAgB,CAI/ByL,EAAKiV,KAAK,GACVmR,EAAQllB,GAAGC,GAAK,EAChB,IAAIslB,EAAYC,GAAelwB,EAAKwJ,EAAMomB,EAAS9X,EAAMC,GAIzD,GAHA6X,EAAQllB,GAAGC,GAAK,EAGZslB,GAAa,EAAG,CAEhB,IAAK,IAAIE,EAAK,EAAGA,EAAK3mB,EAAKrF,MAAOgsB,IAC9B,IAAK,IAAIC,EAAK,EAAGA,EAAK5mB,EAAK4C,OAAQgkB,IAC3B5mB,EAAK2mB,GAAIC,IACTH,EACIjwB,EAAIqB,KAAK8uB,EAAIC,GAAIlK,aACrBlmB,EAAIqB,KAAK8uB,EAAIC,GAAIlK,WACb+J,EACJjwB,EAAIqB,KAAK8uB,EAAIC,GAAIxwB,MAAMyB,OAClBwO,EAAW7R,cAKxBiyB,EAAY5uB,EAAK6kB,aACjB7kB,EAAK6kB,WAAa+J,EAClB5uB,EAAKzB,MAAMyB,MAAQwO,EAAW7R,kBAS9D5C,EAAIoO,KAAKC,KAAKmmB,GACdx0B,EAAIoO,KAAKC,KAAKD,GAIX,SAAS0mB,GAAelwB,EAAKqwB,EAAST,EAASU,EAAQC,GAC1D,SAASC,EAASvxB,EAAGC,GACjB,IAAIuH,EAAyB,GAAjBmpB,EAAQ3wB,GAAGC,GAAU,IAAO,EAIxC,OAHIc,EAAIqB,KAAKpC,EAAGC,GAAGU,MAAMyB,KAAOwO,EAAWtS,qBACvCkJ,EAAQ,KAELA,EAEX,IAAIA,EAAQ,EACZ,MAAMgqB,EAAO,CAAC,CAACH,EAAQC,IACjB9mB,EAAO,GACb,KAAOgnB,EAAK9sB,QAAQ,CAChB,MAAMkI,EAAO4kB,EAAKC,MAClBjnB,EAAK7E,KAAKiH,GACV,MAAM5M,EAAI4M,EAAK,GACT3M,EAAI2M,EAAK,GACf,IAAIwkB,EAAQpxB,GAAGC,GAAf,CAEAmxB,EAAQpxB,GAAGC,GAAK,EAChBuH,GAAS+pB,EAASvxB,EAAGC,GACrB,IAAK,IAAI6P,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,MAAM+I,EAAO7Y,EAAI7D,EAAImP,GAAGoO,KAAK5J,GAAK,GAC5BgJ,EAAO7Y,EAAI9D,EAAImP,GAAGoO,KAAK5J,GAAK,GAClC,GAAI/O,EAAI4W,MAAMkB,EAAMC,IAChB6X,EAAQ9X,GAAMC,KACbsY,EAAQvY,GAAMC,GAAO,CACtB,MAAMlM,EAAOpC,EAAKinB,OAAS,EAAE,GAAI,GACjC7kB,EAAK,GAAKiM,EACVjM,EAAK,GAAKkM,EACV0Y,EAAK7rB,KAAKiH,MAItB,OAAO5G,KAAKkB,IAAIM,EAAO,KAKpB,SAASkqB,GAAgB3wB,GAC5BA,EAAI6Q,SAAS+f,IACbC,GAAe7wB,GACf8wB,GAAe9wB,GAEZ,SAAS4wB,GAAevvB,EAAMmiB,EAAIC,EAAIlkB,IACpC8B,EAAK4Q,kBAAmB5Q,EAAK8O,cAC7B9O,EAAKZ,cAAcgkB,EAAYuD,qBAKhC3mB,EAAKzB,MAAMyB,MAAQwO,EAAW/R,WAJ9BuD,EAAKzB,MAAMyB,OAASwO,EAAW/R,WAQhC,SAAS+yB,GAAe7wB,GAC3B,IAAI+wB,EACAjZ,EAAMC,EAAMhJ,EAAKiiB,EACjBC,EAAYC,EAAiBC,EACjC,MAAMV,EAAOr1B,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,OAAQ,GACnD,IAAIglB,GAAW,EACf,KAAOA,GACHA,GAAW,EACXX,EAAKjsB,SAAQ,CAACsB,EAAG7G,EAAGC,KAChB,IAAK4G,EACD,OACJ,MAAMzE,EAAOrB,EAAIqB,KAAKpC,EAAGC,GAEzB,GADAuxB,EAAKxxB,GAAGC,GAAK,EACRmC,EAAKyP,YAAYjB,EAAW/R,YAAjC,CAIA,IAAKkzB,EAAO,EAAGA,EAAO,EAAGA,IAAQ,CAG7B,GAFAlZ,EAAO7Y,EAAI7D,EAAImP,GAAGwlB,WAAWiB,GAAM,GACnCjZ,EAAO7Y,EAAI9D,EAAImP,GAAGwlB,WAAWiB,GAAM,IAC9BhxB,EAAI4W,MAAMkB,EAAMC,GACjB,SAEJ,IADa/X,EAAIqB,KAAKyW,EAAMC,GAClBjH,YAAYjB,EAAW/R,YAC7B,MAGR,GAAY,GAARkzB,EAAJ,CAUA,IAFAC,EAAaC,EAAkBC,EAAsB,EACrDJ,GAAW,EACNhiB,EAAMiiB,EAAMjiB,EAAMiiB,EAAO,EAAGjiB,IAAO,CAGpC,GAFA+I,EAAO7Y,EAAI7D,EAAImP,GAAGwlB,WAAWhhB,EAAM,GAAG,GACtCgJ,EAAO7Y,EAAI9D,EAAImP,GAAGwlB,WAAWhhB,EAAM,GAAG,IACjC/O,EAAI4W,MAAMkB,EAAMC,GACjB,SAEJ,GADgB/X,EAAIqB,KAAKyW,EAAMC,GACnBjH,YAAYjB,EAAW/R,aAE/B,GADAqzB,KACKJ,IACDE,IACAF,GAAW,EACPE,EAAa,GACb,WAIHF,IACDI,EAAsBD,IACtBA,EAAkBC,GAEtBA,EAAsB,EACtBJ,GAAW,GAMnB,GAHIA,GAAYI,EAAsBD,IAClCA,EAAkBC,GAEJ,GAAdF,GAAmBC,GAAmB,EAMtC,IALA7vB,EAAKuO,cAAcC,EAAW/R,YAKzBiR,EAAM,EAAGA,EAAM,EAAGA,IACnB+I,EAAO7Y,EAAI7D,EAAImP,GAAGwlB,WAAWhhB,GAAK,GAClCgJ,EAAO7Y,EAAI9D,EAAImP,GAAGwlB,WAAWhhB,GAAK,GAC9B/O,EAAI4W,MAAMkB,EAAMC,IAChB/X,EAAIqB,KAAKyW,EAAMC,GAAMjH,YAAYjB,EAAW/R,cAC5C2yB,EAAK3Y,GAAMC,GAAQ,EACnBqZ,GAAW,QAO5B,SAASC,GAAkBrxB,EAAKwJ,GACnC,IAAK,IAAIvK,EAAI,EAAGA,EAAIe,EAAImE,QAASlF,EAC7B,IAAK,IAAIC,EAAI,EAAGA,EAAIc,EAAIoM,SAAUlN,EAAG,CAEjC,GADac,EAAIqB,KAAKpC,EAAGC,GAChBU,MAAMyB,KAAOwO,EAAW/R,WAC7B0L,EAAKvK,GAAGC,GAAK,OAEZ,GAAID,EAAI,GAAKC,EAAI,EAAG,CACrB,MAAMoyB,EAAKtxB,EAAIqB,KAAKpC,EAAGC,EAAI,GACrBqyB,EAAOvxB,EAAIqB,KAAKpC,EAAI,EAAGC,GACzBoyB,EAAG1xB,MAAMyB,KAAOwO,EAAW/R,YAC3ByzB,EAAK3xB,MAAMyB,KAAOwO,EAAW/R,aAC7B0L,EAAKvK,GAAGC,GAAK,KAM1B,SAAS4xB,GAAe9wB,GAE3B,MAAMwJ,EAAOpO,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,QAG3C,IAAIolB,EAFJH,GAAkBrxB,EAAKwJ,GAGvB,IAAK,IAAIkB,EAAI,EAAGA,EAAIlB,EAAKrF,MAAOuG,IAC5B,IAAK,IAAIC,EAAI,EAAGA,EAAInB,EAAK4C,OAAQzB,IAAK,CAElC,GADa3K,EAAIqB,KAAKqJ,EAAGC,GAChB/K,MAAMyB,KAAOwO,EAAW/R,WAAY,CACzC0zB,GAAsB,EACtB,IAAK,IAAIziB,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAC9B,IAAI+I,EAAOpN,EAAItP,EAAImP,GAAGwlB,WAAWhhB,GAAK,GAClCgJ,EAAOpN,EAAIvP,EAAImP,GAAGwlB,WAAWhhB,GAAK,GACtC,GAAI/O,EAAI4W,MAAMkB,EAAMC,KACfvO,EAAKsO,GAAMC,MACV/X,EAAIqB,KAAKyW,EAAMC,GAAMnY,MAAMyB,KACzBwO,EAAW/R,YAAa,CAC5B0zB,GAAsB,EACtB,OAGHA,IACDhoB,EAAKkB,GAAGC,GAAK,EACb3K,EAAIqB,KAAKqJ,EAAGC,GAAG/K,MAAMyB,OAASwO,EAAW/R,aAKzD1C,EAAIoO,KAAKC,KAAKD,GCtTX,MAAMioB,GACTzyB,YAAYgB,GACRZ,KAAKY,IAAM,IAAI1B,GAAI0B,EAAImE,MAAOnE,EAAIoM,QAClChN,KAAKsyB,QAAU,GCJhB,SAASC,GAAU3xB,EAAKf,EAAGC,GAC9B,OAAQ9D,EAAImP,GAAGqnB,SAAS3yB,EAAGC,GAAG,CAACwL,EAAGC,IACvB3K,EAAIqB,KAAKqJ,EAAGC,GAAGknB,eACrB,ECHF,SAAS9uB,GAAKgsB,EAAG+C,EAAGtwB,EAAO,GAAI6sB,GACd,iBAAT7sB,IACPA,EAAO,CAAE+Y,KAAM/Y,IAEf6sB,IACA7sB,EAAK6sB,SAAWA,IAEF,IAAd7sB,EAAK+Y,OACL/Y,EAAK+Y,KAAO,UAEM,IAAlB/Y,EAAK6sB,WACL7sB,EAAK6sB,SAAW,QAEpB,MAAMruB,EAAM,IAAI1B,GAAIywB,EAAG+C,EAAGtwB,GAoB1B,YAnBkBoF,IAAdpF,EAAK+Y,OACL/Y,EAAK+Y,KAAO,cAEM3T,IAAlBpF,EAAK6sB,WACL7sB,EAAK6sB,SAAW,QAEhB7sB,EAAK+Y,OACLva,EAAIye,KAAKjd,EAAK+Y,KAAM/Y,EAAK6sB,UACzBruB,EAAIL,MAAM0M,UAWPrM,4EH/BJ,SAAiBA,EAAK+xB,GAAoB,GAC7CpB,GAAgB3wB,GAChB0vB,GAAkB1vB,EAAK+xB,qKCGpB,MACH/yB,YAAYgB,GACRZ,KAAKsyB,QAAU,EACftyB,KAAK4yB,aAAe,GACpB5yB,KAAK6yB,aAAe,EAEpB7yB,KAAKqK,KAAO,GACZrK,KAAKY,IAAMA,EACXZ,KAAK8yB,YAAc92B,EAAIoO,KAAKzG,KAAK/C,EAAImE,MAAOnE,EAAIoM,QAChDhN,KAAK4yB,aAAehyB,EAAI0gB,OAAO1gB,KAAI,IAAM,IAE7ChB,YACMI,KAAKsyB,QACP,MAAMS,EAAO/yB,KAAKqK,KAAK9F,OACjBvE,KAAKqK,KAAKinB,MACV,IAAIe,GAASryB,KAAKY,KAuCxB,OAtCAmyB,EAAKnyB,IAAIJ,MAAMI,IAAMZ,KAAKY,IAAIJ,MAAMI,IACpCZ,KAAK8yB,YAAY7lB,QAAO,CAACvG,EAAG7G,EAAGC,KAC3B,MAAMkzB,EAAUhzB,KAAKY,IAAIqB,KAAKpC,EAAGC,GAIjC,GAHIkzB,EAAQ/qB,UACRvB,EAAI1G,KAAKsyB,SAET5rB,IAAMqsB,EAAKT,QAAS,CACHS,EAAKnyB,IAAIqB,KAAKpC,EAAGC,GACzB2B,KAAKuxB,GAElB,OAAOtsB,KAGP1G,KAAKY,IAAIL,MAAM0H,UACfjI,KAAK6yB,aAAe7yB,KAAKsyB,QACzBtyB,KAAKY,IAAIL,MAAM0H,SAAU,GAEzB8qB,EAAKT,UAAYtyB,KAAK6yB,cACtBE,EAAKnyB,IAAIL,MAAMkB,KAAKzB,KAAKY,IAAIL,OAUjCP,KAAKY,IAAI0gB,OAAOlc,SAAQ,CAACooB,EAAO7nB,KAC5B,MAAMstB,EAAYF,EAAKnyB,IAAI0gB,OAAO3b,GAC9B6nB,EAAMvlB,UACNjI,KAAK4yB,aAAajtB,GAAS3F,KAAKsyB,SAEhCtyB,KAAK4yB,aAAajtB,KAAWotB,EAAKT,SAClCW,EAAUxxB,KAAK+rB,MAGvBuF,EAAKT,QAAUtyB,KAAKsyB,QACbS,EAEXnzB,YAAYmzB,GACR/yB,KAAK8yB,YAAY7lB,QAAO,CAACvG,EAAG7G,EAAGC,KAC3B,GAAI4G,EAAIqsB,EAAKT,QACT,OAAO5rB,EACX,MAAMwsB,EAAWlzB,KAAKY,IAAIqB,KAAKpC,EAAGC,GAClC,GAAI4G,EAAIqsB,EAAKT,SAAWY,EAASjrB,QAAS,CACtC,MAAM+qB,EAAUD,EAAKnyB,IAAIqB,KAAKpC,EAAGC,GAEjC,OADAozB,EAASzxB,KAAKuxB,GACPD,EAAKT,QAEhB,OAAO5rB,MAGPqsB,EAAKT,QAAUtyB,KAAK6yB,cAAgB7yB,KAAKY,IAAIL,MAAM0H,WACnDjI,KAAKY,IAAIL,MAAMkB,KAAKsxB,EAAKnyB,IAAIL,OAC7BP,KAAK6yB,aAAeE,EAAKT,SAO7BtyB,KAAK4yB,aAAaxtB,SAAQ,CAACsB,EAAGf,KAC1B,GAAIe,EAAIqsB,EAAKT,QACT,OACJ,MAAMa,EAAYnzB,KAAKY,IAAI0gB,OAAO3b,GAClC,GAAIe,EAAIqsB,EAAKT,SAAWa,EAAUlrB,QAAS,CACvC,MAAMmrB,EAAWL,EAAKnyB,IAAI0gB,OAAO3b,GACjCwtB,EAAU1xB,KAAK2xB,GACfpzB,KAAK4yB,aAAajtB,GAASotB,EAAKT,YAGxCtyB,KAAKsyB,QAAUS,EAAKT,QAExB1yB,QAAQmzB,GACJ/yB,KAAKqK,KAAK7E,KAAKutB,+BEzDhB,SAAcM,EAAQC,EAAYlxB,EAAO,IAC5C,IAEIxB,EAFAoM,EAAS,EACTjI,EAAQ,EA2BZ,MAlCwB,iBASXsuB,IACTA,EAASA,EAAOzvB,MAAM,QAR9B,SAAuBgD,GACnB,OAAO0L,MAAMC,QAAQ3L,IAA8B,iBAAbA,EAAM,GASxC2sB,CAAcF,IAadrmB,EAASqmB,EAAOrmB,OAChBjI,EAAQsuB,EAAOtuB,MACfnE,EAAM+C,GAAKoB,EAAOiI,EAAQ5K,GAC1BixB,EAAOjuB,SAAQ,CAACsB,EAAG7G,EAAGC,KAClB,MAAMqb,EAAOmY,EAAW5sB,IAAM,QAC9B9F,EAAIwgB,QAAQvhB,EAAGC,EAAGqb,QAjBtBnO,EAASqmB,EAAO9uB,OAChBQ,EAAQsuB,EAAO9R,QAAO,CAACiS,EAAKlc,IAASzR,KAAKS,IAAIktB,EAAKlc,EAAK/S,SAAS,GACjE3D,EAAM+C,GAAKoB,EAAOiI,EAAQ5K,GAC1BixB,EAAOjuB,SAAQ,CAACkS,EAAMxX,KAClB,IAAK,IAAID,EAAI,EAAGA,EAAIkF,IAASlF,EAAG,CAC5B,MAAMmX,EAAKM,EAAKzX,IAAM,IAChBsb,EAAOmY,EAAWtc,IAAO,QAC/BpW,EAAIwgB,QAAQvhB,EAAGC,EAAGqb,QAa9Bva,EAAIL,MAAM0M,SACHrM,KCnEJ,MAAMlB,GAETE,YAAYsD,GACRlD,KAAK8B,KAAO,GACZ9B,KAAKyzB,QAAU,GAEfzzB,KAAKQ,MAAQ,CAAEkzB,MAAO,GAClBxwB,EAAOpB,OACoB,iBAAhBoB,EAAOpB,KACd9B,KAAK8B,KAAOoB,EAAOpB,KAAK8B,MAAM,QAAQhD,KAAKiD,GAAMA,EAAEC,SAGnD9D,KAAK8B,KAAOoB,EAAOpB,KAAKiC,SAGhC/D,KAAKyJ,OAASvG,EAAOuG,OACjBvG,EAAOuwB,SACP/xB,OAAOgZ,QAAQxX,EAAOuwB,SAASruB,SAAQ,EAAEzE,EAAIgG,MACzC3G,KAAKyzB,QAAQ9yB,GAAM3E,EAAI2K,MAAMhD,KAAKgD,MAG1C3G,KAAK2zB,UAAY33B,EAAI23B,UAAUhwB,KAAKT,EAAOywB,WAAa,KAExD3zB,KAAKQ,MAAMkzB,MAAQ13B,EAAIC,KAAK+H,KAAK4vB,EAAO1wB,EAAO1C,OAGnDZ,MAAMgB,EAAKf,GAAI,EAAIC,GAAI,EAAIsC,EAAO,IAC9B,IAAImgB,EACJngB,EAAKyxB,SAAWzxB,EAAKyxB,UAAY73B,EAAI83B,KACrC1xB,EAAK2R,IAAM3R,EAAK2R,KAAOnT,EAAImT,IAC3B3R,EAAKye,QAAkC,QAAvB0B,EAAKngB,EAAKye,eAA4B,IAAP0B,EAAgBA,EAAK,EACpE,MAAM9Y,EAASzJ,KAAK+zB,aAAanzB,EAAKf,EAAGC,EAAGsC,GAC5C,OAAKqH,GAELzJ,KAAKg0B,cAAcvqB,EAAQ7I,EAAKwB,GACzBqH,GAFI,KAIf7J,aAAagB,EAAKf,EAAGC,EAAGsC,GACpB,MAAM6xB,EAAaC,GAAUl0B,KAAKyJ,QAClC,IAAKwqB,EACD,MAAM,IAAItsB,MAAM,gCAAkC3H,KAAKyJ,QAE3D,GAAI5J,GAAK,GAAKC,GAAK,GACXm0B,EAAW9xB,WAAWvB,EAAIqB,KAAKpC,EAAGC,IAClC,OAAO,KAEf,MAAM2J,EAAS0qB,EAAWF,EAAY,CAAE5zB,YAAa+B,EAAKye,UAC1D,IAAKpX,EACD,MAAM,IAAI9B,MAAM,iCAAmC3H,KAAKyJ,QAC5D,OAAI5J,EAAI,GAAKC,EAAI,MACZD,EAAGC,GAAKE,KAAKo0B,eAAe3qB,EAAQ7I,EAAKwB,IAAS,EAAE,GAAI,GACrDvC,EAAI,GAAKC,EAAI,GACN,KAIVE,KAAKq0B,WAAW5qB,EAAQ7I,EAAKf,EAAGC,EAAGsC,GAGjCqH,EAFI,KAIf7J,WAAW6J,EAAQ7I,EAAKf,EAAGC,EAAG4E,GAC1B,OAAO9D,EAAIqf,SAASpgB,EAAGC,EAAG2J,GAE9B7J,WAAW00B,EAAQ1zB,EAAKf,EAAGC,EAAG2J,EAAQ/E,GAElC,OADA4vB,EAAO7qB,OAASA,EACT7I,EAAIqf,SAASpgB,EAAGC,EAAGw0B,GAE9B10B,cAAc6J,EAAQ7I,EAAKwB,GACvB,MAAMsY,EAAUhZ,OAAOgZ,QAAQ1a,KAAKyzB,SACpC,GAAsB,GAAlB/Y,EAAQnW,OACR,OAAO,EAQX,OANAmW,EAAQtV,SAAQ,EAAEmvB,EAAQC,MACtB,MAAMntB,EAAQmtB,EAAW5tB,MAAMxE,EAAK2R,KACpC,IAAK,IAAIzI,EAAI,EAAGA,EAAIjE,IAASiE,EACzBtL,KAAKy0B,aAAaF,EAAQ3zB,EAAK6I,EAAQrH,MAJnC,EAShBxC,aAAa20B,EAAQ3zB,EAAK6I,EAAQrH,GAC9B,MAAMlC,EAAOg0B,GAAUK,GACvB,IAAKr0B,EACD,MAAM,IAAIyH,MAAM,gCAAkC4sB,GAEtD,MAAMD,EAASH,EAAWj0B,EAAM,CAAEG,YAAa+B,EAAKye,UACpD,IAAKyT,EACD,MAAM,IAAI3sB,MAAM,iCAAmC4sB,GACvD,MAAO10B,EAAGC,GAAKE,KAAK00B,eAAeJ,EAAQ1zB,EAAK6I,EAAQrH,IAAS,EAC5D,GAAI,GAET,OAAIvC,EAAI,GAAKC,EAAI,EACN,KAGNE,KAAK20B,WAAWL,EAAQ1zB,EAAKf,EAAGC,EAAG2J,EAAQrH,GAGzCkyB,EAFI,KAIf10B,eAAe6J,EAAQ7I,EAAKwB,GAcxB,OAbUA,EAAK2R,IAAI9D,YAAYrP,EAAImE,MAAOnE,EAAIoM,QAAQ,CAACnN,EAAGC,KACtD,MAAMmC,EAAOrB,EAAIqB,KAAKpC,EAAGC,GACzB,OAAImC,EAAKoO,eAEJjO,EAAKyxB,SAASh0B,EAAGC,MAElB2J,EAAOtH,WAAWF,KAElB2yB,GAAch0B,EAAKf,EAAGC,QAOlCF,eAAeoK,EAAOpJ,EAAK6I,EAAQrH,GAe/B,OAdUA,EAAK2R,IAAIgM,gBAAgBtW,EAAO5J,EAAG4J,EAAO3J,GAAG,CAACD,EAAGC,KACvD,IAAKc,EAAI4W,MAAM3X,EAAGC,GACd,OAAO,EACX,MAAMmC,EAAOrB,EAAIqB,KAAKpC,EAAGC,GACzB,OAAImC,EAAKoO,cAGLrG,EAAM7H,WAAWF,KAEjB2yB,GAAch0B,EAAKf,EAAGC,QChI/B,MAAM+0B,GAAS,GACf,SAASpnB,GAAQ9M,EAAI+yB,GAQxB,MAPqB,iBAAVA,IACPA,EAAQ,CAAEjqB,OAAQiqB,IAEhBA,aAAiBh0B,KACnBg0B,EAAQ,IAAIh0B,GAAMg0B,IAEtBmB,GAAOl0B,GAAM+yB,EACNA,gFAEJ,SAAoBmB,GACvBnzB,OAAOgZ,QAAQma,GAAQzvB,SAAQ,EAAEzE,EAAIuC,MACjCuK,GAAQ9M,EAAIuC,YAGb,SAAcvC,GACjB,OAAIA,aAAcjB,GACPiB,EAEO,iBAAPA,EACAk0B,GAAOl0B,GAEX,IAAIjB,GAAMiB,WAEd,SAAgByB,EAAO,IAC1B,MAAMmR,EAAQ,CACVzR,KAAM,GACN0R,WAAY,GACZhT,MAAO,EACPs0B,YAAa,EACbx0B,MAAO,GAES,iBAAT8B,IACPA,EAAO,CACHN,KAAMM,IAGd,MAAM2R,EAAM3R,EAAK2R,KAAO/X,EAAI+X,IAAI/E,OA6ChC,GA5CyB,iBAAd5M,EAAKN,KACZM,EAAKN,KACA8B,MAAM,SACNhD,KAAKiD,GAAMA,EAAEC,SACbsB,SAASvB,IACNA,EAAE4P,WAAW,KACbF,EAAMC,WAAWhO,KAAK3B,EAAE6P,UAAU,GAAG5P,QAGrCyP,EAAMzR,KAAK0D,KAAK3B,MAInByO,MAAMC,QAAQnQ,EAAKN,QACxByR,EAAMzR,KAAOM,EAAKN,KAAKiC,SAEI,iBAApB3B,EAAKoR,WACZD,EAAMC,WAAapR,EAAKoR,WAAW5P,MAAM,SAAShD,KAAKiD,GAAMA,EAAEC,SAE1DwO,MAAMC,QAAQnQ,EAAKoR,cACxBD,EAAMC,WAAapR,EAAKoR,WAAWzP,SAEnC3B,EAAK5B,OACqB,iBAAf4B,EAAK5B,OACZ4B,EAAK5B,MACAoD,MAAM,QACNhD,KAAKiD,GAAMA,EAAEC,SACbsB,SAASnJ,IACV,GAAIA,EAAKwX,WAAW,KAAM,CACtB,MAAMrT,EAAMnE,EAAKyX,UAAU,GAC3BH,EAAMuhB,aAAelB,EAAMxzB,QAG3BmT,EAAM/S,OAASozB,EAAM33B,MAKjCmG,EAAK0yB,cACLvhB,EAAMuhB,YAAc94B,EAAIC,KAAK+H,KAAK4vB,EAAOxxB,EAAK0yB,cAE9C1yB,EAAK9B,QACLiT,EAAMjT,MAAQ8B,EAAK9B,OAEnBiT,EAAMjT,OAAS8B,EAAK2yB,UAAW,CAC/B,KAAOhhB,EAAI9E,OAAO7M,EAAK2yB,YACnBxhB,EAAMjT,OAAS,EAEnBiT,EAAMuhB,aAAelB,EAAMoB,gBAE/B,MAAMhzB,EAAUN,OAAOiS,OAAOkhB,IAAQjhB,QAAQC,KACtCN,EAAMzR,KAAKyC,SAAWvI,EAAI8X,gBAAgBP,EAAMzR,KAAM+R,EAAE/R,WAExDyR,EAAMC,aAAcxX,EAAI8X,gBAAgBP,EAAMC,WAAYK,EAAE/R,WAE5DyR,EAAM/S,SAAWqT,EAAErT,MAAMkzB,MAAQngB,EAAM/S,WAGvC+S,EAAMuhB,aAAejhB,EAAErT,MAAMkzB,MAAQngB,EAAMuhB,iBAKnD,GAAIvhB,EAAMjT,MACN,OAAOyT,EAAItH,KAAKzK,IAAY,KAEhC,MAAM1B,EAAQiT,EAAMjT,MACd20B,EAAUjzB,EAAQpB,KAAK8xB,GAAMA,EAAEiB,UAAUrzB,KACzCqF,EAAQoO,EAAImhB,SAASD,GAC3B,OAAItvB,EAAQ,EACD,KACJ3D,EAAQ2D,MCjHZ,MAAM+E,GAAU,GAChB,SAASyqB,GAAenyB,EAAMmG,GACjCuB,GAAQ1H,GAAQmG,EAEb,SAASisB,GAAWpyB,GACvB,OAAO0H,GAAQ1H,GCDZ+K,eAAe8B,GAAQ7F,EAAOyR,GACjC,MAAM9L,EAAM8L,EAAE9L,IACd,OAAK3F,EAAMpJ,KAAQ+O,EAEZ0lB,GAAsBr1B,KAAMgK,EAAOyR,IAD9B,ECLT1N,eAAeyL,GAAOxP,EAAOsrB,GAChC,IAAKtrB,EAAMpJ,IACP,OAAQ,EACZ,MAAM20B,EAAevrB,EAAMX,UAAU,UACrC,IAAKksB,EAED,OADAv5B,EAAI2d,QAAQC,MAAM5P,EAAMnK,EAAGmK,EAAMlK,EAAG,4BAC7BkK,EAAMqC,UAEZ,CAED,MAAMyB,QAAeynB,EAAav1B,KAAMgK,GACxC,GAAI8D,EACA,OAAOA,EAGf,MAAM8C,EAAa5G,EAAMX,UAAU,cACnC,IAAKuH,EACD,MAAM,IAAIjJ,MAAM,6BACpB,OAAOiJ,EAAW5Q,KAAMgK,GDV5BmrB,GAAe,UAAWtlB,ICY1BslB,GAAe,SAAU3b,sJCpBJ,uDCgDd,MAAMgc,GACT51B,YAAY61B,GACRz1B,KAAK01B,MAAQ,GACb11B,KAAKmG,KAAO,GACZnG,KAAK21B,OAAS,GACd31B,KAAK41B,SAAW,GAChB51B,KAAKqG,OAAS,GACdrG,KAAKiI,QAAU,KACfjI,KAAKkE,KAAKuxB,GAEd71B,KAAK61B,GACD,IAAK,IAAI5hB,KAAKgiB,GAAY,CACtB,MAAMnvB,EAA0B,iBAAf+uB,EAA0BA,EAAaI,GAAWhiB,GACnE7T,KAAKyG,IAAIoN,EAAGnN,GAEhB,GAA0B,iBAAf+uB,EACP,IAAK,IAAI5hB,KAAK4hB,EACVz1B,KAAKyG,IAAIoN,EAAG4hB,EAAW5hB,IAInCjU,QAAQuJ,GACJzH,OAAOo0B,KAAKD,IAAYzwB,SAASyO,GAAM1K,EAAGnJ,KAAKwG,IAAIqN,MAKvDjU,IAAIoD,GACA,OAAOhD,KAAKqG,OAAOrD,IAAS,EAEhCpD,IAAIoD,EAAM4D,EAAQ,GAKd,OAJA5G,KAAKqG,OAAOrD,GAAQ4D,EACpB5G,KAAK01B,MAAM1yB,GAAQ4D,EACnB5G,KAAKmG,KAAKnD,GAAQ4D,EAClB5G,KAAK21B,OAAO3yB,GAAQ,GACb4D,EAEXhH,KAAKoD,GACD,OAAOhD,KAAK01B,MAAM1yB,IAAS,EAE/BpD,IAAIoD,GACA,OAAOhD,KAAKmG,KAAKnD,IAAS,EAE9BpD,QAAQoD,GACJ,OAAOhD,KAAK41B,SAAS5yB,KAAS,EAElCpD,KAAKoD,EAAMyF,EAAOstB,GAAW,GACzB,GAAIttB,EAAQ,GAAKzI,KAAK41B,SAAS5yB,GAC3B,OAAO,EACXhD,KAAK01B,MAAM1yB,IAASyF,EAChBstB,GAAY/1B,KAAK01B,MAAM1yB,GAAQhD,KAAKmG,KAAKnD,KACzChD,KAAKmG,KAAKnD,GAAQhD,KAAK01B,MAAM1yB,IAEjC,IAAIgzB,EAAMh2B,KAAKwG,IAAIxD,GACnB,OAAOhD,KAAKi2B,WAAWjzB,GAAQgzB,EAEnCp2B,MAAMoD,EAAMkzB,EAAMC,GAAW,GACrBD,EAAO,IACPA,GAAQA,GACZ,MAAMjuB,EAAUjI,KAAKiH,KAAKjE,GAAOkzB,GAAM,GAIvC,OAHIjuB,GAAWkuB,IACXn2B,KAAKmG,KAAKnD,GAAQhD,KAAK01B,MAAM1yB,IAE1BiF,EAEXrI,QAAQoD,GACJhD,KAAK01B,MAAM1yB,GAAQhD,KAAKmG,KAAKnD,GAC7B,IAAIgzB,EAAMh2B,KAAKwG,IAAIxD,GACnB,OAAOhD,KAAKi2B,WAAWjzB,GAAQgzB,EAEnCp2B,SAASoD,EAAMozB,GACX,OAAOp2B,KAAKq2B,UAAUrzB,EAAM,CAAEozB,MAAAA,IAElCx2B,UAAUoD,EAAMozB,GACS,iBAAVA,IACPA,EAAQ,CAAEA,MAAAA,SACY5uB,IAAtBxH,KAAKqG,OAAOrD,IACZhD,KAAKyG,IAAIzD,EAAM,GAEnBhD,KAAK21B,OAAO3yB,GAAMwC,KAAK4wB,GACvB,IAAIJ,EAAMh2B,KAAKwG,IAAIxD,GACnB,OAAOhD,KAAKi2B,WAAWjzB,GAAQgzB,EAEnCp2B,WAAWoD,EAAMozB,GACb,OAAOp2B,KAAKs2B,YAAYtzB,EAAM,CAAEozB,MAAAA,IAEpCx2B,YAAYoD,EAAMozB,GACO,iBAAVA,IACPA,EAAQ,CAAEA,MAAAA,IACd,IAAIG,EAAMv2B,KAAK21B,OAAO3yB,IAAS,GAC3B5C,EAAM+Z,KAAKC,UAAUgc,GACrBzwB,EAAQ4wB,EAAIC,WAAWC,GAChBtc,KAAKC,UAAUqc,IAAMr2B,IAEhC,GAAIuF,GAAS,EAAG,CACZ4wB,EAAIG,OAAO/wB,EAAO,GAClB,IAAIqwB,EAAMh2B,KAAKwG,IAAIxD,GACnB,OAAOhD,KAAKi2B,WAAWjzB,GAAQgzB,EAEnC,OAAO,EAEXp2B,WAAWoD,GACP,IAAI2zB,EAAiB,GACrB32B,KAAK21B,OAAO3yB,GAAMoC,SAASwxB,GAAQ52B,KAAK62B,iBAAiBF,EAAgBC,KACzE52B,KAAK41B,SAAS5yB,GAAQ2zB,EAAeG,UAAW,EAChD,IAAIlwB,EAAQ5G,KAAK01B,MAAM1yB,IAAS,EAahC,YAZ6BwE,IAAzBmvB,EAAeI,MACfnwB,EAAQ+vB,EAAeI,OAGvBnwB,GAAS+vB,EAAeP,OAAS,OACN5uB,IAAvBmvB,EAAe5vB,MACfH,EAAQf,KAAKS,IAAIqwB,EAAe5vB,IAAKH,SAEdY,IAAvBmvB,EAAerwB,MACfM,EAAQf,KAAKkB,IAAI4vB,EAAerwB,IAAKM,KAGrC5G,KAAKqG,OAAOrD,GAAQ4D,EAEhChH,OAAOoD,EAAM4zB,GACT,IAAInuB,EAiBJ,MAhBmB,iBAARmuB,IACPA,EAAM,CAAER,MAAOQ,IAEfA,EAAInT,KACJhb,EAAQzI,KAAKiH,KAAKjE,EAAM4zB,EAAInT,MAEvBmT,EAAII,SACTvuB,EAAQzI,KAAKg3B,QAAQh0B,GACR,GAATyF,IACAA,OAAQjB,IAGZiB,EAAQzI,KAAKq2B,UAAUrzB,EAAM4zB,GAE7B52B,KAAKiI,cAAqBT,IAAViB,GAChBzI,KAAKiI,QAAQjI,KAAMgD,GAChByF,EAEX7I,gBAAgBoD,EAAM4zB,GAClB,IAAInuB,EAeJ,MAdmB,iBAARmuB,IACPA,EAAM,CAAER,MAAOQ,IAEfA,EAAInT,KACJhb,EAAQzI,KAAKmH,MAAMnE,EAAM4zB,EAAInT,MAAM,GAE9BmT,EAAII,UAITvuB,EAAQzI,KAAKs2B,YAAYtzB,EAAM4zB,IAE/B52B,KAAKiI,cAAqBT,IAAViB,GAChBzI,KAAKiI,QAAQjI,KAAMgD,GAChByF,EAEX7I,iBAAiBolB,EAAO5iB,GAChBA,EAAKg0B,QACLpR,EAAMoR,OAASpR,EAAMoR,OAAS,GAAKh0B,EAAKg0B,YAEzB5uB,IAAfpF,EAAK20B,QACL/R,EAAM+R,MAAQlxB,KAAKS,IAAI0e,EAAM+R,OAAS,EAAG30B,EAAK20B,aAEjCvvB,IAAbpF,EAAK2E,MACLie,EAAMje,IAAMlB,KAAKS,IAAI0e,EAAMje,KAAO,EAAG3E,EAAK2E,WAE7BS,IAAbpF,EAAKkE,MACL0e,EAAM1e,IAAMT,KAAKS,IAAI0e,EAAM1e,KAAO,EAAGlE,EAAKkE,WAEzBkB,IAAjBpF,EAAK00B,UACL9R,EAAM8R,QAAU10B,EAAK00B,UAI1B,MAAMjB,GAAa,GCvM1B,MAAMoB,GACFr3B,YAAYoD,GACRhD,KAAKgD,KAAOA,EAEhBk0B,UACI,OAAOl3B,KAAKm3B,MAAM,QAEtBC,YACI,OAAOp3B,KAAKq3B,KAAK,UAErBC,mBACI,OAAOt3B,KAAKm3B,MAAM,iBAEtBI,gBACI,OAAOv3B,KAAKm3B,MAAM,cAEtBJ,YACI,OAAO/2B,KAAKq3B,KAAK,UAErBjB,YACI,MAAMoB,EAAIx3B,KAAKq3B,KAAK,WAAa,EACjC,OAAKr3B,KAAKy3B,QAEHD,EAAIx3B,KAAKy3B,QAAQrB,MADboB,EAGfE,cACI,OAAO13B,KAAKm3B,MAAM,YAEtBQ,WACI,OAAO33B,KAAKm3B,MAAM,SAEtBv3B,IAAIgH,IACc,IAAVA,GACA5G,KAAK43B,MAAO,EACZ53B,KAAK63B,OAAS,IAGd73B,KAAK43B,MAAO,EACZ53B,KAAK63B,QAAmB,IAAVjxB,EAAiB,EAAIA,GAG3ChH,OAAOoD,GACH,YAAmBwE,IAAfxH,KAAKgD,GAEEhD,KAAKgD,GAEZhD,KAAKy3B,QAEEz3B,KAAKy3B,QAAQpxB,OAAOrD,QAF/B,EAMJpD,MAAMoD,GACF,QAAShD,KAAKqG,OAAOrD,GAEzBpD,KAAKoD,GACD,OAAOhD,KAAKqG,OAAOrD,GAEvBpD,OAAOg3B,GACHl1B,OAAOgZ,QAAQkc,GAAKxxB,SAAQ,EAAEhF,EAAKwG,MAE/B,GADAxG,EAAM,IAAMA,OACEoH,IAAVZ,EAAJ,CAEA,GAAY,WAARxG,EAAkB,CAClB,GAAqB,iBAAVwG,EACP,MAAM,IAAIe,MAAM,4CAEpBf,EAAQf,KAAKS,IAAIM,EAAO5G,KAAK83B,QAAU,QAEtC,GAAY,WAAR13B,EAAkB,CACvB,GAAqB,iBAAVwG,EACP,MAAM,IAAIe,MAAM,4CAEpBf,GAAiB5G,KAAK21B,QAAU,EAGpC31B,KAAKI,GAAOwG,MAGpBhH,MAAMg3B,GACFl1B,OAAOo0B,KAAKc,GAAKxxB,SAAShF,SAGJoH,IAAdxH,KAFJI,EAAM,IAAMA,KAIRJ,KAAKI,QAAOoH,OAKrB,MAAMuwB,GACTn4B,YAAYsW,EAAO,IACflW,KAAKg4B,QAAU,GACft2B,OAAOgZ,QAAQxE,GAAM9Q,SAAQ,EAAEhF,EAAKwG,MAChC5G,KAAKyG,IAAIrG,EAAKwG,MAGtBhH,IAAIoD,EAAM4D,GACN,MAAMykB,EAAIrrB,KAAKwG,IAAIxD,GAEnB,OADAqoB,EAAE5kB,IAAIG,GACCykB,EAEXzrB,IAAIoD,GACA,IAAIqoB,EAAIrrB,KAAKg4B,QAAQh1B,GACrB,GAAIqoB,EACA,OAAOA,EACXA,EAAIrrB,KAAKg4B,QAAQh1B,GAAQ,IAAIi0B,GAAMj0B,GACnC,MAAM2C,EAAQ3C,EAAKi1B,YAAY,KAO/B,OANItyB,EAAQ,EACR0lB,EAAEoM,QAAUz3B,KAAKwG,IAAIxD,EAAK0Q,UAAU,EAAG/N,IAGvC0lB,EAAE5kB,KAAI,GAEH4kB,EAEXzrB,OAAOoD,EAAM4zB,GACU,iBAARA,IACPA,EAAM,CAAER,MAAOQ,IAEnB,IAAIvL,EAAIrrB,KAAKwG,IAAIxD,GAEjB,OADAqoB,EAAEpJ,OAAO2U,GACFvL,GCpJR,MAAM6M,GACTt4B,YAAYkM,GACR9L,KAAKm4B,QAAUrsB,EAEnBlM,IAAIC,EAAGC,GACH,OAAKE,KAAKo4B,MAEHp4B,KAAKo4B,MAAMv4B,GAAGC,GADV,EAGfF,QACSI,KAAKm4B,QAAQv3B,MAEdZ,KAAKo4B,OACLp8B,EAAIoO,KAAKC,KAAKrK,KAAKo4B,OACvBp4B,KAAKo4B,MAAQp8B,EAAIoO,KAAK2C,MAAM/M,KAAKm4B,QAAQv3B,IAAImE,MAAO/E,KAAKm4B,QAAQv3B,IAAIoM,SAEzEpN,SACI,IAAKI,KAAKm4B,QAAQv3B,IACd,OACJ,MAAM8O,EAAQ1P,KAAKm4B,QAAQvuB,KAAK8F,OAAS,GACzC1P,KAAKo4B,MAAMp4B,KAAKm4B,QAAQt4B,GAAGG,KAAKm4B,QAAQr4B,GAAK4P,EAC7C,MAAM6e,EAAUvyB,EAAIoO,KAAK2C,MAAM/M,KAAKo4B,MAAMrzB,MAAO/E,KAAKo4B,MAAMprB,QACtDpM,EAAMZ,KAAKm4B,QAAQv3B,IACzBZ,KAAKo4B,MAAMhzB,SAAQ,CAACsB,EAAG7G,EAAGC,KACtB,MAAMmC,EAAOrB,EAAIqB,KAAKpC,EAAGC,GACzB,GAAImC,EAAK8O,aACL,OACJ,IAAIsnB,EAAU3xB,EACd1K,EAAImP,GAAG2F,aAAajR,EAAGC,GAAG,CAACoY,EAAIC,KAC3B,IAAKnY,KAAKo4B,MAAM5gB,MAAMU,EAAIC,GACtB,OACJ,MAAMmgB,EAAKt4B,KAAKo4B,MAAMlgB,GAAIC,GACtBmgB,EAAKD,IACLA,EAAUC,MAEf,GACH,MAAM7vB,EAAQxG,EAAKs2B,YAAc,EAAI,EACrChK,EAAQ1uB,GAAGC,GAAK+F,KAAKS,IAAI,EAAG+xB,EAAU5vB,MAE1CzM,EAAIoO,KAAKC,KAAKrK,KAAKo4B,OACnBp4B,KAAKo4B,MAAQ7J,EAEjB3uB,QAAQC,EAAGC,GACP,MAAM4G,EAAI1G,KAAKo4B,MAAMv4B,GAAGC,IAAM,EAC9B,IAAK4G,EACD,OAAO,KACX,IAAI2xB,EAAU3xB,EACV8xB,EAAa,GAajB,GAZAx8B,EAAImP,GAAG2F,aAAajR,EAAGC,GAAG,CAACoY,EAAIC,KAC3B,IAAKnY,KAAKo4B,MAAM5gB,MAAMU,EAAIC,GACtB,OACJ,MAAMmgB,EAAKt4B,KAAKo4B,MAAMlgB,GAAIC,GACtBmgB,GAAMD,EACNG,EAAWhzB,KAAK,CAAC0S,EAAIC,IAEhBmgB,EAAKD,IACVG,EAAa,CAAC,CAACtgB,EAAIC,IACnBkgB,EAAUC,MAEf,IACEE,EAAWj0B,OACZ,OAAO,KACX,MAAMgL,EAAMvT,EAAIgT,OAAOvC,KAAK+rB,GAG5B,OAFAjpB,EAAI,GAAKA,EAAI,GAAK1P,EAClB0P,EAAI,GAAKA,EAAI,GAAKzP,EACXyP,GC9DR,MAAMkpB,WAAe17B,EACxB6C,YAAYM,GACRqJ,MAAMrJ,GACNF,KAAK0P,MAAQ,IAAIwoB,GAAMl4B,MAE3BJ,YACII,KAAKyO,YAET7O,QAAQ6F,EAAM,KAOV,OANIzF,KAAKY,MACDZ,KAAKY,IAAIqK,IAAIgC,UACbjN,KAAKkM,eAAe3B,EAAYsC,iBAEpC7M,KAAK0P,MAAMzC,UAER1D,MAAM8C,QAAQ5G,GAEzB7F,SAASgB,EAAKf,EAAGC,GACb,QAAKyJ,MAAMvI,SAASJ,EAAKf,EAAGC,KAE5BE,KAAK0P,MAAM6P,SACJ,GAEX3f,QAAQC,EAAGC,GACP,MAAMc,EAAMZ,KAAKG,KACjB,IAAKS,EACD,MAAM,IAAI+G,MAAM,4BACf3H,KAAK8J,WACN9J,KAAK8J,SAAW9N,EAAIoO,KAAK2C,MAAMnM,EAAImE,MAAOnE,EAAIoM,SAElD,MAAMI,EAAUpN,KAAK8J,SACf4uB,EAAc14B,KAAK24B,UACzB,GAAID,EAAY74B,GAAGC,GAAK,GACpB44B,EAAY74B,GAAGC,IAAM9D,EAAIqR,KAAK6C,UAC7BtP,EAAIqK,IAAIihB,WAAWrsB,EAAGC,GAAI,CAC3B,IAAIyP,EAAMvT,EAAIqR,KAAKurB,wBAAwBF,EAAa74B,EAAGC,GAAG,CAACD,EAAGC,KAAOc,EAAIqK,IAAIihB,WAAWrsB,EAAGC,KAC/FyP,EAAMA,GAAO,CAACvP,KAAKH,EAAGG,KAAKF,GAC3BD,EAAI0P,EAAI,GACRzP,EAAIyP,EAAI,GAGZ,OADAvT,EAAIqR,KAAKC,mBAAmBF,EAASvN,EAAGC,EAAGE,KAAKuN,WACzCvN,KAAK8J,SAEhBlK,eACI,MAAMgB,EAAMZ,KAAKY,IACjB,IAAKA,EACD,OAAO,KACX,MAAMwM,EAAUpN,KAAKoN,QAErB,OADapR,EAAIqR,KAAK+C,SAAShD,EAASpN,KAAKH,EAAGG,KAAKF,GAAG,CAACD,EAAGC,IAAMc,EAAIyP,SAASxQ,EAAGC,IAAMc,EAAI0P,QAAQzQ,EAAGC,KAAOE,OAGlHJ,UAAUokB,GACN,IAAInkB,EAAImkB,EAAK,GACTlkB,EAAIkkB,EAAK,GACO,IAAhBA,EAAKzf,SACL1E,EAAImkB,EAAK,GAAGnkB,EACZC,EAAIkkB,EAAK,GAAGlkB,GAEhB,MAAMc,EAAMZ,KAAKY,IACjB,IAAKA,EACD,OAAO,KACX,MAAM83B,EAAc14B,KAAK24B,UACzB,GAAID,EAAY74B,GAAGC,GAAK,GACpB44B,EAAY74B,GAAGC,IAAM9D,EAAIqR,KAAK6C,UAC7BtP,EAAIqK,IAAIihB,WAAWrsB,EAAGC,GAAI,CAC3B,MAAMyP,EAAMvT,EAAIqR,KAAKurB,wBAAwBF,EAAa74B,EAAGC,GAAG,CAACD,EAAGC,KAAOc,EAAIqK,IAAIihB,WAAWrsB,EAAGC,KACjG,IAAKyP,EACD,OAAO,KACX1P,EAAI0P,EAAI,GACRzP,EAAIyP,EAAI,GAGZ,OADavT,EAAIqR,KAAKwrB,QAAQH,EAAa74B,EAAGC,GAAG,CAACD,EAAGC,KAAOc,EAAIqK,IAAIihB,WAAWrsB,EAAGC,KAAI,IAI9F24B,GAAO/qB,QAAU,CACbsJ,GAAI,IACJE,GAAI,QACJlU,KAAM,MACN0P,MAAM,GC7EH,MAAMomB,WAAmBC,EAC5Bn5B,YAAYwC,EAAO,IACfmH,OACSnH,EAAKjB,SACNiB,EAAK4U,GAAK5U,EAAK4U,IAAMyhB,GAAO/qB,QAAQsJ,GACpC5U,EAAK8U,GAAK9U,EAAK8U,IAAMuhB,GAAO/qB,QAAQwJ,IAEnC9U,EAAKY,OACNZ,EAAKY,KAAOy1B,GAAO/qB,QAAQ1K,WAEbwE,IAAdpF,EAAKsQ,OACLtQ,EAAKsQ,KAAO+lB,GAAO/qB,QAAQgF,MAExBtQ,IAEXpC,KAAKQ,MAAMwJ,OAASO,EAAYC,UAChCxK,KAAK61B,WAAa,IAAImD,GAAsB52B,EAAKyzB,YAAc,IAC/D71B,KAAKi5B,OAAS,IAAIC,GAAc92B,EAAK62B,QAAU,IAEnDr5B,KAAKgT,GACD,MAAM5I,EAAQ,IAAIyuB,GAAOz4B,MAEzB,OADAA,KAAKkE,KAAK8F,EAAO4I,GACV5I,EAEXpK,SAASqC,EAAM6J,GAEX,OADY7J,EAAKrB,IACRqK,IAAIihB,WAAWjqB,EAAKpC,EAAGoC,EAAKnC,GAE9ByJ,MAAM4D,SAASlL,EAAM6J,GADjB9P,EAAIqR,KAAKmE,WCMrB,SAAS4B,GAASF,GACrB,MAAMhQ,EAASxB,OAAOC,OAAO,GAAIuR,GACjC,OAAO,IAAI4lB,GAAW51B,qFL0LnB,SAA0Bi2B,GACT,iBAATA,GAKXz3B,OAAOo0B,KAAKD,IAAYzwB,SAASyO,WACtBgiB,GAAWhiB,MAEtBnS,OAAOC,OAAOk0B,GAAYsD,IAPtBtD,GAAWsD,GAAQ,kBASpB,SAAwBC,GAC3B,OAAO,IAAI5D,GAAW4D,2CK7OnB,SAAcz4B,EAAIwS,GACrB,IAAIjT,EACJ,GAAkB,iBAAPS,EAAiB,CAGxB,GADAT,EAAOg0B,GAAUvzB,IACZT,EACD,MAAM,IAAIyH,MAAM,8BAAgChH,GACpD,KAAMT,aAAgB44B,IAClB,MAAM,IAAInxB,MAAM,2BAGpBzH,EADKS,aAAcm4B,GACZn4B,EAGAyS,GAASzS,GAEpB,OAAOT,EAAKyD,KAAKwP,YAEd,SAAiBxS,EAAIT,GACxB,GAAIA,aAAgB44B,GAEhB,OADAO,GAAY14B,GAAMT,EACXA,EAEX,MAAMma,EAAOjH,GAASlT,GAGtB,OAFAma,EAAK1Z,GAAKA,EACV04B,GAAY14B,GAAM0Z,EACXA,OAEJ,SAAa1Z,GAChB,GAAIA,aAAcm4B,GACd,OAAOn4B,EACX,MAAMkT,EAAIwlB,GAAY14B,GACtB,GAAIkT,KAAOA,aAAailB,IACpB,MAAM,IAAInxB,MAAM,qBAEpB,OAAOkM,iBClCJ,MAAMylB,GACT15B,YAAYwC,GACRpC,KAAKqqB,QAAU,EACfrqB,KAAKsqB,QAAU,EACftqB,KAAKu5B,SAAW,KAChBv5B,KAAK8L,OAAS,KACd9L,KAAK2C,OAAS,IAAI3G,EAAImP,GAAGquB,OAAOp3B,EAAKvC,EAAGuC,EAAKtC,EAAGsC,EAAK2C,MAAO3C,EAAK4K,QACjEhN,KAAKmX,GAAKnb,EAAIqnB,MAAMrf,KAAK5B,EAAK+U,IAAM,SACpCnX,KAAK+yB,KAAO3wB,EAAK2wB,OAAQ,EACzB/yB,KAAK6Q,OAASzO,EAAKyO,SAAU,EAC7B7Q,KAAK4T,OAASxR,EAAKwR,QAAU,KAC7B5T,KAAKy5B,MAAQr3B,EAAKs3B,MAAQt3B,EAAKq3B,QAAS,EACxCz5B,KAAK25B,MAAQv3B,EAAKs3B,MAAQt3B,EAAKu3B,QAAS,EACxC35B,KAAK0P,MAAQtN,EAAKsN,QAAS,EAE/BkqB,cACI,OAAO55B,KAAKu5B,SAEhBK,YAAYA,GACR55B,KAAK6Q,SAAW+oB,EACZA,IACA55B,KAAKqqB,QAAUuP,EAAQ/5B,EAAIG,KAAK65B,YAChC75B,KAAKsqB,QAAUsP,EAAQ95B,EAAIE,KAAK85B,cAEpC95B,KAAKu5B,SAAWK,EAEZ55B,KAAK8L,OADL8tB,GAAWA,aAAmBnB,GAChBmB,EAGA,KAGtBF,SAAShzB,GACL1G,KAAKy5B,MAAQ/yB,EACb1G,KAAK25B,MAAQjzB,EAEjB9G,OAAOC,GACH,OAAOA,EAAIG,KAAKqqB,QAAUrqB,KAAK2C,OAAO9C,EAE1CD,OAAOE,GACH,OAAOA,EAAIE,KAAKsqB,QAAUtqB,KAAK2C,OAAO7C,EAE1CF,SAASC,GACL,OAAOA,EAAIG,KAAK2C,OAAO9C,EAE3BD,SAASE,GACL,OAAOA,EAAIE,KAAK2C,OAAO7C,EAE3BF,YACI,OAAOiG,KAAKC,MAAM9F,KAAK2C,OAAOoC,MAAQ,GAE1CnF,aACI,OAAOiG,KAAKC,MAAM9F,KAAK2C,OAAOqK,OAAS,GAE3CpN,SAASgB,EAAKf,EAAGC,GACbE,KAAK6Q,QAAS,EACd7Q,KAAK45B,QAAU,CAAE/5B,EAAAA,EAAGC,EAAAA,EAAGc,IAAAA,GAE3BhB,QAAQgB,EAAKf,EAAI,EAAGC,EAAI,GACpBE,KAAK45B,QAAU,CAAE/5B,EAAAA,EAAGC,EAAAA,EAAGc,IAAAA,GACvBZ,KAAKqqB,QAAUxqB,EACfG,KAAKsqB,QAAUxqB,EACfE,KAAK6Q,QAAS,EACd7Q,KAAK+yB,MAAO,EAEhBnzB,eACI,IAAKI,KAAKu5B,SAGN,OAFAv5B,KAAKqqB,QAAU,OACfrqB,KAAKsqB,QAAU,GAGnB,MAAMsP,EAAU55B,KAAKu5B,SACf34B,EAAMg5B,EAAQh5B,IACd+B,EAAS/B,EACf,GAAIg5B,GAAWh5B,EAAI4W,MAAMoiB,EAAQ/5B,EAAG+5B,EAAQ95B,GACxC,GAAIE,KAAK+yB,KAAM,CACX,IAAIZ,EAAOnyB,KAAKqqB,QACZ0P,EAAQ/5B,KAAKqqB,QAAUrqB,KAAK2C,OAAOoC,MACnCi1B,EAAMh6B,KAAKsqB,QACX2P,EAASj6B,KAAKsqB,QAAUtqB,KAAK2C,OAAOqK,QAEpC4sB,EAAQ/5B,EAAIsyB,GAAQyH,EAAQ/5B,EAAIk6B,KAChC5H,EAAOnyB,KAAKqqB,QAAUuP,EAAQ/5B,EAAIG,KAAK65B,YACvCE,EAAQ5H,EAAOnyB,KAAK2C,OAAOoC,QAE3B60B,EAAQ95B,EAAIk6B,GAAOJ,EAAQ95B,EAAIm6B,KAC/BD,EAAMh6B,KAAKsqB,QAAUsP,EAAQ95B,EAAIE,KAAK85B,aACtCG,EAASD,EAAMh6B,KAAK2C,OAAOqK,QAE/B,MAAMktB,EAAQr0B,KAAKC,MAAM9F,KAAK2C,OAAOoC,MAAQ,GACvCo1B,EAAQt0B,KAAKC,MAAM9F,KAAK2C,OAAOqK,OAAS,GACxCotB,EAASv0B,KAAKC,MAAM9F,KAAK2C,OAAOoC,MAAQ,GAC1CotB,EAAO+H,GAASN,EAAQ/5B,EACxBG,KAAKqqB,QAAUxkB,KAAKS,IAAI,EAAGszB,EAAQ/5B,EAAIu6B,EAASp6B,KAAK2C,OAAOoC,OAEvDg1B,EAAQG,GAASN,EAAQ/5B,IAC9BG,KAAKqqB,QAAUxkB,KAAKkB,IAAI6yB,EAAQ/5B,EAAIu6B,EAAQz3B,EAAOoC,MAAQ/E,KAAK2C,OAAOoC,QAE3E,MAAMs1B,EAASx0B,KAAKC,MAAM9F,KAAK2C,OAAOqK,OAAS,GAC3CgtB,EAAMG,GAASP,EAAQ95B,EACvBE,KAAKsqB,QAAUzkB,KAAKS,IAAI,EAAGszB,EAAQ95B,EAAIu6B,EAASr6B,KAAK2C,OAAOqK,QAEvDitB,EAASE,GAASP,EAAQ95B,IAC/BE,KAAKsqB,QAAUzkB,KAAKkB,IAAI6yB,EAAQ95B,EAAIu6B,EAAQ13B,EAAOqK,OAAShN,KAAK2C,OAAOqK,cAGvEhN,KAAK6Q,QACV7Q,KAAKqqB,QAAUuP,EAAQ/5B,EAAIG,KAAK65B,YAChC75B,KAAKsqB,QAAUsP,EAAQ95B,EAAIE,KAAK85B,eAGhC95B,KAAKqqB,QAAUuP,EAAQ/5B,EACvBG,KAAKsqB,QAAUsP,EAAQ95B,GAG3BE,KAAKy5B,OAAS74B,IACdZ,KAAKqqB,QAAUruB,EAAI4J,MAAM5F,KAAKqqB,QAAS,EAAGzpB,EAAImE,MAAQ/E,KAAK2C,OAAOoC,QAElE/E,KAAK25B,OAAS/4B,IACdZ,KAAKsqB,QAAUtuB,EAAI4J,MAAM5F,KAAKsqB,QAAS,EAAG1pB,EAAIoM,OAAShN,KAAK2C,OAAOqK,SAG3EpN,KAAK8C,GACD,IAAK1C,KAAKu5B,SACN,OAAO,EACX,MAAM34B,EAAMZ,KAAKu5B,SAAS34B,IAC1B,IAAKA,IAAQA,EAAI8U,YACb,OAAO,EACX,MAAMzK,EAAMrK,EAAIqK,IAEhB,GADAvI,EAAO43B,aAAat6B,KAAK2C,OAAO9C,EAAGG,KAAK2C,OAAO7C,EAAGE,KAAK2C,OAAOoC,MAAO/E,KAAK2C,OAAOqK,OAAQhN,KAAKmX,KACzFnX,KAAKu5B,SACN,OAAO,EAEXv5B,KAAKu6B,eACU35B,EAAI+rB,OACZjd,MAAQ1P,KAAK0P,MACpB,MAAM/K,EAAQ,IAAI3I,EAAImF,OAAOyD,MAC7B,IAAK,IAAI/E,EAAI,EAAGA,EAAIG,KAAK2C,OAAOoC,QAASlF,EACrC,IAAK,IAAIC,EAAI,EAAGA,EAAIE,KAAK2C,OAAOqK,SAAUlN,EAAG,CACzC,MAAM06B,EAAO36B,EAAIG,KAAKqqB,QAChBoQ,EAAO36B,EAAIE,KAAKsqB,QACtB,GAAI1pB,EAAI4W,MAAMgjB,EAAMC,GAAO,CACvB,MAAMx4B,EAAOrB,EAAIqB,KAAKu4B,EAAMC,GAC5B75B,EAAI+rB,OAAOlC,SAAS9lB,EAAO/D,EAAKqB,EAAMgJ,QAGtCtG,EAAM+1B,KAAK,IAAK16B,KAAKmX,GAAInX,KAAKmX,IAE9BnX,KAAK4T,QACL5T,KAAK4T,OAAOjP,EAAO61B,EAAMC,EAAM75B,GAEnC8B,EAAOK,WAAWlD,EAAIG,KAAK2C,OAAO9C,EAAGC,EAAIE,KAAK2C,OAAO7C,EAAG6E,GAIhE,OAAO,EAEX/E,KAAK2kB,GACD,IAAKvkB,KAAKu5B,SACN,OAAO,EACX,MAAM34B,EAAMZ,KAAKu5B,SAAS34B,IAC1B,QAAKA,OAEAA,EAAI+tB,WAAWtF,EAAUmB,cAAgBxuB,EAAI6vB,SAAS5c,OAAO,OAGlErO,EAAI6Q,UAAU/J,IACNA,EAAEgK,YAAYjB,EAAWoa,eACzBjqB,EAAIqK,IAAIU,mBAAmBjE,EAAE7H,EAAG6H,EAAE5H,IAClC9D,EAAI6vB,SAAS5c,OAAO,KACpBvH,EAAEgO,aAAc,MAGxB9U,EAAI8U,aAAc,GACX,IAEX9V,UAAU8pB,GACN,IAAK1pB,KAAK2C,OAAOg4B,SAASjR,EAAG7pB,EAAG6pB,EAAG5pB,GAC/B,OAAO,EACX,IAAKE,KAAK8L,OACN,OAAO,EAEX,QADY9L,KAAK8L,OAAOlL,KAGjBZ,KAAK46B,SAAS56B,KAAK66B,SAASnR,EAAG7pB,GAAIG,KAAK86B,SAASpR,EAAG5pB,IAE/DF,MAAM8pB,GACF,QAAK1pB,KAAK2C,OAAOg4B,SAASjR,EAAG7pB,EAAG6pB,EAAG5pB,OAE9BE,KAAK8L,SAEN9L,KAAK8L,OAAOwD,UACZtP,KAAK8L,OAAO2C,YAGZzO,KAAK8L,OAAO0D,QAAQxP,KAAK66B,SAASnR,EAAG7pB,GAAIG,KAAK86B,SAASpR,EAAG5pB,KAEvD,IAEXF,SAASC,EAAGC,GACR,IAAKE,KAAK8L,OACN,OAAO,EACX,MAAMlL,EAAMZ,KAAK8L,OAAOlL,IACxB,IAAKA,EACD,OAAO,EAGX,MAAMyM,EAAOrN,KAAK8L,OAAOivB,OAAOl7B,EAAGC,GAOnC,OANIuN,EACAzM,EAAIo6B,cAAc3tB,GAAM,GAGxBzM,EAAIkuB,aAED,GCxNR,MAAMmM,GACTr7B,YAAYwC,GAKR,GAJApC,KAAKk7B,WAAY,EACjBl7B,KAAK2C,OAAS,IAAI3G,EAAImP,GAAGquB,OAAOp3B,EAAKvC,EAAGuC,EAAKtC,EAAGsC,EAAK2C,MAAO3C,EAAK4K,QACjEhN,KAAKmX,GAAKnb,EAAIqnB,MAAMrf,KAAK5B,EAAK+U,IAAM,gBACpCnX,KAAKkX,GAAKlb,EAAIqnB,MAAMrf,KAAK5B,EAAK8U,IAAM,WAC/BlX,KAAK2C,OAAOqK,OACb,MAAM,IAAIrF,MAAM,6CACpB3H,KAAKm7B,MAAQ,IAAIn/B,EAAI2d,QAAQyhB,aAAa,CACtCr2B,MAAO/E,KAAK2C,OAAOoC,MACnBR,OAAQnC,EAAKi5B,SAAW,GACxB9nB,MAAO,KACHvT,KAAKk7B,WAAY,KAI7Bt7B,QACII,KAAKm7B,MAAM5b,QACXvf,KAAKk7B,WAAY,EAErBt7B,MAAM6b,EAAG7P,GACL,QAAK5L,KAAK2C,OAAOg4B,SAASlf,IAEnBzb,KAAKs7B,YAAY1vB,GAE5BhM,KAAK8C,GACD,IAAK1C,KAAKk7B,UACN,OAAO,EACXl7B,KAAKk7B,WAAY,EACjB,MAAMK,EAAUv7B,KAAK2C,OAAO7C,EAAI,GAahC,OAXA4C,EAAO84B,SAASx7B,KAAK2C,OAAO9C,EAAGG,KAAK2C,OAAO7C,EAAGE,KAAK2C,OAAOoC,MAAO/E,KAAK2C,OAAOqK,OAAQ,IAAKhN,KAAKmX,GAAInX,KAAKmX,IACxGnX,KAAKm7B,MAAM/1B,SAAQ,CAACkS,EAAMmkB,EAAWnwB,KACjC,GAAIA,GAAKtL,KAAK2C,OAAOqK,OACjB,OACJ,MACMlN,GADSy7B,EAAUv7B,KAAK2C,OAAOqK,OAAS1B,EAAI,EAAIA,GACnCtL,KAAK2C,OAAO7C,EAC/B4C,EAAOg5B,SAAS17B,KAAK2C,OAAO9C,EAAGC,EAAGwX,EAAMtX,KAAKkX,IACzCukB,GAAaz7B,KAAKmX,IAClBzU,EAAOyoB,IAAInrB,KAAKmX,GAAI,GAAInX,KAAK2C,OAAO9C,EAAGC,EAAGE,KAAK2C,OAAOoC,MAAO,OAG9D,EAEXnF,YAAYgM,GACR,QAAI5L,KAAKm7B,MAAM52B,QAAUvE,KAAK2C,OAAOqK,SAE9BsuB,GAAYt7B,KAAM4L,IAG1B,MAAM+vB,WAAuB3/B,EAAI4/B,OAAOC,OAC3Cj8B,YAAY4tB,EAAO3X,GACftM,MAAMikB,EAAO,CACT7sB,GAAI,UACJkB,IAAK,WACLmL,OAAQ6I,EAAOlT,OAAOqK,OACtBjI,MAAO8Q,EAAOlT,OAAOoC,MACrBlF,EAAG,EACHC,EAAG,EACHg8B,SAAS,EACTx7B,MAAO,MAEXN,KAAK+7B,KAAO,UACZ/7B,KAAKg8B,SAAW,KAChBh8B,KAAK6V,OAASA,EACd7V,KAAKu7B,QAAUv7B,KAAK6V,OAAOlT,OAAO7C,EAAI,GACtCE,KAAK2C,OAAOqK,OAAShN,KAAKu7B,QACpB/N,EAAMxgB,OAAS6I,EAAOlT,OAAO7C,EAC7B+V,EAAOlT,OAAOs3B,OACpBj6B,KAAKi8B,WAAap2B,KAAKkB,IAAI8O,EAAOslB,MAAM52B,OAAQvE,KAAKu7B,QAC/C/N,EAAMxgB,OAAShN,KAAK6V,OAAOlT,OAAOq3B,IAClCh6B,KAAK6V,OAAOlT,OAAOs3B,QACzBj6B,KAAKk8B,MAAQrmB,EAAOlT,OAAOqK,OAC3BhN,KAAKg8B,SAAWh8B,KAAKwtB,MAAM2O,YAAW,IAAMn8B,KAAKo8B,YAAY,IAE7Dp8B,KAAK6V,OAAOslB,MAAMkB,aAEtBz8B,WACI,OAAO,EAEXA,SACII,KAAKwtB,MAAM8O,SAEf18B,SAAS6b,GACL,OAAOzb,KAAKu8B,MAAM9gB,GAEtB7b,MAAM2jB,GAqBF,MApBkB,QAAdvjB,KAAK+7B,MACL/7B,KAAK+7B,KAAO,UACZ/7B,KAAKwtB,MAAM0N,WAAY,EACnBl7B,KAAKg8B,UACLh8B,KAAKwtB,MAAMgP,aAAax8B,KAAKg8B,UAEjCh8B,KAAKg8B,SAAWh8B,KAAKwtB,MAAM2O,YAAW,IAAMn8B,KAAKy8B,YAAY,KAE1C,YAAdz8B,KAAK+7B,KACV/7B,KAAKs8B,UAGLt8B,KAAK+7B,KAAO,MACZ/7B,KAAKk8B,MAAQl8B,KAAKi8B,WACdj8B,KAAKg8B,WACLh8B,KAAKwtB,MAAMgP,aAAax8B,KAAKg8B,UAC7Bh8B,KAAKg8B,SAAW,MAEpBh8B,KAAKwtB,MAAM0N,WAAY,IAEpB,EAEXt7B,WAYI,QAVEI,KAAKk8B,MACPl8B,KAAKg8B,SAAW,KAChBh8B,KAAKwtB,MAAM0N,WAAY,EACnBl7B,KAAKk8B,MAAQl8B,KAAKi8B,WAClBj8B,KAAKg8B,SAAWh8B,KAAKwtB,MAAM2O,YAAW,IAAMn8B,KAAKo8B,YAAY,KAG7Dp8B,KAAK+7B,KAAO,MACZ/7B,KAAKk8B,MAAQl8B,KAAKi8B,aAEf,EAEXr8B,WAWI,QATEI,KAAKk8B,MACPl8B,KAAKg8B,SAAW,KACZh8B,KAAKk8B,OAASl8B,KAAK6V,OAAOlT,OAAOqK,OACjChN,KAAKs8B,UAGLt8B,KAAKwtB,MAAM0N,WAAY,EACvBl7B,KAAKg8B,SAAWh8B,KAAKwtB,MAAM2O,YAAW,IAAMn8B,KAAKy8B,YAAY,MAE1D,EAEX78B,MAAM8C,GACF,IAAIg6B,EAAc,EAIlB,MAAMnB,EAAUv7B,KAAKu7B,QACfoB,EAAOj6B,EACPwU,EAAKlb,EAAIqnB,MAAMrf,KAAKhE,KAAK6V,OAAOqB,IAMhCia,EAASoK,EACTv7B,KAAKk8B,MAAQ,EACbl8B,KAAK2C,OAAOs3B,OAASj6B,KAAKk8B,MAC1BU,EAAOrB,EAAU,EAAIv7B,KAAK2C,OAAOs3B,OAAS,EAC1C4C,EAAKtB,GAAW,EAAI,EAc1B,GAbAoB,EAAKnB,SAASx7B,KAAK6V,OAAOlT,OAAO9C,EAAGgG,KAAKkB,IAAIoqB,EAAQyL,GAAO58B,KAAK2C,OAAOoC,MAAO/E,KAAKk8B,MAAO,IAAKl8B,KAAK88B,MAAM3lB,GAAInX,KAAK88B,MAAM3lB,IAC1HnX,KAAK6V,OAAOslB,MAAM/1B,SAAQ,CAACkS,EAAMylB,EAAYxxB,KACzC,MAAMzL,EAAIqxB,EAAS5lB,EAAIsxB,EACvB,GAAItB,GACA,GAAIz7B,EAAI88B,EACJ,YAEH,GAAI98B,EAAI88B,EACT,OACJF,EAAc72B,KAAKC,MAAO,GAAKyF,EAAKvL,KAAKk8B,OACzC,MAAMc,EAAU9lB,EAAGiU,IAAInrB,KAAK88B,MAAM3lB,GAAIulB,GACtCC,EAAKjB,SAAS17B,KAAK6V,OAAOlT,OAAO9C,EAAGC,EAAGwX,EAAM0lB,EAASh9B,KAAK88B,MAAM3lB,OAEnD,QAAdnX,KAAK+7B,KAAgB,CACrB,MAAMj8B,EAAIE,KAAKu7B,QAAU,EAAIoB,EAAK3vB,OAAS,EACrCnN,EAAIG,KAAK6V,OAAOlT,OAAO9C,EAAI,EAC3BG,KAAK6V,OAAOlT,OAAO9C,EAAI,EACvBgG,KAAKkB,IAAI/G,KAAK6V,OAAOlT,OAAO9C,EAAIG,KAAK2C,OAAOoC,MAC9C43B,EAAK53B,MAAQ,GAEjB43B,EAAK73B,SAASjF,EAAGC,EAAG,EAAG,WAAYE,KAAK88B,MAAM3lB,GAAInX,KAAK88B,MAAM5lB,IAEjE,OAAO,GAGRnJ,eAAeutB,GAAYM,EAAQhwB,GACtC,MAAM4hB,EAAQ,IAAIxxB,EAAI4/B,OAAOqB,YAAYrxB,EAAKsxB,IAEpC,IAAIvB,GAAenO,EAAOoO,SAC9BpO,EAAM2P,gDCnLT,MACHv9B,YAAYwC,GACRpC,KAAK8N,YAAStG,EACdxH,KAAKo9B,OAAQ,EACbp9B,KAAKiL,KAAM,EACXjL,KAAK0P,OAAQ,EACb1P,KAAKq9B,SAAU,EACfr9B,KAAKs9B,OAAS,GACdt9B,KAAKk9B,GAAK96B,EAAK86B,IAAM,IAAIlhC,EAAIkhC,GAAGK,GAAGn7B,GACnCpC,KAAKw9B,SAAWp7B,EAAKq7B,QACrBz9B,KAAK09B,YAAct7B,EAAKu7B,WACxB39B,KAAK49B,UAAYx7B,EAAKy7B,SAClBz7B,EAAKk7B,QACL57B,OAAOC,OAAO3B,KAAKs9B,OAAQl7B,EAAKk7B,QAEhCl7B,EAAKg7B,QACLp9B,KAAKo9B,OAAQ,GAEY,iBAAlBh7B,EAAK07B,WACZ17B,EAAK07B,SAAW,CAAEv5B,OAAQnC,EAAK07B,WAEnC17B,EAAK27B,SAAW37B,EAAK27B,UAAY,GACjC,MAAMr5B,EAAQtC,EACdsC,EAAMq5B,SAASl+B,EAAI,EACnB6E,EAAMq5B,SAASj+B,EAAI,EACnB4E,EAAMq5B,SAASh5B,MAAQ/E,KAAKk9B,GAAGn4B,MAC/BL,EAAMq5B,SAAS/wB,OAAShN,KAAKk9B,GAAGlwB,OAChChN,KAAKg+B,UAAUt5B,GACf1E,KAAKi+B,aAAav5B,QACI8C,IAAlBpF,EAAK07B,UACL99B,KAAKk+B,cAAcx5B,GACvB1E,KAAKm+B,YAAYz5B,GACjB1E,KAAKo+B,cAAc15B,GAEvB9E,UAAU8E,IACV9E,aAAa8E,IACb9E,cAAcwC,GACV,MAAMi8B,EAAWj8B,EAAK07B,UAAY,GAElC,GADAO,EAAS95B,OAAS85B,EAAS95B,QAAU85B,EAASv+B,GAAK,EAC/Cu+B,EAAS95B,OAAS,EAAG,CAErB,MAAM+5B,EAAWl8B,EAAK27B,SACtBM,EAASx+B,EAAIy+B,EAASz+B,EACtBw+B,EAASv+B,EAAIE,KAAKk9B,GAAGlwB,OAASqxB,EAAS95B,OACvC85B,EAASt5B,MAAQu5B,EAASv5B,MAC1Bs5B,EAASrxB,QAAUqxB,EAAS95B,OAC5BnC,EAAK27B,SAAS/wB,QAAUqxB,EAASrxB,WAEhC,CAED,MAAMsxB,EAAWl8B,EAAK27B,SACtBM,EAASx+B,EAAIy+B,EAASz+B,EACtBw+B,EAASv+B,EAAIw+B,EAASx+B,EACtBu+B,EAASt5B,MAAQu5B,EAASv5B,MAC1Bs5B,EAASrxB,OAASqxB,EAAS95B,OAC3B+5B,EAASx+B,GAAKu+B,EAAS95B,OACvB+5B,EAAStxB,QAAUqxB,EAAS95B,OAEhCvE,KAAK89B,SAAW,IAAIS,GAAiBF,GAEzCz+B,YAAY8E,IACZ9E,cAAcwC,GACV,MACMk8B,EADWl8B,EAAK27B,UAAY,GAElCO,EAAS5E,MAAO,EAChB15B,KAAK+9B,SAAW,IAAIS,GAAkBF,GAE1C1+B,cAoBI,IAnBAI,KAAKwtB,MAAQ,IAAIxxB,EAAIkhC,GAAGuB,MAAMz+B,KAAKk9B,IACnCl9B,KAAK0C,OAAS1C,KAAKwtB,MAAM9qB,OACzB1C,KAAKkV,GAAKlV,KAAKwtB,MAAMtY,GACrBlV,KAAKq9B,SAAU,EACfr9B,KAAK0+B,UAAY,IAAI1iC,EAAI0iC,UAAUC,UACnC3+B,KAAK89B,SAASve,QACdvf,KAAKY,IAAMZ,KAAKw9B,SAASoB,KAAK5+B,KAAM,GACpCA,KAAK8L,OAAS9L,KAAK09B,YAAYkB,KAAK5+B,MACpCA,KAAKY,IAAIusB,UAAUntB,KAAK8L,QACxB9L,KAAK+9B,SAASnE,QAAU55B,KAAK8L,OAC7B9L,KAAK49B,UAAUgB,KAAK5+B,KAAMA,KAAKY,IAAKZ,KAAK8L,QACrC9L,KAAK0P,QACL1P,KAAKY,IAAI+rB,OAAOjd,MAAQ1P,KAAK0P,OAEjC1P,KAAKY,IAAI0Q,OAAOlM,SAASmM,IACrBvR,KAAK0+B,UAAUl5B,KAAK+L,EAAGA,EAAEjF,gBAE7BtM,KAAKY,IAAIqK,IAAIgC,SACbjN,KAAK06B,OACE16B,KAAKq9B,eACFr9B,KAAK6+B,gBACL7+B,KAAK8+B,UAEf,OAAO9+B,KAAK8N,OAEhBlO,OACII,KAAK+9B,SAASrD,KAAK16B,KAAK0C,QACxB1C,KAAK89B,SAASpD,KAAK16B,KAAK0C,QACpB1C,KAAK0C,OAAOuF,SACZjI,KAAK0C,OAAOq8B,SAEhB/+B,KAAK0C,OAAOuF,SAAU,EAE1BrI,OAAOkO,GACH9N,KAAKq9B,SAAU,EACfr9B,KAAKwtB,MAAM8O,SACXt8B,KAAK8N,OAASA,EAElBlO,gBACI,MAAMoK,EAAQhK,KAAK0+B,UAAUpN,MAC7B,IAAKtnB,EAED,YADAhK,KAAKs8B,SAGT,IAAI0C,EAAW,EACf,KAAoB,IAAbA,GACCh1B,IAAUhK,KAAK8L,OACfkzB,QAAiBh/B,KAAKi/B,WAAWj1B,GAE5B,QAASA,EACdg1B,QAAiBh1B,EAAMk1B,IAAIl/B,MAEtB,SAAUgK,IACfg1B,QAAiBh1B,EAAMqlB,QAE3BrvB,KAAK06B,OAELsE,GAAY,GACZh/B,KAAK0+B,UAAUl5B,KAAKwE,EAAOg1B,GAGnCp/B,gBACI,IAAKI,KAAKwtB,MAAMtY,GAAGiqB,QAAQ56B,OACvB,OACJ,MAAM66B,EAAQC,aAAY,KACtB,MAAMhQ,EAAOrzB,EAAIkZ,GAAGoqB,cAAc,IAClCt/B,KAAKwtB,MAAMtY,GAAGqqB,QAAQlQ,KACvB,IACH,KAAOrvB,KAAKwtB,MAAMtY,GAAGiqB,QAAQ56B,QAAQ,CACjC,MAAMmlB,QAAW1pB,KAAKwtB,MAAMtY,GAAGsqB,WAC3B9V,GAAMA,EAAG0F,KACTpvB,KAAKwtB,MAAMtY,GAAGiqB,QAAQ/5B,SAASmM,GAAMA,GAAKA,EAAE8d,KAAK3F,EAAG0F,MACpDpvB,KAAKwtB,MAAMtY,GAAGiqB,QAAUn/B,KAAKwtB,MAAMtY,GAAGiqB,QAAQvrB,QAAQrC,GAAMA,GAAKA,EAAE+d,eAEvEtvB,KAAK06B,OAET+E,cAAcL,GAElBx/B,iBAAiBkM,GACb,IAAIxD,EAAO,EACX,MAAM82B,EAAQC,aAAY,KACtB,MAAMhQ,EAAOrzB,EAAIkZ,GAAGoqB,cAAc,IAElCt/B,KAAKwtB,MAAMtY,GAAGqqB,QAAQlQ,KACvB,IACH,IAAI9nB,EAAU,EACd,MAAQe,GAAQtI,KAAKq9B,SAAS,CAC1B,MAAM3T,QAAW1pB,KAAKwtB,MAAMtY,GAAGwqB,WAAW,GAC1C,GAAIhW,EACA,GAAIA,EAAGjiB,OAASzL,EAAIkZ,GAAGyqB,SAEnB,GADA3/B,KAAKY,IAAIkuB,YACL9uB,KAAK8L,OAAOwD,UACZtP,KAAK8L,OAAO2C,gBAEX,CACD,MAAMqM,EAAU9e,EAAIkZ,GAAG0qB,WAAWlW,EAAI1pB,KAAKs9B,QAC3C,GAAIxiB,EACA,GAAuB,iBAAZA,EAAsB,CAC7B,MAAMrQ,EAASo1B,GAAmB/kB,GAC9BrQ,IACAnC,QAAamC,EAAOm0B,KAAK5+B,KAAM8L,EAAQ4d,QAGnB,mBAAZ5O,IACZxS,QAAawS,EAAQ8jB,KAAK5+B,KAAM8L,EAAQ4d,SAK/CA,EAAGjiB,OAASzL,EAAIkZ,GAAG4qB,MACxB9/B,KAAKwtB,MAAM6B,KAAK3F,GAChBniB,GAAWmiB,EAAG0F,IAAM,GAChBpvB,KAAK+9B,SAAS1O,KAAK3F,EAAG0F,KACtBpvB,KAAK06B,QAIJ16B,KAAKo9B,OAAS1T,EAAGjiB,OAASzL,EAAIkZ,GAAG6qB,UAClC//B,KAAK+9B,SAASiC,UAAUtW,IACxB1pB,KAAK06B,OAGJ16B,KAAKo9B,OAAS1T,EAAGjiB,OAASzL,EAAIkZ,GAAG+qB,OAEtCjgC,KAAK+9B,SAASxB,MAAM7S,GAG5B,KAAIniB,EAAU,MAGdA,GAAW,GACPvH,KAAK8L,OAAOwD,WAAW,CACvB,MAAMa,EAAOnQ,KAAK8L,OAAOo0B,eACzB,GAAK/vB,EAGA,CACD,MAAM1F,EAAS01B,EAAgB,WAC/B,IAAK11B,EACD,MAAM,IAAI9C,MAAM,kCAEpB,GADAW,QAAamC,EAAOzK,KAAMA,KAAK8L,OAAQ,CAAE6D,IAAKQ,IAC1C7H,GAAQtI,KAAK8L,OAAOwD,UAAW,CAC/B,MAAMlC,EAAUpN,KAAK8L,OAAOsB,QAC5BpN,KAAK+9B,SAASnD,SAASxtB,EAAQvN,EAAGuN,EAAQtN,SAT9CE,KAAK8L,OAAO2C,aAexB,OADAgxB,cAAcL,GACP92B,kEC1NF,QAAS,CAClB0O,GAAI,IACJE,GAAIlb,EAAIqnB,MAAMrf,KAAK,CAAC,GAAI,GAAI,KAAKo8B,KAAK,GAAI,EAAG,EAAG,GAChDjpB,GAAInb,EAAIqnB,MAAMrf,KAAK,CAAC,EAAG,EAAG,KAAKo8B,KAAK,EAAG,EAAG,EAAG,GAC7Cxd,SAAU,GACVE,QAAS,MACTrf,OAAQ,uBAEC,OAAQ,CACjBuT,GAAI,IACJE,GAAI,CAAC,IAAK,GAAI,IACdC,GAAI,CAAC,GAAI,GAAI,IACbyL,SAAU,GACVpiB,MAAO,oFACPsiB,QAAS,IACT1H,QAAS,CACLilB,MAAO,iBACPC,KAAM,yBAEV78B,OAAQ,qBAEC,YAAa,OAAQ,CAC9BuT,GAAI,IACJE,GAAI,CAAC,IAAK,GAAI,IACdC,GAAI,CAAC,GAAI,GAAI,IACbyL,SAAU,GACVpiB,MAAO,oCACPwC,KAAM,YACN8f,QAAS,KACT1H,QAAS,CACLiU,KAAM,CACFpgB,OAAQ,IACRmM,QAAS,eAEbilB,MAAO,KACPC,KAAM,KACNC,MAAO,eAEX98B,OAAQ,oBAEC,mBAAoB,YAAa,CAC1C2X,QAAS,CACLiU,KAAM,KACNkR,MAAO,eAEX98B,OAAQ,oBAEC,YAAa,CACtBuT,GAAI,IACJE,GAAI,CAAC,IAAK,GAAI,IACdC,GAAI,CAAC,GAAI,GAAI,IACbyL,SAAU,IACVpiB,MAAO,2EACPwC,KAAM,mBACN8f,QAAS,KACT1H,QAAS,CACLtP,OAAQ,kBAEZrI,OAAQ,8BAEC,cAAe,CACxBuT,GAAI,IACJE,GAAI,CAAC,IAAK,GAAI,IACdC,GAAI,CAAC,GAAI,GAAI,IACbyL,SAAU,IACVpiB,MAAO,6EACPwC,KAAM,qBACN8f,QAAS,IACT1H,QAAS,CACLtP,OAAQ,oBAEZrI,OAAQ,+BAEC,OAAQ,CACjBuT,GAAI,IACJE,GAAIlb,EAAIqnB,MAAMrf,KAAK,CAAC,EAAG,EAAG,IAAIo8B,KAAK,EAAG,EAAG,EAAG,GAC5CjpB,GAAInb,EAAIqnB,MAAMrf,KAAK,CAAC,GAAI,GAAI,KAAKo8B,KAAK,GAAI,GAAI,EAAG,GACjDxd,SAAU,IACVpiB,MAAO,eACPsiB,QAAS,IACT9f,KAAM,aACNU,YAAa,oCACbD,OAAQ,0BAEC,cAAe,CACxBuT,GAAI,IACJE,GAAIlb,EAAIqnB,MAAMrf,KAAK,CAAC,EAAG,EAAG,IAAIo8B,KAAK,EAAG,EAAG,EAAG,GAC5CjpB,GAAInb,EAAIqnB,MAAMrf,KAAK,CAAC,GAAI,GAAI,KAAKo8B,KAAK,GAAI,GAAI,EAAG,GACjDxd,SAAU,IACVpiB,MAAO,4BACPsiB,QAAS,IACT9f,KAAM,mBACNU,YAAa,oCACbD,OAAQ,wBAEC,OAAQ,CACjBuT,GAAI,IACJE,GAAIlb,EAAIqnB,MAAMrf,KAAK,CAAC,GAAI,GAAI,KAAKw8B,MAAM,GAAI,EAAG,EAAG,IACjDrpB,GAAInb,EAAIqnB,MAAMrf,KAAK,CAAC,GAAI,GAAI,KAAKw8B,MAAM,GAAI,EAAG,EAAG,GACjD5d,SAAU,GACVpiB,MAAO,eACPwC,KAAM,aACN8f,QAAS,MACTrf,OAAQ,uBAEC,UAAW,CACpBuT,GAAI,IACJE,GAAIlb,EAAIqnB,MAAMrf,KAAK,CAAC,EAAG,EAAG,KAAKw8B,MAAM,GAAI,EAAG,EAAG,IAC/CrpB,GAAInb,EAAIqnB,MAAMrf,KAAK,CAAC,GAAI,GAAI,KAAKw8B,MAAM,EAAG,EAAG,GAAI,IACjD5d,SAAU,GACV5f,KAAM,gBACN8f,QAAS,MACTtiB,MAAO,kBAEPiD,OAAQ,0BAEC,SAAU,CACnBuT,GAAI,IACJE,GAAI,CAAC,GAAI,GAAI,IACb0L,SAAU,GACVtiB,MAAO,UACPE,MAAO,gCACPsiB,QAAS,IACTD,WAAY,OACZpf,OAAQ"}