{"version":3,"file":"gw-map.min.js","sources":["../js/flags.js","../js/tileEvent.js","../js/light.js","../js/tile.js","../js/cell.js","../js/map.js","../js/tiles.js"],"sourcesContent":["import { flag as Flag } from \"gw-utils\";\nexport var Layer;\n(function (Layer) {\n    Layer[Layer[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Layer[Layer[\"GROUND\"] = 0] = \"GROUND\";\n    Layer[Layer[\"LIQUID\"] = 1] = \"LIQUID\";\n    Layer[Layer[\"SURFACE\"] = 2] = \"SURFACE\";\n    Layer[Layer[\"GAS\"] = 3] = \"GAS\";\n    Layer[Layer[\"ITEM\"] = 4] = \"ITEM\";\n    Layer[Layer[\"ACTOR\"] = 5] = \"ACTOR\";\n    Layer[Layer[\"PLAYER\"] = 6] = \"PLAYER\";\n    Layer[Layer[\"FX\"] = 7] = \"FX\";\n    Layer[Layer[\"UI\"] = 8] = \"UI\";\n})(Layer || (Layer = {}));\nconst Fl = Flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Activation;\n(function (Activation) {\n    Activation[Activation[\"DFF_SUBSEQ_ALWAYS\"] = Fl(0)] = \"DFF_SUBSEQ_ALWAYS\";\n    Activation[Activation[\"DFF_SUBSEQ_EVERYWHERE\"] = Fl(1)] = \"DFF_SUBSEQ_EVERYWHERE\";\n    Activation[Activation[\"DFF_TREAT_AS_BLOCKING\"] = Fl(2)] = \"DFF_TREAT_AS_BLOCKING\";\n    Activation[Activation[\"DFF_PERMIT_BLOCKING\"] = Fl(3)] = \"DFF_PERMIT_BLOCKING\";\n    Activation[Activation[\"DFF_ACTIVATE_DORMANT_MONSTER\"] = Fl(4)] = \"DFF_ACTIVATE_DORMANT_MONSTER\";\n    Activation[Activation[\"DFF_BLOCKED_BY_OTHER_LAYERS\"] = Fl(6)] = \"DFF_BLOCKED_BY_OTHER_LAYERS\";\n    Activation[Activation[\"DFF_SUPERPRIORITY\"] = Fl(7)] = \"DFF_SUPERPRIORITY\";\n    Activation[Activation[\"DFF_AGGRAVATES_MONSTERS\"] = Fl(8)] = \"DFF_AGGRAVATES_MONSTERS\";\n    Activation[Activation[\"DFF_RESURRECT_ALLY\"] = Fl(9)] = \"DFF_RESURRECT_ALLY\";\n    Activation[Activation[\"DFF_EMIT_EVENT\"] = Fl(10)] = \"DFF_EMIT_EVENT\";\n    Activation[Activation[\"DFF_NO_REDRAW_CELL\"] = Fl(11)] = \"DFF_NO_REDRAW_CELL\";\n    Activation[Activation[\"DFF_ABORT_IF_BLOCKS_MAP\"] = Fl(12)] = \"DFF_ABORT_IF_BLOCKS_MAP\";\n    Activation[Activation[\"DFF_BLOCKED_BY_ITEMS\"] = Fl(13)] = \"DFF_BLOCKED_BY_ITEMS\";\n    Activation[Activation[\"DFF_BLOCKED_BY_ACTORS\"] = Fl(14)] = \"DFF_BLOCKED_BY_ACTORS\";\n    Activation[Activation[\"DFF_ALWAYS_FIRE\"] = Fl(15)] = \"DFF_ALWAYS_FIRE\";\n    Activation[Activation[\"DFF_NO_MARK_FIRED\"] = Fl(16)] = \"DFF_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Activation[Activation[\"DFF_PROTECTED\"] = Fl(19)] = \"DFF_PROTECTED\";\n    Activation[Activation[\"DFF_SPREAD_CIRCLE\"] = Fl(20)] = \"DFF_SPREAD_CIRCLE\";\n    Activation[Activation[\"DFF_SPREAD_LINE\"] = Fl(21)] = \"DFF_SPREAD_LINE\";\n    Activation[Activation[\"DFF_NULL_SURFACE\"] = Fl(22)] = \"DFF_NULL_SURFACE\";\n    Activation[Activation[\"DFF_NULL_LIQUID\"] = Fl(23)] = \"DFF_NULL_LIQUID\";\n    Activation[Activation[\"DFF_NULL_GAS\"] = Fl(24)] = \"DFF_NULL_GAS\";\n    Activation[Activation[\"DFF_EVACUATE_CREATURES\"] = Fl(25)] = \"DFF_EVACUATE_CREATURES\";\n    Activation[Activation[\"DFF_EVACUATE_ITEMS\"] = Fl(26)] = \"DFF_EVACUATE_ITEMS\";\n    Activation[Activation[\"DFF_BUILD_IN_WALLS\"] = Fl(27)] = \"DFF_BUILD_IN_WALLS\";\n    Activation[Activation[\"DFF_MUST_TOUCH_WALLS\"] = Fl(28)] = \"DFF_MUST_TOUCH_WALLS\";\n    Activation[Activation[\"DFF_NO_TOUCH_WALLS\"] = Fl(29)] = \"DFF_NO_TOUCH_WALLS\";\n    Activation[Activation[\"DFF_ONLY_IF_EMPTY\"] = Activation.DFF_BLOCKED_BY_ITEMS | Activation.DFF_BLOCKED_BY_ACTORS] = \"DFF_ONLY_IF_EMPTY\";\n    Activation[Activation[\"DFF_NULLIFY_CELL\"] = Activation.DFF_NULL_SURFACE | Activation.DFF_NULL_LIQUID | Activation.DFF_NULL_GAS] = \"DFF_NULLIFY_CELL\";\n})(Activation || (Activation = {}));\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_LIQUID\"] = Fl(0)] = \"T_LIQUID\";\n    Tile[Tile[\"T_SURFACE\"] = Fl(1)] = \"T_SURFACE\";\n    Tile[Tile[\"T_GAS\"] = Fl(2)] = \"T_GAS\";\n    Tile[Tile[\"T_OBSTRUCTS_PASSABILITY\"] = Fl(3)] = \"T_OBSTRUCTS_PASSABILITY\";\n    Tile[Tile[\"T_OBSTRUCTS_VISION\"] = Fl(4)] = \"T_OBSTRUCTS_VISION\";\n    Tile[Tile[\"T_OBSTRUCTS_ITEMS\"] = Fl(5)] = \"T_OBSTRUCTS_ITEMS\";\n    Tile[Tile[\"T_OBSTRUCTS_SURFACE\"] = Fl(6)] = \"T_OBSTRUCTS_SURFACE\";\n    Tile[Tile[\"T_OBSTRUCTS_GAS\"] = Fl(7)] = \"T_OBSTRUCTS_GAS\";\n    Tile[Tile[\"T_OBSTRUCTS_LIQUID\"] = Fl(8)] = \"T_OBSTRUCTS_LIQUID\";\n    Tile[Tile[\"T_OBSTRUCTS_TILE_EFFECTS\"] = Fl(9)] = \"T_OBSTRUCTS_TILE_EFFECTS\";\n    Tile[Tile[\"T_OBSTRUCTS_DIAGONAL_MOVEMENT\"] = Fl(10)] = \"T_OBSTRUCTS_DIAGONAL_MOVEMENT\";\n    Tile[Tile[\"T_BRIDGE\"] = Fl(11)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(12)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(13)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(14)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(15)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(16)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(17)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(18)] = \"T_ENTANGLES\";\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(24)] = \"T_IS_TRAP\";\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    Tile[Tile[\"T_SACRED\"] = Fl(26)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(27)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(28)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(29)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(30)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_OBSTRUCTS_PASSABILITY |\n        Tile.T_OBSTRUCTS_VISION |\n        Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_OBSTRUCTS_PASSABILITY |\n        Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_OBSTRUCTS_PASSABILITY |\n        Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_OBSTRUCTS_PASSABILITY |\n        Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    Tile[Tile[\"T_OBSTRUCTS_EVERYTHING\"] = Tile.T_OBSTRUCTS_PASSABILITY |\n        Tile.T_OBSTRUCTS_VISION |\n        Tile.T_OBSTRUCTS_ITEMS |\n        Tile.T_OBSTRUCTS_GAS |\n        Tile.T_OBSTRUCTS_SURFACE |\n        Tile.T_OBSTRUCTS_LIQUID |\n        Tile.T_OBSTRUCTS_DIAGONAL_MOVEMENT] = \"T_OBSTRUCTS_EVERYTHING\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_LIQUID\";\n    Tile[Tile[\"T_STAIR_BLOCKERS\"] = Tile.T_OBSTRUCTS_ITEMS |\n        Tile.T_OBSTRUCTS_SURFACE |\n        Tile.T_OBSTRUCTS_GAS |\n        Tile.T_OBSTRUCTS_LIQUID |\n        Tile.T_OBSTRUCTS_TILE_EFFECTS] = \"T_STAIR_BLOCKERS\";\n})(Tile || (Tile = {}));\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    TileMech[TileMech[\"TM_IS_SECRET\"] = Fl(0)] = \"TM_IS_SECRET\";\n    TileMech[TileMech[\"TM_PROMOTES_WITH_KEY\"] = Fl(1)] = \"TM_PROMOTES_WITH_KEY\";\n    TileMech[TileMech[\"TM_PROMOTES_WITHOUT_KEY\"] = Fl(2)] = \"TM_PROMOTES_WITHOUT_KEY\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_STEP\"] = Fl(3)] = \"TM_PROMOTES_ON_STEP\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_ITEM_REMOVE\"] = Fl(4)] = \"TM_PROMOTES_ON_ITEM_REMOVE\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_PLAYER_ENTRY\"] = Fl(5)] = \"TM_PROMOTES_ON_PLAYER_ENTRY\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_SACRIFICE_ENTRY\"] = Fl(6)] = \"TM_PROMOTES_ON_SACRIFICE_ENTRY\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_ELECTRICITY\"] = Fl(7)] = \"TM_PROMOTES_ON_ELECTRICITY\";\n    TileMech[TileMech[\"TM_ALLOWS_SUBMERGING\"] = Fl(8)] = \"TM_ALLOWS_SUBMERGING\";\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_EXTINGUISHES_FIRE\"] = Fl(14)] = \"TM_EXTINGUISHES_FIRE\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_REFLECTS_BOLTS\"] = Fl(16)] = \"TM_REFLECTS_BOLTS\";\n    TileMech[TileMech[\"TM_STAND_IN_TILE\"] = Fl(17)] = \"TM_STAND_IN_TILE\";\n    TileMech[TileMech[\"TM_LIST_IN_SIDEBAR\"] = Fl(18)] = \"TM_LIST_IN_SIDEBAR\";\n    TileMech[TileMech[\"TM_VISUALLY_DISTINCT\"] = Fl(19)] = \"TM_VISUALLY_DISTINCT\";\n    TileMech[TileMech[\"TM_BRIGHT_MEMORY\"] = Fl(20)] = \"TM_BRIGHT_MEMORY\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_CONNECTS_LEVEL\"] = Fl(22)] = \"TM_CONNECTS_LEVEL\";\n    TileMech[TileMech[\"TM_INTERRUPT_EXPLORATION_WHEN_SEEN\"] = Fl(23)] = \"TM_INTERRUPT_EXPLORATION_WHEN_SEEN\";\n    TileMech[TileMech[\"TM_INVERT_WHEN_HIGHLIGHTED\"] = Fl(24)] = \"TM_INVERT_WHEN_HIGHLIGHTED\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    TileMech[TileMech[\"TM_PROMOTES\"] = TileMech.TM_PROMOTES_WITH_KEY |\n        TileMech.TM_PROMOTES_WITHOUT_KEY |\n        TileMech.TM_PROMOTES_ON_STEP |\n        TileMech.TM_PROMOTES_ON_ITEM_REMOVE |\n        TileMech.TM_PROMOTES_ON_SACRIFICE_ENTRY |\n        TileMech.TM_PROMOTES_ON_ELECTRICITY |\n        TileMech.TM_PROMOTES_ON_PLAYER_ENTRY] = \"TM_PROMOTES\";\n})(TileMech || (TileMech = {}));\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"REVEALED\"] = Fl(0)] = \"REVEALED\";\n    Cell[Cell[\"VISIBLE\"] = Fl(1)] = \"VISIBLE\";\n    Cell[Cell[\"WAS_VISIBLE\"] = Fl(2)] = \"WAS_VISIBLE\";\n    Cell[Cell[\"IN_FOV\"] = Fl(3)] = \"IN_FOV\";\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(4)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_MONSTER\"] = Fl(5)] = \"HAS_MONSTER\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(6)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(7)] = \"HAS_ITEM\";\n    Cell[Cell[\"HAS_STAIRS\"] = Fl(8)] = \"HAS_STAIRS\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(9)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"CELL_CHANGED\"] = Fl(10)] = \"CELL_CHANGED\";\n    Cell[Cell[\"IS_IN_PATH\"] = Fl(12)] = \"IS_IN_PATH\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(13)] = \"IS_CURSOR\";\n    Cell[Cell[\"MAGIC_MAPPED\"] = Fl(14)] = \"MAGIC_MAPPED\";\n    Cell[Cell[\"ITEM_DETECTED\"] = Fl(15)] = \"ITEM_DETECTED\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(16)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"CLAIRVOYANT_VISIBLE\"] = Fl(17)] = \"CLAIRVOYANT_VISIBLE\";\n    Cell[Cell[\"WAS_CLAIRVOYANT_VISIBLE\"] = Fl(18)] = \"WAS_CLAIRVOYANT_VISIBLE\";\n    Cell[Cell[\"CLAIRVOYANT_DARKENED\"] = Fl(19)] = \"CLAIRVOYANT_DARKENED\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(20)] = \"IMPREGNABLE\";\n    Cell[Cell[\"TELEPATHIC_VISIBLE\"] = Fl(22)] = \"TELEPATHIC_VISIBLE\";\n    Cell[Cell[\"WAS_TELEPATHIC_VISIBLE\"] = Fl(23)] = \"WAS_TELEPATHIC_VISIBLE\";\n    Cell[Cell[\"MONSTER_DETECTED\"] = Fl(24)] = \"MONSTER_DETECTED\";\n    Cell[Cell[\"WAS_MONSTER_DETECTED\"] = Fl(25)] = \"WAS_MONSTER_DETECTED\";\n    Cell[Cell[\"LIGHT_CHANGED\"] = Fl(27)] = \"LIGHT_CHANGED\";\n    Cell[Cell[\"CELL_LIT\"] = Fl(28)] = \"CELL_LIT\";\n    Cell[Cell[\"IS_IN_SHADOW\"] = Fl(29)] = \"IS_IN_SHADOW\";\n    Cell[Cell[\"CELL_DARK\"] = Fl(30)] = \"CELL_DARK\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.REVEALED |\n        Cell.MAGIC_MAPPED |\n        Cell.ITEM_DETECTED |\n        Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.HAS_STAIRS |\n        Cell.STABLE_MEMORY |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"ANY_KIND_OF_VISIBLE\"] = Cell.VISIBLE | Cell.CLAIRVOYANT_VISIBLE | Cell.TELEPATHIC_VISIBLE] = \"ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"HAS_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_MONSTER] = \"HAS_ACTOR\";\n    Cell[Cell[\"IS_WAS_ANY_KIND_OF_VISIBLE\"] = Cell.VISIBLE |\n        Cell.WAS_VISIBLE |\n        Cell.CLAIRVOYANT_VISIBLE |\n        Cell.WAS_CLAIRVOYANT_VISIBLE |\n        Cell.TELEPATHIC_VISIBLE |\n        Cell.WAS_TELEPATHIC_VISIBLE] = \"IS_WAS_ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.VISIBLE | Cell.IN_FOV | Cell.NEEDS_REDRAW | Cell.CELL_CHANGED] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n///////////////////////////////////////////////////////\n// CELL MECH\nexport var CellMech;\n(function (CellMech) {\n    CellMech[CellMech[\"SEARCHED_FROM_HERE\"] = Fl(0)] = \"SEARCHED_FROM_HERE\";\n    CellMech[CellMech[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(1)] = \"PRESSURE_PLATE_DEPRESSED\";\n    CellMech[CellMech[\"KNOWN_TO_BE_TRAP_FREE\"] = Fl(2)] = \"KNOWN_TO_BE_TRAP_FREE\";\n    CellMech[CellMech[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(4)] = \"CAUGHT_FIRE_THIS_TURN\";\n    CellMech[CellMech[\"EVENT_FIRED_THIS_TURN\"] = Fl(5)] = \"EVENT_FIRED_THIS_TURN\";\n    CellMech[CellMech[\"EVENT_PROTECTED\"] = Fl(6)] = \"EVENT_PROTECTED\";\n    CellMech[CellMech[\"IS_IN_LOOP\"] = Fl(10)] = \"IS_IN_LOOP\";\n    CellMech[CellMech[\"IS_CHOKEPOINT\"] = Fl(11)] = \"IS_CHOKEPOINT\";\n    CellMech[CellMech[\"IS_GATE_SITE\"] = Fl(12)] = \"IS_GATE_SITE\";\n    CellMech[CellMech[\"IS_IN_ROOM_MACHINE\"] = Fl(13)] = \"IS_IN_ROOM_MACHINE\";\n    CellMech[CellMech[\"IS_IN_AREA_MACHINE\"] = Fl(14)] = \"IS_IN_AREA_MACHINE\";\n    CellMech[CellMech[\"IS_POWERED\"] = Fl(15)] = \"IS_POWERED\";\n    CellMech[CellMech[\"IS_IN_MACHINE\"] = CellMech.IS_IN_ROOM_MACHINE | CellMech.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    CellMech[CellMech[\"PERMANENT_MECH_FLAGS\"] = CellMech.SEARCHED_FROM_HERE |\n        CellMech.PRESSURE_PLATE_DEPRESSED |\n        CellMech.KNOWN_TO_BE_TRAP_FREE |\n        CellMech.IS_IN_LOOP |\n        CellMech.IS_CHOKEPOINT |\n        CellMech.IS_GATE_SITE |\n        CellMech.IS_IN_MACHINE] = \"PERMANENT_MECH_FLAGS\";\n})(CellMech || (CellMech = {}));\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_STABLE_GLOW_LIGHTS\"] = Fl(1)] = \"MAP_STABLE_GLOW_LIGHTS\";\n    Map[Map[\"MAP_STABLE_LIGHTS\"] = Fl(2)] = \"MAP_STABLE_LIGHTS\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(7)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = Map.MAP_STABLE_LIGHTS | Map.MAP_STABLE_GLOW_LIGHTS | Map.MAP_FOV_CHANGED] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import { utils as Utils, random, grid as Grid, events as Events, color as Color, flag as Flag, data as Data, message as Msg, make as Make, } from \"gw-utils\";\nimport { Layer, Activation as Flags, Tile as TileFlags, CellMech as CellMechFlags, } from \"./flags\";\nimport * as Tile from \"./tile\";\nexport { Flags };\nexport class TileEvent {\n    constructor(opts = {}) {\n        if (typeof opts === \"function\") {\n            opts = {\n                fn: opts,\n            };\n        }\n        this.tile = opts.tile || null;\n        this.fn = opts.fn || null;\n        this.item = opts.item || null;\n        this.chance = opts.chance || 0;\n        this.volume = opts.volume || 0;\n        // spawning pattern:\n        this.spread = opts.spread || 0;\n        this.radius = opts.radius || 0;\n        this.decrement = opts.decrement || 0;\n        this.flags = Flag.from(Flags, opts.flags);\n        this.matchTile = opts.matchTile || opts.needs || 0; /* ENUM tileType */\n        this.next = opts.next || null; /* ENUM makeEventTypes */\n        this.message = opts.message || null;\n        this.lightFlare = opts.flare || null;\n        this.flashColor = opts.flash ? Color.from(opts.flash) : null;\n        // this.effectRadius = radius || 0;\n        this.messageDisplayed = false;\n        this.emit = opts.emit || null; // name of the event to emit when activated\n        this.id = opts.id || null;\n    }\n}\nexport function make(opts) {\n    if (!opts)\n        return null;\n    if (typeof opts === \"string\") {\n        opts = { tile: opts };\n    }\n    const te = new TileEvent(opts);\n    return te;\n}\nMake.tileEvent = make;\nexport const activations = {\n    DF_NONE: null,\n};\nexport function install(id, event) {\n    if (!(event instanceof TileEvent)) {\n        event = make(event);\n    }\n    activations[id] = event;\n    if (event)\n        event.id = id;\n    return event;\n}\nexport function resetAllMessages() {\n    Object.values(activations).forEach((f) => {\n        if (f instanceof TileEvent) {\n            f.messageDisplayed = false;\n        }\n    });\n}\n// returns whether the feature was successfully generated (false if we aborted because of blocking)\nexport async function spawn(activation, ctx = {}) {\n    let i, j;\n    if (!activation)\n        return false;\n    if (!ctx)\n        return false;\n    let feat;\n    if (typeof activation === \"string\") {\n        // @ts-ignore\n        feat = activations[activation];\n        if (!feat)\n            Utils.ERROR(\"Unknown tile Event: \" + activation);\n    }\n    else if (typeof activation === \"function\") {\n        return activation(ctx);\n    }\n    else {\n        feat = activation;\n    }\n    const map = ctx.map;\n    const x = ctx.x;\n    const y = ctx.y;\n    if (!map || x === undefined || y === undefined) {\n        Utils.ERROR(\"MAP, x, y are required in context.\");\n    }\n    if (ctx.safe &&\n        map.hasCellMechFlag(x, y, CellMechFlags.EVENT_FIRED_THIS_TURN)) {\n        if (!(feat.flags & Flags.DFF_ALWAYS_FIRE)) {\n            // Activation.debug('spawn - already fired.');\n            return false;\n        }\n    }\n    // Activation.debug('spawn', x, y, 'id=', feat.id, 'tile=', feat.tile, 'item=', feat.item);\n    ctx.refreshCell = ctx.refreshCell || !(feat.flags & Flags.DFF_NO_REDRAW_CELL);\n    const abortIfBlocking = (ctx.abortIfBlocking =\n        ctx.abortIfBlocking || feat.flags & Flags.DFF_ABORT_IF_BLOCKS_MAP);\n    // if ((feat.flags & DFF_RESURRECT_ALLY) && !resurrectAlly(x, y))\n    // {\n    //     return false;\n    // }\n    if (feat.message &&\n        feat.message.length &&\n        !feat.messageDisplayed &&\n        map.isVisible(x, y)) {\n        feat.messageDisplayed = true;\n        Msg.add(feat.message);\n    }\n    let tile = null;\n    if (feat.tile) {\n        tile = Tile.tiles[feat.tile] || null;\n        if (!tile) {\n            Utils.ERROR(\"Unknown tile: \" + feat.tile);\n        }\n    }\n    let item = null;\n    if (feat.item && \"item\" in Make) {\n        item = Make.item(feat.item);\n        if (!item) {\n            Utils.ERROR(\"Unknown item: \" + feat.item);\n        }\n    }\n    // Blocking keeps track of whether to abort if it turns out that the DF would obstruct the level.\n    const blocking = (ctx.blocking =\n        abortIfBlocking &&\n            !(feat.flags & Flags.DFF_PERMIT_BLOCKING) &&\n            ((tile && tile.flags & TileFlags.T_PATHING_BLOCKER) ||\n                (item && item.blocksMove()) ||\n                feat.flags & Flags.DFF_TREAT_AS_BLOCKING)\n            ? true\n            : false);\n    // Activation.debug('- blocking', blocking);\n    const spawnMap = Grid.alloc(map.width, map.height);\n    let didSomething = false;\n    computeSpawnMap(feat, spawnMap, ctx);\n    if (!blocking ||\n        !map.gridDisruptsPassability(spawnMap, { bounds: ctx.bounds })) {\n        if (feat.flags & Flags.DFF_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (feat.flags & Flags.DFF_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (feat.flags & Flags.DFF_NULLIFY_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (nullifyCells(map, spawnMap, feat.flags)) {\n                didSomething = true;\n            }\n        }\n        if (tile || item || feat.fn) {\n            if (await spawnTiles(feat, spawnMap, ctx, tile, item)) {\n                didSomething = true;\n            }\n        }\n    }\n    if (item) {\n        item.delete();\n    }\n    if (didSomething && feat.flags & Flags.DFF_PROTECTED) {\n        spawnMap.forEach((v, i, j) => {\n            if (!v)\n                return;\n            const cell = map.cell(i, j);\n            cell.mechFlags |= CellMechFlags.EVENT_PROTECTED;\n        });\n    }\n    if (didSomething) {\n        // if ((feat.flags & Flags.DFF_AGGRAVATES_MONSTERS) && feat.effectRadius) {\n        //     await aggravateMonsters(feat.effectRadius, x, y, /* Color. */gray);\n        // }\n        // if (refreshCell && feat.flashColor && feat.effectRadius) {\n        //     await colorFlash(feat.flashColor, 0, (IN_FOV | CLAIRVOYANT_VISIBLE), 4, feat.effectRadius, x, y);\n        // }\n        // if (refreshCell && feat.lightFlare) {\n        //     createFlare(x, y, feat.lightFlare);\n        // }\n    }\n    // if (refreshCell && feat.tile\n    // \t&& (tile.flags & (TileFlags.T_IS_FIRE | TileFlags.T_AUTO_DESCENT))\n    // \t&& map.hasTileFlag(PLAYER.xLoc, PLAYER.yLoc, (TileFlags.T_IS_FIRE | TileFlags.T_AUTO_DESCENT)))\n    // {\n    // \tawait applyInstantTileEffectsToCreature(PLAYER);\n    // }\n    // apply tile effects\n    if (didSomething) {\n        for (let i = 0; i < spawnMap.width; ++i) {\n            for (let j = 0; j < spawnMap.height; ++j) {\n                const v = spawnMap[i][j];\n                if (!v || Data.gameHasEnded)\n                    continue;\n                const cell = map.cell(i, j);\n                if (cell.actor || cell.item) {\n                    for (let t of cell.tiles()) {\n                        await t.applyInstantEffects(map, i, j, cell);\n                        if (Data.gameHasEnded) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (feat.emit) {\n        await Events.emit(feat.emit, ctx);\n        didSomething = true;\n    }\n    if (Data.gameHasEnded) {\n        Grid.free(spawnMap);\n        return didSomething;\n    }\n    //\tif (succeeded && feat.message[0] && !feat.messageDisplayed && isVisible(x, y)) {\n    //\t\tfeat.messageDisplayed = true;\n    //\t\tmessage(feat.message, false);\n    //\t}\n    if (feat.next && (didSomething || feat.flags & Flags.DFF_SUBSEQ_ALWAYS)) {\n        // Activation.debug('- subsequent: %s, everywhere=%s', feat.next, feat.flags & Flags.DFF_SUBSEQ_EVERYWHERE);\n        if (feat.flags & Flags.DFF_SUBSEQ_EVERYWHERE) {\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j]) {\n                        ctx.x = i;\n                        ctx.y = j;\n                        await spawn(feat.next, ctx);\n                    }\n                }\n            }\n            ctx.x = x;\n            ctx.y = y;\n        }\n        else {\n            await spawn(feat.next, ctx);\n        }\n    }\n    if (didSomething) {\n        if (tile &&\n            tile.flags &\n                (TileFlags.T_DEEP_WATER | TileFlags.T_LAVA | TileFlags.T_AUTO_DESCENT)) {\n            Data.updateMapToShoreThisTurn = false;\n        }\n        // awaken dormant creatures?\n        // if (feat.flags & Flags.DFF_ACTIVATE_DORMANT_MONSTER) {\n        //     for (monst of map.dormant) {\n        //         if (monst.x == x && monst.y == y || spawnMap[monst.x][monst.y]) {\n        //             // found it!\n        //             toggleMonsterDormancy(monst);\n        //         }\n        //     }\n        // }\n    }\n    if (didSomething) {\n        spawnMap.forEach((v, i, j) => {\n            if (v)\n                map.redrawXY(i, j);\n        });\n        map.changed(true);\n        if (!(feat.flags & Flags.DFF_NO_MARK_FIRED)) {\n            spawnMap.forEach((v, i, j) => {\n                if (v) {\n                    map.setCellFlags(i, j, 0, CellMechFlags.EVENT_FIRED_THIS_TURN);\n                }\n            });\n        }\n    }\n    // Activation.debug('- spawn complete : @%d,%d, ok=%s, feat=%s', ctx.x, ctx.y, didSomething, feat.id);\n    Grid.free(spawnMap);\n    return didSomething;\n}\nfunction cellIsOk(feat, x, y, ctx = {}) {\n    const map = ctx.map;\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (feat.flags & Flags.DFF_BUILD_IN_WALLS) {\n        if (!cell.isWall())\n            return false;\n    }\n    else if (feat.flags & Flags.DFF_MUST_TOUCH_WALLS) {\n        let ok = false;\n        map.eachNeighbor(x, y, (c) => {\n            if (c.isWall()) {\n                ok = true;\n            }\n        });\n        if (!ok)\n            return false;\n    }\n    else if (feat.flags & Flags.DFF_NO_TOUCH_WALLS) {\n        let ok = true;\n        map.eachNeighbor(x, y, (c) => {\n            if (c.isWall()) {\n                ok = false;\n            }\n        });\n        if (!ok)\n            return false;\n    }\n    if (ctx.bounds && !ctx.bounds.containsXY(x, y))\n        return false;\n    if (feat.matchTile && !cell.hasTile(feat.matchTile))\n        return false;\n    if (cell.hasTileFlag(TileFlags.T_OBSTRUCTS_TILE_EFFECTS) &&\n        !feat.matchTile &&\n        (ctx.x != x || ctx.y != y))\n        return false;\n    return true;\n}\nexport function computeSpawnMap(feat, spawnMap, ctx = {}) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    const map = ctx.map;\n    const x = ctx.x;\n    const y = ctx.y;\n    const bounds = ctx.bounds || null;\n    if (bounds) {\n        // Activation.debug('- bounds', bounds);\n    }\n    let startProb = feat.spread || 0;\n    let probDec = feat.decrement || 0;\n    if (feat.matchTile && typeof feat.matchTile === \"string\") {\n        const name = feat.matchTile;\n        const tile = Tile.tiles[name];\n        if (!tile) {\n            Utils.ERROR(\"Failed to find match tile with name:\" + name);\n        }\n        feat.matchTile = tile.id;\n    }\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let radius = feat.radius || 0;\n    if (feat.flags & Flags.DFF_SPREAD_CIRCLE) {\n        radius = 0;\n        startProb = startProb || 100;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        while (random.chance(startProb)) {\n            startProb -= probDec;\n            ++radius;\n        }\n        startProb = 100;\n        probDec = 0;\n    }\n    if (radius) {\n        startProb = startProb || 100;\n        spawnMap.updateCircle(x, y, radius, (_v, i, j) => {\n            if (!cellIsOk(feat, i, j, ctx))\n                return 0;\n            const dist = Math.floor(Utils.distanceBetween(x, y, i, j));\n            const prob = startProb - dist * probDec;\n            if (!random.chance(prob))\n                return 0;\n            return 1;\n        });\n        spawnMap[x][y] = 1;\n    }\n    else if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (feat.flags & Flags.DFF_SPREAD_LINE) {\n            x2 = x;\n            y2 = y;\n            const dir = Utils.DIRS[random.number(4)];\n            while (madeChange) {\n                madeChange = false;\n                x2 = x2 + dir[0];\n                y2 = y2 + dir[1];\n                if (spawnMap.hasXY(x2, y2) &&\n                    !spawnMap[x2][y2] &&\n                    cellIsOk(feat, x2, y2, ctx) &&\n                    random.chance(startProb)) {\n                    spawnMap[x2][y2] = 1;\n                    madeChange = true;\n                    startProb -= probDec;\n                }\n            }\n        }\n        else {\n            if (probDec <= 0)\n                probDec = startProb;\n            while (madeChange && startProb > 0) {\n                madeChange = false;\n                t++;\n                for (i = 0; i < map.width; i++) {\n                    for (j = 0; j < map.height; j++) {\n                        if (spawnMap[i][j] == t - 1) {\n                            for (dir = 0; dir < 4; dir++) {\n                                x2 = i + Utils.DIRS[dir][0];\n                                y2 = j + Utils.DIRS[dir][1];\n                                if (spawnMap.hasXY(x2, y2) &&\n                                    !spawnMap[x2][y2] &&\n                                    cellIsOk(feat, x2, y2, ctx) &&\n                                    random.chance(startProb)) {\n                                    spawnMap[x2][y2] = t;\n                                    madeChange = true;\n                                }\n                            }\n                        }\n                    }\n                }\n                startProb -= probDec;\n            }\n        }\n    }\n    if (!cellIsOk(feat, x, y, ctx)) {\n        spawnMap[x][y] = 0;\n    }\n}\nexport async function spawnTiles(feat, spawnMap, ctx, tile, item) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = feat.flags & Flags.DFF_BLOCKED_BY_OTHER_LAYERS;\n    const superpriority = feat.flags & Flags.DFF_SUPERPRIORITY;\n    const applyEffects = ctx.refreshCell;\n    const map = ctx.map;\n    const volume = ctx.volume || feat.volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.mechFlags & CellMechFlags.EVENT_PROTECTED)\n                continue;\n            if (tile) {\n                if (cell.layers[tile.layer] === tile.id) {\n                    // If the new cell does not already contains the fill terrain,\n                    if (tile.layer == Layer.GAS) {\n                        spawnMap[i][j] = 1;\n                        cell.gasVolume += volume;\n                    }\n                    else if (tile.layer == Layer.LIQUID) {\n                        spawnMap[i][j] = 1;\n                        cell.liquidVolume += volume;\n                    }\n                }\n                else if ((superpriority || cell.tile(tile.layer).priority < tile.priority) && // If the terrain in the layer to be overwritten has a higher priority number (unless superpriority),\n                    !cell.obstructsLayer(tile.layer) && // If we will be painting into the surface layer when that cell forbids it,\n                    (!cell.item || !(feat.flags & Flags.DFF_BLOCKED_BY_ITEMS)) &&\n                    (!cell.actor || !(feat.flags & Flags.DFF_BLOCKED_BY_ACTORS)) &&\n                    (!blockedByOtherLayers ||\n                        cell.highestPriorityTile().priority < tile.priority)) {\n                    // if the fill won't violate the priority of the most important terrain in this cell:\n                    spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                    map.setTile(i, j, tile, volume);\n                    // map.redrawCell(cell);\n                    // if (volume && cell.gas) {\n                    //     cell.volume += (feat.volume || 0);\n                    // }\n                    // debug('- tile', i, j, 'tile=', tile.id);\n                    // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                    accomplishedSomething = true;\n                }\n            }\n            if (item) {\n                if (superpriority || !cell.item) {\n                    if (!cell.hasTileFlag(TileFlags.T_OBSTRUCTS_ITEMS)) {\n                        spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                        if (cell.item) {\n                            map.removeItem(cell.item);\n                        }\n                        const clone = item.clone();\n                        map.addItem(i, j, clone);\n                        // map.redrawCell(cell);\n                        // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                        accomplishedSomething = true;\n                        // Activation.debug('- item', i, j, 'item=', itemKind.id);\n                    }\n                }\n            }\n            if (feat.fn) {\n                ctx.spawnMap = spawnMap;\n                if (await feat.fn(i, j, ctx)) {\n                    spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                    // map.redrawCell(cell);\n                    // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                    accomplishedSomething = true;\n                }\n            }\n            if (applyEffects) {\n                // if (PLAYER.xLoc == i && PLAYER.yLoc == j && !PLAYER.status.levitating && refresh) {\n                // \tflavorMessage(tileFlavor(PLAYER.xLoc, PLAYER.yLoc));\n                // }\n                // if (cell.actor || cell.item) {\n                // \tfor(let t of cell.tiles()) {\n                // \t\tawait t.applyInstantEffects(map, i, j, cell);\n                // \t\tif (Data.gameHasEnded) {\n                // \t\t\treturn true;\n                // \t\t}\n                // \t}\n                // }\n                // if (tile.flags & TileFlags.T_IS_FIRE) {\n                // \tif (cell.flags & CellFlags.HAS_ITEM) {\n                // \t\ttheItem = map.itemAt(i, j);\n                // \t\tif (theItem.flags & Flags.Item.ITEM_FLAMMABLE) {\n                // \t\t\tawait burnItem(theItem);\n                // \t\t}\n                // \t}\n                // }\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.changed(true);\n    }\n    return accomplishedSomething;\n}\nexport function nullifyCells(map, spawnMap, flags) {\n    let didSomething = false;\n    const nullSurface = flags & Flags.DFF_NULL_SURFACE;\n    const nullLiquid = flags & Flags.DFF_NULL_LIQUID;\n    const nullGas = flags & Flags.DFF_NULL_GAS;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        map.clearCellLayers(i, j, !!nullLiquid, !!nullSurface, !!nullGas);\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let i, j;\n    let didSomething = false;\n    for (i = 0; i < map.width; i++) {\n        for (j = 0; j < map.height; j++) {\n            if (!blockingMap[i][j])\n                continue;\n            const cell = map.cell(i, j);\n            if (!cell.actor)\n                continue;\n            const monst = cell.actor;\n            const loc = map.matchingLocNear(i, j, (cell) => {\n                return !monst.forbidsCell(cell);\n            }, { hallways: true, blockingMap });\n            if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                map.moveActor(loc[0], loc[1], monst);\n                // map.redrawXY(loc[0], loc[1]);\n                didSomething = true;\n            }\n        }\n    }\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    blockingMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (!cell.item)\n            return;\n        const item = cell.item;\n        const loc = map.matchingLocNear(i, j, (dest) => {\n            return !item.forbidsCell(dest);\n        }, { hallways: true, blockingMap });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(item);\n            map.addItem(loc[0], loc[1], item);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import { utils as Utils, range as Range, grid as Grid, color as Color, data as DATA, config as CONFIG, make as Make, } from \"gw-utils\";\nimport * as Flags from \"./flags\";\n// const LIGHT_SMOOTHING_THRESHOLD = 150;       // light components higher than this magnitude will be toned down a little\nexport const config = (CONFIG.light = { INTENSITY_DARK: 20 }); // less than 20% for highest color in rgb\nconst LIGHT_COMPONENTS = Color.make();\nexport class Light {\n    constructor(color, range, fadeTo, pass = false) {\n        this.fadeTo = 0;\n        this.passThroughActors = false;\n        this.id = null;\n        this.color = Color.from(color) || null; /* color */\n        this.radius = Range.make(range || 1);\n        this.fadeTo = fadeTo || 0;\n        this.passThroughActors = pass; // generally no, but miner light does (TODO - string parameter?  'false' or 'true')\n    }\n    copy(other) {\n        this.color = other.color;\n        this.radius.copy(other.radius);\n        this.fadeTo = other.fadeTo;\n        this.passThroughActors = other.passThroughActors;\n    }\n    get intensity() {\n        return intensity(this.color);\n    }\n    // Returns true if any part of the light hit cells that are in the player's field of view.\n    paint(map, x, y, maintainShadows = false, isMinersLight = false) {\n        if (!map)\n            return;\n        let k;\n        // let colorComponents = [0,0,0];\n        let lightMultiplier;\n        let radius = this.radius.value();\n        let outerRadius = Math.ceil(radius);\n        // calcLightComponents(colorComponents, this);\n        LIGHT_COMPONENTS.copy(this.color).bake();\n        // console.log('paint', LIGHT_COMPONENTS.toString(true), x, y, outerRadius);\n        // the miner's light does not dispel IS_IN_SHADOW,\n        // so the player can be in shadow despite casting his own light.\n        const dispelShadows = !isMinersLight &&\n            !maintainShadows &&\n            intensity(LIGHT_COMPONENTS) > config.INTENSITY_DARK;\n        const fadeToPercent = this.fadeTo;\n        const grid = Grid.alloc(map.width, map.height, 0);\n        map.calcFov(grid, x, y, outerRadius, this.passThroughActors ? 0 : Flags.Cell.HAS_ACTOR, Flags.Tile.T_OBSTRUCTS_VISION);\n        let overlappedFieldOfView = false;\n        grid.forCircle(x, y, outerRadius, (v, i, j) => {\n            if (!v)\n                return;\n            const cell = map.cell(i, j);\n            lightMultiplier = Math.floor(100 -\n                (100 - fadeToPercent) * (Utils.distanceBetween(x, y, i, j) / radius));\n            for (k = 0; k < 3; k++) {\n                cell.light[k] += Math.floor((LIGHT_COMPONENTS[k] * lightMultiplier) / 100);\n            }\n            if (dispelShadows) {\n                cell.flags &= ~Flags.Cell.IS_IN_SHADOW;\n            }\n            if (cell.flags & (Flags.Cell.IN_FOV | Flags.Cell.ANY_KIND_OF_VISIBLE)) {\n                overlappedFieldOfView = true;\n            }\n            // console.log(i, j, lightMultiplier, cell.light);\n        });\n        if (dispelShadows) {\n            const cell = map.cell(x, y);\n            cell.flags &= ~Flags.Cell.IS_IN_SHADOW;\n        }\n        Grid.free(grid);\n        return overlappedFieldOfView;\n    }\n}\nexport function intensity(color) {\n    return Math.max(color[0], color[1], color[2]);\n}\nexport function make(...args) {\n    if (args.length == 1) {\n        const config = args[0];\n        if (typeof config === \"string\") {\n            const cached = lights[config];\n            if (cached)\n                return cached;\n            const [color, radius, fadeTo, pass] = config\n                .split(/[,|]/)\n                .map((t) => t.trim());\n            return new Light(Color.from(color), Range.from(radius || 1), Number.parseInt(fadeTo || \"0\"), !!pass && pass !== \"false\");\n        }\n        else if (Array.isArray(config)) {\n            const [color, radius, fadeTo, pass] = config;\n            return new Light(color, radius, fadeTo, pass);\n        }\n        else if (config && config.color) {\n            return new Light(Color.from(config.color), Range.from(config.radius), Number.parseInt(config.fadeTo || \"0\"), config.pass);\n        }\n        else {\n            throw new Error(\"Unknown Light config - \" + config);\n        }\n    }\n    else {\n        const [color, radius, fadeTo, pass] = args;\n        return new Light(color, radius, fadeTo, pass);\n    }\n}\nMake.light = make;\nexport const lights = {};\nexport function from(...args) {\n    if (args.length != 1)\n        Utils.ERROR(\"Unknown Light config: \" + JSON.stringify(args));\n    const arg = args[0];\n    if (typeof arg === \"string\") {\n        const cached = lights[arg];\n        if (cached)\n            return cached;\n    }\n    return make(arg);\n}\nexport function install(id, ...args) {\n    let source;\n    if (args.length == 1) {\n        source = make(args[0]);\n    }\n    else {\n        source = make(args[0], args[1], args[2], args[3]);\n    }\n    lights[id] = source;\n    if (source)\n        source.id = id;\n    return source;\n}\nexport function installAll(config = {}) {\n    const entries = Object.entries(config);\n    entries.forEach(([name, info]) => {\n        install(name, info);\n    });\n}\n// export function calcLightComponents(colorComponents, theLight) {\n// \tconst randComponent = cosmetic.range(0, theLight.color.rand);\n// \tcolorComponents[0] = randComponent + theLight.color.red + cosmetic.range(0, theLight.color.redRand);\n// \tcolorComponents[1] = randComponent + theLight.color.green + cosmetic.range(0, theLight.color.greenRand);\n// \tcolorComponents[2] = randComponent + theLight.color.blue + cosmetic.range(0, theLight.color.blueRand);\n// }\nfunction updateDisplayDetail(map) {\n    map.eachCell((cell, _i, _j) => {\n        // clear light flags\n        cell.flags &= ~(Flags.Cell.CELL_LIT | Flags.Cell.CELL_DARK);\n        if (cell.light.some((v, i) => v !== cell.oldLight[i])) {\n            cell.flags |= Flags.Cell.LIGHT_CHANGED;\n        }\n        if (cell.isDark()) {\n            cell.flags |= Flags.Cell.CELL_DARK;\n        }\n        else if (!(cell.flags & Flags.Cell.IS_IN_SHADOW)) {\n            cell.flags |= Flags.Cell.CELL_LIT;\n        }\n    });\n}\nexport function backUpLighting(map, lights) {\n    let k;\n    map.eachCell((cell, i, j) => {\n        for (k = 0; k < 3; k++) {\n            lights[i][j][k] = cell.light[k];\n        }\n    });\n}\nexport function restoreLighting(map, lights) {\n    let k;\n    map.eachCell((cell, i, j) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = lights[i][j][k];\n        }\n    });\n}\nexport function recordOldLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.oldLight[k] = cell.light[k];\n            cell.flags &= ~Flags.Cell.LIGHT_CHANGED;\n        }\n    });\n}\nexport function zeroOutLights(map) {\n    let k;\n    const light = map.ambientLight ? map.ambientLight : [0, 0, 0];\n    map.eachCell((cell, _i, _j) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = light[k];\n        }\n        cell.flags |= Flags.Cell.IS_IN_SHADOW;\n    });\n}\nexport function recordGlowLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.glowLight[k] = cell.light[k];\n        }\n    });\n}\nexport function restoreGlowLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = cell.glowLight[k];\n        }\n    });\n}\nexport function updateLighting(map) {\n    // Copy Light over oldLight\n    recordOldLights(map);\n    if (map.flags & Flags.Map.MAP_STABLE_LIGHTS)\n        return false;\n    // and then zero out Light.\n    zeroOutLights(map);\n    if (map.flags & Flags.Map.MAP_STABLE_GLOW_LIGHTS) {\n        restoreGlowLights(map);\n    }\n    else {\n        // GW.debug.log('painting glow lights.');\n        // Paint all glowing tiles.\n        map.eachGlowLight((light, x, y) => {\n            //   const light = lights[id];\n            if (light) {\n                light.paint(map, x, y);\n            }\n        });\n        recordGlowLights(map);\n        map.setFlag(Flags.Map.MAP_STABLE_GLOW_LIGHTS);\n    }\n    // Cycle through monsters and paint their lights:\n    map.eachDynamicLight((light, x, y) => {\n        light.paint(map, x, y);\n        // if (monst.mutationIndex >= 0 && mutationCatalog[monst.mutationIndex].light != lights['NO_LIGHT']) {\n        //     paint(map, mutationCatalog[monst.mutationIndex].light, actor.x, actor.y, false, false);\n        // }\n        // if (actor.isBurning()) { // monst.status.burning && !(actor.kind.flags & Flags.Actor.AF_FIERY)) {\n        // \tpaint(map, lights.BURNING_CREATURE, actor.x, actor.y, false, false);\n        // }\n        // if (actor.isTelepathicallyRevealed()) {\n        // \tpaint(map, lights['TELEPATHY_LIGHT'], actor.x, actor.y, false, true);\n        // }\n    });\n    // Also paint telepathy lights for dormant monsters.\n    // for (monst of map.dormantMonsters) {\n    //     if (monsterTelepathicallyRevealed(monst)) {\n    //         paint(map, lights['TELEPATHY_LIGHT'], monst.xLoc, monst.yLoc, false, true);\n    //     }\n    // }\n    updateDisplayDetail(map);\n    // Miner's light:\n    const PLAYER = DATA.player;\n    if (PLAYER) {\n        const MINERS_LIGHT = lights.MINERS_LIGHT;\n        if (MINERS_LIGHT && MINERS_LIGHT.radius) {\n            MINERS_LIGHT.paint(map, PLAYER.x, PLAYER.y, true, true);\n        }\n    }\n    map.setFlag(Flags.Map.MAP_STABLE_LIGHTS);\n    // if (PLAYER.status.invisible) {\n    //     PLAYER.info.foreColor = playerInvisibleColor;\n    // } else if (playerInDarkness()) {\n    // \tPLAYER.info.foreColor = playerInDarknessColor;\n    // } else if (pmap[PLAYER.xLoc][PLAYER.yLoc].flags & IS_IN_SHADOW) {\n    // \tPLAYER.info.foreColor = playerInShadowColor;\n    // } else {\n    // \tPLAYER.info.foreColor = playerInLightColor;\n    // }\n    return true;\n}\n// TODO - Move and make more generic\nexport function playerInDarkness(map, PLAYER, darkColor) {\n    const cell = map.cell(PLAYER.x, PLAYER.y);\n    return (cell.light[0] + 10 < darkColor.r &&\n        cell.light[1] + 10 < darkColor.g &&\n        cell.light[2] + 10 < darkColor.b);\n}\n","import { flag as Flag, utils as Utils, color as Color, canvas as Canvas, make as Make, } from \"gw-utils\";\nimport { Tile as Flags, TileMech as MechFlags, Layer } from \"./flags\";\nimport * as TileEvent from \"./tileEvent\";\nimport * as Light from \"./light\";\nexport { Flags, MechFlags, Layer };\n/** Tile Class */\nexport class Tile {\n    /**\n     * Creates a new Tile object.\n     * @param {Object} [config={}] - The configuration of the Tile\n     * @param {String|Number|String[]} [config.flags=0] - Flags and MechFlags for the tile\n     * @param {String} [config.layer=GROUND] - Name of the layer for this tile\n     * @param {String} [config.ch] - The sprite character\n     * @param {String} [config.fg] - The sprite foreground color\n     * @param {String} [config.bg] - The sprite background color\n     */\n    constructor(config, base) {\n        this.flags = 0;\n        this.mechFlags = 0;\n        this.layer = Layer.GROUND;\n        this.priority = -1;\n        this.activates = {};\n        this.light = null; // TODO - Light\n        this.flavor = null;\n        this.desc = null;\n        this.article = null;\n        this.dissipate = 2000; // 20 * 100 = 20%\n        if (base) {\n            Utils.assignOmitting([\"activates\", \"ch\", \"fg\", \"bg\", \"opacity\"], this, base);\n        }\n        Utils.assignOmitting([\n            \"Extends\",\n            \"extends\",\n            \"flags\",\n            \"mechFlags\",\n            \"sprite\",\n            \"activates\",\n            \"ch\",\n            \"fg\",\n            \"bg\",\n            \"opacity\",\n            \"light\",\n        ], this, config);\n        this.name = config.name || (base ? base.name : config.id);\n        this.id = config.id;\n        this.sprite = new Canvas.Sprite(Utils.first(config.ch, base ? base.sprite.ch : -1), Utils.first(config.fg, base ? base.sprite.fg : -1), Utils.first(config.bg, base ? base.sprite.bg : -1), Utils.first(config.opacity, base ? base.sprite.opacity : 100));\n        this.layer = this.layer || Layer.GROUND;\n        if (typeof this.layer === \"string\") {\n            this.layer = Layer[this.layer];\n        }\n        if (this.priority < 0) {\n            this.priority = 50;\n        }\n        this.flags = Flag.from(Flags, this.flags, config.flags);\n        this.mechFlags = Flag.from(MechFlags, this.mechFlags, config.mechFlags || config.flags);\n        if (config.light) {\n            // Light.from will throw an Error on invalid config\n            this.light = Light.from(config.light);\n        }\n        if (base && base.activates) {\n            Object.assign(this.activates, base.activates);\n        }\n        if (config.activates) {\n            Object.entries(config.activates).forEach(([key, info]) => {\n                if (info) {\n                    const activation = TileEvent.make(info);\n                    this.activates[key] = activation;\n                }\n                else {\n                    delete this.activates[key];\n                }\n            });\n        }\n    }\n    /**\n     * Returns the flags for the tile after the given event is fired.\n     * @param {string} id - Name of the event to fire.\n     * @returns {number} The flags from the Tile after the event.\n     */\n    successorFlags(id) {\n        const e = this.activates[id];\n        if (!e)\n            return 0;\n        const tileId = e.tile;\n        if (!tileId)\n            return 0;\n        const tile = tiles[tileId];\n        if (!tile)\n            return 0;\n        return tile.flags;\n    }\n    /**\n     * Returns whether or not this tile as the given flag.\n     * Will return true if any bit in the flag is true, so testing with\n     * multiple flags will return true if any of them is set.\n     * @param {number} flag - The flag to check\n     * @returns {boolean} Whether or not the flag is set\n     */\n    hasFlag(flag) {\n        return (this.flags & flag) > 0;\n    }\n    hasMechFlag(flag) {\n        return (this.mechFlags & flag) > 0;\n    }\n    hasFlags(flags, mechFlags) {\n        return ((!flags || this.flags & flags) &&\n            (!mechFlags || this.mechFlags & mechFlags));\n    }\n    activatesOn(name) {\n        return !!this.activates[name];\n    }\n    getName(arg) {\n        let opts = {};\n        if (arg === true || arg === false) {\n            opts.article = arg;\n        }\n        else if (typeof arg === \"string\") {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg;\n            }\n            if (typeof color !== \"string\") {\n                color = Color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === \"string\" ? opts.article : this.article || \"a\";\n            result = article + \" \" + result;\n        }\n        return result;\n    }\n    getDescription(opts = {}) {\n        return this.getName(opts);\n    }\n}\n// Types.Tile = Tile;\nexport function make(config) {\n    return new Tile(config);\n}\nMake.tile = make;\nexport const tiles = {};\nexport function install(...args) {\n    let id = args[0];\n    let base = args[1];\n    let config = args[2];\n    if (arguments.length == 1) {\n        config = args[0];\n        base = config.Extends || null;\n        id = config.id;\n    }\n    else if (arguments.length == 2) {\n        config = base;\n        base = config.Extends || config.extends || null;\n    }\n    if (typeof base === \"string\") {\n        base = tiles[base] || Utils.ERROR(\"Unknown base tile: \" + base);\n    }\n    // config.name = config.name || base.name || id.toLowerCase();\n    config.id = id;\n    const tile = new Tile(config, base);\n    tiles[id] = tile;\n    return tile;\n}\n/**\n * Adds multiple tiles to the GW.tiles collection.\n * It extracts all the id:opts pairs from the config object and uses\n * them to call addTileKind.\n * @param {Object} config - The tiles to add in [id, config] pairs\n * @returns {void} Nothing\n * @see addTileKind\n */\nexport function installAll(config) {\n    Object.entries(config).forEach(([id, opts]) => {\n        opts.id = id;\n        install(id, opts);\n    });\n}\n","import { color as Color, canvas as Canvas, utils as Utils, config as CONFIG, data as DATA, random, make as Make, } from \"gw-utils\";\nimport { Tile, tiles as TILES, Layer } from \"./tile\";\nimport * as Activation from \"./tileEvent\";\nimport * as Light from \"./light\";\nimport { Cell as Flags, CellMech as MechFlags, TileMech as TileMechFlags, Tile as TileFlags, Map as MapFlags, } from \"./flags\";\nexport { Flags, MechFlags };\n// TODO - Move to gw-ui\nColor.install(\"cursorColor\", 25, 100, 150);\nCONFIG.cursorPathIntensity = 50;\nexport class CellMemory {\n    constructor() {\n        this.mixer = new Canvas.Mixer();\n        this.item = null;\n        this.itemQuantity = 0;\n        this.actor = null;\n        this.tile = null;\n        this.cellFlags = 0;\n        this.cellMechFlags = 0;\n        this.tileFlags = 0;\n        this.tileMechFlags = 0;\n    }\n    nullify() {\n        this.mixer.nullify();\n        this.item = null;\n        this.itemQuantity = 0;\n        this.actor = null;\n        this.tile = null;\n        this.cellFlags = 0;\n        this.cellMechFlags = 0;\n        this.tileFlags = 0;\n        this.tileMechFlags = 0;\n    }\n    copy(other) {\n        const mixer = this.mixer;\n        Object.assign(this, other);\n        this.mixer = mixer;\n        this.mixer.copy(other.mixer);\n    }\n}\nexport class Cell {\n    constructor() {\n        this.layers = [];\n        this.sprites = null;\n        this._actor = null;\n        this._item = null;\n        this.data = {};\n        this.flags = Flags.CELL_DEFAULT; // non-terrain cell flags\n        this.mechFlags = 0;\n        this.gasVolume = 0; // quantity of gas in cell\n        this.liquidVolume = 0;\n        this.machineNumber = 0;\n        this.memory = new CellMemory();\n        this.light = [100, 100, 100];\n        this.oldLight = [100, 100, 100];\n        this.glowLight = [100, 100, 100];\n    }\n    copy(other) {\n        Utils.copyObject(this, other);\n    }\n    nullify() {\n        for (let i = 0; i < this.layers.length; ++i) {\n            this.layers[i] = null;\n        }\n        this.sprites = null;\n        this._actor = null;\n        this._item = null;\n        this.data = {};\n        this.flags = Flags.CELL_DEFAULT; // non-terrain cell flags\n        this.mechFlags = 0;\n        this.gasVolume = 0; // quantity of gas in cell\n        this.liquidVolume = 0;\n        this.machineNumber = 0;\n        this.memory.nullify();\n        this.light = [100, 100, 100];\n        this.oldLight = [100, 100, 100];\n        this.glowLight = [100, 100, 100];\n    }\n    nullifyLayers(nullLiquid = false, nullSurface = false, nullGas = false) {\n        if (nullLiquid) {\n            this.layers[1] = null;\n            this.liquidVolume = 0;\n        }\n        if (nullSurface) {\n            this.layers[2] = null;\n        }\n        if (nullGas) {\n            this.layers[3] = null;\n            this.gasVolume = 0;\n        }\n        this.flags |= Flags.CELL_CHANGED;\n    }\n    get ground() {\n        var _a;\n        return ((_a = this.layers[Layer.GROUND]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get liquid() {\n        var _a;\n        return ((_a = this.layers[Layer.LIQUID]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get surface() {\n        var _a;\n        return ((_a = this.layers[Layer.SURFACE]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get gas() {\n        var _a;\n        return ((_a = this.layers[Layer.GAS]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get groundTile() {\n        return this.layers[Layer.GROUND] || TILES.NULL;\n    }\n    get liquidTile() {\n        return this.layers[Layer.LIQUID] || TILES.NULL;\n    }\n    get surfaceTile() {\n        return this.layers[Layer.SURFACE] || TILES.NULL;\n    }\n    get gasTile() {\n        return this.layers[Layer.GAS] || TILES.NULL;\n    }\n    dump() {\n        if (this.actor)\n            return this.actor.sprite.ch;\n        if (this.item)\n            return this.item.sprite.ch;\n        for (let i = this.layers.length - 1; i >= 0; --i) {\n            if (!this.layers[i])\n                continue;\n            const tile = this.layers[i] || TILES.NULL;\n            if (tile.sprite.ch)\n                return tile.sprite.ch;\n        }\n        return TILES[0].sprite.ch;\n    }\n    changed() {\n        return this.flags & Flags.CELL_CHANGED;\n    }\n    isVisible() {\n        return this.flags & Flags.VISIBLE;\n    }\n    isAnyKindOfVisible() {\n        return (this.flags & Flags.ANY_KIND_OF_VISIBLE /* || CONFIG.playbackOmniscience */);\n    }\n    isOrWasAnyKindOfVisible() {\n        return (this.flags &\n            Flags.IS_WAS_ANY_KIND_OF_VISIBLE /* || CONFIG.playbackOmniscience */);\n    }\n    isRevealed(orMapped = false) {\n        const flag = Flags.REVEALED | (orMapped ? Flags.MAGIC_MAPPED : 0);\n        return this.flags & flag;\n    }\n    listInSidebar() {\n        return this.hasTileMechFlag(TileMechFlags.TM_LIST_IN_SIDEBAR, true);\n    }\n    _needsRedraw() {\n        this.flags |= Flags.NEEDS_REDRAW;\n    }\n    // TODO - Use functions in LIGHT to check these on cell.light directly???\n    hasVisibleLight() {\n        return Light.intensity(this.light) > CONFIG.light.INTENSITY_DARK;\n    } // TODO\n    isDark() {\n        return Light.intensity(this.light) <= CONFIG.light.INTENSITY_DARK;\n    } // TODO\n    lightChanged() {\n        return this.flags & Flags.LIGHT_CHANGED;\n    } // TODO\n    tile(layer = Layer.GROUND) {\n        return this.layers[layer] || TILES.NULL;\n    }\n    *tiles() {\n        for (let tile of this.layers) {\n            if (tile) {\n                yield tile;\n            }\n        }\n    }\n    tileFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.tileFlags;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags;\n        }\n        return flags;\n    }\n    tileMechFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.tileMechFlags;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.mechFlags;\n        }\n        return flags;\n    }\n    hasTileFlag(flagMask = 0, limitToPlayerKnowledge = false) {\n        const tileFlags = this.tileFlags(limitToPlayerKnowledge);\n        return !!(flagMask & tileFlags);\n    }\n    hasAllTileFlags(flags = 0) {\n        return (flags & this.tileFlags()) === flags;\n    }\n    hasTileMechFlag(flagMask = 0, limitToPlayerKnowledge = false) {\n        const mechFlags = this.tileMechFlags(limitToPlayerKnowledge);\n        return !!(flagMask & mechFlags);\n    }\n    hasAllTileMechFlags(flags = 0) {\n        return (flags & this.tileMechFlags()) === flags;\n    }\n    setFlags(cellFlag = 0, cellMechFlag = 0) {\n        this.flags |= cellFlag;\n        this.mechFlags |= cellMechFlag;\n        // this.flags |= Flags.NEEDS_REDRAW;\n    }\n    clearFlags(cellFlag = 0, cellMechFlag = 0) {\n        this.flags &= ~cellFlag;\n        this.mechFlags &= ~cellMechFlag;\n        // if ((~cellFlag) & Flags.NEEDS_REDRAW) {\n        //   this.flags |= Flags.NEEDS_REDRAW;\n        // }\n    }\n    hasFlag(flag = 0, limitToPlayerKnowledge = false) {\n        const flags = limitToPlayerKnowledge && !this.isAnyKindOfVisible()\n            ? this.memory.cellFlags\n            : this.flags;\n        return !!(flag & flags);\n    }\n    hasMechFlag(flag = 0, limitToPlayerKnowledge = false) {\n        const flags = limitToPlayerKnowledge && !this.isAnyKindOfVisible()\n            ? this.memory.cellMechFlags\n            : this.mechFlags;\n        return !!(flag & flags);\n    }\n    hasTile(tile) {\n        let id;\n        if (tile instanceof Tile) {\n            id = tile.id;\n        }\n        else {\n            id = tile;\n        }\n        return this.layers.some((t) => t && t.id === id);\n    }\n    // hasTileInGroup(...groups) {\n    //   if (groups.length == 1 && Array.isArray(groups[0])) {\n    //     groups = groups[0];\n    //   }\n    //   return this.layers.some( (tileId) => {\n    //     const tile = TILES[tileId] || TILES.NOTHING;\n    //     return Utils.intersect(groups, tile.groups);\n    //   });\n    // }\n    successorTileFlags(id) {\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.successorFlags(id);\n        }\n        return flags;\n    }\n    promotedTileFlags() {\n        return this.successorTileFlags(\"promote\");\n    }\n    discoveredTileFlags() {\n        return this.successorTileFlags(\"discover\");\n    }\n    hasDiscoveredTileFlag(flag) {\n        // if (!this.hasTileMechFlag(TM_IS_SECRET)) return false;\n        return this.discoveredTileFlags() & flag;\n    }\n    highestPriorityTile(skipGas = false) {\n        let best = TILES[0];\n        let bestPriority = -10000;\n        for (let layer = Layer.GROUND; layer <= (skipGas ? Layer.LIQUID : Layer.GAS); ++layer) {\n            // @ts-ignore\n            const tile = this.layers[layer];\n            if (!tile)\n                continue;\n            if (tile.priority > bestPriority) {\n                best = tile;\n                bestPriority = tile.priority;\n            }\n        }\n        return best;\n    }\n    tileWithFlag(tileFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags & tileFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileWithMechFlag(mechFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.mechFlags & mechFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileDesc() {\n        return this.highestPriorityTile().desc;\n    }\n    tileFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    isNull() {\n        return this.ground == null;\n    }\n    isEmpty() {\n        return !(this._actor || this._item);\n    }\n    isPassableNow(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        if (!(tileFlags & TileFlags.T_PATHING_BLOCKER))\n            return true;\n        if (tileFlags & TileFlags.T_BRIDGE)\n            return true;\n        return limitToPlayerKnowledge\n            ? false\n            : this.isSecretDoor(limitToPlayerKnowledge);\n    }\n    canBePassed(limitToPlayerKnowledge = false) {\n        if (this.isPassableNow(limitToPlayerKnowledge))\n            return true;\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileMechFlags = useMemory\n            ? this.memory.tileMechFlags\n            : this.tileMechFlags();\n        if (tileMechFlags & TileMechFlags.TM_CONNECTS_LEVEL)\n            return true;\n        return !!(tileMechFlags & TileMechFlags.TM_PROMOTES &&\n            !(this.promotedTileFlags() & TileFlags.T_PATHING_BLOCKER));\n    }\n    isWall(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_OBSTRUCTS_EVERYTHING);\n    }\n    isObstruction(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_OBSTRUCTS_DIAGONAL_MOVEMENT);\n    }\n    isDoor(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_IS_DOOR);\n    }\n    isSecretDoor(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge)\n            return false;\n        const tileMechFlags = this.tileMechFlags();\n        return !!(tileMechFlags & TileMechFlags.TM_IS_SECRET &&\n            !(this.discoveredTileFlags() & TileFlags.T_PATHING_BLOCKER));\n    }\n    blocksPathing(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_PATHING_BLOCKER);\n    }\n    blocksVision() {\n        let tileFlags = this.tileFlags();\n        return !!(tileFlags & TileFlags.T_OBSTRUCTS_VISION);\n    }\n    isLiquid(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_IS_LIQUID);\n    }\n    // TODO - Should this look at the tiles instead of the flags?\n    // What if a gas tile is not set with T_GAS?\n    // Should we force T_GAS if layer === GAS when creating a tile?\n    hasGas(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_GAS);\n    }\n    markRevealed() {\n        this.flags &= ~Flags.STABLE_MEMORY;\n        if (this.flags & Flags.REVEALED)\n            return false;\n        this.flags |= Flags.REVEALED;\n        return !this.hasTileFlag(TileFlags.T_PATHING_BLOCKER);\n    }\n    obstructsLayer(layer) {\n        return (layer == Layer.SURFACE && this.hasTileFlag(TileFlags.T_OBSTRUCTS_SURFACE));\n    }\n    _setTile(tileId = null, volume = 0, map) {\n        map = map || DATA.map;\n        let tile;\n        if (tileId === null) {\n            tile = TILES.NULL;\n            tileId = null;\n        }\n        else if (typeof tileId === \"string\") {\n            tile = TILES[tileId];\n        }\n        else if (tileId instanceof Tile) {\n            tile = tileId;\n            tileId = tile.id;\n        }\n        if (!tile) {\n            return Utils.ERROR(\"Unknown tile - \" + tileId);\n        }\n        const oldTile = this.layers[tile.layer] || TILES.NULL;\n        const oldTileId = oldTile === TILES.NULL ? null : oldTile.id;\n        if ((oldTile.flags & TileFlags.T_PATHING_BLOCKER) !=\n            (tile.flags & TileFlags.T_PATHING_BLOCKER)) {\n            DATA.staleLoopMap = true;\n        }\n        if (tile.flags & TileFlags.T_IS_FIRE &&\n            !(oldTile.flags & TileFlags.T_IS_FIRE)) {\n            this.mechFlags |= MechFlags.CAUGHT_FIRE_THIS_TURN;\n        }\n        const blocksVision = tile.flags & TileFlags.T_OBSTRUCTS_VISION;\n        const oldBlocksVision = oldTile.flags & TileFlags.T_OBSTRUCTS_VISION;\n        if (map && this.isAnyKindOfVisible() && blocksVision != oldBlocksVision) {\n            map.setFlag(MapFlags.MAP_FOV_CHANGED);\n        }\n        if (oldTileId !== null)\n            this.removeSprite(oldTile.sprite);\n        this.layers[tile.layer] = tileId === null ? null : tile;\n        if (tileId !== null)\n            this.addSprite(tile.sprite, tile.layer);\n        if (tile.layer == Layer.LIQUID) {\n            this.liquidVolume =\n                volume + (tileId == oldTileId ? this.liquidVolume : 0);\n            if (map)\n                map.clearFlag(MapFlags.MAP_NO_LIQUID);\n        }\n        else if (tile.layer == Layer.GAS) {\n            this.gasVolume = volume + (tileId == oldTileId ? this.gasVolume : 0);\n            if (map)\n                map.clearFlag(MapFlags.MAP_NO_GAS);\n        }\n        if (tile.layer > 0 && !this.layers[0]) {\n            this.layers[0] = TILES.FLOOR; // TODO - Not good\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n        this.flags |= Flags.CELL_CHANGED;\n        if (map && oldTile.light !== tile.light) {\n            map.clearFlag(MapFlags.MAP_STABLE_GLOW_LIGHTS | MapFlags.MAP_STABLE_LIGHTS);\n        }\n        return true;\n    }\n    clearLayer(layer) {\n        // @ts-ignore\n        if (typeof layer === \"string\")\n            layer = Layer[layer];\n        const current = this.layers[layer];\n        if (current) {\n            // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n            this.flags |= Flags.CELL_CHANGED;\n            this.removeSprite(current.sprite);\n        }\n        this.layers[layer] = null;\n        if (layer == Layer.LIQUID) {\n            this.liquidVolume = 0;\n        }\n        else if (layer == Layer.GAS) {\n            this.gasVolume = 0;\n        }\n    }\n    clearLayers(except = Layer.GROUND, ground) {\n        const floorTile = ground ? TILES[ground] : this.groundTile;\n        for (let layer = 0; layer < this.layers.length; layer++) {\n            if (layer != except && layer != Layer.GAS) {\n                if (layer === Layer.GROUND) {\n                    if (floorTile !== this.groundTile)\n                        this._setTile(floorTile);\n                }\n                else {\n                    this.clearLayer(layer);\n                }\n            }\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n        this.flags |= Flags.CELL_CHANGED;\n    }\n    clearLayersWithFlags(tileFlags, tileMechFlags = 0) {\n        for (let i = 0; i < this.layers.length; ++i) {\n            const tile = this.layers[i];\n            if (!tile)\n                continue;\n            if (tileFlags && tileMechFlags) {\n                if (tile.flags & tileFlags && tile.mechFlags & tileMechFlags) {\n                    this.clearLayer(i);\n                }\n            }\n            else if (tileFlags) {\n                if (tile.flags & tileFlags) {\n                    this.clearLayer(i);\n                }\n            }\n            else if (tileMechFlags) {\n                if (tile.mechFlags & tileMechFlags) {\n                    this.clearLayer(i);\n                }\n            }\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n    }\n    // EVENTS\n    async activate(name, ctx = {}) {\n        ctx.cell = this;\n        let fired = false;\n        // cell.debug(\"fire event - %s\", name);\n        for (let tile of this.tiles()) {\n            if (!tile.activates)\n                continue;\n            const ev = tile.activates[name];\n            if (ev) {\n                // cell.debug(\" - has event\");\n                if (ev.chance && !random.chance(ev.chance, 10000)) {\n                    continue;\n                }\n                ctx.tile = tile;\n                // cell.debug(\" - spawn event @%d,%d - %s\", ctx.x, ctx.y, name);\n                fired = (await Activation.spawn(ev, ctx)) || fired;\n                // cell.debug(\" - spawned\");\n                if (fired) {\n                    break;\n                }\n            }\n        }\n        if (fired) {\n            // this.mechFlags |= MechFlags.EVENT_FIRED_THIS_TURN;\n        }\n        return fired;\n    }\n    activatesOn(name) {\n        for (let tile of this.tiles()) {\n            if (tile.activatesOn(name))\n                return true;\n        }\n        return false;\n    }\n    // ITEM\n    get item() {\n        return this._item;\n    }\n    set item(item) {\n        if (this.item) {\n            this.removeSprite(this.item.sprite);\n        }\n        this._item = item;\n        if (item) {\n            this.flags |= Flags.HAS_ITEM;\n            this.addSprite(item.sprite, Layer.ITEM);\n        }\n        else {\n            this.flags &= ~Flags.HAS_ITEM;\n        }\n    }\n    // ACTOR\n    get actor() {\n        return this._actor;\n    }\n    set actor(actor) {\n        if (this.actor) {\n            this.removeSprite(this.actor.sprite);\n        }\n        this._actor = actor;\n        if (actor) {\n            this.flags |= Flags.HAS_ACTOR;\n            this.addSprite(actor.sprite, Layer.ACTOR);\n        }\n        else {\n            this.flags &= ~Flags.HAS_ACTOR;\n        }\n    }\n    // SPRITES\n    addSprite(sprite, layer = Layer.GROUND, priority = 50) {\n        if (!sprite)\n            return;\n        // this.flags |= Flags.NEEDS_REDRAW;\n        this.flags |= Flags.CELL_CHANGED;\n        if (!this.sprites ||\n            this.sprites.layer > layer ||\n            (this.sprites.layer == layer && this.sprites.priority > priority)) {\n            this.sprites = { layer, priority, sprite, next: this.sprites };\n            return;\n        }\n        let current = this.sprites;\n        while (current.next &&\n            (current.layer < layer ||\n                (current.layer == layer && current.priority <= priority))) {\n            current = current.next;\n        }\n        const item = { layer, priority, sprite, next: current.next };\n        current.next = item;\n    }\n    removeSprite(sprite) {\n        if (!sprite)\n            return false;\n        if (!this.sprites)\n            return false;\n        // this.flags |= Flags.NEEDS_REDRAW;\n        this.flags |= Flags.CELL_CHANGED;\n        if (this.sprites && this.sprites.sprite === sprite) {\n            this.sprites = this.sprites.next;\n            return true;\n        }\n        let prev = this.sprites;\n        let current = this.sprites.next;\n        while (current) {\n            if (current.sprite === sprite) {\n                prev.next = current.next;\n                return true;\n            }\n            prev = current;\n            current = current.next;\n        }\n        return false;\n    }\n    // MEMORY\n    storeMemory() {\n        const memory = this.memory;\n        memory.tileFlags = this.tileFlags();\n        memory.tileMechFlags = this.tileMechFlags();\n        memory.cellFlags = this.flags;\n        memory.cellMechFlags = this.mechFlags;\n        memory.tile = this.highestPriorityTile();\n        if (this.item) {\n            memory.item = this.item;\n            memory.itemQuantity = this.item.quantity;\n        }\n        else {\n            memory.item = null;\n            memory.itemQuantity = 0;\n        }\n        memory.actor = this.actor;\n        getAppearance(this, memory.mixer);\n        if (this.actor && this.isOrWasAnyKindOfVisible()) {\n            if (this.actor.rememberedInCell && this.actor.rememberedInCell !== this) {\n                // console.log(\"remembered in cell change\");\n                this.actor.rememberedInCell.storeMemory();\n                this.actor.rememberedInCell.flags |= Flags.NEEDS_REDRAW;\n            }\n            this.actor.rememberedInCell = this;\n        }\n    }\n}\nexport function make(tile) {\n    const cell = new Cell();\n    if (tile) {\n        cell._setTile(tile);\n    }\n    return cell;\n}\nMake.cell = make;\nexport function getAppearance(cell, dest) {\n    const memory = cell.memory.mixer;\n    memory.blackOut();\n    let needDistinctness = cell.tileMechFlags() & TileMechFlags.TM_VISUALLY_DISTINCT;\n    let current = cell.sprites;\n    while (current) {\n        let alpha = current.sprite.opacity || 100;\n        if (current.layer == Layer.LIQUID) {\n            alpha = Utils.clamp(cell.liquidVolume || 0, 20, 100);\n        }\n        else if (current.layer == Layer.GAS) {\n            alpha = Utils.clamp(cell.gasVolume || 0, 20, 100);\n        }\n        memory.drawSprite(current.sprite, alpha);\n        current = current.next;\n    }\n    memory.fg.multiply(cell.light);\n    memory.bg.multiply(cell.light);\n    memory.bake(!cell.isAnyKindOfVisible()); // turns off dancing if not visible\n    if (needDistinctness) {\n        Color.separate(memory.fg, memory.bg);\n    }\n    dest.drawSprite(memory);\n    return true;\n}\n","import { utils as Utils, random, grid as Grid, fov as Fov, flag as Flag, path as Path, color as Color, colors as COLORS, canvas as Canvas, config as CONFIG, data as DATA, make as Make, } from \"gw-utils\";\nimport * as Cell from \"./cell\";\nimport { Map as Flags, Cell as CellFlags, Tile as TileFlags, CellMech as CellMechFlags, TileMech as TileMechFlags, Layer as TileLayer, } from \"./flags\";\nexport { Flags };\nUtils.setDefaults(CONFIG, {\n    \"map.deepestLevel\": 99,\n});\nexport class Map {\n    constructor(w, h, opts = {}) {\n        this.locations = {};\n        this.config = {};\n        this._actors = null;\n        this._items = null;\n        this.flags = 0;\n        this.ambientLight = null;\n        this.lights = null;\n        this.events = {};\n        this._width = w;\n        this._height = h;\n        this.cells = Grid.make(w, h, () => new Cell.Cell());\n        this.locations = opts.locations || {};\n        this.config = Object.assign({}, opts);\n        this.config.tick = this.config.tick || 100;\n        this._actors = null;\n        this._items = null;\n        this.flags = Flag.from(Flags, Flags.MAP_DEFAULT, opts.flags);\n        this.ambientLight = null;\n        const ambient = opts.ambient || opts.ambientLight || opts.light;\n        if (ambient) {\n            this.ambientLight = Color.make(ambient);\n        }\n        this.lights = null;\n        this.id = opts.id;\n        this.events = opts.events || {};\n    }\n    get width() {\n        return this._width;\n    }\n    get height() {\n        return this._height;\n    }\n    async start() { }\n    nullify() {\n        this.cells.forEach((c) => c.nullify());\n    }\n    dump(fmt) {\n        this.cells.dump(fmt || ((c) => c.dump()));\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    eachCell(fn) {\n        this.cells.forEach((c, i, j) => fn(c, i, j, this));\n    }\n    forEach(fn) {\n        this.cells.forEach((c, i, j) => fn(c, i, j, this));\n    }\n    forRect(x, y, w, h, fn) {\n        this.cells.forRect(x, y, w, h, (c, i, j) => fn(c, i, j, this));\n    }\n    eachNeighbor(x, y, fn, only4dirs = false) {\n        this.cells.eachNeighbor(x, y, (c, i, j) => fn(c, i, j, this), only4dirs);\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.cells.isBoundaryXY(x, y);\n    }\n    changed(v) {\n        if (v === true) {\n            this.flags |= Flags.MAP_CHANGED;\n        }\n        else if (v === false) {\n            this.flags &= ~Flags.MAP_CHANGED;\n        }\n        return this.flags & Flags.MAP_CHANGED;\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).flags & flag;\n    }\n    hasCellMechFlag(x, y, flag) {\n        return this.cell(x, y).mechFlags & flag;\n    }\n    hasTileFlag(x, y, flag) {\n        return this.cell(x, y).hasTileFlag(flag);\n    }\n    hasTileMechFlag(x, y, flag) {\n        return this.cell(x, y).hasTileMechFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).flags |= flag;\n    }\n    redrawCell(cell) {\n        // if (cell.isAnyKindOfVisible()) {\n        cell._needsRedraw();\n        this.flags |= Flags.MAP_CHANGED;\n        // }\n    }\n    redrawXY(x, y) {\n        const cell = this.cell(x, y);\n        this.redrawCell(cell);\n    }\n    redrawAll() {\n        this.forEach((c) => {\n            // if (c.isAnyKindOfVisible()) {\n            c.flags |= CellFlags.NEEDS_REDRAW;\n            // }\n        });\n        this.flags |= Flags.MAP_CHANGED;\n    }\n    revealAll() {\n        this.forEach((c) => {\n            c.markRevealed();\n            c.storeMemory();\n        });\n    }\n    markRevealed(x, y) {\n        if (!this.cell(x, y).markRevealed())\n            return;\n        if (DATA.player) {\n            DATA.player.invalidateCostMap();\n        }\n    }\n    isVisible(x, y) {\n        return this.cell(x, y).isVisible();\n    }\n    isAnyKindOfVisible(x, y) {\n        return this.cell(x, y).isAnyKindOfVisible();\n    }\n    isOrWasAnyKindOfVisible(x, y) {\n        return this.cell(x, y).isOrWasAnyKindOfVisible();\n    }\n    hasVisibleLight(x, y) {\n        return this.cell(x, y).hasVisibleLight();\n    }\n    setFlag(flag) {\n        this.flags |= flag;\n        this.changed(true);\n    }\n    setFlags(mapFlag = 0, cellFlag = 0, cellMechFlag = 0) {\n        if (mapFlag) {\n            this.flags |= mapFlag;\n        }\n        if (cellFlag || cellMechFlag) {\n            this.forEach((c) => c.setFlags(cellFlag, cellMechFlag));\n        }\n        this.changed(true);\n    }\n    clearFlag(flag) {\n        this.flags &= ~flag;\n        this.changed(true);\n    }\n    clearFlags(mapFlag = 0, cellFlag = 0, cellMechFlag = 0) {\n        if (mapFlag) {\n            this.flags &= ~mapFlag;\n        }\n        if (cellFlag || cellMechFlag) {\n            this.forEach((cell) => cell.clearFlags(cellFlag, cellMechFlag));\n        }\n        this.changed(true);\n    }\n    setCellFlags(x, y, cellFlag = 0, cellMechFlag = 0) {\n        this.cell(x, y).setFlags(cellFlag, cellMechFlag);\n        this.flags |= Flags.MAP_CHANGED;\n    }\n    clearCellFlags(x, y, cellFlags = 0, cellMechFlags = 0) {\n        this.cell(x, y).clearFlags(cellFlags, cellMechFlags);\n        this.changed(true);\n    }\n    hasTile(x, y, tile) {\n        return this.cells[x][y].hasTile(tile);\n    }\n    tileFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].tileFlags(limitToPlayerKnowledge);\n    }\n    tileMechFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].tileMechFlags(limitToPlayerKnowledge);\n    }\n    tileWithFlag(x, y, flag = 0) {\n        return this.cells[x][y].tileWithFlag(flag);\n    }\n    tileWithMechFlag(x, y, mechFlag = 0) {\n        return this.cells[x][y].tileWithMechFlag(mechFlag);\n    }\n    hasKnownTileFlag(x, y, flagMask = 0) {\n        return this.cells[x][y].memory.tileFlags & flagMask;\n    }\n    // hasTileInGroup(x, y, ...groups) { return this.cells[x][y].hasTileInGroup(...groups); }\n    discoveredTileFlags(x, y) {\n        return this.cells[x][y].discoveredTileFlags();\n    }\n    hasDiscoveredTileFlag(x, y, flag = 0) {\n        return this.cells[x][y].hasDiscoveredTileFlag(flag);\n    }\n    canBePassed(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].canBePassed(limitToPlayerKnowledge);\n    }\n    isPassableNow(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isPassableNow(limitToPlayerKnowledge);\n    }\n    isNull(x, y) {\n        return this.cells[x][y].isNull();\n    }\n    isEmpty(x, y) {\n        return this.cells[x][y].isEmpty();\n    }\n    isObstruction(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isObstruction(limitToPlayerKnowledge);\n    }\n    isDoor(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isDoor(limitToPlayerKnowledge);\n    }\n    isLiquid(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isLiquid(limitToPlayerKnowledge);\n    }\n    hasGas(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].hasGas(limitToPlayerKnowledge);\n    }\n    blocksPathing(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].blocksPathing(limitToPlayerKnowledge);\n    }\n    blocksVision(x, y) {\n        return this.cells[x][y].blocksVision();\n    }\n    highestPriorityTile(x, y, skipGas = false) {\n        return this.cells[x][y].highestPriorityTile(skipGas);\n    }\n    tileFlavor(x, y) {\n        return this.cells[x][y].tileFlavor();\n    }\n    setTile(x, y, tileId, volume = 0) {\n        return this.cell(x, y)._setTile(tileId, volume, this);\n    }\n    clearLayersWithFlags(x, y, tileFlags, tileMechFlags = 0) {\n        const cell = this.cell(x, y);\n        cell.clearLayersWithFlags(tileFlags, tileMechFlags);\n    }\n    clearCellLayers(x, y, nullLiquid = true, nullSurface = true, nullGas = true) {\n        this.changed(true);\n        return this.cell(x, y).nullifyLayers(nullLiquid, nullSurface, nullGas);\n    }\n    fill(tileId, boundaryTile) {\n        let i, j;\n        if (boundaryTile === undefined) {\n            boundaryTile = tileId;\n        }\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                if (this.isBoundaryXY(i, j)) {\n                    this.setTile(i, j, boundaryTile);\n                }\n                else {\n                    this.setTile(i, j, tileId);\n                }\n            }\n        }\n    }\n    neighborCount(x, y, matchFn, only4dirs = false) {\n        let count = 0;\n        this.eachNeighbor(x, y, (...args) => {\n            if (matchFn(...args))\n                ++count;\n        }, only4dirs);\n        return count;\n    }\n    passableArcCount(x, y) {\n        if (!this.hasXY(x, y))\n            return -1;\n        return this.cells.arcCount(x, y, (c) => c.isPassableNow());\n    }\n    diagonalBlocked(x1, y1, x2, y2, limitToPlayerKnowledge = false) {\n        if (x1 == x2 || y1 == y2) {\n            return false; // If it's not a diagonal, it's not diagonally blocked.\n        }\n        const locFlags1 = this.tileFlags(x1, y2, limitToPlayerKnowledge);\n        if (locFlags1 & TileFlags.T_OBSTRUCTS_DIAGONAL_MOVEMENT) {\n            return true;\n        }\n        const locFlags2 = this.tileFlags(x2, y1, limitToPlayerKnowledge);\n        if (locFlags2 & TileFlags.T_OBSTRUCTS_DIAGONAL_MOVEMENT) {\n            return true;\n        }\n        return false;\n    }\n    fillCostGrid(costGrid, costFn) {\n        costFn = costFn || Utils.ONE;\n        this.cells.forEach((cell, i, j) => {\n            if (cell.isNull()) {\n                costGrid[i][j] = Path.OBSTRUCTION;\n            }\n            else {\n                costGrid[i][j] = cell.canBePassed()\n                    ? costFn(cell, i, j, this)\n                    : Path.OBSTRUCTION;\n            }\n        });\n    }\n    matchingNeighbor(x, y, matcher, only4dirs = false) {\n        const maxIndex = only4dirs ? 4 : 8;\n        for (let d = 0; d < maxIndex; ++d) {\n            const dir = Utils.DIRS[d];\n            const i = x + dir[0];\n            const j = y + dir[1];\n            if (this.hasXY(i, j)) {\n                if (matcher(this.cells[i][j], i, j, this))\n                    return [i, j];\n            }\n        }\n        return null;\n    }\n    matchingLocNear(x, y, ...args) {\n        let i, j, k;\n        let matcher = args[0];\n        let opts = args[1] || {};\n        const arg = args[0];\n        if (typeof arg !== \"function\") {\n            opts = arg || args[1];\n            matcher = opts.match || Utils.TRUE;\n        }\n        const hallwaysAllowed = opts.hallways || false;\n        const blockingMap = opts.blockingMap || null;\n        const forbidLiquid = opts.liquids === false;\n        const deterministic = opts.deterministic || false;\n        const candidateLocs = [];\n        // count up the number of candidate locations\n        for (k = 0; k < Math.max(this.width, this.height) && !candidateLocs.length; k++) {\n            for (i = x - k; i <= x + k; i++) {\n                for (j = y - k; j <= y + k; j++) {\n                    if (!this.hasXY(i, j))\n                        continue;\n                    const cell = this.cell(i, j);\n                    // if ((i == x-k || i == x+k || j == y-k || j == y+k)\n                    if (Math.ceil(Utils.distanceBetween(x, y, i, j)) == k &&\n                        (!blockingMap || !blockingMap[i][j]) &&\n                        matcher(cell, i, j, this) &&\n                        (!forbidLiquid || !cell.liquid) &&\n                        (hallwaysAllowed || this.passableArcCount(i, j) < 2)) {\n                        candidateLocs.push([i, j]);\n                    }\n                }\n            }\n        }\n        if (candidateLocs.length == 0) {\n            return [-1, -1];\n        }\n        // and pick one\n        let randIndex = 0;\n        if (deterministic) {\n            randIndex = Math.floor(candidateLocs.length / 2);\n        }\n        else {\n            randIndex = random.number(candidateLocs.length);\n        }\n        return candidateLocs[randIndex];\n    }\n    // fills (*x, *y) with the coordinates of a random cell with\n    // no creatures, items or stairs and with either a matching liquid and dungeon type\n    // or at least one layer of type terrainType.\n    // A dungeon, liquid type of -1 will match anything.\n    randomMatchingLoc(opts = {}) {\n        let x;\n        let y;\n        let cell;\n        if (typeof opts === \"function\") {\n            opts = { match: opts };\n        }\n        const hallwaysAllowed = opts.hallways || false;\n        const blockingMap = opts.blockingMap || null;\n        const forbidLiquid = opts.liquids === false;\n        const matcher = opts.match || Utils.TRUE;\n        const forbidCellFlags = opts.forbidCellFlags || 0;\n        const forbidTileFlags = opts.forbidTileFlags || 0;\n        const forbidTileMechFlags = opts.forbidTileMechFlags || 0;\n        const tile = opts.tile || null;\n        let tries = opts.tries || 500;\n        let retry = true;\n        while (retry) {\n            tries--;\n            if (!tries)\n                break;\n            x = random.range(0, this.width - 1);\n            y = random.range(0, this.height - 1);\n            cell = this.cell(x, y);\n            if ((!blockingMap || !blockingMap[x][y]) &&\n                (!tile || cell.hasTile(tile)) &&\n                (!forbidLiquid || !cell.liquid) &&\n                (!forbidCellFlags || !(cell.flags & forbidCellFlags)) &&\n                (!forbidTileFlags || !cell.hasTileFlag(forbidTileFlags)) &&\n                (!forbidTileMechFlags || !cell.hasTileMechFlag(forbidTileMechFlags)) &&\n                (hallwaysAllowed || this.passableArcCount(x, y) < 2) &&\n                matcher(cell, x, y, this)) {\n                retry = false;\n            }\n        }\n        if (!tries) {\n            // map.debug('randomMatchingLocation', dungeonType, liquidType, terrainType, ' => FAIL');\n            return false;\n        }\n        // map.debug('randomMatchingLocation', dungeonType, liquidType, terrainType, ' => ', x, y);\n        return [x, y];\n    }\n    // LIGHT\n    addLight(x, y, light) {\n        const info = { x, y, light, next: this.lights };\n        this.lights = info;\n        this.flags &= ~(Flags.MAP_STABLE_LIGHTS | Flags.MAP_STABLE_GLOW_LIGHTS);\n        return info;\n    }\n    removeLight(info) {\n        Utils.removeFromChain(this, \"lights\", info);\n        this.flags &= ~(Flags.MAP_STABLE_LIGHTS | Flags.MAP_STABLE_GLOW_LIGHTS);\n    }\n    eachGlowLight(fn) {\n        Utils.eachChain(this.lights, (info) => fn(info.light, info.x, info.y));\n        this.eachCell((cell, x, y) => {\n            for (let tile of cell.tiles()) {\n                if (tile.light) {\n                    fn(tile.light, x, y);\n                }\n            }\n        });\n    }\n    eachDynamicLight(fn) {\n        Utils.eachChain(this._actors, (actor) => {\n            if (actor.light)\n                fn(actor.light, actor.x, actor.y);\n        });\n    }\n    // FX\n    addFx(x, y, anim) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        cell.addSprite(anim.sprite, TileLayer.FX);\n        anim.x = x;\n        anim.y = y;\n        this.redrawCell(cell);\n        return true;\n    }\n    moveFx(x, y, anim) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        const oldCell = this.cell(anim.x, anim.y);\n        oldCell.removeSprite(anim.sprite);\n        this.redrawCell(oldCell);\n        cell.addSprite(anim.sprite, TileLayer.FX);\n        this.redrawCell(cell);\n        anim.x = x;\n        anim.y = y;\n        return true;\n    }\n    removeFx(anim) {\n        const oldCell = this.cell(anim.x, anim.y);\n        oldCell.removeSprite(anim.sprite);\n        this.redrawCell(oldCell);\n        this.flags |= Flags.MAP_CHANGED;\n        return true;\n    }\n    // ACTORS\n    // will return the PLAYER if the PLAYER is at (x, y).\n    actorAt(x, y) {\n        // creature *\n        if (!this.hasXY(x, y))\n            return null;\n        const cell = this.cell(x, y);\n        return cell.actor;\n    }\n    addActor(x, y, theActor) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.actor) {\n            return false;\n        }\n        cell.actor = theActor;\n        theActor.next = this._actors;\n        this._actors = theActor;\n        const layer = theActor === DATA.player ? TileLayer.PLAYER : TileLayer.ACTOR;\n        cell.addSprite(theActor.sprite, layer);\n        const flag = theActor === DATA.player ? CellFlags.HAS_PLAYER : CellFlags.HAS_MONSTER;\n        cell.flags |= flag;\n        // if (theActor.flags & Flags.Actor.MK_DETECTED)\n        // {\n        // \tcell.flags |= CellFlags.MONSTER_DETECTED;\n        // }\n        if (theActor.light) {\n            this.flags &= ~Flags.MAP_STABLE_LIGHTS;\n        }\n        // If the player moves or an actor that blocks vision and the cell is visible...\n        // -- we need to update the FOV\n        if (theActor.isPlayer() ||\n            (cell.isAnyKindOfVisible() && theActor.blocksVision())) {\n            this.flags |= Flags.MAP_FOV_CHANGED;\n        }\n        theActor.x = x;\n        theActor.y = y;\n        this.redrawCell(cell);\n        return true;\n    }\n    addActorNear(x, y, theActor) {\n        const loc = this.matchingLocNear(x, y, (cell) => {\n            return theActor.avoidsCell(cell);\n        });\n        if (!loc || loc[0] < 0) {\n            // GW.ui.message(colors.badMessageColor, 'There is no place to put the actor.');\n            return false;\n        }\n        return this.addActor(loc[0], loc[1], theActor);\n    }\n    moveActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        this.removeActor(actor);\n        if (!this.addActor(x, y, actor)) {\n            this.addActor(actor.x, actor.y, actor);\n            return false;\n        }\n        if (actor.light) {\n            this.flags &= ~Flags.MAP_STABLE_LIGHTS;\n        }\n        return true;\n    }\n    removeActor(actor) {\n        if (!this.hasXY(actor.x, actor.y))\n            return false;\n        const cell = this.cell(actor.x, actor.y);\n        if (cell.actor === actor) {\n            cell.actor = null;\n            Utils.removeFromChain(this, \"actors\", actor);\n            cell.flags &= ~CellFlags.HAS_ACTOR;\n            cell.removeSprite(actor.sprite);\n            if (actor.light) {\n                this.flags &= ~Flags.MAP_STABLE_LIGHTS;\n            }\n            // If the player moves or an actor that blocks vision and the cell is visible...\n            // -- we need to update the FOV\n            if (actor.isPlayer() ||\n                (cell.isAnyKindOfVisible() && actor.blocksVision())) {\n                this.flags |= Flags.MAP_FOV_CHANGED;\n            }\n            this.redrawCell(cell);\n            return true;\n        }\n        return false;\n    }\n    deleteActorAt(x, y) {\n        const actor = this.actorAt(x, y);\n        if (!actor)\n            return false;\n        this.removeActor(actor);\n        actor.delete();\n        return true;\n    }\n    // dormantAt(x: number, y: number) {  // creature *\n    // \tif (!(this.cell(x, y).flags & CellFlags.HAS_DORMANT_MONSTER)) {\n    // \t\treturn null;\n    // \t}\n    // \treturn this.dormantActors.find( (m) => m.x == x && m.y == y );\n    // }\n    //\n    // addDormant(x, y, actor) {\n    // \ttheActor.x = x;\n    // \ttheActor.y = y;\n    // \tthis.dormant.add(theActor);\n    // \tcell.flags |= (CellFlags.HAS_DORMANT_MONSTER);\n    // \tthis.flags |= Flags.MAP_CHANGED;\n    // \treturn true;\n    // }\n    //\n    // removeDormant(actor) {\n    // \tconst cell = this.cell(actor.x, actor.y);\n    // \tcell.flags &= ~(CellFlags.HAS_DORMANT_MONSTER);\n    // \tcell.flags |= CellFlags.NEEDS_REDRAW;\n    // \tthis.flags |= Flags.MAP_CHANGED;\n    // \tthis.dormant.remove(actor);\n    // }\n    // ITEMS\n    itemAt(x, y) {\n        const cell = this.cell(x, y);\n        return cell.item;\n    }\n    addItem(x, y, theItem) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.flags & CellFlags.HAS_ITEM) {\n            // GW.ui.message(colors.badMessageColor, 'There is already an item there.');\n            return false;\n        }\n        theItem.x = x;\n        theItem.y = y;\n        cell.item = theItem;\n        theItem.next = this._items;\n        this._items = theItem;\n        cell.addSprite(theItem.sprite, TileLayer.ITEM);\n        cell.flags |= CellFlags.HAS_ITEM;\n        if (theItem.light) {\n            this.flags &= ~Flags.MAP_STABLE_LIGHTS;\n        }\n        this.redrawCell(cell);\n        if (theItem.isDetected() || CONFIG.D_ITEM_OMNISCIENCE) {\n            cell.flags |= CellFlags.ITEM_DETECTED;\n        }\n        return true;\n    }\n    addItemNear(x, y, theItem) {\n        const loc = this.matchingLocNear(x, y, (cell) => {\n            return theItem.forbidsCell(cell);\n        });\n        if (!loc || loc[0] < 0) {\n            // GW.ui.message(colors.badMessageColor, 'There is no place to put the item.');\n            return false;\n        }\n        return this.addItem(loc[0], loc[1], theItem);\n    }\n    removeItem(theItem) {\n        const x = theItem.x;\n        const y = theItem.y;\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.item !== theItem)\n            return false;\n        cell.removeSprite(theItem.sprite);\n        cell.item = null;\n        Utils.removeFromChain(this, \"items\", theItem);\n        if (theItem.light) {\n            this.flags &= ~Flags.MAP_STABLE_LIGHTS;\n        }\n        cell.flags &= ~(CellFlags.HAS_ITEM | CellFlags.ITEM_DETECTED);\n        this.redrawCell(cell);\n        return true;\n    }\n    // // PROMOTE\n    //\n    // async promote(x, y, mechFlag) {\n    // \tif (this.hasTileMechFlag(x, y, mechFlag)) {\n    // \t\tconst cell = this.cell(x, y);\n    // \t\tfor (let tile of cell.tiles()) {\n    // \t\t\tif (tile.mechFlags & mechFlag) {\n    // \t\t\t\tawait tile.promote(this, x, y, false);\n    // \t\t\t}\n    // \t\t}\n    // \t}\n    // }\n    gridDisruptsPassability(blockingGrid, opts = {}) {\n        const walkableGrid = Grid.alloc(this.width, this.height);\n        let disrupts = false;\n        const gridOffsetX = opts.gridOffsetX || 0;\n        const gridOffsetY = opts.gridOffsetY || 0;\n        const bounds = opts.bounds || null;\n        // Get all walkable locations after lake added\n        this.cells.forEach((cell, i, j) => {\n            if (bounds && !bounds.contains(i, j))\n                return; // outside bounds\n            const blockingX = i + gridOffsetX;\n            const blockingY = j + gridOffsetY;\n            if (cell.isNull()) {\n                return; // do nothing\n            }\n            else if (cell.canBePassed()) {\n                if (blockingGrid.hasXY(blockingX, blockingY) &&\n                    blockingGrid[blockingX][blockingY])\n                    return;\n                walkableGrid[i][j] = 1;\n            }\n            else if (cell.hasTileFlag(TileFlags.T_HAS_STAIRS)) {\n                if (blockingGrid.hasXY(blockingX, blockingY) &&\n                    blockingGrid[blockingX][blockingY]) {\n                    disrupts = true;\n                }\n                else {\n                    walkableGrid[i][j] = 1;\n                }\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        Grid.free(walkableGrid);\n        return disrupts;\n    }\n    // FOV\n    // Returns a boolean grid indicating whether each square is in the field of view of (xLoc, yLoc).\n    // forbiddenTileFlags is the set of terrain flags that will block vision (but the blocking cell itself is\n    // illuminated); forbiddenCellFlags is the set of map flags that will block vision.\n    // If cautiousOnWalls is set, we will not illuminate blocking tiles unless the tile one space closer to the origin\n    // is visible to the player; this is to prevent lights from illuminating a wall when the player is on the other\n    // side of the wall.\n    calcFov(grid, x, y, maxRadius, forbiddenCellFlags = 0, forbiddenTileFlags = TileFlags.T_OBSTRUCTS_VISION) {\n        maxRadius = maxRadius || this.width + this.height;\n        grid.fill(0);\n        const map = this;\n        const FOV = new Fov.FOV({\n            isBlocked(i, j) {\n                return !!(!grid.hasXY(i, j) ||\n                    map.hasCellFlag(i, j, forbiddenCellFlags) ||\n                    map.hasTileFlag(i, j, forbiddenTileFlags));\n            },\n            calcRadius(x, y) {\n                return Math.sqrt(x ** 2 + y ** 2);\n            },\n            setVisible(x, y) {\n                grid[x][y] = 1;\n            },\n            hasXY(x, y) {\n                return grid.hasXY(x, y);\n            },\n        });\n        return FOV.calculate(x, y, maxRadius);\n    }\n    losFromTo(a, b) {\n        const line = Utils.getLine(a.x, a.y, b.x, b.y);\n        if (!line || !line.length)\n            return false;\n        return !line.some((loc) => {\n            return this.blocksVision(loc[0], loc[1]);\n        });\n    }\n    // MEMORIES\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        cell.storeMemory();\n    }\n    storeMemories() {\n        let x, y;\n        for (x = 0; x < this.width; ++x) {\n            for (y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.flags & CellFlags.ANY_KIND_OF_VISIBLE) {\n                    this.storeMemory(x, y);\n                }\n                cell.flags &= CellFlags.PERMANENT_CELL_FLAGS;\n                cell.mechFlags &= CellMechFlags.PERMANENT_MECH_FLAGS;\n            }\n        }\n    }\n    // TICK\n    async tick() {\n        // map.debug(\"tick\");\n        this.forEach((c) => (c.mechFlags &= ~(CellMechFlags.EVENT_FIRED_THIS_TURN | CellMechFlags.EVENT_PROTECTED)));\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cells[x][y];\n                await cell.activate(\"tick\", { map: this, x, y, cell, safe: true });\n            }\n        }\n        updateLiquid(this);\n    }\n    resetEvents() {\n        this.forEach((c) => (c.mechFlags &= ~(CellMechFlags.EVENT_FIRED_THIS_TURN | CellMechFlags.EVENT_PROTECTED)));\n    }\n}\nexport function make(w, h, opts = {}, wall) {\n    if (typeof opts === \"string\") {\n        opts = { tile: opts };\n        if (wall) {\n            opts.wall = wall;\n        }\n    }\n    const map = new Map(w, h, opts);\n    const floor = opts.tile || opts.floor || opts.floorTile;\n    const boundary = opts.boundary || opts.wall || opts.wallTile;\n    if (floor) {\n        map.fill(floor, boundary);\n    }\n    if (!DATA.map) {\n        DATA.map = map;\n    }\n    return map;\n}\nMake.map = make;\nexport function getCellAppearance(map, x, y, dest) {\n    dest.blackOut();\n    if (!map.hasXY(x, y))\n        return;\n    const cell = map.cell(x, y);\n    if (cell.isAnyKindOfVisible() &&\n        cell.flags & (CellFlags.CELL_CHANGED | CellFlags.NEEDS_REDRAW)) {\n        Cell.getAppearance(cell, dest);\n    }\n    else if (cell.isRevealed()) {\n        dest.drawSprite(cell.memory.mixer);\n    }\n    if (cell.isVisible()) {\n        // keep here to allow for games that do not use fov to work\n    }\n    else if (!cell.isRevealed()) {\n        dest.blackOut();\n    }\n    else if (!cell.isAnyKindOfVisible()) {\n        dest.bg.mix(COLORS.black, 30);\n        dest.fg.mix(COLORS.black, 30);\n    }\n    let needDistinctness = false;\n    if (cell.flags & (CellFlags.IS_CURSOR | CellFlags.IS_IN_PATH)) {\n        const highlight = cell.flags & CellFlags.IS_CURSOR ? COLORS.cursorColor : COLORS.yellow;\n        if (cell.hasTileMechFlag(TileMechFlags.TM_INVERT_WHEN_HIGHLIGHTED)) {\n            Color.swap(dest.fg, dest.bg);\n        }\n        else {\n            // if (!GAME.trueColorMode || !dest.needDistinctness) {\n            // dest.fg.mix(highlight, CONFIG.cursorPathIntensity || 20);\n            // }\n            dest.bg.mix(highlight, CONFIG.cursorPathIntensity || 20);\n        }\n        needDistinctness = true;\n    }\n    if (needDistinctness) {\n        Color.separate(dest.fg, dest.bg);\n    }\n    // dest.bake();\n}\nexport function addText(map, x, y, text, fg, bg, layer) {\n    for (let ch of text) {\n        const sprite = Canvas.makeSprite(ch, fg, bg);\n        const cell = map.cell(x++, y);\n        cell.addSprite(sprite, layer || TileLayer.GROUND);\n    }\n}\nexport function updateGas(map) {\n    if (map.flags & Flags.MAP_NO_GAS)\n        return;\n    const newVolume = Grid.alloc(map.width, map.height);\n    map.forEach((c, x, y) => {\n        if (c.hasTileFlag(TileFlags.T_OBSTRUCTS_GAS))\n            return;\n        let gas = c.gas;\n        let highest = c.gasVolume;\n        let sum = c.gasVolume;\n        let count = 1;\n        map.eachNeighbor(x, y, (n) => {\n            if (n.hasTileFlag(TileFlags.T_OBSTRUCTS_GAS))\n                return;\n            ++count;\n            sum += n.gasVolume;\n            if (n.gasVolume > highest) {\n                gas = n.gas;\n                highest = n.gasVolume;\n            }\n        });\n        if (!sum)\n            return;\n        const newVol = Math.floor(sum / count);\n        if (c.gas != gas) {\n            c._setTile(gas, newVol, map); // volume = 1 to start, will change later\n        }\n        newVolume[x][y] += newVol;\n        const rem = sum - count * Math.floor(sum / count);\n        if (rem && random.number(count) < rem) {\n            newVolume[x][y] += 1;\n        }\n        // disperses\n        // if (newVolume[x][y] && random.chance(20)) {\n        // \tnewVolume[x][y] -= 1;\n        // }\n    });\n    let hasGas = false;\n    newVolume.forEach((v, i, j) => {\n        const cell = map.cell(i, j);\n        if (v) {\n            hasGas = true;\n            if (cell.gas && cell.gasVolume !== v) {\n                cell.gasVolume = v;\n                map.redrawCell(cell);\n            }\n        }\n        else if (cell.gas) {\n            cell.clearLayer(TileLayer.GAS);\n            map.redrawCell(cell);\n        }\n    });\n    if (hasGas) {\n        map.flags &= ~Flags.MAP_NO_GAS;\n    }\n    else {\n        map.flags |= Flags.MAP_NO_GAS;\n    }\n    map.changed(true);\n    Grid.free(newVolume);\n}\nexport function updateLiquid(map) {\n    if (map.flags & Flags.MAP_NO_LIQUID)\n        return;\n    const newVolume = Grid.alloc(map.width, map.height);\n    map.forEach((c, x, y) => {\n        if (c.hasTileFlag(TileFlags.T_OBSTRUCTS_LIQUID))\n            return;\n        let liquid = c.liquid;\n        let highest = c.liquidVolume;\n        let count = 1;\n        map.eachNeighbor(x, y, (n) => {\n            if (n.hasTileFlag(TileFlags.T_OBSTRUCTS_LIQUID))\n                return;\n            ++count;\n            if (n.liquidVolume > highest) {\n                liquid = n.liquid;\n                highest = n.liquidVolume;\n            }\n        });\n        let newVol = c.liquidVolume;\n        if (newVol > 10 && count > 1) {\n            let spread = Math.round(0.2 * c.liquidVolume);\n            if (spread > 5) {\n                newVol -= spread;\n                if (c.liquid != liquid) {\n                    c._setTile(liquid, newVol, map); // volume = 1 to start, will change later\n                }\n                // spread = Math.floor(spread / count);\n                if (spread) {\n                    newVolume.eachNeighbor(x, y, (v, i, j) => {\n                        newVolume[i][j] = v + spread;\n                    });\n                }\n            }\n        }\n        newVolume[x][y] += newVol;\n        // disperses\n        const tile = c.liquidTile;\n        if (newVolume[x][y] > 0 && random.chance(tile.dissipate, 10000)) {\n            newVolume[x][y] -= 1;\n        }\n    });\n    let hasLiquid = false;\n    newVolume.forEach((v, i, j) => {\n        const cell = map.cell(i, j);\n        if (v) {\n            hasLiquid = true;\n            if (cell.liquid && cell.liquidVolume !== v) {\n                cell.liquidVolume = v;\n                map.redrawCell(cell);\n            }\n        }\n        else if (cell.liquid) {\n            cell.clearLayer(TileLayer.LIQUID);\n            map.redrawCell(cell);\n        }\n    });\n    if (hasLiquid) {\n        map.flags &= ~Flags.MAP_NO_LIQUID;\n    }\n    else {\n        map.flags |= Flags.MAP_NO_LIQUID;\n    }\n    map.changed(true);\n    Grid.free(newVolume);\n}\n","import * as Tile from \"./tile\";\n// These are the minimal set of tiles to make the diggers work\nTile.install(\"NULL\", {\n    ch: \"\\u2205\",\n    fg: \"white\",\n    bg: \"black\",\n    flags: \"T_OBSTRUCTS_PASSABILITY\",\n    name: \"eerie nothingness\",\n    article: \"an\",\n    priority: 0,\n});\nTile.install(\"FLOOR\", {\n    ch: \"\\u00b7\",\n    fg: [30, 30, 30, 20, 0, 0, 0],\n    bg: [2, 2, 10, 0, 2, 2, 0],\n    priority: 10,\n    article: \"the\",\n});\nTile.install(\"DOOR\", {\n    ch: \"+\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: \"T_IS_DOOR, T_OBSTRUCTS_TILE_EFFECTS, T_OBSTRUCTS_ITEMS, T_OBSTRUCTS_VISION, TM_VISUALLY_DISTINCT\",\n    article: \"a\",\n    activates: {\n        enter: { tile: \"DOOR_OPEN\" },\n        open: { tile: \"DOOR_OPEN_ALWAYS\" },\n    },\n});\nTile.install(\"DOOR_OPEN\", \"DOOR\", {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: \"!T_OBSTRUCTS_ITEMS, !T_OBSTRUCTS_VISION\",\n    name: \"open door\",\n    article: \"an\",\n    activates: {\n        tick: { tile: \"DOOR\", flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\" },\n        enter: null,\n        open: null,\n        close: { tile: \"DOOR\", flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\" },\n    },\n});\nTile.install(\"DOOR_OPEN_ALWAYS\", \"DOOR_OPEN\", {\n    activates: {\n        tick: null,\n        close: { tile: \"DOOR\", flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\" },\n    },\n});\nTile.install(\"BRIDGE\", {\n    ch: \"=\",\n    fg: [100, 40, 40],\n    priority: 40,\n    layer: \"SURFACE\",\n    flags: \"T_BRIDGE, TM_VISUALLY_DISTINCT\",\n    article: \"a\",\n});\nTile.install(\"UP_STAIRS\", {\n    ch: \"<\",\n    fg: [100, 40, 40],\n    bg: [100, 60, 20],\n    priority: 200,\n    flags: \"T_UP_STAIRS, T_STAIR_BLOCKERS, TM_VISUALLY_DISTINCT, TM_LIST_IN_SIDEBAR\",\n    name: \"upward staircase\",\n    article: \"an\",\n});\nTile.install(\"DOWN_STAIRS\", {\n    ch: \">\",\n    fg: [100, 40, 40],\n    bg: [100, 60, 20],\n    priority: 200,\n    flags: \"T_DOWN_STAIRS, T_STAIR_BLOCKERS, TM_VISUALLY_DISTINCT, TM_LIST_IN_SIDEBAR\",\n    name: \"downward staircase\",\n    article: \"a\",\n});\nTile.install(\"WALL\", {\n    ch: \"#\",\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: \"T_OBSTRUCTS_EVERYTHING\",\n    article: \"a\",\n});\nTile.install(\"LAKE\", {\n    ch: \"~\",\n    fg: [5, 8, 20, 10, 0, 4, 15, true],\n    bg: [10, 15, 41, 6, 5, 5, 5, true],\n    priority: 50,\n    flags: \"T_DEEP_WATER\",\n    name: \"deep water\",\n    article: \"the\",\n});\n"],"names":["Layer","Fl","Flag","fl","Activation","Tile","TileMech","Cell","CellMech","Map","DFF_BLOCKED_BY_ITEMS","DFF_BLOCKED_BY_ACTORS","DFF_NULL_SURFACE","DFF_NULL_LIQUID","DFF_NULL_GAS","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_OBSTRUCTS_PASSABILITY","T_OBSTRUCTS_VISION","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","T_OBSTRUCTS_ITEMS","T_OBSTRUCTS_GAS","T_OBSTRUCTS_SURFACE","T_OBSTRUCTS_LIQUID","T_OBSTRUCTS_DIAGONAL_MOVEMENT","T_OBSTRUCTS_TILE_EFFECTS","TM_PROMOTES_WITH_KEY","TM_PROMOTES_WITHOUT_KEY","TM_PROMOTES_ON_STEP","TM_PROMOTES_ON_ITEM_REMOVE","TM_PROMOTES_ON_SACRIFICE_ENTRY","TM_PROMOTES_ON_ELECTRICITY","TM_PROMOTES_ON_PLAYER_ENTRY","REVEALED","MAGIC_MAPPED","ITEM_DETECTED","HAS_ITEM","HAS_DORMANT_MONSTER","HAS_STAIRS","STABLE_MEMORY","IMPREGNABLE","VISIBLE","CLAIRVOYANT_VISIBLE","TELEPATHIC_VISIBLE","HAS_PLAYER","HAS_MONSTER","WAS_VISIBLE","WAS_CLAIRVOYANT_VISIBLE","WAS_TELEPATHIC_VISIBLE","IN_FOV","NEEDS_REDRAW","CELL_CHANGED","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_TRAP_FREE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","MAP_STABLE_LIGHTS","MAP_STABLE_GLOW_LIGHTS","MAP_FOV_CHANGED","TileEvent","[object Object]","opts","fn","this","tile","item","chance","volume","spread","radius","decrement","flags","from","Flags","matchTile","needs","next","message","lightFlare","flare","flashColor","flash","Color","messageDisplayed","emit","id","make","tileEvent","activations","DF_NONE","async","spawn","activation","ctx","i","j","feat","Utils","ERROR","map","x","y","undefined","safe","hasCellMechFlag","CellMechFlags","EVENT_FIRED_THIS_TURN","DFF_ALWAYS_FIRE","refreshCell","DFF_NO_REDRAW_CELL","abortIfBlocking","DFF_ABORT_IF_BLOCKS_MAP","length","isVisible","Msg","add","Tile.tiles","Make","blocking","DFF_PERMIT_BLOCKING","TileFlags","T_PATHING_BLOCKER","blocksMove","DFF_TREAT_AS_BLOCKING","spawnMap","Grid","alloc","width","height","didSomething","computeSpawnMap","gridDisruptsPassability","bounds","DFF_EVACUATE_CREATURES","evacuateCreatures","DFF_EVACUATE_ITEMS","evacuateItems","DFF_NULLIFY_CELL","nullifyCells","spawnTiles","delete","DFF_PROTECTED","forEach","v","cell","mechFlags","EVENT_PROTECTED","Data","gameHasEnded","actor","t","tiles","applyInstantEffects","Events","free","DFF_SUBSEQ_ALWAYS","DFF_SUBSEQ_EVERYWHERE","updateMapToShoreThisTurn","redrawXY","changed","DFF_NO_MARK_FIRED","setCellFlags","cellIsOk","hasXY","DFF_BUILD_IN_WALLS","isWall","DFF_MUST_TOUCH_WALLS","ok","eachNeighbor","c","DFF_NO_TOUCH_WALLS","containsXY","hasTile","hasTileFlag","dir","x2","y2","madeChange","startProb","probDec","name","DFF_SPREAD_CIRCLE","random","updateCircle","_v","dist","Math","floor","distanceBetween","prob","DFF_SPREAD_LINE","DIRS","number","accomplishedSomething","blockedByOtherLayers","DFF_BLOCKED_BY_OTHER_LAYERS","superpriority","DFF_SUPERPRIORITY","layers","layer","GAS","gasVolume","LIQUID","liquidVolume","priority","obstructsLayer","highestPriorityTile","setTile","removeItem","clone","addItem","nullSurface","nullLiquid","nullGas","clearCellLayers","blockingMap","monst","loc","matchingLocNear","forbidsCell","hallways","moveActor","dest","event","Object","values","f","config","CONFIG","light","INTENSITY_DARK","LIGHT_COMPONENTS","Light","color","range","fadeTo","pass","passThroughActors","Range","other","copy","intensity","maintainShadows","isMinersLight","k","lightMultiplier","value","outerRadius","ceil","bake","dispelShadows","fadeToPercent","grid","calcFov","Flags.Cell","HAS_ACTOR","Flags.Tile","overlappedFieldOfView","forCircle","IS_IN_SHADOW","ANY_KIND_OF_VISIBLE","max","args","cached","lights","split","trim","Number","parseInt","Array","isArray","Error","JSON","stringify","arg","install","source","recordOldLights","eachCell","oldLight","LIGHT_CHANGED","zeroOutLights","ambientLight","_i","_j","recordGlowLights","glowLight","restoreGlowLights","entries","info","Flags.Map","eachGlowLight","paint","setFlag","eachDynamicLight","CELL_LIT","CELL_DARK","some","isDark","updateDisplayDetail","PLAYER","DATA","player","MINERS_LIGHT","darkColor","r","g","b","base","GROUND","activates","flavor","desc","article","dissipate","assignOmitting","sprite","Canvas","Sprite","first","ch","fg","bg","opacity","MechFlags","Light.from","assign","key","TileEvent.make","e","tileId","flag","result","toString","getName","arguments","Extends","extends","cursorPathIntensity","CellMemory","mixer","Mixer","itemQuantity","cellFlags","cellMechFlags","tileFlags","tileMechFlags","nullify","sprites","_actor","_item","data","CELL_DEFAULT","machineNumber","memory","copyObject","ground","_a","liquid","surface","SURFACE","gas","groundTile","TILES","NULL","liquidTile","surfaceTile","gasTile","IS_WAS_ANY_KIND_OF_VISIBLE","orMapped","hasTileMechFlag","TileMechFlags","TM_LIST_IN_SIDEBAR","Light.intensity","limitToPlayerKnowledge","flagMask","cellFlag","cellMechFlag","isAnyKindOfVisible","successorFlags","successorTileFlags","discoveredTileFlags","skipGas","best","bestPriority","tileFlag","mechFlag","T_BRIDGE","isSecretDoor","isPassableNow","TM_CONNECTS_LEVEL","TM_PROMOTES","promotedTileFlags","T_OBSTRUCTS_EVERYTHING","T_IS_DOOR","TM_IS_SECRET","T_IS_LIQUID","T_GAS","oldTile","oldTileId","staleLoopMap","CAUGHT_FIRE_THIS_TURN","blocksVision","oldBlocksVision","MapFlags","removeSprite","addSprite","clearFlag","MAP_NO_LIQUID","MAP_NO_GAS","FLOOR","current","except","floorTile","_setTile","clearLayer","fired","ev","Activation.spawn","activatesOn","ITEM","ACTOR","prev","quantity","getAppearance","isOrWasAnyKindOfVisible","rememberedInCell","storeMemory","blackOut","needDistinctness","TM_VISUALLY_DISTINCT","alpha","clamp","drawSprite","multiply","separate","setDefaults","map.deepestLevel","w","h","locations","_actors","_items","events","_width","_height","cells","Cell.Cell","tick","MAP_DEFAULT","ambient","fmt","dump","forRect","only4dirs","isBoundaryXY","MAP_CHANGED","_needsRedraw","redrawCell","CellFlags","markRevealed","invalidateCostMap","hasVisibleLight","mapFlag","setFlags","clearFlags","tileWithFlag","tileWithMechFlag","hasDiscoveredTileFlag","canBePassed","isNull","isEmpty","isObstruction","isDoor","isLiquid","hasGas","blocksPathing","tileFlavor","clearLayersWithFlags","nullifyLayers","boundaryTile","matchFn","count","arcCount","x1","y1","costGrid","costFn","ONE","Path","OBSTRUCTION","matcher","maxIndex","d","match","TRUE","hallwaysAllowed","forbidLiquid","liquids","deterministic","candidateLocs","passableArcCount","push","randIndex","forbidCellFlags","forbidTileFlags","forbidTileMechFlags","tries","retry","removeFromChain","eachChain","anim","TileLayer","FX","oldCell","theActor","isPlayer","avoidsCell","addActor","removeActor","actorAt","theItem","isDetected","D_ITEM_OMNISCIENCE","blockingGrid","walkableGrid","disrupts","gridOffsetX","gridOffsetY","contains","blockingX","blockingY","floodFill","maxRadius","forbiddenCellFlags","forbiddenTileFlags","fill","Fov","FOV","isBlocked","hasCellFlag","calcRadius","sqrt","calculate","a","line","getLine","PERMANENT_CELL_FLAGS","PERMANENT_MECH_FLAGS","activate","updateLiquid","wall","boundary","wallTile","newVolume","highest","n","newVol","round","hasLiquid","Cell.getAppearance","isRevealed","mix","COLORS","black","IS_CURSOR","IS_IN_PATH","highlight","cursorColor","yellow","TM_INVERT_WHEN_HIGHLIGHTED","swap","text","makeSprite","sum","rem","enter","open","close"],"mappings":"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"}