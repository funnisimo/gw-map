{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/flags/horde.js","../js/entity/key.js","../js/action/action.js","../js/action/actions.js","../js/entity/entity.js","../js/entity/kind.js","../js/actor/status.js","../js/actor/stat.js","../js/actor/actor.js","../js/effect/effect.js","../js/tile/tile.js","../js/tile/index.js","../js/map/cell.js","../js/item/item.js","../js/entity/message.js","../js/actor/pain.js","../js/ai/ai.js","../js/ai/wander.js","../js/ai/typical.js","../js/ai/utils.js","../js/actor/kind.js","../js/actor/make.js","../js/item/kind.js","../js/item/make.js","../js/actions/standStill.js","../js/fx/fx.js","../js/actions/bump.js","../js/actions/moveDir.js","../js/actions/idle.js","../js/actions/pickup.js","../js/actions/climb.js","../js/effects/fn.js","../js/effects/activateMachine.js","../js/effects/chance.js","../js/effects/clear.js","../js/effects/emit.js","../js/effects/feature.js","../js/effects/msg.js","../js/effects/nourish.js","../js/effects/spread.js","../js/effects/stat.js","../js/effects/tile.js","../js/layer/mapLayer.js","../js/layer/tileLayer.js","../js/layer/gasLayer.js","../js/layer/fireLayer.js","../js/draw/basic.js","../js/map/map.js","../js/map/analyze.js","../js/map/snapshot.js","../js/map/utils.js","../js/map/make.js","../js/horde/horde.js","../js/horde/make.js","../js/memory/index.js","../js/player/attribute.js","../js/player/skill.js","../js/player/scent.js","../js/player/player.js","../js/player/kind.js","../js/player/make.js","../js/game/viewport.js","../js/game/message.js","../js/game/flavor.js","../js/game/sidebar.js","../js/game/game.js","../js/tile/tiles.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_NO_SIDEBAR\"] = Fl(13)] = \"L_NO_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_ON_MAP\"] = Fl(17)] = \"L_ON_MAP\";\n    Entity[Entity[\"L_IN_SIDEBAR\"] = Fl(18)] = \"L_IN_SIDEBAR\";\n    Entity[Entity[\"L_FORMAL_NAME\"] = Fl(20)] = \"L_FORMAL_NAME\";\n    Entity[Entity[\"L_ALWAYS_PLURAL\"] = Fl(21)] = \"L_ALWAYS_PLURAL\";\n    Entity[Entity[\"DEFAULT_ACTOR\"] = 0] = \"DEFAULT_ACTOR\";\n    Entity[Entity[\"DEFAULT_ITEM\"] = 0] = \"DEFAULT_ITEM\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n    Actor[Actor[\"HAS_MEMORY\"] = Fl(1)] = \"HAS_MEMORY\";\n    Actor[Actor[\"USES_FOV\"] = Fl(2)] = \"USES_FOV\";\n    Actor[Actor[\"STABLE_COST_MAP\"] = Fl(3)] = \"STABLE_COST_MAP\";\n    Actor[Actor[\"IS_VISIBLE\"] = Fl(4)] = \"IS_VISIBLE\";\n    Actor[Actor[\"WAS_VISIBLE\"] = Fl(5)] = \"WAS_VISIBLE\";\n    Actor[Actor[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n    Item[Item[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_SHALLOW_WATER\"] = Fl(4)] = \"T_SHALLOW_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_LIST_IN_SIDEBAR\"] = Fl(22)] = \"T_LIST_IN_SIDEBAR\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n    Tile[Tile[\"T_ANY_LIQUID\"] = Tile.T_IS_DEEP_LIQUID | Tile.T_SHALLOW_WATER] = \"T_ANY_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(0)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(1)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"KNOWN_TO_BE_SAFE\"] = Fl(2)] = \"KNOWN_TO_BE_SAFE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(14)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"STABLE_SNAPSHOT\"] = Fl(15)] = \"STABLE_SNAPSHOT\";\n    // These are to speed checks\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(16)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(17)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(18)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(19)] = \"HAS_ITEM\";\n    Cell[Cell[\"HAS_FX\"] = Fl(20)] = \"HAS_FX\";\n    Cell[Cell[\"HAS_TICK_EFFECT\"] = Fl(22)] = \"HAS_TICK_EFFECT\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(23)] = \"IS_CURSOR\";\n    Cell[Cell[\"IS_HIGHLIGHTED\"] = Fl(24)] = \"IS_HIGHLIGHTED\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_SAFE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_NEEDS_REDRAW\"] = Fl(1)] = \"MAP_NEEDS_REDRAW\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_SIDEBAR_TILES_CHANGED\"] = Fl(10)] = \"MAP_SIDEBAR_TILES_CHANGED\";\n    Map[Map[\"MAP_SIDEBAR_CHANGED\"] = Fl(11)] = \"MAP_SIDEBAR_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_IGNORE_FOV\"] = Fl(12)] = \"E_IGNORE_FOV\";\n    // E_SPREAD_CIRCLE = Fl(13), // Spread in a circle around the spot (using FOV), radius calculated using spread+decrement\n    // E_SPREAD_LINE = Fl(14), // Spread in a line in one random direction\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Horde;\n(function (Horde) {\n    Horde[Horde[\"HORDE_DIES_ON_LEADER_DEATH\"] = Fl(0)] = \"HORDE_DIES_ON_LEADER_DEATH\";\n    Horde[Horde[\"HORDE_IS_SUMMONED\"] = Fl(1)] = \"HORDE_IS_SUMMONED\";\n    Horde[Horde[\"HORDE_SUMMONED_AT_DISTANCE\"] = Fl(2)] = \"HORDE_SUMMONED_AT_DISTANCE\";\n    Horde[Horde[\"HORDE_NO_PERIODIC_SPAWN\"] = Fl(4)] = \"HORDE_NO_PERIODIC_SPAWN\";\n    Horde[Horde[\"HORDE_ALLIED_WITH_PLAYER\"] = Fl(5)] = \"HORDE_ALLIED_WITH_PLAYER\";\n    Horde[Horde[\"HORDE_NEVER_OOD\"] = Fl(15)] = \"HORDE_NEVER_OOD\";\n    // Move all these to tags?\n    // HORDE_LEADER_CAPTIVE = Fl(3), // the leader is in chains and the followers are guards\n    // HORDE_MACHINE_BOSS = Fl(6), // used in machines for a boss challenge\n    // HORDE_MACHINE_WATER_MONSTER = Fl(7), // used in machines where the room floods with shallow water\n    // HORDE_MACHINE_CAPTIVE = Fl(8), // powerful captive monsters without any captors\n    // HORDE_MACHINE_STATUE = Fl(9), // the kinds of monsters that make sense in a statue\n    // HORDE_MACHINE_TURRET = Fl(10), // turrets, for hiding in walls\n    // HORDE_MACHINE_MUD = Fl(11), // bog monsters, for hiding in mud\n    // HORDE_MACHINE_KENNEL = Fl(12), // monsters that can appear in cages in kennels\n    // HORDE_VAMPIRE_FODDER = Fl(13), // monsters that are prone to capture and farming by vampires\n    // HORDE_MACHINE_LEGENDARY_ALLY = Fl(14), // legendary allies\n    // HORDE_MACHINE_THIEF = Fl(16), // monsters that can be generated in the key thief area machines\n    // HORDE_MACHINE_GOBLIN_WARREN = Fl(17), // can spawn in goblin warrens\n    // HORDE_SACRIFICE_TARGET = Fl(18), // can be the target of an assassination challenge; leader will get scary light.\n    // HORDE_MACHINE_ONLY = HORDE_MACHINE_BOSS |\n    //     HORDE_MACHINE_WATER_MONSTER |\n    //     HORDE_MACHINE_CAPTIVE |\n    //     HORDE_MACHINE_STATUE |\n    //     HORDE_MACHINE_TURRET |\n    //     HORDE_MACHINE_MUD |\n    //     HORDE_MACHINE_KENNEL |\n    //     HORDE_VAMPIRE_FODDER |\n    //     HORDE_MACHINE_LEGENDARY_ALLY |\n    //     HORDE_MACHINE_THIEF |\n    //     HORDE_MACHINE_GOBLIN_WARREN |\n    //     HORDE_SACRIFICE_TARGET,\n})(Horde || (Horde = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","export class Action {\n    constructor(action, opts) {\n        this.actor = null; // actor doing the acting\n        this.item = null; // item being acted upon (if any/known)\n        this.x = 0;\n        this.y = 0;\n        this.target = null;\n        this.dir = null;\n        this.aware = false;\n        this.identified = false;\n        this.machine = 0;\n        this.try = false;\n        this.force = false;\n        this.good = false;\n        this.seen = false;\n        this.quiet = false;\n        // TODO - move to Game\n        // rng?: GWU.rng.Random;\n        // time = 0; // turn time (-1 means dead, 0 means no action, >0 means did something)\n        this.ok = false;\n        this.failed = false;\n        this.done = false;\n        this.logged = false; // message was logged\n        this.visible = false; // visible to player\n        this.data = {};\n        this.action = action;\n        this.map = opts.map;\n        this.game = opts.game || this.map.game;\n        this.actor = opts.actor || null;\n        this.item = opts.item || null;\n        this.target = opts.target || null;\n        if (opts.x !== undefined) {\n            this.x = opts.x;\n            this.y = opts.y;\n        }\n        else if (this.actor) {\n            this.x = this.actor.x;\n            this.y = this.actor.y;\n        }\n        else if (this.item) {\n            this.x = this.item.x;\n            this.y = this.item.y;\n        }\n        this.originX = this.x;\n        this.originY = this.y;\n        this.key = !!opts.key;\n        if (opts.force)\n            this.force = true;\n        if (opts.aware)\n            this.aware = true;\n        if (opts.machine)\n            this.machine = opts.machine;\n    }\n    isSuccess() {\n        return this.ok;\n    }\n    isFailed() {\n        return this.failed;\n    }\n    didSomething() {\n        this.ok = true;\n    }\n    didNothing() { }\n    fail() {\n        this.failed = true;\n        this.done = true;\n    }\n    isDone() {\n        return this.done;\n    }\n    stop() {\n        this.done = true;\n    }\n    reset() {\n        this.done = false;\n        this.failed = false;\n        this.ok = false;\n    }\n}\n// export type ActionNext = () => boolean;\n// export type ActionFn = (req: ActionCtx, next: ActionNext) => boolean;\n// export type ActionAfterFn = (req: ActionCtx) => void;\n// export enum Priority {\n//     FIRST = 0,\n//     EARLY = 25,\n//     NORMAL = 50,\n//     LATE = 75,\n//     LAST = 100,\n// }\n// export interface Action {\n//     fn: ActionFn;\n//     priority: Priority;\n// }\n// interface ActionData {\n//     fns: Action[];\n//     afterFns: ActionAfterFn[];\n// }\n// export interface ActionObj {\n//     [key: string]: ActionFn | ActionFn[] | null | false;\n// }\n// export type ActionBase = ActionFn | ActionFn[];\n// export type ActionConfig = ActionBase | ActionObj;\n// // function isActionObj(arg: any): arg is ActionObj {\n// //     return typeof arg === 'object' && !Array.isArray(arg);\n// // }\n// export class ActionManager {\n//     ACTIONS: Record<string, ActionData> = {};\n//     has(name: string): boolean {\n//         return name in this.ACTIONS;\n//     }\n//     load(obj: ActionObj) {\n//         Object.entries(obj).forEach(([key, value]) => {\n//             if (!value) {\n//                 this.clear(key);\n//             } else {\n//                 this.use(key, value);\n//             }\n//         });\n//     }\n//     copy(other: ActionManager) {\n//         Object.entries(other.ACTIONS).forEach(([name, data]) => {\n//             this.ACTIONS[name] = {\n//                 fns: data.fns.slice(),\n//                 afterFns: data.afterFns.slice(),\n//             };\n//         });\n//     }\n//     clear(name: string) {\n//         delete this.ACTIONS[name];\n//     }\n//     use(name: string, fn: ActionBase): void;\n//     use(\n//         name: string,\n//         fn: ActionFn,\n//         afterFn?: ActionAfterFn,\n//         priority?: number | keyof typeof Priority\n//     ): void;\n//     use(\n//         name: string,\n//         fn: ActionFn,\n//         priority?: number | keyof typeof Priority\n//     ): void;\n//     use(\n//         name: string,\n//         fn: ActionBase,\n//         afterFn?: ActionAfterFn | number | keyof typeof Priority,\n//         priority?: number | keyof typeof Priority\n//     ): void {\n//         if (Array.isArray(fn)) {\n//             if (fn.length && !fn[0]) {\n//                 this.clear(name);\n//                 fn.shift();\n//             }\n//             fn = chain(...fn);\n//         }\n//         if (typeof afterFn !== 'function') {\n//             priority = afterFn;\n//             afterFn = undefined;\n//         }\n//         if (priority === undefined) priority = Priority.NORMAL;\n//         if (typeof priority === 'string') {\n//             priority = Priority[priority] || 50;\n//         }\n//         if (name.startsWith('!') || name.startsWith('^')) {\n//             name = name.substring(1);\n//             priority = Priority.FIRST;\n//         } else if (name.startsWith('-')) {\n//             name = name.substring(1);\n//             priority = Priority.EARLY;\n//         } else if (name.startsWith('+')) {\n//             name = name.substring(1);\n//             priority = Priority.LATE;\n//         } else if (name.startsWith('$')) {\n//             name = name.substring(1);\n//             priority = Priority.LAST;\n//         }\n//         if (!(name in this.ACTIONS)) {\n//             this.ACTIONS[name] = { fns: [], afterFns: [] };\n//         }\n//         const data = this.ACTIONS[name];\n//         const a = { fn, priority };\n//         data.fns.unshift(a); // should go before others with same priority\n//         data.fns.sort((a, b) => a.priority - b.priority);\n//         if (afterFn) {\n//             data.afterFns.push(afterFn);\n//         }\n//     }\n//     useAfter(name: string, fn: ActionAfterFn) {\n//         if (!(name in this.ACTIONS)) {\n//             this.ACTIONS[name] = { fns: [], afterFns: [] };\n//         }\n//         const data = this.ACTIONS[name];\n//         data.afterFns.push(fn);\n//     }\n//     trigger(action: string, req: ActionCtx, next?: ActionNext): boolean {\n//         const data = this.ACTIONS[action];\n//         if (data) {\n//             return this._trigger(req, data.fns, data.afterFns, next);\n//         }\n//         return true;\n//     }\n//     _trigger(\n//         req: ActionCtx,\n//         fns: Action[],\n//         afterFns: ActionAfterFn[] = [],\n//         next?: ActionNext\n//     ): boolean {\n//         let index = -1;\n//         function _next(): boolean {\n//             index += 1;\n//             if (index >= fns.length) {\n//                 return next ? next() : true;\n//             }\n//             const result = fns[index].fn(req, _next);\n//             return result;\n//         }\n//         const result = _next();\n//         afterFns.forEach((fn) => fn(req));\n//         return result;\n//     }\n// }\n// export function chain(...fns: ActionFn[]): ActionFn {\n//     return function (req: ActionCtx, next: ActionNext): boolean {\n//         let index = -1;\n//         function _next(): boolean {\n//             index += 1;\n//             if (index >= fns.length) {\n//                 return next();\n//             }\n//             return fns[index](req, _next);\n//         }\n//         return _next();\n//     };\n// }\n// export function each(...fns: ActionFn[]): ActionFn {\n//     return function (req: ActionCtx, next: ActionNext): boolean {\n//         for (let fn of fns) {\n//             fn(req, GWU.TRUE);\n//         }\n//         return next();\n//     };\n// }\n// export function make(opts?: ActionBase): ActionManager {\n// }\n/*\n    ActorKind\n        actions: Record<string,ActionFn[]>={};\n        use(action, fn, priority) {\n            // push\n            // sort\n        }\n        exec(action,req, res) {\n            // see exec\n        }\n*/\n/*\n\nfunction TRUE() { return true; }\n\ntype ActionCtx = any;\ntype ActionNext = () => boolean | boolean;\ntype ActionFn = (ctx: ActionCtx, next: ActionNext) => boolean | boolean;\n\ninterface ActionObj {\n  actions: Record<string, ActionFn[]>;\n}\n\n function actionObj(ev: string, ctx: ActionCtx, obj: ActionObj, next: ActionNext=TRUE): boolean {\n\n  const allActions = obj.actions;\n  if (!(ev in allActions)) return next();\n  const actions = allActions[ev];\n  \n  let index = -1;\n   function _next() : boolean {\n    ++index;\n    if (index >= actions.length) return next();\n    return actions[index](ctx, _next);\n  }\n\n  return _next();\n}\n\n// e.g. actionObj('test', {}, a, next);\n\n function actionObjs(ev: string, ctx: ActionCtx, objs: ActionObj[], next:ActionNext=TRUE): boolean {\n\n  let index = -1;\n   function _nextObj() {\n    ++index;\n    if (index >= objs.length) return next();\n    const obj = objs[index];\n    return actionObj(ev, ctx, obj, _nextObj);\n  }\n\n  return _nextObj();\n}\n\n// e.g. actionObjs('test', {}, a, b, c, next);\n\ntype ActionArg = ActionFn | { eg: string, obj: ActionObj };\ntype ChainList = [...ActionArg[], ActionNext] | ActionArg[];\n\n function actionChain(ctx: ActionCtx, ...args: ChainList) : boolean {\n\n\n\n  return true;\n}\n\n// map move might include something like...\n// e.g. actionChain({}, { ev: 'exit', obj: cell }, { ev: 'enter', obj: newCell }, next);\n// enter - covers bump/collide\n*/\n","import * as GWU from 'gw-utils';\nimport { Action } from './action';\nexport class Actions {\n    constructor(ctx) {\n        this._handlers = {};\n        this.onUnhandled = null;\n        this._ctx = ctx;\n    }\n    copy(other) {\n        Object.entries(other._handlers).forEach(([ev, fns]) => {\n            if (!fns)\n                return;\n            this._handlers[ev] = Array.isArray(fns) ? fns.slice() : fns;\n        });\n    }\n    has(ev) {\n        const events = this._handlers[ev];\n        if (!events)\n            return false;\n        return events.some((e) => e && !!e.fn);\n    }\n    on(ev, fn) {\n        if (Array.isArray(ev)) {\n            const cleanup = ev.map((e) => this.on(e, fn));\n            return () => {\n                cleanup.forEach((c) => c());\n            };\n        }\n        if (Array.isArray(fn)) {\n            const cleanup = fn.map((cb) => this.on(ev, cb));\n            return () => {\n                cleanup.forEach((c) => c());\n            };\n        }\n        let handlers = this._handlers[ev];\n        if (!handlers) {\n            handlers = this._handlers[ev] = [];\n        }\n        const info = { fn };\n        handlers.unshift(info);\n        return () => {\n            const events = this._handlers[ev];\n            if (Array.isArray(events)) {\n                GWU.arrayNullify(events, info);\n            }\n        };\n    }\n    load(obj) {\n        Object.entries(obj).forEach(([ev, cfg]) => {\n            this.on(ev, cfg);\n        });\n    }\n    once(ev, fn) {\n        if (Array.isArray(ev)) {\n            const cleanup = ev.map((e) => this.once(e, fn));\n            return () => {\n                cleanup.forEach((c) => c());\n            };\n        }\n        if (Array.isArray(fn)) {\n            const cleanup = fn.map((cb) => this.on(ev, cb));\n            return () => {\n                cleanup.forEach((c) => c());\n            };\n        }\n        let handlers = this._handlers[ev];\n        if (!handlers) {\n            handlers = this._handlers[ev] = [];\n        }\n        const info = { fn, once: true };\n        handlers.unshift(info);\n        return () => {\n            const events = this._handlers[ev];\n            if (Array.isArray(events)) {\n                GWU.arrayNullify(events, info);\n            }\n        };\n    }\n    off(ev, cb) {\n        if (Array.isArray(ev)) {\n            ev.forEach((e) => this.off(e, cb));\n            return;\n        }\n        const events = this._handlers[ev];\n        if (!events)\n            return;\n        if (cb) {\n            const current = events.findIndex((i) => i && i.fn === cb);\n            if (current > -1) {\n                events[current] = null;\n            }\n        }\n        else {\n            for (let i = 0; i < events.length; ++i) {\n                events[i] = null;\n            }\n        }\n    }\n    trigger(ev, action) {\n        if (ev instanceof Action) {\n            return this.trigger(ev.action, ev);\n        }\n        if (!action)\n            throw new Error('Need Action parameter.');\n        if (Array.isArray(ev)) {\n            let didSomething = false;\n            for (let name of ev) {\n                didSomething = this.trigger(name, action) || didSomething;\n                if (action.isDone())\n                    return didSomething;\n            }\n            return didSomething;\n        }\n        const handlers = this._handlers[ev];\n        if (!handlers || handlers.length == 0) {\n            return this._unhandled(ev, action);\n        }\n        for (let i = 0; i < handlers.length; ++i) {\n            const info = handlers[i];\n            if (info) {\n                if (info.fn) {\n                    // console.log('info.fn', info.fn);\n                    info.fn.call(this._ctx, action);\n                }\n                if (info.once) {\n                    handlers[i] = null;\n                }\n            }\n            if (action.isDone())\n                break;\n        }\n        this._handlers[ev] = handlers.filter((i) => i);\n        return true;\n    }\n    _unhandled(ev, action) {\n        if (!this.onUnhandled)\n            return false;\n        this.onUnhandled(ev, action);\n        return true;\n    }\n    clear() {\n        this._handlers = {};\n        this.onUnhandled = null;\n    }\n    restart() {\n        Object.keys(this._handlers).forEach((ev) => {\n            this._handlers[ev] = this._handlers[ev].filter((i) => i && !i.once);\n        });\n        // this.onUnhandled = null;\n    }\n}\nconst global = new Actions();\nexport function install(ev, fn) {\n    fn.seen = false;\n    global.on(ev, fn);\n}\nexport function doAction(ev, action) {\n    if (!(action instanceof Action)) {\n        action = new Action(ev, action);\n    }\n    if (action.actor) {\n        if (!action.actor.canDoAction(ev)) {\n            return action.fail();\n        }\n    }\n    if (action.item) {\n        if (!action.item.canDoAction(ev)) {\n            return action.fail();\n        }\n    }\n    action.map.trigger(ev, action);\n    if (action.isDone())\n        return;\n    if (action.item) {\n        action.item.trigger(ev, action);\n        if (action.isDone())\n            return;\n    }\n    action.actor && action.actor.trigger(ev, action);\n    if (action.isDone())\n        return;\n    action.game.trigger(ev, action);\n    if (action.isDone())\n        return;\n    global.trigger(ev, action);\n}\nexport function defaultAction(ev, _action) {\n    // if we get here then there was no action installed, this is a problem\n    throw new Error('Unhandled action - ' + ev);\n}\nglobal.onUnhandled = defaultAction;\n","import * as Flags from '../flags/entity';\nimport * as ACTION from '../action';\nlet lastId = 0;\nexport class Entity {\n    // lastSeen: GWU.xy.Loc = [-1, -1];\n    constructor(kind) {\n        this._map = null;\n        this.key = null;\n        this.machineHome = 0;\n        this.changed = true;\n        this.actions = new ACTION.Actions(this);\n        this._actions = {};\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n        this.id = '' + ++lastId;\n    }\n    get map() {\n        return this._map;\n    }\n    isPlural() {\n        return this.hasEntityFlag(Flags.Entity.L_ALWAYS_PLURAL);\n    }\n    isOnMap() {\n        // return this.hasEntityFlag(Flags.Entity.L_ON_MAP);\n        return !!this._map;\n    }\n    addToMap(map, x, y) {\n        this.x = x;\n        this.y = y;\n        this.setEntityFlag(Flags.Entity.L_ON_MAP);\n        if (this._map === map) {\n            return false;\n        }\n        this._map = map;\n        this.kind.addToMap(this, map);\n        return true;\n    }\n    removeFromMap() {\n        this.clearEntityFlag(Flags.Entity.L_ON_MAP);\n        this.kind.removeFromMap(this);\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    isAt(x, y) {\n        return this.x === x && this.y === y;\n    }\n    clone() {\n        const other = new this.constructor(this.kind);\n        other.copy(this);\n        return other;\n    }\n    copy(other) {\n        this.depth = other.depth;\n        this.light = other.light;\n        Object.assign(this.flags, other.flags);\n        this.next = other.next;\n        this.x = other.x;\n        this.y = other.y;\n        this.kind = other.kind;\n        this.id = other.id;\n    }\n    canBeSeen() {\n        return this.kind.canBeSeen(this);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    setEntityFlag(flag) {\n        this.flags.entity |= flag;\n    }\n    clearEntityFlag(flag) {\n        this.flags.entity &= ~flag;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isKey(x, y) {\n        return this.key && this.key.matches(x, y);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(cell, this);\n    }\n    avoidsCell(cell) {\n        return this.kind.avoidsCell(cell, this);\n    }\n    getName(opts) {\n        return this.kind.getName(this, opts);\n    }\n    getDescription(opts) {\n        return this.kind.getDescription(this, opts);\n    }\n    getFlavor(opts) {\n        return this.kind.getFlavor(this, opts);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n    drawSidebar(buffer, bounds) {\n        return this.kind.drawSidebar(this, buffer, bounds);\n    }\n    drawInto(dest, _observer) {\n        dest.drawSprite(this.sprite);\n    }\n    canDoAction(action) {\n        const v = this._actions[action];\n        if (v !== undefined)\n            return v;\n        return this.kind.canDoAction(action);\n    }\n    hasAction(action) {\n        return this.actions.has(action) || this.kind.actions.has(action);\n    }\n    on(action, fn) {\n        this.actions.on(action, fn);\n    }\n    once(action, fn) {\n        this.actions.once(action, fn);\n    }\n    off(action, fn) {\n        this.actions.off(action, fn);\n    }\n    trigger(name, action) {\n        if (name instanceof ACTION.Action) {\n            return this.trigger(name.action, name);\n        }\n        if (!action)\n            throw new Error('Action required.');\n        if (action.isDone())\n            return;\n        this.actions.trigger(name, action);\n        if (action.isDone())\n            return;\n        this.kind.trigger(name, action);\n    }\n    toString() {\n        return `${this.kind.id}-${this.id} @ ${this.x},${this.y}`;\n    }\n}\nEntity.default = {\n    sidebarFg: 'purple',\n};\n","import * as GWU from 'gw-utils';\nimport { Entity } from './entity';\nimport * as Flags from '../flags';\nimport * as ACTION from '../action';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.requireTileFlags = 0;\n        this.forbidTileFlags = 0;\n        this.avoidTileFlags = 0;\n        this.requireTileTags = [];\n        this.forbidTileTags = [];\n        this.avoidTileTags = [];\n        this.actions = new ACTION.Actions(this);\n        this._actions = {};\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config.sprite ? config.sprite : config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        if (config.requireTileFlags) {\n            this.requireTileFlags = GWU.flag.from(Flags.Tile, config.requireTileFlags);\n        }\n        if (config.avoidTileFlags) {\n            this.avoidTileFlags = GWU.flag.from(Flags.Tile, config.avoidTileFlags);\n        }\n        if (config.forbidTileFlags) {\n            this.forbidTileFlags = GWU.flag.from(Flags.Tile, config.forbidTileFlags);\n        }\n        if (config.requireTileTags) {\n            if (typeof config.requireTileTags === 'string') {\n                config.requireTileTags = config.requireTileTags.split(/[,|]/g);\n            }\n            this.requireTileTags = config.requireTileTags.map((t) => t.trim());\n        }\n        if (config.avoidTileTags) {\n            if (typeof config.avoidTileTags === 'string') {\n                config.avoidTileTags = config.avoidTileTags.split(/[,|]/g);\n            }\n            this.avoidTileTags = config.avoidTileTags.map((t) => t.trim());\n        }\n        if (config.forbidTileTags) {\n            if (typeof config.forbidTileTags === 'string') {\n                config.forbidTileTags = config.forbidTileTags.split(/[,|]/g);\n            }\n            this.forbidTileTags = config.forbidTileTags.map((t) => t.trim());\n        }\n        if (config.drawSidebar) {\n            this.drawSidebar = config.drawSidebar;\n        }\n        this.sidebarFg = GWU.color.from(config.sidebarFg || Entity.default.sidebarFg);\n        if (config.actions) {\n            Object.entries(config.actions).forEach(([name, value]) => this.on(name, value));\n        }\n    }\n    make(opts) {\n        const entity = new Entity(this);\n        this.init(entity, opts);\n        return entity;\n    }\n    init(entity, opts = {}) {\n        if (opts.machineHome) {\n            entity.machineHome = opts.machineHome;\n        }\n    }\n    addToMap(_entity, _map) { }\n    removeFromMap(_entity) { }\n    canBeSeen(_entity) {\n        return true;\n    }\n    forbidsCell(cell, _entity) {\n        if (this.requireTileFlags &&\n            !cell.hasAllTileFlags(this.requireTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.forbidTileFlags &&\n            cell.hasTileFlag(this.forbidTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.requireTileTags.length &&\n            !cell.hasAllTileTags(this.requireTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.forbidTileTags.length &&\n            cell.hasAnyTileTag(this.forbidTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        return false;\n    }\n    avoidsCell(cell, entity) {\n        if (this.forbidsCell(cell, entity))\n            return true;\n        if (this.avoidTileFlags &&\n            cell.hasTileFlag(this.avoidTileFlags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        if (this.avoidTileTags.length &&\n            cell.hasAnyTileTag(this.avoidTileTags) &&\n            !cell.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return true;\n        }\n        return false;\n    }\n    getName(_entity, _opts) {\n        return this.name;\n    }\n    getDescription(_entity, _opts) {\n        return this.description;\n    }\n    getFlavor(_entity, _opts) {\n        return this.flavor;\n    }\n    getVerb(_entity, verb) {\n        return verb;\n    }\n    drawSidebar(entity, buffer, bounds) {\n        if (!entity.map)\n            return 0;\n        if (entity.isDestroyed)\n            return 0;\n        const mixer = new GWU.sprite.Mixer();\n        entity.map.getAppearanceAt(entity.x, entity.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, entity.getName(), this.sidebarFg);\n        return 1;\n    }\n    canDoAction(action) {\n        const v = this._actions[action];\n        if (v !== undefined)\n            return v;\n        return true; // by default you can do everything!\n    }\n    on(action, fn) {\n        if (Array.isArray(action)) {\n            action.forEach((a) => this.on(a, fn));\n            return;\n        }\n        if (fn === true) {\n            this._actions[action] = true;\n        }\n        else if (fn === false) {\n            this._actions[action] = false;\n        }\n        else {\n            this.actions.on(action, fn);\n            this._actions[action] = true;\n        }\n    }\n    off(action) {\n        if (Array.isArray(action)) {\n            action.forEach((a) => this.off(a));\n            return;\n        }\n        this._actions[action] = false;\n    }\n    trigger(name, action) {\n        if (name instanceof ACTION.Action) {\n            return this.trigger(name.action, name);\n        }\n        if (!action)\n            throw new Error('Action required.');\n        if (action.isDone())\n            return;\n        this.actions.trigger(name, action);\n    }\n}\nexport function make(opts, makeOpts = {}) {\n    const kind = new EntityKind(opts);\n    return kind.make(makeOpts);\n}\n","import * as GWU from 'gw-utils';\nexport class Status {\n    constructor() {\n        this._set = {};\n        this._time = {};\n        this._count = {};\n        this._done = {};\n        this._value = {};\n        this.changed = null;\n    }\n    clear(name) {\n        this.clearTime(name);\n        this.clearCount(name);\n        this.setOff(name);\n        return this._update(name);\n    }\n    get(name) {\n        return this._value[name] || false;\n    }\n    has(name) {\n        return this._value[name] || false;\n    }\n    _addDone(name, done) {\n        if (done) {\n            if (!this._done[name]) {\n                this._done[name] = done;\n            }\n        }\n    }\n    /**\n     * Sets the count for a status variable.\n     * If setting the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} count The count to set.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not setting the count turned the status on.\n     */\n    setCount(name, count, done) {\n        const status = this;\n        status._count[name] = Math.max(count, status._count[name] || 0);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Increments the count for the status by the given amount (1=default)\n     * If incrementing the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} [count=1] The count to incrmeent.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not incrementing the count turned the status on.\n     */\n    increment(name, count = 1, done) {\n        if (typeof count == 'function') {\n            done = count;\n            count = 1;\n        }\n        const status = this;\n        status._count[name] = (status._count[name] || 0) + count;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Decrements the count for the status by the given amount (1=default)\n     * If decrementing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @param {number} [count=1] The count to decrement.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    decrement(name, count = 1) {\n        const status = this;\n        status._count[name] = Math.max(0, (status._count[name] || 0) - count);\n        return this._update(name);\n    }\n    /**\n     * Clears all counts from the given status.\n     * If clearing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    clearCount(name) {\n        const status = this;\n        status._count[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Turns on the given status.\n     * @param {string} name The status to adjust.\n     * @param {function} [done] The function to call when the status is turned off.\n     * @returns {boolean} True if this turns on the status. (It could be on because of a time or count).\n     */\n    setOn(name, done) {\n        const status = this;\n        status._set[name] = true;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Turns off the given status.\n     *\n     * @param {string} name The status to adjust.\n     * @returns {boolean} True if this turns off the status. (It could be on because of a time or count).\n     */\n    setOff(name) {\n        const status = this;\n        status._set[name] = false;\n        return this._update(name);\n    }\n    /**\n     * Sets the time for a status variable.\n     * If setting the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to set.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not setting the time turned the status on.\n     */\n    setTime(name, value, done) {\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        const current = status._time[name] || 0;\n        status._time[name] = Math.max(value, current);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Adds to the time for a status variable.\n     * If adding to the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to add.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not adding the time turned the status on.\n     */\n    addTime(name, value = 1, done) {\n        if (typeof value == 'function') {\n            done = value;\n            value = 1;\n        }\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        status._time[name] = (status._time[name] || 0) + value;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Removes time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to remove.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    removeTime(name, value = 1) {\n        const status = this;\n        value = GWU.range.make(value).value();\n        status._time[name] = Math.max(0, (status._time[name] || 0) - value);\n        return this._update(name);\n    }\n    /**\n     * Removes all time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    clearTime(name) {\n        const status = this;\n        status._time[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Removes time for all status variables that have time.\n     * If removing the time turns off any status (it was on),\n     * then this function returns an object with all of those statuses as keys and false as the values.  Otherwise, false.\n     * @param {Status|object} source The object to set the status on.  If object.status is set then that is where the values are updated.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean|object} false or an object with the names of the statuses that were cleared as keys and false as the values.\n     */\n    decayAllTimes(delta = 1) {\n        const status = this;\n        const cleared = {};\n        let noticed = false;\n        for (let name in status._time) {\n            if (this.removeTime(name, delta)) {\n                noticed = true;\n                cleared[name] = false;\n            }\n        }\n        return noticed ? cleared : false;\n    }\n    /**\n     * Updates the value of the status and returns whether or not this change\n     * turned the status on or off (true = change, false = no change)\n     * @param {string} name The name of the status to update\n     * @returns {boolean} True if the value was turned on or off, False otherwise.\n     */\n    _update(name) {\n        const status = this;\n        const rec = this._value;\n        let was = rec[name];\n        let value = (rec[name] =\n            status._set[name] ||\n                status._time[name] > 0 ||\n                status._count[name] > 0 ||\n                false);\n        const doneFn = this._done[name];\n        if (!value && doneFn) {\n            doneFn(this, name);\n            status._done[name] = null;\n        }\n        if (was && !value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: false');\n            return true;\n        }\n        else if (!was && value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: true');\n            return true;\n        }\n        return false;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Stats {\n    constructor(opts = {}) {\n        this._max = {};\n        this._rate = {};\n        this._value = {};\n        this.init(opts);\n    }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    getPct(name) {\n        const max = this.max(name);\n        return max ? Math.round((100 * this.get(name)) / max) : 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    regen(name) {\n        return this._rate[name] || null;\n    }\n    init(opts) {\n        for (let name in opts) {\n            this.set(name, opts[name]);\n        }\n    }\n    set(name, v, max) {\n        if (typeof v !== 'number') {\n            const r = GWU.range.make(v);\n            v = r.value();\n        }\n        this._value[name] = v;\n        this._max[name] = max || v;\n    }\n    gain(name, amount, allowOver = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        let v = this._value[name] + amount;\n        if (!allowOver) {\n            v = Math.min(v, this._max[name]);\n        }\n        this._value[name] = v;\n    }\n    drain(name, amount) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._value[name] = Math.max(0, this._value[name] - amount);\n    }\n    raiseMax(name, amount, raiseValue = true) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] += amount;\n        if (raiseValue) {\n            this.gain(name, amount);\n        }\n    }\n    reduceMax(name, amount, lowerValue = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] = Math.max(0, this._max[name] - amount);\n        if (lowerValue) {\n            this.drain(name, amount);\n        }\n    }\n    setRegen(name, turns, count = 1) {\n        const r = (this._rate[name] = this._rate[name] || { elapsed: 0 });\n        r.turns = turns;\n        r.count = count;\n    }\n    regenAll() {\n        for (let name in this._max) {\n            const r = this._rate[name];\n            r.elapsed += 1;\n            if (r.elapsed >= r.turns) {\n                this.gain(name, r.count);\n                r.elapsed -= r.turns;\n            }\n        }\n    }\n    restore(name, value) {\n        if (value === undefined)\n            value = this._max[name];\n        this._value[name] = value;\n    }\n    adjust(name, type, amount) {\n        amount = GWU.range.from(amount);\n        const v = amount.value();\n        const c = this.get(name);\n        if (type === 'inc') {\n            this.gain(name, amount);\n        }\n        else if (type === 'dec') {\n            this.drain(name, amount);\n        }\n        else if (type === 'set') {\n            this.set(name, amount);\n        }\n        else if (type === 'min') {\n            const v = amount.value();\n            if (this.get(name) < v) {\n                this.set(name, v);\n            }\n        }\n        else if (type === 'max') {\n            if (this.get(name) > v) {\n                this.set(name, v);\n            }\n        }\n        else {\n            throw new Error('Invalid stat adjust type: ' + type);\n        }\n        return c !== this.get(name);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity/entity';\nimport * as Flags from '../flags';\nimport { Status } from './status';\nimport { Stats } from './stat';\nimport * as ACTION from '../action';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.ai = {};\n        this._action = 'idle';\n        this._turnTime = 0;\n        this.leader = null;\n        this.items = null; // inventory\n        this.visionDistance = 99;\n        this.data = {};\n        this._costMap = null;\n        this._goalMap = null;\n        this._mapToMe = null;\n        this.next = null; // TODO - can we get rid of this?\n        // @ts-ignore - initialized in Entity\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n        this.kind = kind;\n        this.stats = new Stats();\n        this.status = new Status();\n    }\n    setData(key, value) {\n        this.data[key] = value;\n        this.changed = true;\n    }\n    copy(other) {\n        super.copy(other);\n        this.leader = other.leader;\n        this.items = other.items;\n        this.visionDistance = other.visionDistance;\n    }\n    destroy() {\n        this.setEntityFlag(Flags.Entity.L_DESTROYED);\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n        if (this._mapToMe) {\n            GWU.grid.free(this._mapToMe);\n            this._mapToMe = null;\n        }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    setActorFlag(flag) {\n        this.flags.actor |= flag;\n    }\n    clearActorFlag(flag) {\n        this.flags.actor &= ~flag;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    isDead() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n    /////////////// VISIBILITY\n    becameVisible() {\n        return (this.hasActorFlag(Flags.Actor.IS_VISIBLE) &&\n            !this.hasActorFlag(Flags.Actor.WAS_VISIBLE));\n    }\n    canSee(x, y) {\n        if (x instanceof Entity.Entity) {\n            return this.canSee(x.x, x.y) && this.kind.isAbleToSee(this, x);\n        }\n        else if (this.map) {\n            if (this.isPlayer()) {\n                return this.map.fov.isDirectlyVisible(x, y);\n            }\n            if (GWU.xy.distanceBetween(this.x, this.y, x, y) >\n                this.visionDistance) {\n                return false;\n            }\n            return GWU.xy.forLineBetween(this.x, this.y, x, y, (i, j) => {\n                if (this.map.cell(i, j).blocksVision())\n                    return false;\n            });\n        }\n        else {\n            return false; // need a map or an fov\n        }\n    }\n    canSeeOrSense(x, y) {\n        if (x instanceof Entity.Entity) {\n            return (this.canSeeOrSense(x.x, x.y) &&\n                (this.kind.isAbleToSee(this, x) ||\n                    this.kind.isAbleToSense(this, x)));\n        }\n        if (this.map && this.isPlayer()) {\n            return this.map.fov.isAnyKindOfVisible(x, y);\n        }\n        return this.canSee(x, y);\n    }\n    isAbleToSee(entity) {\n        return this.kind.isAbleToSee(this, entity);\n    }\n    isAbleToSense(entity) {\n        return this.kind.isAbleToSense(this, entity);\n    }\n    ////////////////// ACTOR\n    setAction(name) {\n        if (!this.canDoAction(name)) {\n            throw new Error('Actor cannot do action - ' + name);\n        }\n        this._action = name;\n    }\n    clearAction() {\n        this._action = 'idle';\n    }\n    act(game) {\n        let startedVisible = false;\n        if (game.player.canSee(this)) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n            startedVisible = true;\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n        if (this.becameVisible()) {\n            game.player.interrupt(this);\n        }\n        ACTION.doAction(this._action, { game, actor: this, map: this.map });\n        // let r = 0;\n        // if (this.ai && this.ai.fn) {\n        //     r = this.ai.fn(game, this);\n        // }\n        // if (r == 0 && this.kind.ai.fn) {\n        //     r = this.kind.ai.fn(game, this);\n        // }\n        // if (r) {\n        //     // did something\n        if (startedVisible || game.player.canSee(this)) {\n        }\n        //     return r;\n        // }\n        // // idle - always\n        return this._turnTime;\n    }\n    moveSpeed() {\n        return this.kind.moveSpeed;\n    }\n    startTurn() {\n        this._turnTime = 0;\n        if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n            this.setActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        const map = this.map;\n        const isVisible = map && map.fov.isAnyKindOfVisible(this.x, this.y);\n        if (isVisible) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n        }\n    }\n    endTurn(pct = 100) {\n        if (this.hasActorFlag(Flags.Actor.IS_VISIBLE)) {\n            this.setActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.WAS_VISIBLE);\n        }\n        const map = this.map;\n        const isVisible = map && map.fov.isAnyKindOfVisible(this.x, this.y);\n        if (isVisible) {\n            this.setActorFlag(Flags.Actor.IS_VISIBLE);\n            if (!this.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR) &&\n                !this.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n                map.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n            }\n        }\n        else {\n            this.clearActorFlag(Flags.Actor.IS_VISIBLE);\n            if (map &&\n                !this.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR) &&\n                this.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n                map.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n            }\n        }\n        this._turnTime = Math.max(this._turnTime, Math.floor((pct * this.moveSpeed()) / 100));\n    }\n    ///////\n    willAttack(_other) {\n        return true;\n    }\n    canPass(_other) {\n        return false;\n    }\n    ////////////////// INVENTORY\n    avoidsItem(_item) {\n        return false;\n    }\n    canAddItem(_item) {\n        return false;\n    }\n    addItem(_item) { }\n    pickupItem(item, opts) {\n        return this.kind.pickupItem(this, item, opts);\n    }\n    dropItem(item, opts) {\n        return this.kind.dropItem(this, item, opts);\n    }\n    // PATHFINDING\n    addToMap(map, x, y) {\n        const mapChanged = super.addToMap(map, x, y);\n        if (mapChanged) {\n            this.clearActorFlag(Flags.Actor.STABLE_COST_MAP);\n        }\n        return mapChanged;\n    }\n    removeFromMap() {\n        super.removeFromMap();\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n        if (this._mapToMe) {\n            GWU.grid.free(this._mapToMe);\n            this._mapToMe = null;\n        }\n    }\n    /*\n    Calculates and returns the actor's move cost map.\n    Used in pathfinding.\n    */\n    costMap() {\n        if (!this.map) {\n            throw new Error('Actor must have map to calculate costMap.');\n        }\n        const staleMap = !this.hasActorFlag(Flags.Actor.STABLE_COST_MAP);\n        if (staleMap && this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (!this._costMap) {\n            this._costMap = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        else if (!staleMap) {\n            return this._costMap;\n        }\n        const kind = this.kind;\n        const map = this.map;\n        this._costMap.update((_v, x, y) => {\n            const cell = map.cell(x, y);\n            return kind.cellCost(cell, this);\n        });\n        this.setActorFlag(Flags.Actor.STABLE_COST_MAP);\n        /*\n\n            if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n            && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))\n            {\n                playerCostMap[i][j] = monsterCostMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_SACRED)) {\n                    playerCostMap[i][j] = 1;\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_LAVA_INSTA_DEATH)) {\n        monsterCostMap[i][j] = PDS_FORBIDDEN;\n        if (player.status[STATUS_LEVITATING] || !player.status[STATUS_IMMUNE_TO_FIRE]) {\n            playerCostMap[i][j] = 1;\n        } else {\n            playerCostMap[i][j] = PDS_FORBIDDEN;\n        }\n            } else {\n                if (pmap[i][j].flags & HAS_MONSTER) {\n                    monst = monsterAtLoc(i, j);\n                    if ((monst.creatureState == MONSTER_SLEEPING\n                         || monst.turnsSpentStationary > 2\n             || (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)\n                         || monst.creatureState == MONSTER_ALLY)\n                        && monst.creatureState != MONSTER_FLEEING)\n                    {\n                        playerCostMap[i][j] = 1;\n                        monsterCostMap[i][j] = PDS_FORBIDDEN;\n                        continue;\n                    }\n                }\n\n                if (cellHasTerrainFlag(i, j, (T_AUTO_DESCENT | T_IS_DF_TRAP))) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, T_IS_FIRE)) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_IMMUNE_TO_FIRE]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, (T_IS_DEEP_WATER | T_SPONTANEOUSLY_IGNITES))) {\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = 5;\n          }\n                    monsterCostMap[i][j] = 5;\n        } else if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n                   && cellHasTMFlag(i, j, TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)\n                   && !(pmap[i][j].flags & IN_FIELD_OF_VIEW))\n             {\n            // Secret door that the player can't currently see\n            playerCostMap[i][j] = 100;\n            monsterCostMap[i][j] = 1;\n                } else {\n                    playerCostMap[i][j] = monsterCostMap[i][j] = 1;\n                }\n            }\n        }\n    }\n        */\n        return this._costMap;\n    }\n    get goalMap() {\n        return this._goalMap;\n    }\n    hasGoal() {\n        return !!this._goalMap;\n    }\n    setGoal(x, y) {\n        const map = this._map;\n        if (!map)\n            throw new Error('No map to set goal with!');\n        if (!this._goalMap) {\n            this._goalMap = GWU.grid.alloc(map.width, map.height);\n        }\n        const goalMap = this._goalMap;\n        GWU.path.calculateDistances(goalMap, x, y, this.costMap());\n        return this._goalMap;\n    }\n    clearGoal() {\n        if (this._goalMap) {\n            GWU.grid.free(this._goalMap);\n            this._goalMap = null;\n        }\n    }\n    mapToMe() {\n        if (!this.map)\n            throw new Error('No map!');\n        if (!this._mapToMe) {\n            this._mapToMe = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        if (this._mapToMe.x !== this.x || this._mapToMe.y !== this.y) {\n            GWU.path.calculateDistances(this._mapToMe, this.x, this.y, this.costMap());\n        }\n        return this._mapToMe;\n    }\n}\nActor.default = {\n    sidebarFg: 'purple',\n};\n","import * as GWU from 'gw-utils';\nexport const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id.toLowerCase()] = handler;\n}\nexport function make(id, config) {\n    if (!id)\n        return GWU.NOOP;\n    if (typeof id === 'string') {\n        if (!id.length)\n            throw new Error('Cannot create effect from empty string.');\n        if (!config) {\n            const parts = id.split(':');\n            id = parts.shift().toLowerCase();\n            config = parts;\n        }\n        const handler = handlers[id];\n        if (!handler)\n            throw new Error('Failed to find effect - ' + id);\n        return handler(config || {});\n    }\n    let steps;\n    if (Array.isArray(id)) {\n        steps = id\n            .map((config) => make(config))\n            .filter((a) => a !== null);\n    }\n    else if (typeof id === 'function') {\n        return id;\n    }\n    else {\n        steps = Object.entries(id)\n            .map(([key, config]) => make(key, config))\n            .filter((a) => a !== null);\n    }\n    if (steps.length === 1) {\n        return steps[0];\n    }\n    return (a) => {\n        const x = a.x;\n        const y = a.y;\n        for (let step of steps) {\n            a.x = x;\n            a.y = y;\n            step && step(a);\n            if (a.isDone())\n                return;\n        }\n    };\n}\nexport function makeArray(cfg) {\n    if (!cfg)\n        return [];\n    if (Array.isArray(cfg)) {\n        return cfg\n            .map((c) => make(c))\n            .filter((fn) => fn !== null);\n    }\n    if (typeof cfg === 'string') {\n        if (!cfg.length)\n            throw new Error('Cannot create effect from empty string.');\n        const parts = cfg.split(':');\n        cfg = parts.shift().toLowerCase();\n        const handler = handlers[cfg];\n        if (!handler)\n            return [];\n        return [handler(parts)];\n    }\n    else if (typeof cfg === 'function') {\n        return [cfg];\n    }\n    const steps = Object.entries(cfg).map(([key, config]) => make(key, config));\n    return steps.filter((s) => s !== null);\n}\n/*\n\n/////////////////////////\n// TYPES\n\nexport type MakeEffectFn = (config: any) => Effect;\n\nexport const effectTypes: Record<string, MakeEffectFn> = {};\n\nexport function installType(id: string, type: MakeEffectFn) {\n    effectTypes[id] = type;\n}\n\n//////////////////////////\n// EFFECT\n\nexport interface Effect {\n    chance: number; //  100 * 100 =  100%\n    seen: boolean;\n    effects: EffectFn[];\n    next: Effect | null;\n\n    trigger(loc: MapXY, ctx?: EffectCtx): boolean;\n    // clone(): this;\n}\n\n//////////////////////////\n// MAKE\n\nexport interface EffectConfig {\n    chance?: number | string;\n    type?: string; // basic | bolt | beam | ball | burst | adjacent | spread\n\n    effects: string | EffectFn | (string | EffectFn)[] | Record<string, any>;\n    good?: boolean;\n    flags?: GWU.flag.FlagBase;\n\n    next?: EffectBase;\n\n    [key: string]: any;\n}\n\nexport type EffectBase =\n    | string\n    | EffectFn\n    | (string | EffectFn)[]\n    | EffectConfig\n    | Record<string, any>;\n\n*/\n// export class Effect {\n//     id = '';\n//     chance = 100 * 100; // 100%\n//     type: string; // self | bolt | beam | ball | burst | adjacent | spread\n//     aim: string; // actor | item | cell\n//     bolt: string | GWU.sprite.SpriteData | null = null;\n//     beam = false;\n//     range = 0;\n//     ball: string | GWU.sprite.SpriteData | null = null;\n//     radius = 0;\n//     center = false;\n//     effects: EffectFn[];\n//     good = false;\n//     seen = false;\n//     next: Effect | null = null;\n//     constructor(config: EffectConfig) {\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         this.aim = config.aim || 'actor';\n//         if (typeof config.chance === 'string') {\n//             // '20%' becomes 2000\n//             config.chance = Math.floor(Number.parseFloat(config.chance) * 100);\n//         }\n//         this.chance = config.chance || 100 * 100;\n//         const type = config.type || 'basic';\n//         const parts = type.split(':');\n//         if (type.startsWith('bolt') || type.startsWith('beam')) {\n//             // bolt:range:sprite\n//             this.type = parts[0];\n//             this.range = parts[1] ? Number.parseInt(parts[1]) : 99;\n//             this.bolt = parts[1] || 'missile';\n//             this.beam = type.startsWith('beam');\n//         } else if (\n//             type.startsWith('ball') ||\n//             type.startsWith('burst') ||\n//             type.startsWith('aura')\n//         ) {\n//             this.type = parts[0];\n//             this.radius = parts[1] ? Number.parseInt(parts[1]) : 2;\n//             this.range = parts[2] ? Number.parseInt(parts[2]) : 99;\n//             this.ball = parts[3] || 'explosion';\n//             this.center = !type.startsWith('aura');\n//         } else {\n//             this.type = 'basic';\n//         }\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         if (Array.isArray(config.effects)) {\n//             this.effects = config.effects.map((e) => {\n//                 if (typeof e === 'function') return e;\n//                 return effectFnFromString(e);\n//             });\n//         } else {\n//             this.effects = [];\n//             Object.entries(config.effects).forEach(([key, value]) => {\n//                 const handler = handlers[key.toLowerCase()];\n//                 if (handler) {\n//                     this.effects.push(handler(value));\n//                 } else if (typeof value === 'function') {\n//                     this.effects.push(value);\n//                 } else {\n//                     throw new Error('Unknown effect: ' + key);\n//                 }\n//             });\n//         }\n//         if (this.effects.length === 0) throw new Error('No effects!');\n//     }\n//     clone(): this {\n//         const other = new (this.constructor as new (\n//             config: EffectConfig\n//         ) => this)(this as EffectConfig);\n//         return other;\n//     }\n//     fire(map: Map.MapType, x: number, y: number, ctx: EffectCtx = {}): boolean {\n//         let didSomething = false;\n//         ctx.good = this.good;\n//         ctx.seen = this.seen;\n//         if (!this.chance || map.rng.chance(this.chance, 10000)) {\n//             // fire\n//             for (let effect of this.effects) {\n//                 if (GWU.data.gameHasEnded) break;\n//                 if (effect(map, x, y, ctx)) {\n//                     didSomething = true;\n//                 } else {\n//                     break;\n//                 }\n//             }\n//         }\n//         if (ctx.aware && didSomething) {\n//             this.seen = true;\n//         }\n//         this.good = ctx.good;\n//         return didSomething;\n//     }\n//     reset() {\n//         this.seen = false;\n//     }\n// }\n// export function effectFnFromString(e: string): EffectFn {\n//     const parts = e.split(':');\n//     if (parts.length === 0) throw new Error('Invalid effect string.');\n//     // @ts-ignore\n//     const name = parts.shift().toLowerCase();\n//     const handler = handlers[name] || null;\n//     if (!handler) {\n//         throw new Error('Failed to find effect handler: ' + name);\n//     }\n//     return handler(parts);\n// }\n/*\nexport function make(opts: EffectBase): Effect {\n    if (!opts) throw new Error('opts required to make effect.');\n    let config = {} as EffectConfig;\n\n    if (typeof opts === 'string') {\n        // Special case\n        if (opts.toLowerCase().startsWith('spread:')) {\n            const endPos = opts.indexOf(':', 8);\n            const tile = opts.substring(8, endPos);\n            config = {\n                type: 'spread:' + opts.substring(endPos),\n                effects: ['tile:' + tile],\n            };\n        } else {\n            config = { type: 'basic', effects: [opts] };\n        }\n    } else if (typeof opts === 'function') {\n        config = { type: 'basic', effects: [opts] };\n    } else if (Array.isArray(opts)) {\n        config = { type: 'basic', effects: opts };\n    } else {\n        // @ts-ignore\n        if (opts.effect) {\n            // @ts-ignore\n            opts.effects = [opts.effect];\n            delete opts.effect;\n        }\n\n        // object only\n        if (opts.effects) {\n            Object.assign(config, opts);\n            if (typeof config.effects === 'string') {\n                config.effects = [opts.effects];\n            } else if (typeof config.effects === 'function') {\n                config.effects = [opts.effects];\n            }\n        } else {\n            config.effects = {} as Record<string, any>;\n            Object.entries(opts).forEach(([key, value]) => {\n                const handler = handlers[key.toLowerCase()];\n                if (handler !== undefined) {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                } else if (typeof value === 'function') {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                } else {\n                    // @ts-ignore\n                    config[key] = value;\n                }\n            });\n        }\n    }\n\n    config.type = config.type || 'basic';\n\n    if (typeof config.type !== 'string')\n        throw new Error('Invalid effect type: ' + JSON.stringify(config.type));\n\n    const typeParts = config.type.split(':').map((t) => t.trim());\n    const typeName = typeParts.shift()!;\n\n    const makeFn = effectTypes[typeName.toLowerCase()];\n    if (!makeFn) throw new Error('Invalid effect type: ' + typeName);\n\n    const effect = makeFn(config);\n\n    if (Array.isArray(config.effects)) {\n        config.effects.forEach((e: string | EffectFn) => {\n            if (typeof e === 'function') {\n                effect.effects.push(e);\n            } else {\n                const parts = e.split(':').map((t: string) => t.trim());\n\n                if (parts.length === 1) {\n                    const effect = installedEffects[parts[0]];\n                    if (!effect)\n                        throw new Error(\n                            'Failed to find effect with id: ' + parts[0]\n                        );\n                    effect.effects.push(effect.trigger.bind(effect));\n                } else {\n                    const handler = handlers[parts[0].toLowerCase()];\n                    if (!handler)\n                        throw new Error('Unknown effect: ' + parts[0]);\n                    parts.shift();\n                    effect.effects.push(handler(parts));\n                }\n            }\n        });\n    } else {\n        Object.entries(config.effects).forEach(([key, value]) => {\n            const handler = handlers[key.toLowerCase()];\n            if (!handler)\n                throw new Error('Failed to find handler type: ' + key);\n\n            effect.effects.push(handler(value));\n        });\n    }\n\n    if (config.next) {\n        effect.next = make(config.next);\n    }\n\n    return effect;\n}\n\nexport function from(opts: EffectBase): Effect {\n    if (!opts) throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'object' && 'trigger' in opts) {\n        return opts as Effect;\n    }\n\n    if (typeof opts === 'string') {\n        const effect = installedEffects[opts];\n        if (effect) return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\n*/\n//////////////////////////////\n// INSTALL\nexport const installed = {};\nexport function install(id, config) {\n    const effect = make(config);\n    if (!effect)\n        throw new Error('Failed to make effect.');\n    installed[id] = effect;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function resetAll() {\n    Object.values(installed).forEach((e) => (e.seen = false));\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as ACTION from '../action';\nimport * as EFFECT from '../effect';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.actions = new ACTION.Actions(this);\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.tags = [];\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.actions) {\n            Object.entries(config.actions).forEach(([ev, fn]) => {\n                this.on(ev, fn);\n            });\n            if (this.hasAction('fire')) {\n                this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n            }\n        }\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                config.tags\n                    .split(/[,|]/)\n                    .map((t) => t.trim())\n                    .forEach((t) => {\n                    this.tags.push(t);\n                });\n            }\n            else {\n                this.tags = config.tags.slice().map((t) => t.trim());\n            }\n        }\n    }\n    hasTag(tag) {\n        return this.tags.includes(tag);\n    }\n    hasAnyTag(tags) {\n        return GWU.arraysIntersect(this.tags, tags);\n    }\n    hasAllTags(tags) {\n        return tags.every((t) => this.tags.includes(t));\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    // ACTIONS\n    hasAction(name) {\n        return this.actions.has(name);\n    }\n    on(name, fn) {\n        if (!fn) {\n            this.actions.off(name);\n            return;\n        }\n        if (typeof fn === 'string') {\n            const effect = EFFECT.make(fn);\n            if (effect === null)\n                throw new Error('Failed to make effect: ' + fn);\n            fn = effect;\n        }\n        if (Array.isArray(fn)) {\n            fn.forEach((cb) => this.on(name, cb));\n        }\n        else if (typeof fn === 'object') {\n            Object.entries(fn).forEach(([key, value]) => {\n                const effect = EFFECT.make(key, value);\n                effect && this.on(name, effect);\n            });\n        }\n        else {\n            this.actions.on(name, fn);\n        }\n    }\n    trigger(name, action) {\n        if (name instanceof ACTION.Action) {\n            return this.trigger(name.action, name);\n        }\n        if (!action)\n            throw new Error('Need action.');\n        this.actions.trigger(name, action);\n    }\n    // INFO\n    isNull() {\n        return this === NULL;\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isDoor() {\n        return this.hasTileFlag(Flags.Tile.T_IS_DOOR);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isDiggable() {\n        return this.isNull() || this.isWall();\n    }\n    getName(arg) {\n        let opts = {};\n        if (typeof arg === 'boolean') {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `${color}${this.name}`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription(opts) {\n        return this.description || this.getName(opts);\n    }\n    getFlavor(opts) {\n        return this.flavor || this.getName(opts);\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n        tags: options.tags || null,\n    };\n    const tile = new Tile(config);\n    if (base && base.actions) {\n        tile.actions.copy(base.actions);\n    }\n    if (options.actions) {\n        Object.entries(options.actions).forEach(([key, value]) => {\n            tile.on(key, value);\n        });\n    }\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n// These are the minimal set of tiles to make the diggers work\nexport const NULL = install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\n// import './tiles';\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as ACTION from '../action';\nGWU.color.install('cellStatusName', 'light_blue');\nexport const NEVER_SEEN = {\n    tiles: [TILE.NULL],\n    item: null,\n    actor: null,\n    flags: {\n        cell: 0,\n        entity: TILE.NULL.flags.entity,\n        tile: TILE.NULL.flags.tile,\n        tileMech: TILE.NULL.flags.tileMech,\n    },\n};\nexport class Cell {\n    constructor(map, x, y, groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.x = -1;\n        this.y = -1;\n        // toFire: Partial<Effect.EffectCtx>[] = [];\n        this.memory = null;\n        // this._entities = new CellEntities(this);\n        this.flags = { cell: Flags.Cell.NEEDS_REDRAW };\n        this.tiles = [TILE.tiles.NULL];\n        this.map = map;\n        this.x = x;\n        this.y = y;\n        this.snapshot = GWU.sprite.makeMixer();\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n        this.memory = NEVER_SEEN;\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get hasStableSnapshot() {\n        return this.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    }\n    get hasStableMemory() {\n        return this.hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    storeMemory() {\n        var _a;\n        this.setCellFlag(Flags.Cell.STABLE_MEMORY);\n        // store memory\n        this.memory = {\n            flags: {\n                cell: this.flags.cell,\n                entity: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.entity) || 0), 0),\n                tile: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.tile) || 0), 0),\n                tileMech: this.tiles.reduce((out, tile) => out | ((tile === null || tile === void 0 ? void 0 : tile.flags.tileMech) || 0), 0),\n            },\n            tiles: this.tiles.slice(),\n            item: ((_a = this.item) === null || _a === void 0 ? void 0 : _a.clone()) || null,\n            actor: null,\n        };\n        if (this.hasItem()) {\n            const item = this.item;\n            if (item) {\n                this.memory.flags.entity |= item.flags.entity;\n            }\n        }\n        if (this.hasActor()) {\n            const actor = this.actor;\n            if (actor) {\n                this.memory.flags.entity |= actor.flags.entity;\n            }\n            this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n    }\n    clearMemory() {\n        this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT | Flags.Cell.STABLE_MEMORY);\n        this.memory = null;\n        this.needsRedraw = true;\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this.machineId = other.machineId;\n        // this._actor = other.actor;\n        // this._item = other.item;\n        this.memory = other.memory;\n        this.map = other.map;\n        this.x = other.x;\n        this.y = other.y;\n        other.getSnapshot(this.snapshot);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag, checkEntities = false) {\n        var _a, _b;\n        if (this.tiles.some((t) => t && t.flags.entity & flag))\n            return true;\n        if (!checkEntities)\n            return false;\n        if (this.hasItem()) {\n            if ((_a = this.item) === null || _a === void 0 ? void 0 : _a.hasEntityFlag(flag))\n                return true;\n        }\n        if (this.hasActor()) {\n            if ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.hasEntityFlag(flag))\n                return true;\n        }\n        return false;\n    }\n    hasAllEntityFlags(flags, checkEntities = false) {\n        return (this.entityFlags(checkEntities) & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    hasTileTag(tag) {\n        return this.tiles.some((tile) => tile && tile.hasTag(tag));\n    }\n    hasAllTileTags(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAllTags(tags);\n        });\n    }\n    hasAnyTileTag(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAnyTag(tags);\n        });\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags(withEntities = false) {\n        var _a, _b;\n        let flag = this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0);\n        if (withEntities) {\n            if (this.hasItem()) {\n                flag |= ((_a = this.item) === null || _a === void 0 ? void 0 : _a.flags.entity) || 0;\n            }\n            if (this.hasActor()) {\n                flag |= ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.flags.entity) || 0;\n            }\n        }\n        return flag;\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            if (!this.memory) {\n                this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n                this.flags.cell &= ~Flags.Cell.STABLE_SNAPSHOT;\n                this.map.needsRedraw = true;\n            }\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return this.tiles.some((t) => t && t.blocksVision());\n    }\n    blocksPathing() {\n        return (this.tiles.some((t) => t && t.blocksPathing()) &&\n            !this.tiles.some((t) => t && t.hasTileFlag(Flags.Tile.T_BRIDGE)));\n    }\n    blocksMove() {\n        return this.tiles.some((t) => t && t.blocksMove());\n    }\n    blocksEffects() {\n        return this.tiles.some((t) => t && t.blocksEffects());\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isNull() {\n        return this.tiles.every((t) => !t || t === TILE.tiles.NULL);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isDoor() {\n        return this.hasTileFlag(Flags.Tile.T_IS_DOOR);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    // hasKey(): boolean {\n    //     return this._entities.some(\n    //         (e) => !!e.key && e.key.matches(this.x, this.y)\n    //     );\n    // }\n    hasLiquid() {\n        return this.hasTileFlag(Flags.Tile.T_ANY_LIQUID);\n    }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile, opts = {}) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile)\n            return false;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (this.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && this.hasItem())\n            return false;\n        if (opts.blockedByActors && this.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && this.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const currentGround = this.depthTile(Flags.Depth.GROUND);\n            const wantGround = TILE.get(tile.groundTile);\n            if (currentGround !== wantGround) {\n                if (!this.setTile(wantGround, opts)) {\n                    return false;\n                }\n            }\n        }\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            this.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            this.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (current.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR) !==\n            tile.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n            this.map.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            this.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.needsRedraw = true;\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.snapshot.blackOut();\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    tileWithAction(name) {\n        return this.tiles.find((t) => t === null || t === void 0 ? void 0 : t.hasAction(name)) || null;\n    }\n    trigger(action, ctx) {\n        if (action instanceof ACTION.Action) {\n            return this.trigger(action.action, action);\n        }\n        if (!ctx)\n            throw new Error('Action is required.');\n        ctx.x = this.x;\n        ctx.y = this.y;\n        this.tiles.forEach((t) => t && t.trigger(action, ctx));\n    }\n    hasAction(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasAction(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    get item() {\n        return this.map.itemAt(this.x, this.y);\n    }\n    canAddItem(_item) {\n        return true;\n    }\n    canRemoveItem(_item) {\n        return true;\n    }\n    _addItem(_item) {\n        this.setCellFlag(Flags.Cell.HAS_ITEM);\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeItem(item) {\n        let hasItems = false;\n        let foundIndex = -1;\n        this.map.items.forEach((obj, index) => {\n            if (obj === item) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasItems = true;\n            }\n        });\n        if (!hasItems) {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this.map.actorAt(this.x, this.y);\n    }\n    canAddActor(_actor) {\n        return !this.hasActor();\n    }\n    canRemoveActor(_actor) {\n        return true;\n    }\n    _addActor(actor) {\n        this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        if (actor.isPlayer()) {\n            this.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeActor(actor) {\n        let hasActor = false;\n        let foundIndex = -1;\n        this.map.actors.forEach((obj, index) => {\n            if (obj === actor) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasActor = true;\n            }\n        });\n        if (!hasActor) {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.HAS_PLAYER);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    hasFx() {\n        return !!(this.flags.cell & Flags.Cell.HAS_FX);\n    }\n    get fx() {\n        return this.map.fxAt(this.x, this.y);\n    }\n    _addFx(_fx) {\n        this.setCellFlag(Flags.Cell.HAS_FX);\n        this.needsRedraw = true;\n    }\n    _removeFx(_fx) {\n        if (!this.fx) {\n            this.clearCellFlag(Flags.Cell.HAS_FX);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        if (this.hasActor()) {\n            const actor = this.map.actorAt(this.x, this.y);\n            if (actor && actor.sprite.ch)\n                return actor.sprite.ch;\n        }\n        if (this.hasItem()) {\n            const item = this.map.itemAt(this.x, this.y);\n            if (item && item.sprite.ch)\n                return item.sprite.ch;\n        }\n        if (this.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return '=';\n        }\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n    drawSidebar(buffer, bounds) {\n        const mixer = new GWU.sprite.Mixer();\n        this.map.getAppearanceAt(this.x, this.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, this.getName(), 'cellStatusName');\n        return 1;\n    }\n    toString() {\n        return `Cell @ ${this.x},${this.y}`;\n    }\n}\n","import { Entity } from '../entity/entity';\nimport { Depth } from '../flags';\nexport class Item extends Entity {\n    constructor(kind) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore - initialized in constructor\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n    }\n    isPlural() {\n        if (this.quantity > 1)\n            return true;\n        return super.isPlural();\n    }\n    copy(other) {\n        super.copy(other);\n        this.quantity = other.quantity;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n    // getAction(name: string): ACTION.ItemActionBase | undefined {\n    //     const action = this.kind.actions[name];\n    //     return action;\n    // }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n}\nItem.default = {\n    sidebarFg: 'gold',\n};\n","import * as GWU from 'gw-utils';\nimport { Actor } from '../actor/actor';\nimport { Cell } from '../map/cell';\nimport { Item } from '../item/item';\nimport * as Flags from '../flags';\nexport function messageYou(name, view, args) {\n    const field = args[0] || 'actor';\n    const actor = this.get(view, field);\n    if (actor && actor instanceof Actor) {\n        if (actor.isPlayer()) {\n            return 'you';\n        }\n        else {\n            return 'the ' + actor.getName();\n        }\n    }\n    return actor || name;\n}\nGWU.text.addHelper('you', messageYou);\nexport function messageThe(name, view, args) {\n    const value = args[0]\n        ? this.get(view, args[0])\n        : view.item || view.cell || view.target || view.actor;\n    if (value) {\n        if (value instanceof Cell) {\n            return value.getFlavor();\n        }\n        else if (value instanceof Actor) {\n            if (value.isPlayer()) {\n                return 'you';\n            }\n            else {\n                return 'the ' + value.getName();\n            }\n        }\n        else if (value instanceof Item) {\n            return 'the ' + value.getName();\n        }\n    }\n    return name;\n}\nGWU.text.addHelper('the', messageThe);\nexport function messageA(name, view, args) {\n    const value = args[0]\n        ? this.get(view, args[0])\n        : view.item || view.cell || view.target || view.actor;\n    if (value) {\n        if (value instanceof Cell) {\n            return value.getFlavor();\n        }\n        else if (value instanceof Actor) {\n            if (value.isPlayer()) {\n                return 'you';\n            }\n            else if (value.hasEntityFlag(Flags.Entity.L_FORMAL_NAME)) {\n                return value.getName();\n            }\n        }\n        if ('getName' in value) {\n            const name = value.getName();\n            const char = GWU.text.firstChar(name);\n            const ana = /[aeiouy]/i.exec(char) ? 'an ' : 'a ';\n            return ana + name;\n        }\n    }\n    return name;\n}\nGWU.text.addHelper('a', messageA);\nGWU.text.addHelper('an', messageA);\nexport function messageVerb(_name, view, args) {\n    const verb = args[0] || 'verb';\n    const value = args[1]\n        ? this.get(view, args[1])\n        : view.actor || view.target || view.item || view.cell;\n    let plural = false;\n    if (value) {\n        if (value instanceof Cell) {\n            plural = false;\n        }\n        else if (value instanceof Actor) {\n            plural = value.isPlural();\n        }\n        else if (value instanceof Item) {\n            plural = value.isPlural();\n        }\n    }\n    return plural ? GWU.text.toPluralVerb(verb) : GWU.text.toSingularVerb(verb);\n}\nGWU.text.addHelper('verb', messageVerb);\n","import * as GWU from 'gw-utils';\nexport class PainMessages {\n    constructor(msgs = []) {\n        this._msgs = [];\n        msgs.forEach((m) => this.add(m));\n    }\n    add(msg) {\n        this._msgs.push(msg);\n        return this;\n    }\n    get(pct, singular = true) {\n        const index = GWU.clamp(Math.floor(pct * this._msgs.length), 0, this._msgs.length - 1);\n        const msg = this._msgs[index];\n        return this._format(msg, singular);\n    }\n    _format(msg, singular = true) {\n        return msg.replace(/\\[(\\w+)\\|?(\\w*)\\]/g, singular ? '$1' : '$2');\n    }\n}\nexport const painMessages = {};\nexport function installPain(id, pain) {\n    if (Array.isArray(pain)) {\n        pain = new PainMessages(pain);\n    }\n    painMessages[id] = pain;\n}\nexport function getPain(id) {\n    const m = painMessages[id];\n    if (!m)\n        throw new Error('No such pain message index: ' + id);\n    return m;\n}\n","// AI functions\n// actor is current actor\n// returns time until next turn for this actor\n// < 0 means do not requeue\nexport const ais = {};\nexport function install(name, fn) {\n    ais[name] = fn;\n}\nexport function make(opts) {\n    if (typeof opts === 'string') {\n        opts = { fn: opts };\n    }\n    if (typeof opts === 'function') {\n        opts = { fn: opts };\n    }\n    if (typeof opts.fn === 'string') {\n        opts.fn = ais[opts.fn];\n    }\n    if (!opts.fn) {\n        opts.fn = ais.default;\n    }\n    return opts;\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as ACTION from '../action';\nexport function wander(action) {\n    const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor required.');\n    // Do we have a wander target?\n    let goalMap = actor.goalMap;\n    if (!goalMap) {\n        //      pick new wander target\n        const costMap = actor.costMap();\n        const loc = GWU.random.matchingLoc(costMap.width, costMap.height, (x, y) => {\n            return costMap[x][y] > 0 && costMap[x][y] !== GWU.path.NO_PATH;\n        });\n        if (!loc || loc[0] < 0 || loc[1] < 0) {\n            console.log('No wander location found!');\n            return action.didNothing();\n        }\n        //      build distance map to target\n        goalMap = actor.setGoal(loc[0], loc[1]);\n    }\n    // take the next step to the target\n    const step = GWU.path.nextStep(goalMap, actor.x, actor.y, (x, y) => {\n        if (!map.hasActor(x, y))\n            return false;\n        const other = map.actorAt(x, y);\n        if (!other) {\n            console.log(`Cell @ ${x},${y} has actor flag, but no actor.`);\n            map.cell(x, y).clearCellFlag(Flags.Cell.HAS_ACTOR);\n            return false;\n        }\n        return !actor.canPass(other);\n    });\n    if (!step) {\n        actor.clearGoal();\n        return action.didNothing();\n    }\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        return action.didNothing();\n    }\n    action.dir = step;\n    return ACTION.doAction('moveDir', action);\n}\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nimport * as AI from './ai';\nimport { wander } from './wander';\n/*\nhttp://roguebasin.com/index.php/Roguelike_Intelligence_-_Stateless_AIs\n-- Typical AI\n*/\nexport function typical(action) {\n    // const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor required.');\n    if (actor.isDead())\n        return action.didNothing();\n    const target = action.game.player;\n    const tryAttack = actor.canSee(target) && actor.willAttack(target);\n    if (tryAttack) {\n        const damagePct = 100 - actor.stats.getPct('health');\n        const morale = actor.stats.get('morale');\n        const chargeChance = 100;\n        const retreatChance = 0;\n        actor.ai.lastSawPlayer = [target.x, target.y];\n        actor.clearGoal();\n        console.log('SAW YOU!', actor.id, target.x, target.y);\n        if (damagePct > morale) {\n            if (canRunAwayFrom(action)) {\n                runAwayFrom(action);\n            }\n            else if (canAttack(action)) {\n                attack(action);\n            }\n            return;\n        }\n        if (tooFarFrom(action) && canAttack(action) && canMoveToward(action)) {\n            if (GWU.random.chance(chargeChance)) {\n                moveToward(action);\n            }\n            else {\n                attack(action);\n            }\n            return;\n        }\n        if (tooCloseTo(action) &&\n            canAttack(action) &&\n            canMoveAwayFrom(action)) {\n            if (GWU.random.chance(retreatChance)) {\n                moveAwayFrom(action);\n            }\n            else {\n                attack(action);\n            }\n            return;\n        }\n        if (canAttack(action)) {\n            attack(action);\n            return;\n        }\n        if (tooFarFrom(action) && canMoveToward(action)) {\n            moveToward(action);\n            return;\n        }\n        if (tooCloseTo(action) && canMoveAwayFrom(action)) {\n            moveAwayFrom(action);\n            return;\n        }\n    }\n    // TODO - Use scent, menory, other teammates info, ...\n    else if (actor.ai.lastSawPlayer) {\n        if (!actor.hasGoal()) {\n            const loc = actor.ai.lastSawPlayer;\n            actor.setGoal(loc[0], loc[1]);\n        }\n        console.log('CHASING YOU!', actor.id, actor.goalMap.x, actor.goalMap.y);\n        moveTowardGoal(action);\n        if (action.isSuccess()) {\n            return;\n        }\n        actor.ai.lastSawPlayer = null; // no longer\n        actor.clearGoal();\n    }\n    // check if they noticed the player scent\n    if (target.scent) {\n        action.dir = target.scent.nextDir(actor.x, actor.y);\n        if (action.dir) {\n            console.log('tracking scent', actor.id, action.dir);\n            ACTION.doAction('moveDir', action);\n            if (action.isDone())\n                return;\n        }\n    }\n    const wanderOpt = GWU.object.firstOpt('wander', actor.ai, actor.kind.ai, false);\n    if (wanderOpt) {\n        if (actor.goalMap || // we have a current goal\n            typeof wanderOpt !== 'number' || // wander: true\n            GWU.random.chance(wanderOpt) // chance\n        ) {\n            wander(action);\n            if (action.isSuccess())\n                return;\n        }\n        else {\n            ACTION.doAction('idle', action);\n            if (action.isSuccess()) {\n                return;\n            }\n        }\n    }\n    return ACTION.doAction('standStill', action);\n}\nAI.install('typical', typical);\nAI.install('default', typical);\nexport function canMoveToward(action) {\n    // can move?\n    const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor required.');\n    const target = action.target;\n    if (!target)\n        throw new Error('No target.');\n    let x = target.x;\n    let y = target.y;\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = actor.costMap();\n    GWU.path.calculateDistances(distanceMap, x, y, costMap);\n    const canMoveDiagonal = false;\n    // look for distance > current around me\n    let center = distanceMap[actor.x][actor.y];\n    let count = 0;\n    GWU.xy.eachNeighbor(actor.x, actor.y, (x, y) => {\n        if (distanceMap[x][y] < center) {\n            ++count;\n        }\n    }, canMoveDiagonal);\n    GWU.grid.free(distanceMap);\n    return count > 0;\n}\nexport function moveToward(action) {\n    // pathfinding?\n    const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor required.');\n    const target = action.target;\n    if (!target)\n        throw new Error('No target.');\n    let x = target.x;\n    let y = target.y;\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = actor.costMap();\n    GWU.path.calculateDistances(distanceMap, x, y, costMap);\n    const step = GWU.path.nextStep(distanceMap, actor.x, actor.y, (x, y) => {\n        const cell = map.cell(x, y);\n        if (!cell)\n            return true;\n        if (cell.hasActor() && cell.actor !== action.target)\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    });\n    GWU.grid.free(distanceMap);\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        return ACTION.doAction('standStill', action);\n    }\n    action.dir = step;\n    return ACTION.doAction('moveDir', action);\n}\nexport function canMoveAwayFrom(_action) {\n    // can move?\n    // const distanceMap = ctx.distanceMap;\n    // const canMoveDiagonal = false;\n    // // look for distance > current around me\n    // let center = distanceMap[actor.x][actor.y];\n    // let count = 0;\n    // GWU.xy.eachNeighbor(\n    //     actor.x,\n    //     actor.y,\n    //     (x, y) => {\n    //         const d = distanceMap[x][y];\n    //         if (d >= GWU.path.NO_PATH) return;\n    //         if (distanceMap[x][y] > center) {\n    //             ++count;\n    //         }\n    //     },\n    //     canMoveDiagonal\n    // );\n    // return ctx.done(count > 0);\n    return false;\n}\nexport function moveAwayFrom(action) {\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Need actor.');\n    // safety/strategy?\n    // always move using safety map?\n    actor.endTurn();\n    return action.didSomething();\n}\nexport function canRunAwayFrom(_action) {\n    // can move?\n    return false;\n}\nexport function runAwayFrom(action) {\n    // move toward loop if away from player\n    if (!action.actor)\n        throw new Error('Need actor.');\n    action.actor.endTurn();\n    return action.didSomething();\n}\nexport function canAttack(action) {\n    // has attack?\n    // attack affects player?\n    // cooldown?\n    const actor = action.actor;\n    const target = action.target;\n    if (!actor || !target)\n        return false;\n    return GWU.xy.distanceFromTo(actor, target) <= 1;\n}\nexport function attack(action) {\n    const actor = action.actor;\n    const target = action.target;\n    if (!actor || !target)\n        throw new Error('Actor and Target required to attack.');\n    console.log('attack!', actor.id, target.id);\n    return ACTION.doAction('attack', action);\n}\nexport function tooFarFrom(action) {\n    // diagonal?\n    const actor = action.actor;\n    const target = action.target;\n    if (!actor || !target)\n        return true;\n    return GWU.xy.distanceFromTo(actor, target) > 1;\n}\nexport function tooCloseTo(action) {\n    const actor = action.actor;\n    const target = action.target;\n    if (!actor || !target)\n        return true;\n    return GWU.xy.distanceFromTo(actor, target) < 1;\n}\n// TODO - make an action\nexport function moveTowardGoal(action) {\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Need actor.');\n    if (!actor.hasGoal())\n        return action.didNothing();\n    const nextStep = GWU.path.nextStep(actor.goalMap, actor.x, actor.y, (x, y) => {\n        return actor.map.hasActor(x, y);\n    });\n    if (!nextStep) {\n        actor.clearGoal();\n        return action.didNothing();\n    }\n    action.dir = nextStep;\n    return ACTION.doAction('moveDir', action);\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nexport function fillSafetyMap(safetyMap, actor, target) {\n    const costGrid = GWU.grid.alloc(actor.costMap());\n    GWU.path.calculateDistances(safetyMap, target.x, target.y, costGrid, true);\n    safetyMap.update((v) => v * -1); // Can set factor to be < -1 e.g. -1.2\n    actor.map.actors.forEach((a) => {\n        if (a.willAttack(actor)) {\n            costGrid[a.x][a.y] = GWU.path.FORBIDDEN; // This is why we allocate a copy\n        }\n    });\n    actor.map.eachCell((c, x, y) => {\n        if (c.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n            safetyMap[x][y] -= GWU.path.AVOIDED; // loop cells are extra good\n        }\n    });\n    GWU.path.rescan(safetyMap, costGrid, true);\n    safetyMap.update((v) => (v <= -30000 ? 30000 : v));\n    GWU.grid.free(costGrid);\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Actor } from './actor';\nimport * as AI from '../ai';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n        this.flags = {\n            actor: Flags.Actor.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.vision = {};\n        this.bump = ['attack'];\n        this.moveSpeed = 100;\n        if (opts.flags) {\n            this.flags.actor = GWU.flag.from(Flags.Actor, this.flags.actor, opts.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, opts.flags);\n        }\n        if (opts.vision) {\n            this.vision.normal = opts.vision;\n        }\n        this.stats = Object.assign({ health: 1, morale: 100 }, opts.stats);\n        if (opts.moveSpeed) {\n            this.moveSpeed = opts.moveSpeed;\n        }\n        this.ai = AI.make(opts.ai || 'default');\n        if (opts.bump) {\n            if (typeof opts.bump === 'string') {\n                opts.bump = opts.bump.split(/[|,]/g).map((t) => t.trim());\n            }\n            if (typeof opts.bump === 'function') {\n                opts.bump = [opts.bump];\n            }\n            if (Array.isArray(opts.bump)) {\n                this.bump = opts.bump.slice();\n            }\n        }\n        if (opts.waterOnly) {\n            this.forbidTileFlags =\n                this.forbidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            this.avoidTileFlags =\n                this.avoidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            this.requireTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n        }\n        else if (opts.lavaOnly) {\n            this.forbidTileFlags = this.forbidTileFlags & ~Flags.Tile.T_LAVA;\n            this.avoidTileFlags = this.avoidTileFlags & ~Flags.Tile.T_LAVA;\n            this.requireTileFlags |= Flags.Tile.T_LAVA;\n        }\n        else {\n            if (opts.swim) {\n                this.avoidTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n            else {\n                this.forbidTileFlags |= Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n            if (opts.fly) {\n                this.forbidTileFlags =\n                    this.forbidTileFlags & ~Flags.Tile.T_LAVA;\n                this.avoidTileFlags = this.avoidTileFlags & ~Flags.Tile.T_LAVA;\n                this.requireTileFlags =\n                    this.requireTileFlags & ~Flags.Tile.T_LAVA;\n                this.forbidTileFlags =\n                    this.forbidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n                this.avoidTileFlags =\n                    this.avoidTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n                this.requireTileFlags =\n                    this.requireTileFlags & ~Flags.Tile.T_IS_DEEP_LIQUID;\n            }\n        }\n        this.sidebarFg = GWU.color.from(opts.sidebarFg || Actor.default.sidebarFg);\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n        Object.assign(actor.flags, this.flags);\n        // if (options.fov) {\n        //     actor.fov = options.fov;\n        // }\n        // if (options.memory) {\n        //     actor.memory = options.memory;\n        // }\n        if (this.vision.normal) {\n            actor.visionDistance = this.vision.normal;\n        }\n        actor.stats.init(this.stats);\n    }\n    addToMap(actor, map) {\n        super.addToMap(actor, map);\n        // if (this.hasActorFlag(Flags.Actor.HAS_MEMORY)) {\n        //     actor.memory = Memory.get(actor, map);\n        // }\n        // if (this.hasActorFlag(Flags.Actor.USES_FOV)) {\n        //     actor.fov = new GWU.fov.FovSystem(map);\n        //     actor.fov.follow = actor;\n        //     if (actor.memory) {\n        //         actor.fov.callback = actor.memory;\n        //     }\n        // }\n    }\n    removeFromMap(actor) {\n        super.removeFromMap(actor);\n        // if (actor._map && actor.memory) {\n        //     Memory.store(actor, actor._map, actor.memory);\n        // }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    canSeeEntity(_actor, _entity) {\n        return true;\n    }\n    isAbleToSee(_actor, _entity) {\n        return true;\n    }\n    isAbleToSense(_actor, _entity) {\n        return true;\n    }\n    forbidsCell(cell, actor) {\n        if (super.forbidsCell(cell, actor)) {\n            return true;\n        }\n        if (cell.blocksMove())\n            return true;\n        return false;\n    }\n    avoidsCell(cell, actor) {\n        if (super.avoidsCell(cell, actor))\n            return true;\n        if (cell.blocksPathing())\n            return true;\n        return false;\n    }\n    getFlavor(actor, opts) {\n        const flavor = actor.isPlayer() ? 'yourself' : this.flavor;\n        if (opts && opts.action) {\n            return flavor + ' standing';\n        }\n        return flavor;\n    }\n    pickupItem(actor, item, _opts) {\n        if (!GWU.list.push(actor, 'items', item))\n            return false;\n        // TODO - Pickup effects\n        return true;\n    }\n    dropItem(actor, item, _opts) {\n        if (!GWU.list.remove(actor, 'items', item))\n            return false;\n        // TODO - Drop effects\n        return true;\n    }\n    cellCost(cell, actor) {\n        if (this.forbidsCell(cell, actor)) {\n            return cell.hasEntityFlag(Flags.Entity.L_BLOCKS_DIAGONAL)\n                ? GWU.path.OBSTRUCTION\n                : GWU.path.FORBIDDEN;\n        }\n        else if (this.avoidsCell(cell, actor)) {\n            return GWU.path.AVOIDED;\n        }\n        return GWU.path.OK;\n    }\n    drawSidebar(actor, buffer, bounds) {\n        let count = super.drawSidebar(actor, buffer, bounds);\n        if (actor.map.hasTileFlag(actor.x, actor.y, Flags.Tile.T_DEEP_WATER) &&\n            !actor.map.hasTileFlag(actor.x, actor.y, Flags.Tile.T_BRIDGE)) {\n            buffer.drawText(bounds.x + 3, bounds.y + count++, 'Swimming', '#66F');\n        }\n        return count;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ActorKind } from './kind';\nexport function make(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ActorKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ActorKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ActorKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ActorKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Item } from './item';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n        this.flags = {\n            item: Flags.Item.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.bump = [];\n        if (config.flags) {\n            this.flags.item = GWU.flag.from(Flags.Item, this.flags.item, config.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, config.flags);\n        }\n        if (config.bump) {\n            if (typeof config.bump === 'string' ||\n                typeof config.bump === 'function') {\n                config.bump = [config.bump];\n            }\n            if (Array.isArray(config.bump)) {\n                this.bump = config.bump.slice();\n            }\n        }\n        this.avoidTileFlags |= Flags.Tile.T_DEEP_WATER;\n        this.forbidTileFlags |= Flags.Tile.T_LAVA | Flags.Tile.T_AUTO_DESCENT;\n        this.sidebarFg = GWU.color.from(config.sidebarFg || Item.default.sidebarFg);\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n    init(item, options = {}) {\n        super.init(item, options);\n        Object.assign(item.flags, this.flags);\n        item.quantity = options.quantity || 1;\n    }\n    avoidsCell(cell, item) {\n        if (cell.isDoor() || cell.isStairs())\n            return true;\n        return super.avoidsCell(cell, item);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ItemKind } from './kind';\nexport function make(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        kind.id = id;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import * as ACTION from '../action';\nexport function standStill(action) {\n    if (action.actor) {\n        action.actor.endTurn();\n        action.didSomething();\n    }\n}\nACTION.install('standStill', standStill);\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nexport function flashSprite(map, x, y, sprite, duration = 100, count = 1) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ visible: true })\n        .to({ visible: false })\n        .repeat(count)\n        .repeatDelay(duration)\n        .duration(duration)\n        .onUpdate((obj) => {\n        if (obj.visible) {\n            map.addFx(x, y, entity);\n        }\n        else {\n            map.removeFx(entity);\n        }\n    });\n    return tween;\n}\nGWU.sprite.install('bump', 'white', 50);\nexport function hit(map, target, sprite, duration) {\n    sprite = sprite || 'hit';\n    duration = duration || 200;\n    return flashSprite(map, target.x, target.y, sprite, duration, 1);\n}\nGWU.sprite.install('hit', 'red', 50);\nexport function miss(map, target, sprite, duration) {\n    sprite = sprite || 'miss';\n    duration = duration || 200;\n    return flashSprite(map, target.x, target.y, sprite, duration, 1);\n}\nGWU.sprite.install('miss', 'green', 50);\nexport function fadeInOut(map, x, y, sprite, duration = 100) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite).clone();\n    }\n    else {\n        sprite = GWU.sprite.make(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ opacity: 0 })\n        .to({ opacity: 100 })\n        .repeat(2)\n        .yoyo(true)\n        .duration(Math.floor(duration / 2))\n        .onUpdate((obj) => {\n        entity.sprite.opacity = obj.opacity;\n        map.cell(x, y).needsRedraw = true; // we changed the sprite so redraw\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n    });\n    // realTime\n    return tween;\n}\nexport function moveSprite(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    const from = { x: GWU.xy.x(source), y: GWU.xy.y(source) };\n    map.addFx(from.x, from.y, entity);\n    let duration = opts.duration ||\n        Math.ceil(16 * (GWU.xy.maxAxisFromTo(source, target) / (opts.speed || 8)));\n    if (GWU.xy.isLoc(target)) {\n        target = { x: target[0], y: target[1] };\n    }\n    const tween = GWU.tween\n        .make(from)\n        .to(target)\n        .duration(duration)\n        .onUpdate((vals) => {\n        // tweens dont update every step, so...\n        // draw line from current pos to vals pos\n        // check each step for blocking...\n        // end at either vals or last blocking spot\n        const dest = { x: entity.x, y: entity.y };\n        const ok = GWU.xy.forLineBetween(dest.x, dest.y, vals.x, vals.y, (x, y) => {\n            if (opts.stepFn) {\n                if (opts.stepFn(x, y)) {\n                    if (!opts.stopBeforeWalls) {\n                        dest.x = x;\n                        dest.y = y;\n                    }\n                    return false;\n                }\n            }\n            else if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (!opts.stopBeforeWalls) {\n                    dest.x = x;\n                    dest.y = y;\n                }\n                return false;\n            }\n            dest.x = x;\n            dest.y = y;\n        });\n        map.moveFx(entity, dest.x, dest.y);\n        if (!ok) {\n            tween.stop();\n        }\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n        return entity;\n    });\n    return tween;\n}\nexport function bolt(map, source, target, sprite, opts = {}) {\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport function projectile(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    if (sprite.ch && sprite.ch.length == 4) {\n        const dir = GWU.xy.dirFromTo(source, target);\n        let index = 0;\n        if (dir[0] && dir[1]) {\n            index = 2;\n            if (dir[0] != dir[1]) {\n                // remember up is -y\n                index = 3;\n            }\n        }\n        else if (dir[0]) {\n            index = 1;\n        }\n        const ch = sprite.ch[index];\n        sprite = GWU.sprite.make(ch, sprite.fg, sprite.bg);\n    }\n    else if (sprite.ch && sprite.ch.length !== 1) {\n        throw new Error('projectile requires 4 chars - vert,horiz,diag-left,diag-right (e.g: \"|-\\\\/\")');\n    }\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport function beam(map, from, to, sprite, opts = {}) {\n    opts.fade = opts.fade || 100;\n    if (opts.stopAtWalls === undefined)\n        opts.stopAtWalls = true;\n    const line = [];\n    GWU.xy.forLineFromTo(from, to, (x, y) => {\n        if (!map.hasXY(x, y))\n            return false;\n        if (opts.stepFn && opts.stepFn(x, y))\n            return false;\n        if (opts.stopAtWalls || opts.stopBeforeWalls) {\n            if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (opts.stopBeforeWalls)\n                    return false;\n                line.push([x, y]);\n                return false;\n            }\n        }\n        line.push([x, y]);\n        return true;\n    });\n    const duration = opts.duration || Math.ceil(16 * (line.length / (opts.speed || 8)));\n    let lastIndex = -1;\n    const tween = GWU.tween\n        .make({ index: 0 })\n        .to({ index: line.length - 1 })\n        .duration(duration)\n        .onUpdate((vals) => {\n        while (lastIndex < vals.index) {\n            ++lastIndex;\n            const loc = line[lastIndex] || [-1, -1];\n            tween.addChild(fadeInOut(map, loc[0], loc[1], sprite, opts.fade));\n        }\n    });\n    return tween;\n}\nfunction isInShape(shape, cx, cy, allowCenter, x, y) {\n    const sx = Math.abs(x - cx);\n    const sy = Math.abs(y - cy);\n    if (sx == 0 && sy == 0 && !allowCenter)\n        return false;\n    switch (shape) {\n        case '+':\n            return sx == 0 || sy == 0;\n        case 'x':\n        case 'X':\n            return sx == sy;\n        case '*':\n            return sx == 0 || sy == 0 || sx == sy;\n        default:\n            return true;\n    }\n}\nfunction checkExplosionOpts(opts) {\n    opts.speed = opts.speed || 2;\n    opts.fade = opts.fade || 100;\n    opts.shape = opts.shape || 'o';\n    if (opts.center === undefined) {\n        opts.center = true;\n    }\n}\nexport function explosion(map, x, y, radius, sprite, opts = {}) {\n    checkExplosionOpts(opts);\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const grid = GWU.grid.alloc(map.width, map.height);\n    const fov = new GWU.fov.FOV({\n        isBlocked(x, y) {\n            return map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE);\n        },\n        hasXY(x, y) {\n            return map.hasXY(x, y);\n        },\n    });\n    fov.calculate(x, y, radius, (x1, y1) => {\n        grid[x1][y1] = 1;\n    });\n    const duration = opts.duration || 32 * (radius / opts.speed);\n    const tween = GWU.tween\n        .make({ r: 0 })\n        .to({ r: radius })\n        .duration(duration)\n        .onUpdate((vals) => {\n        const minX = Math.max(0, x - vals.r);\n        const minY = Math.max(0, y - vals.r);\n        const maxX = Math.min(map.width - 1, x + vals.r);\n        const maxY = Math.min(map.height - 1, y + vals.r);\n        for (let x1 = minX; x1 <= maxX; ++x1) {\n            for (let y1 = minY; y1 <= maxY; ++y1) {\n                if (grid[x1][y1] &&\n                    GWU.xy.distanceBetween(x, y, x1, y1) <= vals.r) {\n                    grid[x1][y1] = 0;\n                    if (isInShape(opts.shape, x, y, opts.center, x1, y1)) {\n                        tween.addChild(fadeInOut(map, x1, y1, sprite, opts.fade));\n                    }\n                }\n            }\n        }\n    })\n        .onFinish(() => {\n        GWU.grid.free(grid);\n    });\n    return tween;\n}\n","import * as ACTION from '../action';\n// import * as ACTOR from '../actor';\n// BUMP\n//\n// prefixes:\n// @ : only for player\n// + : only for ally\n// - : only for opposed\n// = : only for same kind\n// $ : use my action (if used with one of the above, this comes last)\n//\nexport function bump(action) {\n    const other = action.target;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor is required for bump.');\n    if (other) {\n        const bumpActions = other.getBumpActions();\n        for (let actionName of bumpActions) {\n            if (typeof actionName === 'string') {\n                if (actionName.startsWith('@')) {\n                    if (!actor.isPlayer())\n                        continue;\n                    actionName = actionName.substring(1);\n                    // } else if (actionName.startsWith('+')) {\n                    //     if (!actor.isAllyWith(other)) continue;\n                    //     actionName = actionName.substring(1);\n                    // } else if (actionName.startsWith('-')) {\n                    //     if (actor.isAllyWith(other)) continue;\n                    //     actionName = actionName.substring(1);\n                }\n                else if (actionName.startsWith('=')) {\n                    if (actor.kind !== other.kind)\n                        continue;\n                    actionName = actionName.substring(1);\n                }\n                if (actionName.startsWith('$')) {\n                    const selfName = actionName.substring(1);\n                    if (!other.canDoAction(selfName))\n                        throw new Error('Invalid bump choice - ' + actionName);\n                    other.trigger(selfName, action);\n                    if (action.isDone())\n                        return;\n                    // let selfAction: ACTOR.ActorActionResult =\n                    //     other.getAction(selfName);\n                    // if (selfAction === false) {\n                    //     throw new Error(\n                    //         'Cannot have bump action for self action that actor cannot do: ' +\n                    //             action\n                    //     );\n                    // }\n                    // const ctx2 = Object.assign({}, ctx, { actor });\n                    // const result = selfAction(game, other, ctx2);\n                    // if (result) return result;\n                }\n                else {\n                    ACTION.doAction(actionName, action);\n                    if (action.isDone())\n                        return;\n                    // const config = actor.getAction(actionName);\n                    // if (config === false) {\n                    //     throw new Error(\n                    //         'Cannot configure actor with bump action they cannot do: ' +\n                    //             action\n                    //     );\n                    // } else {\n                    //     action = config;\n                    // }\n                    // const result = action(game, actor, ctx);\n                    // if (result) return result;\n                }\n            }\n            else {\n                actionName(action);\n                if (action.isDone())\n                    return;\n            }\n        }\n    }\n    const item = action.item;\n    if (item) {\n        // TODO - Item Actions\n    }\n}\nACTION.install('bump', bump);\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nimport * as FX from '../fx';\nimport * as Flags from '../flags';\nimport { bump } from './bump';\nimport { standStill } from './standStill';\nexport function moveDir(action) {\n    //\n    const step = action.dir;\n    if (!step)\n        throw new Error('moveDir called with no direction!');\n    const actor = action.actor;\n    const map = action.map;\n    // const game = action.game;\n    if (!actor)\n        throw new Error('moveDir requires actor!');\n    const newX = actor.x + step[0];\n    const newY = actor.y + step[1];\n    const currentCell = map.cell(actor.x, actor.y);\n    const newCell = map.cell(newX, newY);\n    // actor, map/cell/tiles, game, global\n    // - give them all a chance to handle this\n    // if (action.defaultPrevented) return;\n    if (actor.forbidsCell(newCell)) {\n        if (action.try)\n            return action.didNothing();\n        if (actor.isPlayer()) {\n            FX.hit(map, newCell, 'hit', 100);\n            GWU.message.addAt(newCell.x, newCell.y, '{{you}} {{verb bump~}} into {{a cell}}.', { actor, cell: newCell });\n        }\n        actor.clearGoal();\n        actor.endTurn();\n        return action.didSomething();\n    }\n    if (newCell.blocksMove()) {\n        if (action.try)\n            return action.didNothing();\n        FX.hit(map, newCell, 'hit', 100);\n        actor.clearGoal();\n        actor.endTurn();\n        return action.didSomething();\n    }\n    // can we leave?\n    if (!currentCell.canRemoveActor(actor)) {\n        if (action.try)\n            return action.didNothing();\n        // canActorLeave must add appropriate message\n        actor.endTurn();\n        return action.didSomething();\n    }\n    // is there an actor there?\n    if (newCell.hasActor() || newCell.hasItem()) {\n        if (action.try)\n            return action.didNothing();\n        action.target = newCell.actor;\n        action.item = newCell.item;\n        return bump(action);\n    }\n    // can we enter?\n    if (!newCell.canAddActor(actor)) {\n        if (action.try)\n            return action.didNothing();\n        actor.endTurn();\n        return action.didSomething();\n    }\n    if (!map.moveActor(actor, newX, newY)) {\n        return standStill(action);\n    }\n    let rate = 100;\n    if (newCell.hasTileFlag(Flags.Tile.T_DEEP_WATER)) {\n        rate = 150;\n    }\n    actor.endTurn(rate);\n    return action.didSomething();\n}\nACTION.install('moveDir', moveDir);\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nimport { moveDir } from './moveDir';\nexport function idle(action) {\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Action requires an actor.');\n    if (GWU.random.chance(50)) {\n        // stand still\n        actor.endTurn();\n        return action.didSomething();\n    }\n    // try to step in a random direction\n    const dirIndex = GWU.random.number(4);\n    action.dir = GWU.xy.DIRS[dirIndex];\n    return moveDir(action);\n}\nACTION.install('idle', idle);\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nexport function pickup(action) {\n    const map = action.map;\n    if (!map)\n        throw new Error('Map is required!');\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor is required.');\n    const item = map.itemAt(action.x, action.y);\n    if (!item) {\n        if (!action.quiet) {\n            GWU.message.addAt(action.x, action.y, 'Nothing to pickup.');\n        }\n        return action.didNothing();\n    }\n    if (actor.avoidsItem(item))\n        return action.didNothing();\n    if (item.canDoAction('pickup') === false) {\n        if (!action.quiet) {\n            GWU.message.addAt(actor.x, actor.y, '{{you}} cannot pickup {{the item}}.', {\n                actor,\n                item,\n            });\n        }\n        return action.didNothing();\n    }\n    // logs error messages\n    if (!actor.canAddItem(item)) {\n        return action.didNothing();\n    }\n    if (!map.removeItem(item)) {\n        return action.didNothing();\n    }\n    actor.addItem(item);\n    if (!action.quiet) {\n        GWU.message.addAt(actor.x, actor.y, '{{you}} {{verb pick[s]}} up {{an item}}.', {\n            actor,\n            item,\n        });\n    }\n    actor.endTurn();\n    action.didSomething();\n}\nACTION.install('pickup', pickup);\n","import * as GWU from 'gw-utils';\nimport * as ACTION from '../action';\nimport * as Flags from '../flags';\nexport function climb(action) {\n    const map = action.map;\n    const actor = action.actor;\n    if (!actor)\n        throw new Error('Actor is required.');\n    const x = action.x;\n    const y = action.y;\n    if (map.hasTileFlag(x, y, Flags.Tile.T_UP_STAIRS)) {\n        GWU.message.addAt(x, y, '{{you}} {{verb climb[s]}}.', { actor });\n        action.game.startNewMap({ up: true });\n        actor.endTurn();\n        return action.didSomething();\n    }\n    GWU.message.addAt(x, y, 'Nothing to climb.');\n    actor.endTurn(50); // half turn??\n    return action.didSomething();\n}\nACTION.install('climb', climb);\n","import { installHandler } from '../effect';\nexport function fn(cfg) {\n    if (typeof cfg === 'function')\n        return cfg;\n    return (a) => {\n        for (let fn of cfg) {\n            fn(a);\n            if (a.isDone())\n                return;\n        }\n    };\n}\ninstallHandler('fn', fn);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// ActivateMachine\nexport function activateMachine() {\n    return activateMachineAction.bind(undefined);\n}\nexport function activateMachineAction(action) {\n    const map = action.map;\n    const cell = map.cell(action.x, action.y);\n    const machine = cell.machineId;\n    if (!machine)\n        return action.didNothing();\n    action.originX = action.x;\n    action.originY = action.y;\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.machineId !== machine)\n                continue;\n            cell.trigger('machine', action); // will set didSomething or didNothing\n        }\n    }\n}\ninstallHandler('activateMachine', activateMachine);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// chance\nexport function chance(opts) {\n    if (Array.isArray(opts)) {\n        opts = opts[0];\n    }\n    if (typeof opts === 'object') {\n        opts = opts.chance;\n    }\n    if (typeof opts === 'string') {\n        if (opts.endsWith('%')) {\n            opts = Number.parseFloat(opts) * 100;\n        }\n        else {\n            opts = Number.parseInt(opts || '10000');\n        }\n    }\n    if (typeof opts !== 'number') {\n        throw new Error('Chance effect config must be number or string that can be a number.');\n    }\n    return chanceAction.bind(undefined, opts);\n}\nexport function chanceAction(cfg, action) {\n    const map = action.map;\n    if (!map.rng.chance(cfg))\n        return action.stop();\n}\ninstallHandler('chance', chance);\n","import * as Flags from '../flags';\nimport { installHandler } from '../effect';\nexport function clear(config) {\n    let layers = 0;\n    if (!config) {\n        layers = Flags.Depth.ALL_LAYERS;\n    }\n    else if (typeof config === 'number') {\n        layers = config;\n    }\n    else if (typeof config === 'string') {\n        const parts = config.split(/[,|]/g);\n        layers = parts.reduce((out, v) => {\n            if (typeof v === 'number')\n                return out | v;\n            const depth = Flags.Depth[v] || 0;\n            return out | depth;\n        }, 0);\n    }\n    else {\n        throw new Error('Invalid config for clear effect: ' + JSON.stringify(config));\n    }\n    return clearAction.bind(undefined, layers);\n}\nexport function clearAction(layers, action) {\n    if (!layers)\n        return action.didNothing();\n    const cell = action.map.cell(action.x, action.y);\n    if (cell.clearDepth(layers)) {\n        action.didSomething();\n    }\n    else {\n        action.didNothing();\n    }\n}\ninstallHandler('clear', clear);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// EMIT\nexport function emit(config) {\n    if (Array.isArray(config))\n        config = config[0];\n    if (typeof config !== 'string')\n        throw new Error('Invalid EMIT handler config - ' + config);\n    return emitAction.bind(undefined, config);\n}\nexport function emitAction(id, action) {\n    action.actor && action.actor.trigger(id, action);\n    if (action.isDone())\n        return;\n    action.item && action.item.trigger(id, action);\n    if (action.isDone())\n        return;\n    action.map.trigger(id, action);\n    if (action.isDone())\n        return;\n    action.game.trigger(id, action);\n}\ninstallHandler('emit', emit);\n","import * as Effect from '../effect';\nexport function feature(id) {\n    if (Array.isArray(id))\n        id = id[0];\n    if (id && typeof id !== 'string') {\n        id = id.id;\n    }\n    if (!id || !id.length)\n        throw new Error('Feature effect needs ID');\n    return featureAction.bind(undefined, id);\n}\nexport function featureAction(id, action) {\n    const feat = Effect.installed[id];\n    if (!feat) {\n        throw new Error('Failed to find feature: ' + id);\n    }\n    return feat(action);\n}\nEffect.installHandler('feature', feature);\nEffect.installHandler('effect', feature);\nEffect.installHandler('id', feature);\n","import * as GWU from 'gw-utils';\nimport { installHandler } from '../effect';\n//////////////////////////////////////////////\n// MESSAGE\nexport function msg(src) {\n    if (Array.isArray(src))\n        src = src[0];\n    if (typeof src !== 'string') {\n        throw new Error('Need message for message effect.');\n    }\n    const info = {\n        msg: src,\n    };\n    return messageAction.bind(undefined, info);\n}\nexport function messageAction(info, action) {\n    const seen = action.seen;\n    const msg = info.msg;\n    if (msg &&\n        msg.length &&\n        action.aware &&\n        !seen\n    // && map.isVisible(x, y)\n    ) {\n        GWU.message.addAt(action.x, action.y, msg, action);\n        return action.didSomething();\n    }\n    return action.didNothing();\n}\ninstallHandler('msg', msg);\n","import * as GWU from 'gw-utils';\nimport * as EFFECT from '../effect';\nexport function nourish(opts) {\n    if (!opts)\n        throw new Error('Invalid Nourish config.');\n    let info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.type = opts[0] || 'inc';\n        info.amount = GWU.range.make(opts[1] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(opts.amount || 1);\n    }\n    else {\n        throw new Error('Invalid Nourish config: ' + JSON.stringify(opts));\n    }\n    return nourishAction.bind(undefined, info);\n}\nexport function nourishAction(config, action) {\n    if (!config.amount)\n        return action.didNothing();\n    // who am I nourishing?\n    const map = action.map;\n    const actor = map.actorAt(action.x, action.y);\n    if (!actor) {\n        return action.didNothing();\n    }\n    const stats = actor.stats;\n    const c = stats.get('food');\n    if (!stats.adjust('food', config.type, config.amount))\n        return action.didNothing();\n    const n = stats.get('food');\n    if (n < c && n / stats.max('food') < 0.1) {\n        GWU.message.addAt(actor.x, actor.y, nourishAction.default.pukeMsg, {\n            actor,\n        });\n    }\n    return action.didSomething();\n}\nnourishAction.default = {\n    pukeMsg: '%you vomit.',\n};\nEFFECT.installHandler('nourish', nourish);\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as EFFECT from '../effect';\nexport function spread(...args) {\n    let config = {};\n    if (!args.length) {\n        throw new Error('Must have config to create spread.');\n    }\n    if (args.length === 1) {\n        if (typeof args[0] === 'string') {\n            args = args[0].split(':').map((t) => t.trim());\n        }\n        else if (Array.isArray(args[0])) {\n            args = args[0];\n        }\n        else {\n            Object.assign(config, args[0]);\n            args = [config];\n        }\n    }\n    if (args.length >= 3) {\n        Object.assign(config, args[3] || {});\n        config.grow = Number.parseInt(args[0]);\n        config.decrement = Number.parseInt(args[1]);\n        config.actions = args[2];\n    }\n    else if (args.length === 2) {\n        throw new Error('Must have actions to run for spread.');\n    }\n    if (typeof config.grow !== 'number')\n        config.grow = Number.parseInt(config.grow || 0);\n    if (typeof config.decrement !== 'number')\n        config.decrement = Number.parseInt(config.decrement || 100);\n    config.flags = GWU.flag.from(Flags.Effect, config.flags || 0);\n    config.matchTile = config.matchTile || '';\n    const action = EFFECT.makeArray(config.actions);\n    if (!action)\n        throw new Error('Failed to make action for spread.');\n    config.actions = action;\n    const fn = spreadAction.bind(config);\n    fn.config = config;\n    return fn;\n}\nEFFECT.installHandler('spread', spread);\nexport function spreadAction(action) {\n    const abortIfBlocking = !!(this.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n    const map = action.map;\n    const spawnMap = GWU.grid.alloc(map.width, map.height);\n    if (!computeSpawnMap(this, action, spawnMap)) {\n        GWU.grid.free(spawnMap);\n        return action.didNothing();\n    }\n    if (abortIfBlocking && mapDisruptedBy(map, spawnMap)) {\n        GWU.grid.free(spawnMap);\n        return action.didNothing();\n    }\n    if (this.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n        // first, evacuate creatures, so that they do not re-trigger the tile.\n        if (evacuateCreatures(map, spawnMap)) {\n            action.didSomething();\n        }\n    }\n    if (this.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n        // first, evacuate items, so that they do not re-trigger the tile.\n        if (evacuateItems(map, spawnMap)) {\n            action.didSomething();\n        }\n    }\n    if (this.flags & Flags.Effect.E_CLEAR_CELL) {\n        // first, clear other tiles (not base/ground)\n        if (clearCells(map, spawnMap, this.flags)) {\n            action.didSomething();\n        }\n    }\n    spawnMap.update((v) => {\n        if (!v)\n            return 0;\n        return 1;\n    });\n    let didSomething = action.isSuccess();\n    this.actions.forEach((fn, i) => {\n        spawnMap.forEach((v, x, y) => {\n            if (v !== i + 1)\n                return;\n            action.reset();\n            action.x = x;\n            action.y = y;\n            fn(action);\n            if (action.isSuccess()) {\n                didSomething = true;\n                spawnMap[x][y] += 1;\n            }\n        });\n    });\n    if (didSomething) {\n        action.didSomething();\n    }\n    GWU.grid.free(spawnMap);\n}\nexport function mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(map.width, map.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (map.cell(i, j).isStairs()) {\n                disrupts = true;\n            }\n        }\n        else if (!map.cell(i, j).blocksMove()) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGWU.grid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cell(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cell(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.matchTile && !isStart && !cell.hasTile(effect.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, loc, spawnMap) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const map = loc.map;\n    let startProb = effect.grow || 0;\n    let probDec = effect.decrement || 0;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, loc.x, loc.y, true)) {\n        return false;\n    }\n    spawnMap[loc.x][loc.y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap[a.x][a.y])\n            return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const c = map.cell(x, y);\n            return !a.forbidsCell(c);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeActor(a);\n            map.addActor(loc[0], loc[1], a);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap[i.x][i.y])\n            return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const dest = map.cell(x, y);\n            return !i.forbidsCell(dest);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(i);\n            map.addItem(loc[0], loc[1], i);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nexport function stat(opts) {\n    if (!opts)\n        throw new Error('Invalid Stat config.');\n    const info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.stat = opts[0];\n        info.type = opts[1] || 'inc';\n        info.amount = GWU.range.make(opts[2] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.stat = opts.stat;\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(info.amount || 1);\n    }\n    else {\n        throw new Error('Invalid stat effect configuration: ' + JSON.stringify(opts));\n    }\n    return statAction.bind(undefined, info);\n}\nexport function statAction(config, action) {\n    if (!config.amount)\n        return action.didNothing();\n    // who am I nourishing?\n    const actor = action.actor || action.map.actorAt(action.x, action.y);\n    if (!actor) {\n        return action.didNothing();\n    }\n    // sustain?\n    const stats = actor.stats;\n    if (!stats.adjust(config.stat, config.type, config.amount))\n        return action.didNothing();\n    return action.didSomething();\n}\nEffect.installHandler('stat', stat);\n","import { installHandler } from '../effect';\nexport function tile(src) {\n    if (!src)\n        throw new Error('Tile effect needs configuration.');\n    if (typeof src === 'string') {\n        src = { id: src };\n    }\n    else if (Array.isArray(src)) {\n        src = { id: src[0] };\n    }\n    else if (!src.id) {\n        throw new Error('Tile effect needs configuration with id.');\n    }\n    const opts = src;\n    if (opts.id.includes('!')) {\n        opts.superpriority = true;\n    }\n    if (opts.id.includes('~')) {\n        opts.blockedByActors = true;\n        opts.blockedByItems = true;\n    }\n    opts.id = opts.id.replace(/[!~]*/g, '');\n    return tileAction.bind(undefined, opts);\n}\nexport function tileAction(cfg, action) {\n    const map = action.map;\n    cfg.machine = action.machine || 0;\n    if (map.setTile(action.x, action.y, cfg.id, cfg)) {\n        action.didSomething();\n    }\n}\ninstallHandler('tile', tile);\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile, _opts) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n}\n","import { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts) {\n        const cell = this.map.cell(x, y);\n        return cell.setTile(tile, opts);\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // // Bookkeeping for fire, pressure plates and key-activated tiles.\n        // for (let x = 0; x < this.map.width; ++x) {\n        //     for (let y = 0; y < this.map.height; ++y) {\n        //         const cell = this.map.cell(x, y);\n        //         if (\n        //             !cell.hasCellFlag(\n        //                 Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM\n        //             ) &&\n        //             cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)\n        //         ) {\n        //             cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n        //         }\n        //     }\n        // }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    clear() {\n        this.volume.fill(0);\n    }\n    setTile(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.setTile(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.changed = true;\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n        this.changed = other.changed;\n    }\n    tick(_dt) {\n        if (!this.changed)\n            return false;\n        this.changed = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.changed = true;\n            }\n            else {\n                this.clearTile(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clearTile(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nimport * as ACTION from '../action';\n// import * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.xy.DIRS[d];\n                        this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                // const effect = Effect.from(tile.effects.fire);\n                // if (effect && effect.chance > ignitionChance) {\n                //     ignitionChance = effect.chance;\n                // }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && this.map.rng.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasAction('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            cell.trigger(event, new ACTION.Action(event, { map: this.map, force: true }));\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nconst highlightColor = GWU.color.install('highlight', [100, 100, 0]);\nexport class BasicDrawer {\n    constructor() {\n        this.scent = false;\n    }\n    drawInto(dest, map, opts = {}) {\n        const buffer = dest instanceof GWU.buffer.Buffer ? dest : dest.buffer;\n        const offsetX = opts.offsetX || 0;\n        const offsetY = opts.offsetY || 0;\n        map.clearMapFlag(Flags.Map.MAP_DANCES);\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                if (map.hasXY(x + offsetX, y + offsetY)) {\n                    const cell = map.cell(x + offsetX, y + offsetY);\n                    this.drawCell(mixer, map, cell, map.fov);\n                    buffer.drawSprite(x, y, mixer);\n                }\n            }\n        }\n    }\n    drawCell(dest, map, cell, fov) {\n        dest.blackOut();\n        // const isVisible = fov ? fov.isAnyKindOfVisible(cell.x, cell.y) : true;\n        const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (cell.needsRedraw || needSnapshot) {\n            this.getAppearance(dest, map, cell);\n            cell.putSnapshot(dest);\n            cell.needsRedraw = false;\n            cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n        else {\n            cell.getSnapshot(dest);\n            if (cell.hasCellFlag(Flags.Cell.COLORS_DANCE)) {\n                map.setMapFlag(Flags.Map.MAP_DANCES);\n            }\n        }\n        this.applyLight(dest, cell, fov);\n        let separate = false;\n        if (cell.memory) {\n            separate = !!((cell.memory.flags.entity & Flags.Entity.L_VISUALLY_DISTINCT)\n            // Flags.Entity.L_LIST_IN_SIDEBAR)\n            );\n        }\n        else {\n            separate = cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT, \n            // Flags.Entity.L_LIST_IN_SIDEBAR,\n            true);\n        }\n        if (cell.hasCellFlag(Flags.Cell.IS_CURSOR)) {\n            dest.bg = highlightColor;\n            dest.fg = dest.bg.inverse();\n            separate = true;\n        }\n        else if (cell.hasCellFlag(Flags.Cell.IS_HIGHLIGHTED)) {\n            dest.bg = highlightColor.mix(dest.bg, 35);\n            dest.fg = dest.bg.inverse();\n            separate = true;\n        }\n        if (this.scent && map.player) {\n            const s = GWU.clamp(map.player.scent.get(cell.x, cell.y) * 5, 0, 50);\n            if (s) {\n                const c = GWU.color.colors.red;\n                dest.mix(c, 0, s);\n            }\n        }\n        if (separate) {\n            [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n        }\n        return true;\n    }\n    // getCellAppearance(cell: CellType, dest: GWU.sprite.Mixer) {\n    //     dest.blackOut();\n    //     const isVisible = true; // this.fov.isAnyKindOfVisible(x, y);\n    //     const isRevealed = true; // this.fov.isRevealed(x, y);\n    //     const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     if (needSnapshot || (cell.needsRedraw && isVisible)) {\n    //         this.layers.forEach((layer) => layer.putAppearance(dest, cell));\n    //         if (dest.dances) {\n    //             cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n    //         } else {\n    //             cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n    //         }\n    //         dest.bake();\n    //         cell.putSnapshot(dest);\n    //         cell.needsRedraw = false;\n    //         cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     } else {\n    //         cell.getSnapshot(dest);\n    //     }\n    //     if (isVisible) {\n    //         const light = this.light.getLight(cell.x, cell.y);\n    //         dest.multiply(light);\n    //     } else if (isRevealed) {\n    //         dest.scale(50);\n    //     } else {\n    //         dest.blackOut();\n    //     }\n    //     if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n    //         [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n    //     }\n    // }\n    getAppearance(dest, map, cell) {\n        let tiles = cell.tiles;\n        let actor = null;\n        let item = null;\n        if (cell.memory) {\n            tiles = cell.memory.tiles;\n            item = cell.memory.item;\n        }\n        else {\n            actor = cell.hasActor() ? cell.actor : null;\n            item = cell.hasItem() ? cell.item : null;\n        }\n        const ground = tiles[Flags.Depth.GROUND];\n        const surface = tiles[Flags.Depth.SURFACE];\n        const liquid = tiles[Flags.Depth.LIQUID];\n        const gas = tiles[Flags.Depth.GAS]; // How to get volume!?!?!?!\n        dest.drawSprite(ground.sprite);\n        if (surface) {\n            dest.drawSprite(surface.sprite);\n        }\n        if (liquid) {\n            dest.drawSprite(liquid.sprite);\n        }\n        if (item) {\n            item.drawInto(dest);\n        }\n        if (actor) {\n            actor.drawInto(dest);\n        }\n        if (gas) {\n            const opacity = GWU.rng.cosmetic.number(50) + 25;\n            dest.drawSprite(gas.sprite, opacity);\n        }\n        if (cell.hasFx()) {\n            const fx = map.fxAt(cell.x, cell.y);\n            if (fx)\n                dest.drawSprite(fx.sprite);\n        }\n        if (dest.dances) {\n            cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n            map.setMapFlag(Flags.Map.MAP_DANCES);\n        }\n        else {\n            cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n        }\n        dest.bake(true); // apply dancing\n    }\n    applyLight(dest, cell, fov) {\n        const isVisible = !fov || fov.isAnyKindOfVisible(cell.x, cell.y);\n        const isRevealed = !fov || fov.isRevealed(cell.x, cell.y);\n        const light = cell.map.light.getLight(cell.x, cell.y);\n        dest.multiply(light);\n        // TODO - is Clairy\n        // TODO - is Telepathy\n        if (fov && fov.isCursor(cell.x, cell.y)) {\n            dest.invert();\n        }\n        else if (!isVisible) {\n            if (cell.hasEntityFlag(Flags.Entity.L_BRIGHT_MEMORY)) {\n            }\n            else if (isRevealed) {\n                dest.scale(70);\n            }\n            else {\n                dest.blackOut();\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport { Tile } from '../tile';\nimport * as Layer from '../layer';\nimport { BasicDrawer } from '../draw/basic';\nimport * as ACTION from '../action';\n// export interface MapEvents extends GWU.events.Events {\n//     // add or remove actor\n//     actor: (map: Map, actor: Actor, isNew: boolean) => void;\n//     // add or remove item\n//     item: (map: Map, item: Item, isNew: boolean) => void;\n//     // add or remove fx\n//     fx: (map: Map, fx: Entity, isNew: boolean) => void;\n//     // change cell tiles\n//     cell: (map: Map, cell: Cell) => void;\n// }\nexport class Map {\n    constructor(width, height, opts = {}) {\n        this.locations = {};\n        // _memory: GWU.grid.Grid<CellMemory>;\n        // machineCount = 0;\n        // _seed = 0;\n        this.rng = GWU.rng.random;\n        this.id = 0;\n        this.actors = [];\n        this.items = [];\n        this.fx = [];\n        this.player = null;\n        this._tweens = new GWU.app.Tweens();\n        this.actions = new ACTION.Actions(this);\n        this.flags = { map: 0 };\n        this.layers = [];\n        this.data = { seed: 0, machineCount: 0 };\n        if (opts.id) {\n            this.data.id = opts.id;\n        }\n        this.drawer = opts.drawer || new BasicDrawer();\n        this.cells = GWU.grid.make(width, height, (x, y) => new Cell(this, x, y));\n        // this._memory = GWU.grid.make(\n        //     width,\n        //     height,\n        //     (x, y) => new CellMemory(this, x, y)\n        // );\n        if (opts.seed) {\n            this.data.seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        if (opts.fov === undefined) {\n            opts.alwaysVisible = true;\n        }\n        else if (opts.fov === false) {\n            opts.visible = true;\n        }\n        opts.callback = this.onFovChange.bind(this);\n        this.fov = new GWU.fov.FovSystem(this, opts);\n        this.initLayers();\n        if (opts.player) {\n            this.setPlayer(opts.player);\n        }\n        if (opts.actions) {\n            this.actions.load(opts.actions);\n        }\n    }\n    get seed() {\n        return this.data.seed;\n    }\n    set seed(v) {\n        this.data.seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    get width() {\n        return this.cells.width;\n    }\n    get height() {\n        return this.cells.height;\n    }\n    // memory(x: number, y: number): CellMemory {\n    //     return this._memory[x][y];\n    // }\n    // knowledge(x: number, y: number): CellInfoType {\n    //     if (this.fov.isAnyKindOfVisible(x, y)) return this.cell(x,y);\n    //     return this._memory[x][y];\n    // }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n        this.addLayer(Flags.Depth.SURFACE, new Layer.FireLayer(this, 'surface'));\n        this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // items\n    hasItem(x, y) {\n        return this.cell(x, y).hasItem();\n    }\n    itemAt(x, y) {\n        return this.items.find((i) => i.isAt(x, y)) || null;\n    }\n    eachItem(cb) {\n        this.items.forEach(cb);\n    }\n    addItem(x, y, item, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        // if (!cell.canAddItem(item)) return false;\n        if (cell._addItem(item)) {\n            const index = this.items.indexOf(item);\n            if (index < 0) {\n                this.items.push(item);\n            }\n            item.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddItemEffects(item, cell);\n            }\n            if (index < 0) {\n                this.trigger(new ACTION.Action('place', { map: this, item }));\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddItemEffects(item, cell) {\n        if (item.key &&\n            item.key.matches(cell.x, cell.y) &&\n            cell.hasAction('key')) {\n            cell.trigger('key', new ACTION.Action('key', { map: this, key: true, item }));\n        }\n        else if (cell.hasAction('place')) {\n            cell.trigger('place', new ACTION.Action('place', { map: this, key: true, item }));\n        }\n    }\n    addItemNear(x, y, item, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasItem())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (item.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addItem(loc[0], loc[1], item, fireEffects);\n    }\n    removeItem(item, fireEffects = false) {\n        const cell = this.cell(item.x, item.y);\n        // if (!cell.canRemoveItem(item)) return false;\n        if (cell._removeItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, cell);\n            }\n            GWU.arrayDelete(this.items, item);\n            item.removeFromMap();\n            this.trigger(new ACTION.Action('remove', { map: this, item }));\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveItemEffects(item, cell) {\n        if (item.isKey(cell.x, cell.y) && cell.hasAction('no_key')) {\n            cell.trigger('no_key', new ACTION.Action('no_key', {\n                map: this,\n                key: true,\n                item,\n            }));\n        }\n        else if (cell.hasAction('remove')) {\n            cell.trigger('remove', new ACTION.Action('remove', { map: this, key: true, item }));\n        }\n    }\n    moveItem(item, x, y, fireEffects = false) {\n        if (item.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this.cell(item.x, item.y);\n        const newCell = this.cell(x, y);\n        // if (!currentCell.canRemoveItem(item)) return false;\n        // if (!newCell.canAddItem(item)) return false;\n        currentCell._removeItem(item);\n        if (newCell._addItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, currentCell);\n                this._fireAddItemEffects(item, newCell);\n            }\n            item.addToMap(this, x, y);\n        }\n        return true;\n    }\n    //  moveItem(item: Item, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = item.x;\n    //     const oldY = item.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[item.depth] as Layer.ItemLayer;\n    //     if (!( layer.removeItem(item))) return false;\n    //     if (!( this.addItem(x, y, item))) {\n    //         layer.forceItem(item.x, item.y, item);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (item.lastSeen) {\n    //     //         this._memory[item.lastSeen.x][item.lastSeen.y].removeItem(item);\n    //     //         this.clearCellFlag(\n    //     //             item.lastSeen.x,\n    //     //             item.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         item.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.item = item;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     item.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    setPlayer(player) {\n        this.player = player;\n    }\n    actorAt(x, y) {\n        return this.actors.find((a) => a.isAt(x, y)) || null;\n    }\n    eachActor(cb) {\n        this.actors.forEach(cb);\n    }\n    addActor(x, y, actor, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (!cell.canAddActor(actor))\n            return false;\n        if (cell._addActor(actor)) {\n            const index = this.actors.indexOf(actor);\n            if (index < 0) {\n                this.actors.push(actor);\n            }\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddActorEffects(actor, cell);\n            }\n            if (index < 0) {\n                this.trigger(new ACTION.Action('enter', { map: this, actor }));\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddActorEffects(actor, cell) {\n        if (actor.isKey(cell.x, cell.y) && cell.hasAction('key')) {\n            cell.trigger('key', new ACTION.Action('key', { map: this, key: true, actor }));\n        }\n        else if (actor.isPlayer() && cell.hasAction('player-enter')) {\n            cell.trigger('player-enter', new ACTION.Action('player-enter', {\n                map: this,\n                actor,\n            }));\n        }\n        else if (cell.hasAction('enter')) {\n            cell.trigger('enter', new ACTION.Action('enter', { map: this, actor }));\n        }\n    }\n    addActorNear(x, y, actor, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasActor())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addActor(loc[0], loc[1], actor, fireEffects);\n    }\n    removeActor(actor, fireEffects = false) {\n        const cell = this.cell(actor.x, actor.y);\n        if (!cell.canRemoveActor(actor))\n            return false;\n        if (cell._removeActor(actor)) {\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, cell);\n            }\n            actor.removeFromMap();\n            GWU.arrayDelete(this.actors, actor);\n            this.trigger(new ACTION.Action('exit', { map: this, actor }));\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveActorEffects(actor, cell) {\n        if (actor.isKey(actor.x, actor.y) && cell.hasAction('no_key')) {\n            cell.trigger('no_key', new ACTION.Action('no_key', { map: this, key: true, actor }));\n        }\n        else if (actor.isPlayer() && cell.hasAction('player-exit')) {\n            cell.trigger('player-exit', new ACTION.Action('player-exit', { map: this, actor }));\n        }\n        else if (cell.hasAction('exit')) {\n            cell.trigger('exit', new ACTION.Action('exit', { map: this, actor }));\n        }\n    }\n    moveActor(actor, x, y, fireEffects = false) {\n        if (actor.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this.cell(actor.x, actor.y);\n        const newCell = this.cell(x, y);\n        // if (!currentCell.canRemoveActor(actor)) return false;\n        // if (!newCell.canAddActor(actor)) return false;\n        currentCell._removeActor(actor);\n        if (newCell._addActor(actor)) {\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, currentCell);\n                this._fireAddActorEffects(actor, newCell);\n            }\n        }\n        return true;\n    }\n    //  moveActor(actor: Actor, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = actor.x;\n    //     const oldY = actor.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[actor.depth] as Layer.ActorLayer;\n    //     if (!( layer.removeActor(actor))) return false;\n    //     if (!( layer.addActor(x, y, actor))) {\n    //         layer.forceActor(actor.x, actor.y, actor);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (actor.lastSeen) {\n    //     //         this._memory[actor.lastSeen.x][actor.lastSeen.y].removeActor(\n    //     //             actor\n    //     //         );\n    //     //         this.clearCellFlag(\n    //     //             actor.lastSeen.x,\n    //     //             actor.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         actor.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.actor = actor;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     actor.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    fxAt(x, y) {\n        return this.fx.find((i) => i.isAt(x, y)) || null;\n    }\n    eachFx(cb) {\n        this.fx.forEach(cb);\n    }\n    addFx(x, y, fx) {\n        const cell = this.get(x, y);\n        if (!cell)\n            return false;\n        fx.x = x;\n        fx.y = y;\n        cell._addFx(fx);\n        this.fx.push(fx);\n        // this.events.emit('fx', this, fx, true);\n        return true;\n    }\n    moveFx(fx, x, y) {\n        const current = this.get(fx.x, fx.y);\n        const updated = this.get(x, y);\n        if (!updated)\n            return false;\n        current._removeFx(fx);\n        fx.x = x;\n        fx.y = y;\n        updated._addFx(fx);\n        return true;\n    }\n    removeFx(fx) {\n        const cell = this.get(fx.x, fx.y);\n        GWU.arrayDelete(this.fx, fx);\n        if (cell) {\n            cell._removeFx(fx);\n        }\n        // this.events.emit('fx', this, fx, false);\n        return true;\n    }\n    // Information\n    // isVisible(x: number, y: number): boolean {\n    //     return this.fov.isAnyKindOfVisible(x, y);\n    // }\n    hasKey(x, y) {\n        const actor = this.actorAt(x, y);\n        if (actor && actor.isKey(x, y))\n            return true;\n        const item = this.itemAt(x, y);\n        if (item && item.isKey(x, y))\n            return true;\n        return false;\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        const getCh = (cell) => {\n            return cell.dump();\n        };\n        this.cells.dump(fmt || getCh, log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    get needsRedraw() {\n        return this.hasMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v)\n            this.setMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n        else\n            this.clearMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).hasCellFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    hasEntityFlag(x, y, flag) {\n        return this.cell(x, y).hasEntityFlag(flag);\n    }\n    hasTileFlag(x, y, flag) {\n        return this.cell(x, y).hasTileFlag(flag);\n    }\n    highlightPath(path, markCursor = true) {\n        this.clearPath();\n        path.forEach((loc) => {\n            this.setCellFlag(loc[0], loc[1], Flags.Cell.IS_HIGHLIGHTED);\n        });\n        if (markCursor && path[0]) {\n            const loc = path[0];\n            this.setCellFlag(loc[0], loc[1], Flags.Cell.IS_CURSOR);\n        }\n        this.needsRedraw = true;\n    }\n    highlightCell(x, y, markCursor = false) {\n        this.setCellFlag(x, y, markCursor ? Flags.Cell.IS_CURSOR : Flags.Cell.IS_HIGHLIGHTED);\n        this.needsRedraw = true;\n    }\n    clearPath() {\n        this.cells.forEach((c) => c.clearCellFlag(Flags.Cell.IS_CURSOR | Flags.Cell.IS_HIGHLIGHTED));\n        this.needsRedraw = true;\n    }\n    showCursor(x, y) {\n        this.clearCursor();\n        this.cell(x, y).setCellFlag(Flags.Cell.IS_CURSOR);\n        this.needsRedraw = true;\n    }\n    clearCursor() {\n        this.cells.forEach((c) => c.clearCellFlag(Flags.Cell.IS_CURSOR));\n        this.needsRedraw = true;\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        // this.fov.needsUpdate = true;\n        this.layers.forEach((l) => l.clear());\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cells[i][j];\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile\n    // useMemory = false\n    ) {\n        return this.cell(x, y).hasTile(tile);\n        // if (!useMemory) return this.cell(x, y).hasTile(tile);\n        // return this.memory(x, y).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof Tile)) {\n            const name = tile;\n            tile = TILE.get(name);\n            if (!tile)\n                throw new Error('Failed to find tile: ' + name);\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof Layer.TileLayer))\n            return false;\n        return layer.setTile(x, y, tile, opts);\n    }\n    clearTiles(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clearTiles(tile);\n    }\n    tick(dt) {\n        let didSomething = this._tweens.length > 0;\n        this._tweens.update(dt);\n        const action = new ACTION.Action('tick', { map: this });\n        this.fireAll(action);\n        didSomething || (didSomething = action.isSuccess());\n        for (let layer of this.layers) {\n            if (layer && layer.tick(dt)) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cell(x, y));\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.actors = src.actors.slice();\n        this.items = src.items.slice();\n        this.flags.map = src.flags.map;\n        // this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        this.data = Object.assign({}, src.data);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    hasAction(action) {\n        return this.actions.has(action);\n    }\n    on(action, fn) {\n        this.actions.on(action, fn);\n    }\n    once(action, fn) {\n        this.actions.once(action, fn);\n    }\n    off(action, fn) {\n        this.actions.off(action, fn);\n    }\n    trigger(ev, action) {\n        if (typeof ev !== 'string') {\n            return this.trigger(ev.action, ev);\n        }\n        if (!action)\n            throw new Error('Action is required.');\n        this.actions.trigger(ev, action);\n        if (action.isDone())\n            return;\n        const cell = this.cell(action.x, action.y);\n        cell.trigger(ev, action);\n    }\n    // fire(\n    //     event: string,\n    //     x: number,\n    //     y: number,\n    //     ctx: Effect.EffectCtx = {}\n    // ): boolean {\n    //     const cell = this.cell(x, y);\n    //     return cell.fireEvent(event, ctx);\n    // }\n    fireAll(action) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                // const ev = tile.effects[event];\n                // if (!ev) return;\n                const effect = { chance: 0 }; // DELETE\n                // const effect = Effect.from(ev);\n                // if (!effect) return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        action.force = true;\n        willFire.forEach((w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    cell.trigger(action.action, action);\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    // DRAW\n    drawInto(dest, opts) {\n        this.drawer.drawInto(dest, this, opts);\n    }\n    getAppearanceAt(x, y, dest) {\n        const cell = this.cell(x, y);\n        return this.drawer.drawCell(dest, this, cell);\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            // cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(cb) {\n        // TODO - Clairy, Telepathy, Detect, etc...\n        if (this.player) {\n            cb(this.player.x, this.player.y, this.player.visionDistance, GWU.fov.FovFlags.PLAYER);\n        }\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    // redrawCell(x: number, y: number): void {\n    //     // if (clearMemory) {\n    //     //     this.clearMemory(x, y);\n    //     // }\n    //     this.cell(x, y).needsRedraw = true;\n    // }\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        cell.storeMemory();\n        if (cell.hasActor() &&\n            cell.actor.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n    }\n    makeVisible(x, y) {\n        const cell = this.cell(x, y);\n        cell.clearMemory();\n        if (cell.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED |\n                Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n        else if (cell.hasActor() &&\n            !cell.actor.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n        else if (cell.hasItem() &&\n            !cell.item.hasEntityFlag(Flags.Entity.L_IN_SIDEBAR)) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        }\n    }\n    onFovChange(x, y, isVisible) {\n        if (!isVisible) {\n            this.storeMemory(x, y);\n        }\n        else {\n            this.makeVisible(x, y);\n        }\n    }\n    // Animator\n    addAnimation(a) {\n        this._tweens.add(a);\n    }\n    removeAnimation(a) {\n        this._tweens.remove(a);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount =\n                                                cellCount;\n                                            map.cell(i2, j2).flags.cell &=\n                                                ~Flags.Cell.IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        this.layerVersion = [];\n        this.lightVersion = 0;\n        // fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        // if (this.map.fov.changed) {\n        //     this.fovVersion = this.version;\n        //     this.map.fov.changed = false;\n        // }\n        // if (snap.version !== this.fovVersion) {\n        //     snap.map.fov.copy(this.map.fov);\n        // }\n        // layers\n        this.map.layers.forEach((layer, index) => {\n            const snapLayer = snap.map.layers[index];\n            if (layer.changed) {\n                this.layerVersion[index] = this.version;\n            }\n            if (this.layerVersion[index] !== snap.version) {\n                snapLayer.copy(layer);\n            }\n        });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        // if (snap.version < this.fovVersion || this.map.fov.changed) {\n        //     this.map.fov.copy(snap.map.fov);\n        //     this.fovVersion = snap.version;\n        // }\n        // layers\n        this.layerVersion.forEach((v, index) => {\n            if (v < snap.version)\n                return;\n            const destLayer = this.map.layers[index];\n            if (v > snap.version || destLayer.changed) {\n                const srcLayer = snap.map.layers[index];\n                destLayer.copy(srcLayer);\n                this.layerVersion[index] = snap.version;\n            }\n        });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function isHallway(map, x, y) {\n    return (GWU.xy.arcCount(x, y, (i, j) => {\n        return map.cell(i, j).isPassable();\n    }) > 1);\n}\nexport function replaceTile(map, find, replace) {\n    let count = 0;\n    map.eachCell((c) => {\n        if (!c.hasTile(find))\n            return;\n        if (c.setTile(replace)) {\n            ++count;\n        }\n    });\n    return count;\n}\nexport function getCellPathCost(map, x, y) {\n    const cell = map.cell(x, y);\n    if (cell.blocksMove())\n        return GWU.path.OBSTRUCTION;\n    if (cell.blocksPathing())\n        return GWU.path.FORBIDDEN;\n    if (cell.hasActor())\n        return 10;\n    return 1;\n}\nexport function fillCostMap(map, costMap) {\n    costMap.update((_v, x, y) => getCellPathCost(map, x, y));\n}\nexport function getPathBetween(map, x0, y0, x1, y1, options = {}) {\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = GWU.grid.alloc(map.width, map.height);\n    fillCostMap(map, costMap);\n    GWU.path.calculateDistances(distanceMap, x1, y1, costMap, options.eightWays, GWU.xy.straightDistanceBetween(x0, y0, x1, y1) + 1);\n    const path = GWU.path.getPath(distanceMap, x0, y0, (x, y) => map.cell(x, y).blocksMove(), options.eightWays);\n    if (path) {\n        path.push([x1, y1]);\n    }\n    GWU.grid.free(costMap);\n    GWU.grid.free(distanceMap);\n    return path;\n}\n","import { Map } from './map';\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile === undefined) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === undefined) {\n        opts.boundary = 'WALL';\n    }\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n        map.light.update();\n    }\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    // // In case we reveal the map or make it all visible we need our memory set correctly\n    // map.cells.forEach((_c, x, y) => {\n    //     if (map.fov.isRevealed(x, y)) {\n    //         map.storeMemory(x, y, true); // with snapshot\n    //     }\n    // });\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Horde as Flags } from '../flags/horde';\nimport * as Map from '../map';\nimport * as Actor from '../actor';\nexport class Horde {\n    // requiredTile: string | null = null;\n    constructor(config) {\n        this.tags = [];\n        this.members = {};\n        // blueprintId: string | null = null;\n        this.flags = { horde: 0 };\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        this.leader = config.leader;\n        if (config.members) {\n            Object.entries(config.members).forEach(([id, range]) => {\n                this.members[id] = GWU.range.make(range);\n            });\n        }\n        this.frequency = GWU.frequency.make(config.frequency || 100);\n        // this.blueprintId = config.blueprintId || null;\n        this.flags.horde = GWU.flag.from(Flags, config.flags);\n        // if (config.requiredTile) this.requiredTile = config.requiredTile;\n    }\n    spawn(map, x = -1, y = -1, opts = {}) {\n        var _a;\n        opts.canSpawn = opts.canSpawn || GWU.TRUE;\n        opts.rng = opts.rng || map.rng;\n        opts.machine = (_a = opts.machine) !== null && _a !== void 0 ? _a : 0;\n        const leader = this._spawnLeader(map, x, y, opts);\n        if (!leader)\n            return null;\n        this._spawnMembers(leader, map, opts);\n        return leader;\n    }\n    _spawnLeader(map, x, y, opts) {\n        const leaderKind = Actor.get(this.leader);\n        if (!leaderKind) {\n            throw new Error('Failed to find leader kind = ' + this.leader);\n        }\n        if (x >= 0 && y >= 0) {\n            if (leaderKind.avoidsCell(map.cell(x, y)))\n                return null;\n        }\n        const leader = Actor.make(leaderKind, { machineHome: opts.machine });\n        if (!leader)\n            throw new Error('Failed to make horde leader - ' + this.leader);\n        if (x < 0 || y < 0) {\n            [x, y] = this._pickLeaderLoc(leader, map, opts) || [-1, -1];\n            if (x < 0 || y < 0) {\n                return null;\n            }\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addLeader(leader, map, x, y, opts)) {\n            return null;\n        }\n        return leader;\n    }\n    _addLeader(leader, map, x, y, _opts) {\n        return map.addActor(x, y, leader);\n    }\n    _addMember(member, map, x, y, leader, _opts) {\n        member.leader = leader;\n        return map.addActor(x, y, member);\n    }\n    _spawnMembers(leader, map, opts) {\n        const entries = Object.entries(this.members);\n        if (entries.length == 0)\n            return 0;\n        let count = 0;\n        entries.forEach(([kindId, countRange]) => {\n            const count = countRange.value(opts.rng);\n            for (let i = 0; i < count; ++i) {\n                this._spawnMember(kindId, map, leader, opts);\n            }\n        });\n        return count;\n    }\n    _spawnMember(kindId, map, leader, opts) {\n        const kind = Actor.get(kindId);\n        if (!kind) {\n            throw new Error('Failed to find member kind = ' + kindId);\n        }\n        const member = Actor.make(kind, { machineHome: opts.machine });\n        if (!member)\n            throw new Error('Failed to make horde member - ' + kindId);\n        const [x, y] = this._pickMemberLoc(member, map, leader, opts) || [\n            -1, -1,\n        ];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addMember(member, map, x, y, leader, opts)) {\n            return null;\n        }\n        return member;\n    }\n    _pickLeaderLoc(leader, map, opts) {\n        let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            if (!opts.canSpawn(x, y))\n                return false;\n            if (leader.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n    _pickMemberLoc(actor, map, leader, opts) {\n        let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Horde } from './horde';\nimport { Horde as Flags } from '../flags/horde';\nexport const hordes = {};\nexport function install(id, horde) {\n    if (typeof horde === 'string') {\n        horde = { leader: horde };\n    }\n    if (!(horde instanceof Horde)) {\n        horde = new Horde(horde);\n    }\n    hordes[id] = horde;\n    return horde;\n}\nexport function installAll(hordes) {\n    Object.entries(hordes).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function from(id) {\n    if (id instanceof Horde) {\n        return id;\n    }\n    if (typeof id === 'string') {\n        return hordes[id];\n    }\n    return new Horde(id);\n}\nexport function random(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n        flags: 0,\n        forbidFlags: 0,\n        depth: 0,\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    const rng = opts.rng || GWU.rng.random;\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    if (opts.flags) {\n        if (typeof opts.flags === 'string') {\n            opts.flags\n                .split(/[,|]/)\n                .map((t) => t.trim())\n                .forEach((flag) => {\n                if (flag.startsWith('!')) {\n                    const key = flag.substring(1);\n                    match.forbidFlags |= Flags[key];\n                }\n                else {\n                    match.flags |= Flags[flag];\n                }\n            });\n        }\n    }\n    if (opts.forbidFlags) {\n        match.forbidFlags = GWU.flag.from(Flags, opts.forbidFlags);\n    }\n    if (opts.depth) {\n        match.depth = opts.depth;\n    }\n    if (match.depth && opts.oodChance) {\n        while (rng.chance(opts.oodChance)) {\n            match.depth += 1;\n        }\n        match.forbidFlags |= Flags.HORDE_NEVER_OOD;\n    }\n    const matches = Object.values(hordes).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        if (match.flags && !(k.flags.horde & match.flags)) {\n            return false;\n        }\n        if (match.forbidFlags && k.flags.horde & match.forbidFlags) {\n            return false;\n        }\n        return true;\n    });\n    if (match.depth) {\n        return rng.item(matches) || null;\n    }\n    const depth = match.depth;\n    const weights = matches.map((h) => h.frequency(depth));\n    const index = rng.weighted(weights);\n    if (index < 0)\n        return null;\n    return matches[index];\n}\n","// export * from './memory';\n// export * from './system';\nexport const empty = {};\n","/*\n    Attributes\n    ========================\n\n    To configure attributes, set the defaults:\n\n    Attribute.install(')\n\n    const attr = new Attributes(10);\n\n    attr.set('str', 10);\n    attr.set('dex', 10);\n    ...\n    attr.set('chr', 10);\n\n    // to get the current value\n    attr.get('str');\n\n    // To raise an attribute permanently\n    attr.gain('chr', 1);\n\n    // To raise an attribute temporarily\n    attr.gain('chr', 1, false);\n\n    // To lower an attribute permanently\n    attr.drain('chr', 1, true);\n\n    // to lower an attribute temporarily\n    attr.drain('chr', 1);\n\n    // to restore (remove) all temporary changes\n    attr.restore();\n\n    // to add a temporary change that can be removed by itself\n    attr.addBonus('str', 1);\n\n    // to remove the bonus\n    attr.clearBonus('str', 1);\n\n    // adjustments (bonuses) are also possible via:\n    attr.adjust('str', { bonus: 1 });\n\n    // But adjustments can also set the\n    attr.adjust('str', { fixed: 14 });      // temporarily sets base\n    attr.adjust('str', { base: 21 });       // resets the base\n    attr.adjust('str', { restore: true });  // removes all bonuses/penalties\n    attr.adjust('str', { min: 10 });        // limits value\n    attr.adjust('str', { max: 30 });        // limits value\n    attr.adjust('str', { sustain: true });  // turns off lowering values\n*/\nexport class Attributes {\n    constructor(baseValues) {\n        this._base = {};\n        this._max = {};\n        this._bonus = {};\n        this._sustain = {};\n        this._value = {};\n        this.changed = null;\n        this.init(baseValues);\n    }\n    init(baseValues) {\n        for (let k in attributes) {\n            const v = typeof baseValues === 'number' ? baseValues : attributes[k];\n            this.set(k, v);\n        }\n        if (typeof baseValues !== 'number') {\n            for (let k in baseValues) {\n                this.set(k, baseValues[k]);\n            }\n        }\n    }\n    forEach(fn) {\n        Object.keys(attributes).forEach((k) => fn(this.get(k)));\n    }\n    // modifier(name: string) {\n    //     return Math.floor((this.get(name) - 10) / 2);\n    // }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    set(name, value = 0) {\n        this._value[name] = value;\n        this._base[name] = value;\n        this._max[name] = value;\n        this._bonus[name] = [];\n        return value;\n    }\n    base(name) {\n        return this._base[name] || 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    sustain(name) {\n        return this._sustain[name] || false;\n    }\n    gain(name, delta, raiseMax = true) {\n        if (delta < 0 && this._sustain[name])\n            return 0;\n        this._base[name] += delta;\n        if (raiseMax && this._base[name] > this._max[name]) {\n            this._max[name] = this._base[name];\n        }\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    drain(name, loss, lowerMax = false) {\n        if (loss < 0)\n            loss = -loss;\n        const changed = this.gain(name, -loss, false);\n        if (changed && lowerMax) {\n            this._max[name] = this._base[name];\n        }\n        return changed;\n    }\n    restore(name) {\n        this._base[name] = this._max[name];\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    addBonus(name, bonus) {\n        return this._addBonus(name, { bonus });\n    }\n    _addBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        if (this._value[name] === undefined) {\n            this.set(name, 0);\n        }\n        this._bonus[name].push(bonus);\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    clearBonus(name, bonus) {\n        return this._clearBonus(name, { bonus });\n    }\n    _clearBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        let arr = this._bonus[name] || [];\n        let key = JSON.stringify(bonus);\n        let index = arr.findIndex((o) => {\n            return JSON.stringify(o) == key;\n        });\n        if (index > -1) {\n            arr.splice(index, 1);\n            let old = this.get(name);\n            return this._calcValue(name) - old;\n        }\n        return 0;\n    }\n    _calcValue(name) {\n        let allAdjustments = {};\n        this._bonus[name].forEach((adj) => this._applyAdjustment(allAdjustments, adj));\n        this._sustain[name] = allAdjustments.sustain || false;\n        let value = this._base[name] || 0;\n        if (allAdjustments.fixed !== undefined) {\n            value = allAdjustments.fixed;\n        }\n        else {\n            value += allAdjustments.bonus || 0;\n            if (allAdjustments.min !== undefined) {\n                value = Math.max(allAdjustments.min, value);\n            }\n            if (allAdjustments.max !== undefined) {\n                value = Math.min(allAdjustments.max, value);\n            }\n        }\n        return (this._value[name] = value);\n    }\n    adjust(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.gain(name, adj.base);\n        }\n        else if (adj.restore) {\n            delta = this.restore(name);\n            if (delta == 0)\n                delta = undefined;\n        }\n        else {\n            delta = this._addBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    clearAdjustment(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.drain(name, adj.base, true);\n        }\n        else if (adj.restore) {\n            // do nothing...\n        }\n        else {\n            delta = this._clearBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    _applyAdjustment(total, opts) {\n        if (opts.bonus) {\n            total.bonus = (total.bonus || 0) + opts.bonus;\n        }\n        if (opts.fixed !== undefined) {\n            total.fixed = Math.max(total.fixed || 0, opts.fixed);\n        }\n        if (opts.min !== undefined) {\n            total.min = Math.max(total.min || 0, opts.min);\n        }\n        if (opts.max !== undefined) {\n            total.max = Math.max(total.max || 0, opts.max);\n        }\n        if (opts.sustain !== undefined) {\n            total.sustain = opts.sustain;\n        }\n    }\n}\nexport const attributes = {};\nexport function installAttribute(attr) {\n    if (typeof attr === 'string') {\n        attributes[attr] = 0;\n        return;\n    }\n    // clear existing\n    Object.keys(attributes).forEach((k) => {\n        delete attributes[k];\n    });\n    Object.assign(attributes, attr);\n}\nexport function makeAttributes(defaults) {\n    return new Attributes(defaults);\n}\n/*\nfunction adjust(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = undefined;\n        if (a.base) {\n            delta = being.attributes.addBase(a.name, a.base);\n        } else if (a.restore) {\n            delta = being.attributes.restoreBase(a.name);\n            if (delta == 0) delta = undefined;\n        } else {\n            delta = being.attributes.addBonus(a.name, a);\n        }\n        if (delta !== undefined) {\n            out[a.name] = delta;\n        }\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n\n    return results;\n};\n\n function clearAdjustment(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = 0;\n        delta += being.attributes.clearBonus(a.name, a);\n\n        out[a.name] = delta;\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n    return results;\n};\n\nRUT.Attribute.rollAttributes = function (opts = {}) {\n    let dice = [];\n    let total = 0;\n\n    if (RUT.Calc.isValue(opts)) opts = { value: opts };\n    Object.defaults(opts, RUT.Config.Attribute.rollAttributes);\n\n    let attributes = RUT.Config.Attributes;\n\n    let min_average = Math.max(opts.min_average - 5, 0);\n    let max_average = Math.min(opts.max_average - 5, RUT.Config.ATTRIBUTE_MAX);\n\n    let min_total = min_average * attributes.length;\n    let max_total = max_average * attributes.length;\n\n    do {\n        total = 0;\n        dice = [];\n        for (let i = 0; i < 18; ++i) {\n            dice.push(RUT.RNG.rollDie(3 + (i % 3)));\n            total += dice[i];\n        }\n    } while (total <= min_total || total > max_total);\n\n    let values = attributes.reduce((out, name, i) => {\n        let index = 3 * i;\n        let value = 5 + dice[index] + dice[index + 1] + dice[index + 2];\n        if (opts.value) {\n            value = RUT.Calc.calc(opts.value);\n        } else if (opts[name]) {\n            value = RUT.Calc.calc(opts[name]);\n        }\n        out[name] = value;\n        return out;\n    }, {});\n    return values;\n};\nRUT.Config.Attribute.rollAttributes = { min_average: 11, max_average: 14 };\n*/\n/*\nexport function normalize_adjustment(args: ) {\n    if (args.length == 3) {\n        let opts = args[2];\n        if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        let name = `${args[0]}.${args[1]}`;\n        return [Object.assign({ name }, opts)];\n    }\n    if (args.length == 2) {\n        let opts = args[1];\n        if (opts === true || opts === false) {\n            opts = { has: opts };\n        } else if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        return [Object.assign({ name: args[0] }, opts)];\n    }\n\n    let opts = args[0];\n    if (opts.name) {\n        return [opts];\n    }\n    if (opts.attribute) {\n        opts.name = opts.attribute;\n        return [opts];\n    }\n    if (opts.restore) {\n        if (opts.restore == 'all') {\n            return RUT.Attributes.map((a) => {\n                return { name: a, restore: true };\n            });\n        }\n        return [{ name: opts.restore, restore: true }];\n    }\n    if (opts.skill) {\n        opts.name = opts.skill;\n        return [opts];\n    }\n    if (opts.stat) {\n        opts.name = opts.stat;\n        return [opts];\n    }\n    if (opts.save) {\n        opts.name = opts.save;\n        return [opts];\n    }\n    // if (opts.saves) {\n    //   opts.name = opts.saves;\n    //   return [opts];\n    // }\n    if (opts.ability) {\n        opts.name = opts.ability;\n        return [opts];\n    }\n\n    // now we assume that each key is for a separate skill...\n    return Object.keys(opts).reduce((out, key) => {\n        let opt = opts[key];\n        if (key == 'reset' || key == 'restore') {\n            if (typeof opt == 'string') opt = [opt];\n            opt.forEach((a) => {\n                out.push({ name: a, restore: true });\n            });\n        } else {\n            if (typeof opt == 'number' || Array.isArray(opt)) {\n                opt = { bonus: opt };\n            } else if (opt === true || opt === false) {\n                opt = { has: opt };\n            } else if (opt == 'reset' || opt == 'restore') {\n                opt = { restore: true };\n            } else if (opt == 'sustain') {\n                opt = { sustain: true };\n            }\n            out.push(Object.assign({ name: key }, opt));\n        }\n        return out;\n    }, []);\n}\n*/\n","/*\nSkills\n\nSkills generally fall into 2 categories - binary and progressive.\n\n\n// Create a skills object\nconst skills = new Skills();\n\n// set skills\nskills.set('diving', true); // = { has: true, level: 0 }\nskills.set('diving', 10); // = { has: true, level: 10 }\n\nskills.remove('diving'); // {}\n\n// adjustments\nskills.adjust('diving', { bonus: 1 });\nskills.adjust('diving', { disadvantage: true });\nskills.adjust('diving', { advantage: 3 });\nskills.adjust('diving', { fixed: 10 });\nskills.adjust('diving', { critical: 5 });\n\n\n\n\n\n*/\nclass Skill {\n    constructor(name) {\n        this.name = name;\n    }\n    get has() {\n        return this._bool('_has');\n    }\n    get level() {\n        return this._int('_level');\n    }\n    get disadvantage() {\n        return this._bool('_disadvantage');\n    }\n    get advantage() {\n        return this._bool('_advantage');\n    }\n    get fixed() {\n        return this._int('_fixed');\n    }\n    get bonus() {\n        const b = this._int('_bonus') || 0;\n        if (!this._parent)\n            return b;\n        return b + this._parent.bonus;\n    }\n    get succeed() {\n        return this._bool('_succeed');\n    }\n    get fail() {\n        return this._bool('_fail');\n    }\n    set(value) {\n        if (value === false) {\n            this._has = false;\n            this._level = 0;\n        }\n        else {\n            this._has = true;\n            this._level = value === true ? 0 : value;\n        }\n    }\n    _value(name) {\n        if (this[name] !== undefined) {\n            // @ts-ignore\n            return this[name];\n        }\n        if (this._parent) {\n            // @ts-ignore\n            return this._parent._value(name);\n        }\n        return undefined;\n    }\n    _bool(name) {\n        return !!this._value(name);\n    }\n    _int(name) {\n        return this._value(name);\n    }\n    adjust(adj) {\n        Object.entries(adj).forEach(([key, value]) => {\n            key = '_' + key;\n            if (value === undefined)\n                return;\n            if (key === '_fixed') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = Math.max(value, this._fixed || 0);\n            }\n            else if (key === '_bonus') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = value + (this._bonus || 0);\n            }\n            // @ts-ignore\n            this[key] = value;\n        });\n    }\n    clear(adj) {\n        Object.keys(adj).forEach((key) => {\n            key = '_' + key;\n            // @ts-ignore\n            if (this[key] !== undefined) {\n                // @ts-ignore\n                this[key] = undefined;\n            }\n        });\n    }\n}\nexport class Skills {\n    constructor(vals = {}) {\n        this._skills = {};\n        Object.entries(vals).forEach(([key, value]) => {\n            this.set(key, value);\n        });\n    }\n    set(name, value) {\n        const s = this.get(name);\n        s.set(value);\n        return s;\n    }\n    get(name) {\n        let s = this._skills[name];\n        if (s)\n            return s;\n        s = this._skills[name] = new Skill(name);\n        const index = name.lastIndexOf('.');\n        if (index > 0) {\n            s._parent = this.get(name.substring(0, index));\n        }\n        else {\n            s.set(false);\n        }\n        return s;\n    }\n    adjust(name, adj) {\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        let s = this.get(name);\n        s.adjust(adj);\n        return s;\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Scent {\n    constructor(player) {\n        this._player = player;\n    }\n    get(x, y) {\n        if (!this._data)\n            return 0;\n        return this._data[x][y];\n    }\n    clear() {\n        if (!this._player.map)\n            return;\n        if (this._data)\n            GWU.grid.free(this._data);\n        this._data = GWU.grid.alloc(this._player.map.width, this._player.map.height);\n    }\n    update() {\n        if (!this._player.map)\n            return;\n        const scent = this._player.data.scent || 10;\n        this._data[this._player.x][this._player.y] = scent;\n        const updated = GWU.grid.alloc(this._data.width, this._data.height);\n        const map = this._player.map;\n        this._data.forEach((v, x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.blocksMove())\n                return;\n            let highest = v;\n            GWU.xy.eachNeighbor(x, y, (x1, y1) => {\n                if (!this._data.hasXY(x1, y1))\n                    return;\n                const v1 = this._data[x1][y1];\n                if (v1 > highest) {\n                    highest = v1;\n                }\n            }, true);\n            const delta = cell.hasLiquid() ? 3 : 1;\n            updated[x][y] = Math.max(0, highest - delta);\n        });\n        GWU.grid.free(this._data);\n        this._data = updated;\n    }\n    nextDir(x, y) {\n        const v = this._data[x][y] || 0;\n        if (!v)\n            return null;\n        let highest = v;\n        let highestLoc = [];\n        GWU.xy.eachNeighbor(x, y, (x1, y1) => {\n            if (!this._data.hasXY(x1, y1))\n                return;\n            const v1 = this._data[x1][y1];\n            if (v1 == highest) {\n                highestLoc.push([x1, y1]);\n            }\n            else if (v1 > highest) {\n                highestLoc = [[x1, y1]];\n                highest = v1;\n            }\n        }, false);\n        if (!highestLoc.length)\n            return null;\n        const loc = GWU.random.item(highestLoc);\n        loc[0] = loc[0] - x;\n        loc[1] = loc[1] - y;\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Actor } from '../actor';\nimport { Scent } from './scent';\nimport * as Flags from '../flags';\nexport class Player extends Actor {\n    constructor(kind) {\n        super(kind);\n        this.scent = new Scent(this);\n    }\n    interrupt(other) {\n        if (this.hasGoal()) {\n            this.clearGoal();\n            GWU.message.addAt(this.x, this.y, '{{you}} {{verb see~}} {{a other}}.', {\n                actor: this,\n                verb: 'see',\n                other,\n            });\n        }\n    }\n    endTurn(pct = 100) {\n        if (this.map) {\n            if (this.map.fov.update()) {\n                this.clearActorFlag(Flags.Actor.STABLE_COST_MAP);\n            }\n            this.scent.update();\n        }\n        super.endTurn(pct);\n    }\n    addToMap(map, x, y) {\n        if (!super.addToMap(map, x, y))\n            return false;\n        this.scent.clear();\n        return true;\n    }\n    setGoal(x, y) {\n        const map = this._map;\n        if (!map)\n            throw new Error('No map to set goal with!');\n        if (!this._goalMap) {\n            this._goalMap = GWU.grid.alloc(map.width, map.height);\n        }\n        const goalMap = this._goalMap;\n        const mapToPlayer = this.mapToMe();\n        if (mapToPlayer[x][y] < 0 ||\n            mapToPlayer[x][y] >= GWU.path.NO_PATH ||\n            !map.fov.isRevealed(x, y)) {\n            let loc = GWU.path.getClosestValidLocation(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y));\n            loc = loc || [this.x, this.y];\n            x = loc[0];\n            y = loc[1];\n        }\n        GWU.path.calculateDistances(goalMap, x, y, this.costMap());\n        return this._goalMap;\n    }\n    nextGoalStep() {\n        const map = this.map;\n        if (!map)\n            return null;\n        const goalMap = this.goalMap;\n        const step = GWU.path.nextStep(goalMap, this.x, this.y, (x, y) => map.hasActor(x, y) && map.actorAt(x, y) !== this);\n        return step;\n    }\n    pathTo(...args) {\n        let x = args[0];\n        let y = args[1];\n        if (args.length === 1) {\n            x = args[0].x;\n            y = args[0].y;\n        }\n        const map = this.map;\n        if (!map)\n            return null;\n        const mapToPlayer = this.mapToMe();\n        if (mapToPlayer[x][y] < 0 ||\n            mapToPlayer[x][y] >= GWU.path.NO_PATH ||\n            !map.fov.isRevealed(x, y)) {\n            const loc = GWU.path.getClosestValidLocation(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y));\n            if (!loc)\n                return null;\n            x = loc[0];\n            y = loc[1];\n        }\n        const path = GWU.path.getPath(mapToPlayer, x, y, (x, y) => !map.fov.isRevealed(x, y), true);\n        return path;\n    }\n}\nPlayer.default = {\n    ch: '@',\n    fg: 'white',\n    name: 'You',\n    swim: true,\n    sidebarFg: 'purple',\n};\n","import * as GWU from 'gw-utils';\nimport * as Actor from '../actor';\nimport * as Skills from './skill';\nimport * as Attributes from './attribute';\nimport { Player } from './player';\nimport * as Flags from '../flags';\nexport class PlayerKind extends Actor.ActorKind {\n    constructor(opts = {}) {\n        super((() => {\n            if (!opts.sprite) {\n                opts.ch = opts.ch || Player.default.ch;\n                opts.fg = opts.fg || Player.default.fg;\n            }\n            if (!opts.name) {\n                opts.name = Player.default.name;\n            }\n            if (opts.swim === undefined) {\n                opts.swim = Player.default.swim;\n            }\n            return opts;\n        })());\n        this.flags.actor |= Flags.Actor.IS_PLAYER;\n        this.flags.entity |= Flags.Entity.L_ALWAYS_PLURAL;\n        this.attributes = new Attributes.Attributes(opts.attributes || {});\n        this.skills = new Skills.Skills(opts.skills || {});\n    }\n    make(options) {\n        const actor = new Player(this);\n        this.init(actor, options);\n        return actor;\n    }\n    cellCost(cell, player) {\n        const map = cell.map;\n        if (!map.fov.isRevealed(cell.x, cell.y))\n            return GWU.path.FORBIDDEN;\n        return super.cellCost(cell, player);\n    }\n}\n","import { PlayerKind } from './kind';\nimport * as Actor from '../actor';\nexport function make(id, makeOptions) {\n    let kind;\n    if (typeof id === 'string') {\n        // @ts-ignore\n        kind = Actor.get(id);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + id);\n        if (!(kind instanceof PlayerKind))\n            throw new Error('Not a player kind.');\n    }\n    else if (id instanceof PlayerKind) {\n        kind = id;\n    }\n    else {\n        kind = makeKind(id);\n    }\n    return kind.make(makeOptions);\n}\nexport function install(id, kind) {\n    if (kind instanceof PlayerKind) {\n        Actor.kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    Actor.kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof PlayerKind)\n        return id;\n    const k = Actor.kinds[id];\n    if (k && !(k instanceof PlayerKind)) {\n        throw new Error('No a player kind.');\n    }\n    return k;\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new PlayerKind(config);\n}\n","import * as GWU from 'gw-utils';\nimport { Player } from '../player/player';\nimport * as Flags from '../flags';\nexport class Viewport extends GWU.widget.Widget {\n    constructor(opts) {\n        super((() => {\n            opts.tag = opts.tag || 'viewport';\n            return opts;\n        })());\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this._subject = null;\n        this.player = null;\n        this.bounds = new GWU.xy.Bounds(opts.x, opts.y, opts.width, opts.height);\n        this.bg = GWU.color.from(opts.bg || 'black');\n        this.attr('snap', opts.snap || false);\n        this.attr('center', opts.center || false);\n        this.attr('lockX', opts.lock || opts.lockX || false);\n        this.attr('lockY', opts.lock || opts.lockY || false);\n        this.filter = opts.filter || null;\n        this.scent = opts.scent || false;\n    }\n    get subject() {\n        return this._subject;\n    }\n    set subject(subject) {\n        this.attr('center', !!subject);\n        if (subject) {\n            this.offsetX = subject.x - this.halfWidth();\n            this.offsetY = subject.y - this.halfHeight();\n        }\n        this._subject = subject;\n        if (subject && subject instanceof Player) {\n            this.player = subject;\n        }\n        else {\n            this.player = null;\n        }\n    }\n    set lock(v) {\n        this.attr('lockX', v);\n        this.attr('lockY', v);\n    }\n    get lockX() {\n        return this._attrBool('lockX');\n    }\n    set lockX(v) {\n        this.attr('lockX', v);\n    }\n    get lockY() {\n        return this._attrBool('lockY');\n    }\n    set lockY(v) {\n        this.attr('lockY', v);\n    }\n    toMapX(x) {\n        return x + this.offsetX - this.bounds.x;\n    }\n    toMapY(y) {\n        return y + this.offsetY - this.bounds.y;\n    }\n    toInnerX(x) {\n        return x - this.bounds.x;\n    }\n    toInnerY(y) {\n        return y - this.bounds.y;\n    }\n    halfWidth() {\n        return Math.floor(this.bounds.width / 2);\n    }\n    halfHeight() {\n        return Math.floor(this.bounds.height / 2);\n    }\n    centerOn(map, x, y) {\n        this.attr('center', true);\n        this.subject = { x, y, map };\n    }\n    showMap(map, x = 0, y = 0) {\n        this.subject = { x, y, map };\n        this.offsetX = x;\n        this.offsetY = y;\n        this.attr('center', false);\n        this.attr('snap', false);\n    }\n    updateOffset() {\n        if (!this._subject) {\n            this.offsetX = 0;\n            this.offsetY = 0;\n            return;\n        }\n        const subject = this._subject;\n        const map = subject.map;\n        const bounds = map;\n        if (subject && map.hasXY(subject.x, subject.y)) {\n            if (this._attrBool('snap')) {\n                let left = this.offsetX;\n                let right = this.offsetX + this.bounds.width;\n                let top = this.offsetY;\n                let bottom = this.offsetY + this.bounds.height;\n                // auto center if outside the viewport\n                if (subject.x < left || subject.x > right) {\n                    left = this.offsetX = subject.x - this.halfWidth();\n                    right = left + this.bounds.width;\n                }\n                if (subject.y < top || subject.y > bottom) {\n                    top = this.offsetY = subject.y - this.halfHeight();\n                    bottom = top + this.bounds.height;\n                }\n                const edgeX = Math.floor(this.bounds.width / 5);\n                const edgeY = Math.floor(this.bounds.height / 5);\n                const thirdW = Math.floor(this.bounds.width / 3);\n                if (left + edgeX >= subject.x) {\n                    this.offsetX = Math.max(0, subject.x + thirdW - this.bounds.width);\n                }\n                else if (right - edgeX <= subject.x) {\n                    this.offsetX = Math.min(subject.x - thirdW, bounds.width - this.bounds.width);\n                }\n                const thirdH = Math.floor(this.bounds.height / 3);\n                if (top + edgeY >= subject.y) {\n                    this.offsetY = Math.max(0, subject.y + thirdH - this.bounds.height);\n                }\n                else if (bottom - edgeY <= subject.y) {\n                    this.offsetY = Math.min(subject.y - thirdH, bounds.height - this.bounds.height);\n                }\n            }\n            else if (this._attrBool('center')) {\n                this.offsetX = subject.x - this.halfWidth();\n                this.offsetY = subject.y - this.halfHeight();\n            }\n            else {\n                this.offsetX = subject.x;\n                this.offsetY = subject.y;\n            }\n        }\n        if (this.lockX && map) {\n            this.offsetX = GWU.clamp(this.offsetX, 0, map.width - this.bounds.width);\n        }\n        if (this.lockY && map) {\n            this.offsetY = GWU.clamp(this.offsetY, 0, map.height - this.bounds.height);\n        }\n    }\n    _draw(buffer) {\n        if (!this._subject)\n            return;\n        const map = this._subject.map;\n        if (!map || !map.needsRedraw)\n            return;\n        const fov = map.fov;\n        buffer.blackOutRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, this.bg);\n        if (!this._subject) {\n            return;\n        }\n        this.updateOffset();\n        const drawer = map.drawer;\n        drawer.scent = this.scent;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < this.bounds.width; ++x) {\n            for (let y = 0; y < this.bounds.height; ++y) {\n                const mapX = x + this.offsetX;\n                const mapY = y + this.offsetY;\n                if (map.hasXY(mapX, mapY)) {\n                    const cell = map.cell(mapX, mapY);\n                    map.drawer.drawCell(mixer, map, cell, fov);\n                }\n                else {\n                    mixer.draw(' ', this.bg, this.bg); // blackOut\n                }\n                if (this.filter) {\n                    this.filter(mixer, mapX, mapY, map);\n                }\n                buffer.drawSprite(x + this.bounds.x, y + this.bounds.y, mixer);\n            }\n        }\n        // map.clearMapFlag(GWM.flags.Map.MAP_CHANGED);\n    }\n    update(dt) {\n        super.update(dt);\n        if (!this._subject)\n            return;\n        const map = this._subject.map;\n        if (!map)\n            return;\n        if (!map.hasMapFlag(Flags.Map.MAP_DANCES) || !GWU.cosmetic.chance(10)) {\n            return;\n        }\n        map.eachCell((c) => {\n            if (c.hasCellFlag(Flags.Cell.COLORS_DANCE) &&\n                map.fov.isAnyKindOfVisible(c.x, c.y) &&\n                GWU.cosmetic.chance(2)) {\n                c.needsRedraw = true;\n            }\n        });\n        map.needsRedraw = true;\n    }\n    _mousemove(ev) {\n        super._mousemove(ev);\n        if (!this.bounds.contains(ev.x, ev.y)) {\n            this.clearPath();\n            return;\n        }\n        if (!this.player)\n            return;\n        const map = this.player.map;\n        if (!map)\n            return;\n        this.showPath(this.toInnerX(ev.x), this.toInnerY(ev.y));\n    }\n    _click(ev) {\n        super._click(ev);\n        if (!this.player)\n            return;\n        if (this.player.hasGoal()) {\n            this.player.clearGoal();\n        }\n        else {\n            this.player.setGoal(this.toInnerX(ev.x), this.toInnerY(ev.y));\n        }\n    }\n    clearPath() {\n        if (!this.player)\n            return;\n        const map = this.player.map;\n        if (!map)\n            return;\n        map.clearPath();\n    }\n    showPath(x, y) {\n        if (!this.player)\n            return false;\n        const map = this.player.map;\n        if (!map)\n            return false;\n        // if (!this.player.hasGoal()) return false;\n        // console.log('mouse', ev.x, ev.y);\n        const path = this.player.pathTo(x, y);\n        if (path) {\n            map.highlightPath(path, true);\n        }\n        else {\n            map.clearPath();\n        }\n        map.highlightCell(x, y);\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nGWU.app.defaultStyle.add('msgs', { bg: 'darkest_gray', fg: 'white' });\nGWU.app.defaultStyle.add('archive', { bg: 'darkest_gray', fg: 'white' });\nexport class Messages extends GWU.widget.Widget {\n    constructor(opts) {\n        super((() => {\n            opts.tag = opts.tag || 'msgs';\n            return opts;\n        })());\n        if (!this.bounds.height)\n            throw new Error('Must provde a height for messages widget.');\n        this.cache = new GWU.message.MessageCache({\n            width: this.bounds.width,\n            length: opts.archive || 40,\n            match: () => {\n                this.needsDraw = true;\n            },\n        });\n        this.on('click', () => {\n            this.showArchive();\n        });\n    }\n    clear() {\n        this.cache.clear();\n        this.needsDraw = true;\n    }\n    confirmAll() {\n        this.cache.confirmAll();\n        this.needsDraw = true;\n    }\n    draw(buffer) {\n        const isOnTop = this.bounds.y < 10;\n        const bg = this._used.bg;\n        const fg = this._used.fg;\n        // black out the message area\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', bg, bg);\n        this.cache.forEach((line, confirmed, i) => {\n            if (i >= this.bounds.height)\n                return;\n            const localY = isOnTop ? this.bounds.height - i - 1 : i;\n            const y = localY + this.bounds.y;\n            buffer.drawText(this.bounds.x, y, line, fg);\n            if (confirmed && bg) {\n                buffer.mix(bg, 50, this.bounds.x, y, this.bounds.width, 1);\n            }\n        });\n        return true;\n    }\n    showArchive() {\n        if (this.cache.length <= this.bounds.height)\n            return;\n        if (!this.scene)\n            return;\n        const app = this.scene.app;\n        app.scenes.run('msg-archive', this);\n    }\n}\nexport const ArchiveScene = {\n    create() { },\n    start(source) {\n        new ArchiveWidget({\n            scene: this,\n            source,\n            id: 'ARCHIVE',\n        });\n    },\n    stop() {\n        this.children.forEach((c) => c.destroy());\n        this.children = [];\n    },\n    destroy() { },\n};\nGWU.app.installScene('msg-archive', ArchiveScene);\nexport class ArchiveWidget extends GWU.widget.Widget {\n    constructor(opts) {\n        super({\n            scene: opts.scene,\n            id: opts.id || 'ARCHIVE',\n            tag: opts.tag || 'archive',\n            x: 0,\n            y: 0,\n            tabStop: true,\n            // depth: 100, // I'm on top\n        });\n        this.mode = 'forward';\n        this._timeout = null;\n        this._needsDraw = true;\n        this.source = opts.source;\n        this.isOnTop = this.source.bounds.y < 10;\n        this.bounds.height = this.isOnTop\n            ? this.scene.height - this.source.bounds.y\n            : this.source.bounds.bottom;\n        this.totalCount = Math.min(this.source.cache.length, this.isOnTop\n            ? this.scene.height - this.source.bounds.top\n            : this.source.bounds.bottom);\n        this.shown = this.source.bounds.height;\n        this._timeout = this.scene.wait(16, () => this._forward());\n        // confirm them as they are right now...\n        this.source.cache.confirmAll();\n        this.on('keypress', () => this._next());\n        this.on('click', () => this._next());\n    }\n    set needsDraw(v) {\n        this._needsDraw || (this._needsDraw = v);\n        super.needsDraw = v;\n    }\n    contains() {\n        return true; // Eat all mouse activity\n    }\n    finish() {\n        this.scene.stop();\n    }\n    _next() {\n        if (!this.scene)\n            return;\n        if (this.mode === 'ack') {\n            this.mode = 'reverse';\n            this.scene.needsDraw = true;\n            if (this._timeout) {\n                this._timeout();\n            }\n            this._timeout = this.scene.wait(16, () => this._reverse());\n        }\n        else if (this.mode === 'reverse') {\n            this.finish();\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n            if (this._timeout) {\n                this._timeout();\n                this._timeout = null;\n            }\n            this.scene.needsDraw = true;\n        }\n    }\n    _forward() {\n        // console.log('forward');\n        if (!this.scene)\n            return;\n        ++this.shown;\n        this._timeout = null;\n        this.scene.needsDraw = true;\n        if (this.shown < this.totalCount) {\n            this._timeout = this.scene.wait(16, () => this._forward());\n        }\n        else {\n            this.mode = 'ack';\n            this.shown = this.totalCount;\n        }\n    }\n    _reverse() {\n        // console.log('reverse');\n        if (!this.scene)\n            return;\n        --this.shown;\n        this._timeout = null;\n        if (this.shown <= this.source.bounds.height) {\n            this.finish();\n        }\n        else {\n            this.scene.needsDraw = true;\n            this._timeout = this.scene.wait(16, () => this._reverse());\n        }\n    }\n    _draw(buffer) {\n        let fadePercent = 0;\n        // let reverse = this.mode === 'reverse';\n        if (!this._needsDraw)\n            return;\n        this._needsDraw = false;\n        // Count the number of lines in the archive.\n        // let totalMessageCount = this.totalCount;\n        const isOnTop = this.isOnTop;\n        const dbuf = buffer;\n        const fg = GWU.color.from(this._used.fg);\n        // const dM = reverse ? -1 : 1;\n        // const startM = reverse ? totalMessageCount : this.bounds.height;\n        // const endM = reverse\n        //     ? this.bounds.height + dM + 1\n        //     : totalMessageCount + dM;\n        const startY = isOnTop\n            ? this.shown - 1\n            : this.bounds.bottom - this.shown;\n        const endY = isOnTop ? 0 : this.bounds.bottom - 1;\n        const dy = isOnTop ? -1 : 1;\n        dbuf.fillRect(this.source.bounds.x, Math.min(startY, endY), this.bounds.width, this.shown, ' ', this._used.bg, this._used.bg);\n        this.source.cache.forEach((line, _confirmed, j) => {\n            const y = startY + j * dy;\n            if (isOnTop) {\n                if (y < endY)\n                    return;\n            }\n            else if (y > endY)\n                return;\n            fadePercent = Math.floor((50 * j) / this.shown);\n            const fgColor = fg.mix(this._used.bg, fadePercent);\n            dbuf.drawText(this.source.bounds.x, y, line, fgColor, this._used.bg);\n        });\n        if (this.mode === 'ack') {\n            const y = this.isOnTop ? 0 : dbuf.height - 1;\n            const x = this.source.bounds.x > 8\n                ? this.source.bounds.x - 8 // to left of box\n                : Math.min(this.source.bounds.x + this.bounds.width, // just to right of box\n                dbuf.width - 8 // But definitely on the screen - overwrite some text if necessary\n                );\n            dbuf.wrapText(x, y, 8, '--DONE--', this._used.bg, this._used.fg);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as Tile from '../tile/tile';\nGWU.color.install('flavorText', 50, 40, 90);\nGWU.color.install('flavorPrompt', 100, 90, 20);\nexport class Flavor extends GWU.widget.Text {\n    constructor(opts) {\n        super((() => {\n            opts.tag = opts.tag || 'flavor';\n            return opts;\n        })());\n        this._needsDraw = true;\n        this.overflow = opts.overflow || false;\n    }\n    showText(text) {\n        this.text(text);\n        this.removeClass('prompt');\n        this.needsDraw = true;\n        return this;\n    }\n    clear() {\n        this.text('');\n        this.removeClass('prompt');\n        this.needsDraw = true;\n        return this;\n    }\n    showPrompt(text) {\n        this.text(text);\n        this.addClass('prompt');\n        this.needsDraw = true;\n        return this;\n    }\n    getFlavorText(map, x, y, fov) {\n        const cell = map.cell(x, y); // KNOWLEDGE / MEMORY !!!\n        let buf;\n        // let magicItem;\n        // let standsInTerrain;\n        // let subjectMoving;\n        // let prepositionLocked = false;\n        // let subject;\n        // let verb;\n        // let preposition;\n        let object = '';\n        // let adjective;\n        const isAnyKindOfVisible = fov ? fov.isAnyKindOfVisible(x, y) : true;\n        const isDirectlyVisible = fov ? fov.isDirectlyVisible(x, y) : true;\n        const isRemembered = fov ? fov.isRevealed(x, y) : false;\n        const isMapped = fov ? fov.isMagicMapped(x, y) : false;\n        let intro;\n        if (isDirectlyVisible) {\n            intro = 'You see';\n        }\n        else if (isAnyKindOfVisible) {\n            intro = 'You sense';\n        }\n        else if (isRemembered) {\n            intro = 'You remember seeing';\n        }\n        else if (isMapped) {\n            intro = 'You expect to see';\n        }\n        else {\n            return '';\n        }\n        const actor = cell.hasActor() ? map.actorAt(x, y) : null;\n        // const player = actor?.isPlayer() ? actor : null;\n        const theItem = cell.hasItem() ? map.itemAt(x, y) : null;\n        const standsInTile = cell.hasTileFlag(Flags.Tile.T_STAND_IN_TILE);\n        let needObjectArticle = false;\n        if (actor) {\n            object = actor.getFlavor({\n                color: false,\n                article: true,\n                action: true,\n            });\n            needObjectArticle = true;\n        }\n        else if (theItem) {\n            object = theItem.getFlavor({ color: false, article: true });\n            needObjectArticle = true;\n        }\n        let article = standsInTile ? ' in ' : ' on ';\n        const groundTile = cell.depthTile(Flags.Depth.GROUND) || Tile.NULL;\n        const surfaceTile = cell.depthTile(Flags.Depth.SURFACE);\n        const liquidTile = cell.depthTile(Flags.Depth.LIQUID);\n        // const gasTile = cell.depthTile(Flags.Depth.GAS);\n        let surface = '';\n        if (surfaceTile) {\n            const tile = surfaceTile;\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' on ';\n            }\n            if (tile.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n                article = ' over ';\n            }\n            surface = surfaceTile.getFlavor() + article;\n        }\n        let liquid = '';\n        if (liquidTile) {\n            liquid = liquidTile.getFlavor() + ' covering ';\n            if (needObjectArticle) {\n                needObjectArticle = false;\n                object += ' in ';\n            }\n        }\n        if (needObjectArticle) {\n            needObjectArticle = false;\n            object += ' on ';\n        }\n        let ground = groundTile.getFlavor({ article: true });\n        buf = GWU.text.apply('{{intro}} {{text}}.', {\n            intro,\n            text: object + surface + liquid + ground,\n        });\n        return buf;\n    }\n    _draw(buffer) {\n        if (!this._needsDraw)\n            return;\n        this._needsDraw = false;\n        super._draw(buffer);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\n// import { UISubject } from './viewport';\nGWU.color.install('blueBar', 15, 10, 50);\nGWU.color.install('redBar', 45, 10, 15);\nGWU.color.install('purpleBar', 50, 0, 50);\nGWU.color.install('greenBar', 10, 50, 10);\nexport class EntryBase {\n    constructor() {\n        this.dist = 0;\n        this.priority = 0;\n        this.sidebarY = -1;\n    }\n    draw(_buffer, _bounds) {\n        return 0;\n    }\n}\nexport class ActorEntry extends EntryBase {\n    constructor(actor) {\n        super();\n        this.actor = actor;\n    }\n    get x() {\n        return this.actor.x;\n    }\n    get y() {\n        return this.actor.y;\n    }\n    get changed() {\n        return this.actor.changed;\n    }\n    draw(buffer, bounds) {\n        return this.actor.drawSidebar(buffer, bounds);\n    }\n}\nexport class ItemEntry extends EntryBase {\n    constructor(item) {\n        super();\n        this.item = item;\n    }\n    get x() {\n        return this.item.x;\n    }\n    get y() {\n        return this.item.y;\n    }\n    get changed() {\n        return this.item.changed;\n    }\n    draw(buffer, bounds) {\n        return this.item.drawSidebar(buffer, bounds);\n    }\n}\nexport class CellEntry extends EntryBase {\n    constructor(cell) {\n        super();\n        this.changed = true;\n        this.cell = cell;\n    }\n    get x() {\n        return this.cell.x;\n    }\n    get y() {\n        return this.cell.y;\n    }\n    draw(buffer, bounds) {\n        return this.cell.drawSidebar(buffer, bounds);\n    }\n}\nexport class Sidebar extends GWU.widget.Widget {\n    constructor(opts) {\n        super((() => {\n            opts.tag = opts.tag || 'sidebar';\n            return opts;\n        })());\n        this.cellCache = [];\n        this.lastX = -1;\n        this.lastY = -1;\n        this.lastMap = null;\n        this.entries = [];\n        this.subject = null;\n        this.highlight = null;\n        this._needsDraw = true;\n    }\n    set needsDraw(v) {\n        if (v)\n            this._needsDraw = v;\n        super.needsDraw = v;\n    }\n    reset() {\n        this.lastMap = null;\n        this.lastX = -1;\n        this.lastY = -1;\n        this._needsDraw = true;\n    }\n    entryAt(e) {\n        return (this.entries.find((entry) => {\n            return entry.sidebarY <= e.y && entry.sidebarY !== -1;\n        }) || null);\n    }\n    click(ev) {\n        if (!this.bounds.contains(ev.x, ev.y))\n            return false;\n        if (!this.highlight)\n            return false;\n        if (!this.subject)\n            return false;\n        this.subject.setGoal(this.highlight.x, this.highlight.y);\n        return true;\n    }\n    mousemove(e) {\n        if (this.contains(e)) {\n            this._highlightRow(e.y);\n            return true;\n        }\n        this.clearHighlight();\n        return false;\n    }\n    highlightAt(x, y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.x == x && e.y == y) {\n                this.highlight = e;\n            }\n        });\n        const changed = this.highlight !== last;\n        this._needsDraw || (this._needsDraw = changed);\n        return changed;\n    }\n    _highlightRow(y) {\n        const last = this.highlight;\n        this.highlight = null;\n        // processed in ascending y order\n        this.entries.forEach((e) => {\n            if (e.sidebarY <= y && e.sidebarY !== -1) {\n                this.highlight = e;\n            }\n        });\n        const changed = this.highlight !== last;\n        this.needsDraw || (this.needsDraw = changed);\n        if (this.highlight && this.subject && this.subject.map) {\n            const path = this.subject.pathTo(\n            // @ts-ignore\n            this.highlight.x, \n            // @ts-ignore\n            this.highlight.y);\n            if (path) {\n                this.subject.map.highlightPath(path, true);\n            }\n            else {\n                // @ts-ignore\n                this.subject.map.showCursor(this.highlight.x, this.highlight.y);\n            }\n            // @ts-ignore\n            this.subject.map.highlightCell(this.highlight.x, this.highlight.y);\n        }\n        return changed;\n    }\n    clearHighlight() {\n        const result = !!this.highlight;\n        this.highlight = null;\n        this.needsDraw || (this.needsDraw = result);\n        return result;\n    }\n    _updateCellCache(map) {\n        if (this.lastMap &&\n            map === this.lastMap &&\n            !map.hasMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            return false;\n        }\n        this.lastMap = null; // Force us to regather the entries, even if at same location\n        this.cellCache.length = 0;\n        GWU.xy.forRect(map.width, map.height, (x, y) => {\n            const info = map.cell(x, y);\n            if (info.hasTileFlag(Flags.Tile.T_LIST_IN_SIDEBAR)) {\n                this.cellCache.push(info);\n            }\n        });\n        map.clearMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        this.needsDraw = true;\n        return true;\n    }\n    _makeActorEntry(actor) {\n        return new ActorEntry(actor);\n    }\n    _makeItemEntry(item) {\n        return new ItemEntry(item);\n    }\n    _makeCellEntry(cell) {\n        return new CellEntry(cell);\n    }\n    _getPriority(map, x, y, fov) {\n        if (!fov) {\n            return map.cell(x, y).hasCellFlag(Flags.Cell.STABLE_MEMORY) ? 3 : 1;\n        }\n        if (fov.isDirectlyVisible(x, y)) {\n            return 1;\n        }\n        else if (fov.isAnyKindOfVisible(x, y)) {\n            return 2;\n        }\n        else if (fov.isRevealed(x, y)) {\n            if (map.cell(x, y).hasEntityFlag(Flags.Entity.L_BRIGHT_MEMORY)) {\n                return 3;\n            }\n            else {\n                return 4;\n            }\n        }\n        return -1; // not visible, or revealed\n    }\n    _isDim(entry) {\n        if (entry === this.highlight)\n            return false;\n        if (!!this.highlight)\n            return true;\n        return entry.priority > 3;\n    }\n    _addActorEntry(actor, map, x, y, fov) {\n        const priority = this._getPriority(map, actor.x, actor.y, fov);\n        if (priority < 0 || priority > 3)\n            return false;\n        if (actor.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR))\n            return false;\n        const entry = this._makeActorEntry(actor);\n        entry.dist = GWU.xy.distanceBetween(x, y, actor.x, actor.y);\n        entry.priority = actor.isPlayer() ? 0 : priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addItemEntry(item, map, x, y, fov) {\n        const priority = this._getPriority(map, item.x, item.y, fov);\n        if (priority < 0)\n            return false;\n        if (item.hasEntityFlag(Flags.Entity.L_NO_SIDEBAR))\n            return false;\n        const entry = this._makeItemEntry(item);\n        entry.dist = GWU.xy.distanceBetween(x, y, item.x, item.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _addCellEntry(cell, map, x, y, fov) {\n        const priority = this._getPriority(map, cell.x, cell.y, fov);\n        if (priority < 0)\n            return false;\n        const entry = this._makeCellEntry(cell);\n        entry.dist = GWU.xy.distanceBetween(x, y, cell.x, cell.y);\n        entry.priority = priority;\n        this.entries.push(entry);\n        return true;\n    }\n    _updateEntryCache(map, cx, cy, fov) {\n        if (map === this.lastMap &&\n            cx === this.lastX &&\n            cy === this.lastY &&\n            !map.hasMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED |\n                Flags.Map.MAP_SIDEBAR_TILES_CHANGED)) {\n            let anyChanged = this.entries.some((e) => e.changed);\n            if (!anyChanged)\n                return false;\n        }\n        map.clearMapFlag(Flags.Map.MAP_SIDEBAR_CHANGED);\n        const highlightX = this.highlight ? this.highlight.x : -1;\n        const highlightY = this.highlight ? this.highlight.y : -1;\n        this.clearHighlight(); // If we are moving around the map, then turn off the highlight\n        this.lastMap = map;\n        this.lastX = cx;\n        this.lastY = cy;\n        this.entries.length = 0;\n        const done = GWU.grid.alloc(map.width, map.height);\n        map.eachActor((a) => {\n            const x = a.x;\n            const y = a.y;\n            if (!done[x][y] && this._addActorEntry(a, map, cx, cy, fov)) {\n                done[x][y] = 1;\n                a.setEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n            else {\n                a.clearEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n        });\n        map.eachItem((i) => {\n            const x = i.x;\n            const y = i.y;\n            if (!done[x][y] && this._addItemEntry(i, map, cx, cy, fov)) {\n                i.setEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n                done[x][y] = 1;\n            }\n            else {\n                i.clearEntityFlag(Flags.Entity.L_IN_SIDEBAR);\n            }\n        });\n        this.cellCache.forEach((c) => {\n            if (done[c.x][c.y])\n                return;\n            if (this._addCellEntry(c, map, cx, cy, fov)) {\n                done[c.x][c.y] = 1;\n            }\n        });\n        this.entries.sort((a, b) => {\n            if (a.priority != b.priority) {\n                return a.priority - b.priority;\n            }\n            return a.dist - b.dist;\n        });\n        if (highlightX > -1) {\n            this.highlightAt(highlightX, highlightY);\n        }\n        GWU.grid.free(done);\n        return true;\n    }\n    update() {\n        if (!this.subject) {\n            return false;\n        }\n        return this.updateFor(this.subject);\n    }\n    updateFor(subject) {\n        if (!subject.map)\n            return false;\n        return this.updateAt(subject.map, subject.x, subject.y, subject.map.fov);\n    }\n    updateAt(map, cx, cy, fov) {\n        let changed = this._updateCellCache(map);\n        if (this._updateEntryCache(map, cx, cy, fov)) {\n            changed = true;\n        }\n        return changed;\n    }\n    draw(buffer) {\n        var _a;\n        const map = (_a = this.subject) === null || _a === void 0 ? void 0 : _a.map;\n        if (!map)\n            return false;\n        if (this.update()) {\n            this.needsDraw = true;\n        }\n        if (!this.needsDraw)\n            return false;\n        this.needsDraw = false;\n        const bg = this._used.bg || GWU.color.BLACK;\n        buffer.fillRect(this.bounds.x, this.bounds.y, this.bounds.width, this.bounds.height, ' ', bg, bg);\n        // clear the row information\n        this.entries.forEach((e) => (e.sidebarY = -1));\n        const drawBounds = this.bounds.clone();\n        let currentEntry;\n        for (let i = 0; i < this.entries.length && drawBounds.height > 0; ++i) {\n            currentEntry = this.entries[i];\n            currentEntry.sidebarY = drawBounds.y;\n            let usedLines = currentEntry.draw(buffer, drawBounds);\n            if (this._isDim(currentEntry)) {\n                buffer.mix(bg, 50, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            else if (this.highlight === currentEntry) {\n                buffer.mix('white', 20, drawBounds.x, drawBounds.y, drawBounds.width, usedLines);\n            }\n            if (usedLines) {\n                ++usedLines; // skip a space\n                drawBounds.y += usedLines;\n                drawBounds.height -= usedLines;\n            }\n        }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Viewport from './viewport';\nimport * as Message from './message';\nimport * as Flavor from './flavor';\nimport * as Sidebar from './sidebar';\nexport class Game extends GWU.app.Scene {\n    constructor(id, app) {\n        super(id, app);\n        this.result = undefined;\n        this.mouse = false;\n        this.fov = false;\n        this.scent = false;\n        this.running = false;\n        this.keymap = {};\n    }\n    get width() {\n        return this.viewport.bounds.width;\n    }\n    get height() {\n        return this.viewport.bounds.height;\n    }\n    _initMenu(_opts) { }\n    _initSidebar(opts) {\n        if (typeof opts.sidebar === 'number') {\n            opts.sidebar = { width: opts.sidebar };\n        }\n        else if (opts.sidebar === true) {\n            opts.sidebar = {};\n        }\n        else if (!opts.sidebar) {\n            return;\n        }\n        const sideOpts = opts.sidebar;\n        sideOpts.width = sideOpts.width || -20; // on right side\n        const viewInit = opts.viewport;\n        if (sideOpts.width < 0) {\n            sideOpts.width *= -1;\n            sideOpts.x = viewInit.x + viewInit.width - sideOpts.width;\n            sideOpts.y = viewInit.y;\n            sideOpts.height = viewInit.height;\n            viewInit.width -= sideOpts.width;\n        }\n        else {\n            sideOpts.x = 0;\n            sideOpts.height = viewInit.height;\n            sideOpts.y = viewInit.y;\n            viewInit.x = sideOpts.width;\n            viewInit.width -= sideOpts.width;\n        }\n        sideOpts.scene = this;\n        this.sidebar = new Sidebar.Sidebar(sideOpts);\n    }\n    _initMessages(opts) {\n        if (opts.messages === false)\n            return;\n        if (opts.messages === true) {\n            opts.messages = { archive: -4 };\n        }\n        else if (typeof opts.messages === 'number') {\n            opts.messages = { archive: opts.messages };\n        }\n        const messOpts = opts.messages || { archive: -4 };\n        messOpts.archive = messOpts.archive || messOpts.y || -4;\n        if (messOpts.archive < 0) {\n            // bottom\n            const viewInit = opts.viewport;\n            messOpts.x = viewInit.x;\n            messOpts.y = this.height + messOpts.archive; // length < 0\n            messOpts.width = viewInit.width;\n            messOpts.height = -messOpts.archive;\n            viewInit.height -= messOpts.height;\n        }\n        else {\n            // top\n            const viewInit = opts.viewport;\n            messOpts.x = viewInit.x;\n            messOpts.y = viewInit.y;\n            messOpts.width = viewInit.width;\n            messOpts.height = messOpts.archive;\n            viewInit.y += messOpts.archive;\n            viewInit.height -= messOpts.archive;\n        }\n        messOpts.scene = this;\n        this.messages = new Message.Messages(messOpts);\n    }\n    _initFlavor(opts) {\n        if (opts.flavor === false)\n            return;\n        if (opts.flavor === true) {\n            opts.flavor = {};\n        }\n        const flavOpts = opts.flavor || {};\n        const viewOpts = opts.viewport;\n        const y = viewOpts.y || 0;\n        if (y === 0) {\n            // messages must be on bottom (or not there)\n            flavOpts.x = viewOpts.x || 0;\n            flavOpts.y = viewOpts.height - 1;\n            flavOpts.width = viewOpts.width;\n            viewOpts.height -= 1;\n        }\n        else {\n            // messages on top\n            flavOpts.x = viewOpts.x;\n            flavOpts.y = viewOpts.y;\n            flavOpts.width = viewOpts.width;\n            viewOpts.y += 1;\n            viewOpts.height -= 1;\n        }\n        flavOpts.scene = this;\n        this.flavor = new Flavor.Flavor(flavOpts);\n    }\n    _initViewport(opts) {\n        if (opts.viewport === true) {\n            opts.viewport = {};\n        }\n        const viewOpts = (opts.viewport || {});\n        viewOpts.lock = true;\n        this.viewport = new Viewport.Viewport(viewOpts);\n    }\n    create(opts) {\n        super.create(opts);\n        if (!opts.makeMap || !opts.makePlayer) {\n            throw new Error('Need funcitons for makeMap and makePlayer');\n        }\n        this._makeMap = opts.makeMap;\n        this._makePlayer = opts.makePlayer;\n        this._startMap = opts.startMap || GWU.NOOP;\n        if (opts.keymap) {\n            Object.assign(this.keymap, opts.keymap);\n        }\n        if (opts.mouse) {\n            this.mouse = true;\n        }\n        if (typeof opts.messages === 'number') {\n            opts.messages = { archive: opts.messages };\n        }\n        if (opts.flavor === true) {\n            opts.flavor = {};\n        }\n        else if (opts.flavor === false) {\n            delete opts.flavor;\n        }\n        opts.viewport = (opts.viewport || {});\n        opts.viewport.x = 0;\n        opts.viewport.y = 0;\n        opts.viewport.width = this.width;\n        opts.viewport.height = this.height;\n        this._initMenu(opts);\n        if (opts.sidebar)\n            this._initSidebar(opts);\n        if (opts.messages)\n            this._initMessages(opts);\n        if (opts.flavor)\n            this._initFlavor(opts);\n        this._initViewport(opts);\n        this.scheduler = new GWU.scheduler.Scheduler();\n    }\n    start(opts = {}) {\n        if (this.messages)\n            this.messages.clear();\n        // move to create?\n        this.player = opts.player || this._makePlayer.call(this);\n        this.viewport.subject = this.player;\n        if (this.sidebar)\n            this.sidebar.subject = this.player;\n        const id = opts.map || 0;\n        this.startNewMap({ id });\n        this.scheduler.push(this.player, 0);\n        super.start(opts);\n    }\n    startNewMap(opts = { id: 0 }) {\n        this.scheduler.clear();\n        if (opts.id === undefined) {\n            opts.id = this.map.id;\n        }\n        this.map = this._makeMap.call(this, opts);\n        this.map.setPlayer(this.player);\n        this._startMap.call(this, this.map, this.player, opts);\n        // make sure player is on map\n        if (this.player.map !== this.map) {\n            // if not, add them (where?)\n            const loc = this.map.locations.start || [0, 0]; // Is top left fallback any good?\n            this.map.addActorNear(loc[0], loc[1], this.player);\n        }\n        if (this.scent) {\n            this.map.drawer.scent = this.scent;\n        }\n        this.map.actors.forEach((a) => {\n            if (!a.isPlayer()) {\n                this.scheduler.push(a, a.moveSpeed());\n            }\n        });\n        this.map.fov.update();\n        // this.draw();\n    }\n    // draw() {\n    //     this.viewport.draw(this.buffer);\n    //     if (this.messages) this.messages.draw(this.buffer);\n    //     if (this.flavor) this.flavor.draw(this.buffer);\n    //     if (this.sidebar) this.sidebar.draw(this.buffer);\n    //     if (this.buffer.changed) {\n    //         this.buffer.render();\n    //     }\n    //     this.buffer.changed = false;\n    //     this.map.actors.forEach((a) => (a.changed = false));\n    //     this.map.items.forEach((i) => (i.changed = false));\n    // }\n    // finish(result?: any) {\n    //     this.running = false;\n    //     this.layer.finish();\n    //     this.result = result;\n    // }\n    update(dt) {\n        super.update(dt);\n        if (this.tweens.length)\n            return;\n        let actor = this.scheduler.pop();\n        if (!actor) {\n            this.stop();\n            return;\n        }\n        let nextTime = 99;\n        while (nextTime > 0 && actor) {\n            nextTime = actor.act(this);\n            if (nextTime >= 0) {\n                this.scheduler.push(actor, nextTime);\n                actor = this.scheduler.pop();\n            }\n            // stop every time the player acts so we can draw the screen\n            if (actor === this.player) {\n                nextTime = 0;\n            }\n        }\n    }\n    // playerTurn(player: Player): number {\n    //     let done = 0;\n    //     const timer = setInterval(() => {\n    //         const tick = GWU.app.makeTickEvent(16);\n    //         // console.log('-tick', Date.now());\n    //         this.io.enqueue(tick);\n    //     }, 16);\n    //     let elapsed = 0;\n    //     while (!done && this.running) {\n    //         const ev = await this.io.nextEvent(-1);\n    //         if (ev) {\n    //             if (ev.type === GWU.app.KEYPRESS) {\n    //             }\n    //         }\n    //         if (elapsed < 50) {\n    //             continue;\n    //         }\n    //         elapsed -= 50;\n    //     }\n    //     clearInterval(timer);\n    //     return done;\n    // }\n    input(ev) {\n        super.input(ev);\n        if (ev.defaultPrevented || ev.propagationStopped)\n            return;\n        if (ev.type === GWU.app.MOUSEMOVE) {\n            this.mousemove(ev);\n        }\n        else if (ev.type === GWU.app.CLICK) {\n            this.click(ev);\n        }\n        else if (ev.type === GWU.app.KEYPRESS) {\n            this.keypress(ev);\n        }\n    }\n    mousemove(ev) {\n        if (this.viewport.contains(ev)) {\n            const x = this.viewport.toInnerX(ev.x);\n            const y = this.viewport.toInnerY(ev.y);\n            if (this.flavor) {\n                const text = this.flavor.getFlavorText(this.map, x, y, this.map.fov);\n                this.flavor.showText(text);\n            }\n            if (this.sidebar) {\n                this.sidebar.highlightAt(x, y);\n            }\n        }\n    }\n    click(_ev) { }\n    keypress(ev) {\n        this.map.clearPath();\n        if (this.player.hasGoal()) {\n            this.player.clearGoal();\n        }\n        else {\n            const action = this._actionFor(this.keymap, ev);\n            if (action) {\n                this.player.setAction(action);\n            }\n        }\n    }\n    _actionFor(keymap, ev) {\n        if (ev.dir && keymap.dir)\n            return keymap.dir;\n        return (keymap[ev.key] ||\n            keymap[ev.code] ||\n            keymap.keypress ||\n            keymap.default ||\n            null);\n    }\n}\nGWU.app.installScene('game', (id, app) => new Game(id, app));\n","import * as GWU from 'gw-utils';\nimport * as Tile from './tile';\nimport '../effects';\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([30, 30, 30]).rand(20, 0, 0, 0),\n    bg: GWU.color.from([2, 2, 10]).rand(0, 2, 2, 0),\n    priority: 10,\n    article: 'the',\n    flavor: 'the stone floor',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    actions: {\n        enter: 'TILE:DOOR_OPEN',\n        open: 'TILE:DOOR_OPEN_ALWAYS',\n    },\n    flavor: 'a closed door',\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    actions: {\n        tick: {\n            chance: 100 * 100,\n            tile: 'DOOR~!',\n        },\n        enter: null,\n        open: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    actions: {\n        tick: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('UP_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, T_LIST_IN_SIDEBAR',\n    name: 'upward stairs',\n    article: 'an',\n    actions: {\n        climb(action) {\n            if (!action.actor)\n                return action.didNothing();\n            if (!action.actor.isPlayer())\n                return action.didNothing();\n            action.game.startNewMap({ up: true });\n            return action.actor.endTurn();\n        },\n    },\n    flavor: 'stairs leading upwards',\n});\nTile.install('DOWN_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, T_LIST_IN_SIDEBAR',\n    name: 'downward stairs',\n    article: 'a',\n    actions: {\n        descend(action) {\n            if (!action.actor)\n                return action.didNothing();\n            if (!action.actor.isPlayer())\n                return action.didNothing();\n            action.game.startNewMap({ down: true });\n            return action.actor.endTurn();\n        },\n    },\n    flavor: 'downward leading stairs',\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'a very hard wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: GWU.color.from([25, 28, 60]).dance(20, 0, 4, 15),\n    bg: GWU.color.from([10, 15, 41]).dance(20, 5, 5, 5),\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n    flavor: 'some deep water',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([5, 8, 10]).dance(10, 0, 4, 15),\n    bg: GWU.color.from([10, 30, 30]).dance(6, 0, 10, 10),\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    flags: 'T_SHALLOW_WATER',\n    // depth: 'LIQUID', // 'SURFACE'?\n    flavor: 'some shallow water',\n});\nTile.install('BRIDGE', {\n    ch: '\\u2630',\n    fg: [80, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n    flavor: 'a bridge',\n});\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","T_IS_DEEP_LIQUID","T_SHALLOW_WATER","TileMech","Cell","NEEDS_REDRAW","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_SAFE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Horde","KeyInfo","[object Object]","x","y","disposable","this","Action","action","opts","actor","item","target","dir","aware","identified","machine","try","force","good","seen","quiet","ok","failed","done","logged","visible","data","map","game","undefined","originX","originY","key","Actions","ctx","_handlers","onUnhandled","_ctx","other","Object","entries","forEach","ev","fns","Array","isArray","slice","events","some","e","fn","cleanup","on","c","cb","handlers","info","unshift","arrayNullify","obj","cfg","once","off","current","findIndex","i","length","trigger","Error","didSomething","name","isDone","_unhandled","call","filter","keys","global","install","doAction","canDoAction","fail","defaultAction","_action","lastId","kind","_map","machineHome","changed","actions","ACTION.Actions","_actions","depth","light","flags","entity","next","id","hasEntityFlag","Flags.Entity","L_ALWAYS_PLURAL","setEntityFlag","L_ON_MAP","addToMap","clearEntityFlag","removeFromMap","sprite","isDestroyed","L_DESTROYED","constructor","copy","assign","canBeSeen","tag","tags","includes","matches","cell","forbidsCell","avoidsCell","getName","getDescription","getFlavor","verb","getVerb","buffer","bounds","drawSidebar","dest","_observer","drawSprite","v","has","ACTION.Action","default","sidebarFg","EntityKind","config","requireTileFlags","forbidTileFlags","avoidTileFlags","requireTileTags","forbidTileTags","avoidTileTags","flavor","description","make","split","t","trim","from","Flags.Tile","color","value","init","_entity","hasAllTileFlags","hasTileFlag","T_BRIDGE","hasAllTileTags","hasAnyTileTag","_opts","mixer","Mixer","getAppearanceAt","wrapText","width","a","makeOpts","Status","_set","_time","_count","_done","_value","clearTime","clearCount","setOff","_update","count","Math","max","_addDone","range","delta","status","cleared","noticed","removeTime","rec","was","doneFn","Stats","_max","_rate","round","get","set","amount","allowOver","min","raiseValue","gain","lowerValue","drain","turns","r","elapsed","type","Entity.Entity","super","ai","_turnTime","leader","items","visionDistance","_costMap","_goalMap","_mapToMe","Flags.Depth","ACTOR","stats","grid","free","hasActorFlag","Flags.Actor","IS_PLAYER","bump","IS_VISIBLE","WAS_VISIBLE","canSee","isAbleToSee","isPlayer","fov","isDirectlyVisible","xy","distanceBetween","forLineBetween","j","blocksVision","canSeeOrSense","isAbleToSense","isAnyKindOfVisible","startedVisible","player","setActorFlag","clearActorFlag","becameVisible","interrupt","ACTION.doAction","moveSpeed","pct","L_NO_SIDEBAR","L_IN_SIDEBAR","setMapFlag","Flags.Map","MAP_SIDEBAR_CHANGED","floor","_other","_item","pickupItem","dropItem","mapChanged","STABLE_COST_MAP","staleMap","alloc","height","update","_v","cellCost","goalMap","path","calculateDistances","costMap","installHandler","handler","toLowerCase","NOOP","parts","shift","steps","step","makeArray","s","installed","effect","effects","values","_a","_b","_c","_d","index","dissipate","priority","groundTile","article","tile","tileMech","hasAction","T_IS_FLAMMABLE","push","arraysIntersect","every","blocksMove","T_PATHING_BLOCKER","EFFECT.make","NULL","hasAllEntityFlags","T_IS_DOOR","L_BLOCKS_EVERYTHING","isNull","isWall","arg","result","fg","toString","options","_e","_f","base","extends","tiles","text","replace","search","Number","parseInt","substring","Flags.TileMech","ch","bg","opacity","all","args","NEVER_SEEN","TILE.NULL","chokeCount","machineId","memory","Flags.Cell","TILE.tiles","snapshot","makeMixer","TILE.get","setTile","src","hasStableSnapshot","hasCellFlag","STABLE_SNAPSHOT","hasStableMemory","setCellFlag","reduce","out","clone","hasItem","hasActor","clearCellFlag","needsRedraw","getSnapshot","checkEntities","entityFlags","tileFlags","tileMechFlags","hasTag","hasAllTags","hasAnyTag","withEntities","CHANGED","TILE.Tile","highestPriorityTile","find","blocksPathing","blocksEffects","TILE.flags","T_BLOCKS_OTHER_LAYERS","L_SECRETLY_PASSABLE","T_ANY_LIQUID","superpriority","blocksLayer","blockedByItems","blockedByActors","blockedByOtherLayers","highestPriority","GROUND","currentGround","depthTile","wantGround","clearDepth","SURFACE","glowLightChanged","T_LIST_IN_SIDEBAR","MAP_SIDEBAR_TILES_CHANGED","CAUGHT_FIRE_THIS_TURN","blackOut","tileFlag","tileMechFlag","hasTileMechFlag","itemAt","hasItems","foundIndex","actorAt","_actor","actors","HAS_FX","fx","fxAt","_fx","quantity","ITEM","isPlural","messageYou","view","field","messageThe","messageA","L_FORMAL_NAME","char","firstChar","exec","messageVerb","_name","plural","toPluralVerb","toSingularVerb","addHelper","PainMessages","msgs","_msgs","m","add","msg","singular","clamp","_format","painMessages","ais","wander","loc","random","matchingLoc","NO_PATH","console","log","didNothing","setGoal","nextStep","canPass","clearGoal","typical","isDead","willAttack","damagePct","getPct","morale","chargeChance","lastSawPlayer","canAttack","attack","tooFarFrom","canMoveToward","chance","moveToward","tooCloseTo","hasGoal","moveTowardGoal","isSuccess","scent","nextDir","wanderOpt","object","firstOpt","distanceMap","center","eachNeighbor","canMoveAwayFrom","moveAwayFrom","endTurn","distanceFromTo","safetyMap","costGrid","FORBIDDEN","eachCell","AVOIDED","rescan","ActorKind","Entity.EntityKind","DEFAULT","DEFAULT_ACTOR","vision","normal","health","AI.make","waterOnly","lavaOnly","swim","fly","list","remove","OBSTRUCTION","OK","drawText","makeOptions","makeKind","kinds","randomKind","match","forbidTags","startsWith","k","rng","pain","JSON","stringify","made","ItemKind","Flags.Item","isDoor","isStairs","standStill","flashSprite","duration","Entity.make","addFx","tween","to","repeat","repeatDelay","onUpdate","removeFx","hit","fadeInOut","yoyo","onFinish","moveSprite","source","ceil","maxAxisFromTo","speed","isLoc","vals","stepFn","stopBeforeWalls","moveFx","stop","isInShape","shape","cx","cy","allowCenter","sx","abs","sy","dirFromTo","fade","stopAtWalls","line","forLineFromTo","hasXY","lastIndex","addChild","radius","checkExplosionOpts","FOV","isBlocked","calculate","x1","y1","minX","minY","maxX","maxY","bumpActions","getBumpActions","actionName","selfName","moveDir","newX","newY","currentCell","newCell","FX.hit","message","addAt","canRemoveActor","canAddActor","moveActor","rate","idle","dirIndex","number","DIRS","pickup","avoidsItem","canAddItem","removeItem","addItem","climb","startNewMap","up","activateMachine","activateMachineAction","bind","endsWith","parseFloat","chanceAction","clear","layers","ALL_LAYERS","clearAction","emit","emitAction","feature","featureAction","feat","Effect.installed","messageAction","nourish","nourishAction","adjust","n","pukeMsg","spread","grow","decrement","Flags.Effect","matchTile","EFFECT.makeArray","spreadAction","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","spawnMap","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","reset","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","first","floodFill","cellIsOk","isStart","EVENT_PROTECTED","E_BUILD_IN_WALLS","E_MUST_TOUCH_WALLS","E_NO_TOUCH_WALLS","hasTile","x2","y2","madeChange","startProb","probDec","fill","clearAll","GAS","LIQUID","blockingMap","eachActor","matchingLocNear","removeActor","addActor","eachItem","stat","statAction","tileAction","MapLayer","properties","_x","_y","_tile","_dt","TileLayer","GasLayer","volume","startingVolume","d","clearTile","total","highestVolume","startingTile","highestTile","updateCellVolume","ObjectFlags","TileFlags","TileMechFlags","CellFlags","FireLayer","exposeToFire","alwaysIgnite","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","TM_EXPLOSIVE_PROMOTE","x0","y0","event","highlightColor","BasicDrawer","Buffer","offsetX","offsetY","clearMapFlag","MAP_DANCES","drawCell","needSnapshot","getAppearance","putSnapshot","COLORS_DANCE","applyLight","separate","L_VISUALLY_DISTINCT","IS_CURSOR","inverse","IS_HIGHLIGHTED","mix","colors","red","ground","surface","liquid","gas","drawInto","cosmetic","hasFx","dances","bake","isVisible","isRevealed","getLight","multiply","isCursor","invert","L_BRIGHT_MEMORY","scale","locations","_tweens","app","Tweens","seed","machineCount","drawer","cells","LightSystem","alwaysVisible","callback","onFovChange","FovSystem","initLayers","setPlayer","load","addLayer","Layer.TileLayer","Layer.FireLayer","Layer.GasLayer","layer","isAt","fireEffects","_addItem","indexOf","_fireAddItemEffects","_removeItem","_fireRemoveItemEffects","arrayDelete","isKey","hasPlayer","_addActor","_fireAddActorEffects","_removeActor","_fireRemoveActorEffects","_addFx","updated","_removeFx","fmt","dump","hasMapFlag","MAP_NEEDS_REDRAW","markCursor","clearPath","clearCursor","l","boundary","isBoundaryXY","clearTiles","dt","fireAll","tick","willFire","EVENT_FIRED_THIS_TURN","promoteChance","w","eachGlowLight","_cb","FovFlags","PLAYER","isDark","storeMemory","clearMemory","makeVisible","updateChokepoints","updateCounts","passMap","passableArcCount","oldX","CLOCK_DIRS","oldY","cellCount","floodFillCount","i2","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","left","designationSurvives","Snapshot","version","isHallway","arcCount","isPassable","getCellPathCost","fillCostMap","h","updateChokeCounts","layerVersion","lightVersion","cellVersion","snap","srcCell","snapLayer","destCell","destLayer","srcLayer","eightWays","straightDistanceBetween","getPath","prefab","charToTile","isStringArray","len","members","horde","frequency","Flags","canSpawn","TRUE","_spawnLeader","_spawnMembers","leaderKind","Actor.get","Actor.make","_pickLeaderLoc","_addLeader","member","kindId","countRange","_spawnMember","_pickMemberLoc","_addMember","Map.isHallway","hordes","forbidFlags","oodChance","HORDE_NEVER_OOD","weights","weighted","Attributes","baseValues","_base","_bonus","_sustain","attributes","raiseMax","old","_calcValue","loss","lowerMax","bonus","_addBonus","_clearBonus","arr","o","splice","allAdjustments","adj","_applyAdjustment","sustain","fixed","restore","Skill","_bool","level","_int","disadvantage","advantage","b","_parent","succeed","_has","_level","_fixed","Skills","_skills","lastIndexOf","Scent","_player","_data","highest","v1","hasLiquid","highestLoc","Player","mapToPlayer","mapToMe","getClosestValidLocation","PlayerKind","Actor.ActorKind","Attributes.Attributes","skills","Skills.Skills","attr","defaults","Actor.kinds","Viewport","widget","Widget","_subject","Bounds","lock","lockX","lockY","subject","halfWidth","halfHeight","_attrBool","right","top","bottom","edgeX","edgeY","thirdW","thirdH","blackOutRect","updateOffset","mapX","mapY","draw","_mousemove","contains","showPath","toInnerX","toInnerY","_click","pathTo","highlightPath","highlightCell","defaultStyle","Messages","cache","MessageCache","archive","needsDraw","showArchive","confirmAll","isOnTop","_used","fillRect","confirmed","scene","scenes","run","ArchiveScene","ArchiveWidget","children","destroy","installScene","tabStop","mode","_timeout","_needsDraw","totalCount","shown","wait","_forward","_next","_reverse","finish","fadePercent","dbuf","endY","dy","_confirmed","fgColor","Flavor","Text","overflow","removeClass","addClass","buf","isRemembered","isMapped","isMagicMapped","intro","theItem","standsInTile","T_STAND_IN_TILE","needObjectArticle","Tile.NULL","surfaceTile","liquidTile","apply","_draw","EntryBase","dist","sidebarY","_buffer","_bounds","ActorEntry","ItemEntry","CellEntry","Sidebar","cellCache","lastX","lastY","lastMap","highlight","entry","_highlightRow","clearHighlight","last","showCursor","_getPriority","_makeActorEntry","_makeItemEntry","_makeCellEntry","highlightX","highlightY","_addActorEntry","_addItemEntry","_addCellEntry","sort","highlightAt","updateFor","updateAt","_updateCellCache","_updateEntryCache","BLACK","drawBounds","currentEntry","usedLines","_isDim","Game","Scene","mouse","running","keymap","viewport","sidebar","sideOpts","viewInit","Sidebar.Sidebar","messages","messOpts","Message.Messages","flavOpts","viewOpts","Flavor.Flavor","Viewport.Viewport","create","makeMap","makePlayer","_makeMap","_makePlayer","_startMap","startMap","_initMenu","_initSidebar","_initMessages","_initFlavor","_initViewport","scheduler","Scheduler","start","addActorNear","tweens","nextTime","act","input","defaultPrevented","propagationStopped","MOUSEMOVE","mousemove","CLICK","click","KEYPRESS","keypress","getFlavorText","showText","_ev","_actionFor","setAction","code","rand","enter","open","close","descend","down","dance"],"mappings":"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"}