{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/entity/key.js","../js/entity/kind.js","../js/entity/entity.js","../js/actor/actor.js","../js/actor/kind.js","../js/item/kind.js","../js/item/item.js","../js/effect/make.js","../js/effect/install.js","../js/effect/fire.js","../js/effect/handlers/emit.js","../js/effect/handlers/fn.js","../js/effect/handlers/message.js","../js/effect/handlers/activateMachine.js","../js/effect/handlers/effect.js","../js/effect/handlers/tile.js","../js/tile/tile.js","../js/tile/tiles.js","../js/tile/index.js","../js/layer/mapLayer.js","../js/layer/tileLayer.js","../js/layer/actorLayer.js","../js/layer/itemLayer.js","../js/layer/gasLayer.js","../js/layer/fireLayer.js","../js/map/cell.js","../js/map/cellMemory.js","../js/map/map.js","../js/map/analyze.js","../js/map/snapshot.js","../js/path.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_LIST_IN_SIDEBAR\"] = Fl(13)] = \"L_LIST_IN_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(0)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(1)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"KNOWN_TO_BE_TRAP_FREE\"] = Fl(2)] = \"KNOWN_TO_BE_TRAP_FREE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"LIGHT_CHANGED\"] = Fl(14)] = \"LIGHT_CHANGED\";\n    Cell[Cell[\"FOV_CHANGED\"] = Fl(15)] = \"FOV_CHANGED\";\n    // These are to help memory\n    Cell[Cell[\"HAS_SURFACE\"] = Fl(16)] = \"HAS_SURFACE\";\n    Cell[Cell[\"HAS_LIQUID\"] = Fl(17)] = \"HAS_LIQUID\";\n    Cell[Cell[\"HAS_GAS\"] = Fl(18)] = \"HAS_GAS\";\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(19)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(20)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(21)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(22)] = \"HAS_ITEM\";\n    Cell[Cell[\"IS_IN_PATH\"] = Fl(23)] = \"IS_IN_PATH\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(24)] = \"IS_CURSOR\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(25)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW | Cell.LIGHT_CHANGED | Cell.FOV_CHANGED] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_TRAP_FREE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW | Cell.LIGHT_CHANGED] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_SPREAD_CIRCLE\"] = Fl(13)] = \"E_SPREAD_CIRCLE\";\n    Effect[Effect[\"E_SPREAD_LINE\"] = Fl(14)] = \"E_SPREAD_LINE\";\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","import * as GWU from 'gw-utils';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n    }\n    forbidsCell(_item, _cell) {\n        return false;\n    }\n    getName(_item) {\n        return this.name;\n    }\n    getDescription(_item) {\n        return this.description;\n    }\n    getFlavor(_item) {\n        return this.flavor;\n    }\n    getVerb(_item, verb) {\n        return verb;\n    }\n}\n","import * as Flags from '../flags/entity';\nexport class Entity {\n    constructor(kind) {\n        this.key = null;\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(this, cell);\n    }\n    getName() {\n        return this.kind.getName(this);\n    }\n    getDescription() {\n        return this.kind.getDescription(this);\n    }\n    getFlavor() {\n        return this.kind.getFlavor(this);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n}\n","import * as Entity from '../entity';\nimport * as Flags from '../flags';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.next = null;\n        // @ts-ignore\n        this.flags = this.flags || {};\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    isVisible() {\n        return true;\n    }\n}\n","import * as Entity from '../entity';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n    }\n    make(_item, _options) { }\n    forbidsCell(_item, _cell) {\n        return false;\n    }\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import { Entity } from '../entity';\nimport { Depth } from '../flags';\nimport * as Kind from './kind';\nexport class Item extends Entity {\n    constructor(kind, options) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore\n        this.flags = this.flags || {};\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n        this.kind.make(this, options);\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n}\nexport function make(id, makeOptions) {\n    const kind = Kind.get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return new Item(kind, makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = Kind.randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return new Item(kind, makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = Kind.get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof Kind.ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = Kind.makeKind(info);\n    }\n    return new Item(kind, makeOptions);\n}\n","import * as GWU from 'gw-utils';\nimport { Effect as Flags } from '../flags';\nimport { handlers, effects } from './install';\nexport function make(opts) {\n    var _a;\n    if (!opts)\n        throw new Error('opts required to make effect.');\n    if (typeof opts === 'string') {\n        throw new Error('Cannot make effect from string: ' + opts);\n    }\n    if (typeof opts === 'function') {\n        opts = { fn: opts };\n    }\n    // now make base effect stuff\n    const info = {\n        flags: GWU.flag.from(Flags, opts.flags),\n        chance: (_a = opts.chance) !== null && _a !== void 0 ? _a : 0,\n        next: null,\n        id: opts.id || 'n/a',\n    };\n    if (opts.next) {\n        if (typeof opts.next === 'string') {\n            info.next = opts.next;\n        }\n        else {\n            info.next = make(opts.next);\n        }\n    }\n    // and all the handlers\n    Object.values(handlers).forEach((v) => v.make(opts, info));\n    return info;\n}\nexport function from(opts) {\n    if (!opts)\n        throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'string') {\n        const effect = effects[opts];\n        if (effect)\n            return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\n","import { Effect as Flags } from '../flags';\nimport { make } from './make';\n// resetMessageDisplayed\nexport function reset(effect) {\n    effect.flags &= ~Flags.E_FIRED;\n}\nexport function resetAll() {\n    Object.values(effects).forEach((e) => reset(e));\n}\nexport const effects = {};\nexport function install(id, config) {\n    const effect = make(config);\n    effects[id] = effect;\n    effect.id = id;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id] = handler;\n}\n","import * as GWU from 'gw-utils';\nimport { Effect as Flags } from '../flags';\nimport { handlers } from './install';\nimport { from } from './make';\nexport async function fire(effect, map, x, y, ctx_ = {}) {\n    if (!effect)\n        return false;\n    if (typeof effect === 'string') {\n        const name = effect;\n        effect = from(name);\n        if (!effect)\n            throw new Error('Failed to find effect: ' + name);\n    }\n    const ctx = ctx_;\n    if (!ctx.force && effect.chance && !map.rng.chance(effect.chance, 10000))\n        return false;\n    const grid = (ctx.grid = GWU.grid.alloc(map.width, map.height));\n    let didSomething = false;\n    const allHandlers = Object.values(handlers);\n    for (let h of allHandlers) {\n        if (await h.fire(effect, map, x, y, ctx)) {\n            didSomething = true;\n        }\n    }\n    // do the next effect - if applicable\n    if (effect.next &&\n        (didSomething || effect.flags & Flags.E_NEXT_ALWAYS) &&\n        !GWU.data.gameHasEnded) {\n        const nextInfo = typeof effect.next === 'string' ? from(effect.next) : effect.next;\n        if (effect.flags & Flags.E_NEXT_EVERYWHERE) {\n            await grid.forEachAsync(async (v, i, j) => {\n                if (!v)\n                    return;\n                didSomething =\n                    (await fire(nextInfo, map, i, j, ctx)) || didSomething;\n            });\n        }\n        else {\n            didSomething =\n                (await fire(nextInfo, map, x, y, ctx)) || didSomething;\n        }\n    }\n    // bookkeeping\n    if (didSomething &&\n        map.isVisible(x, y) &&\n        !(effect.flags & Flags.E_NO_MARK_FIRED)) {\n        effect.flags |= Flags.E_FIRED;\n    }\n    GWU.grid.free(grid);\n    return didSomething;\n}\nexport function fireSync(effect, map, x, y, ctx_ = {}) {\n    if (!effect)\n        return false;\n    if (typeof effect === 'string') {\n        const name = effect;\n        effect = from(name);\n        if (!effect)\n            throw new Error('Failed to find effect: ' + name);\n    }\n    const ctx = ctx_;\n    if (!ctx.force && effect.chance && !map.rng.chance(effect.chance, 10000))\n        return false;\n    const grid = (ctx.grid = GWU.grid.alloc(map.width, map.height));\n    let didSomething = false;\n    const allHandlers = Object.values(handlers);\n    for (let h of allHandlers) {\n        if (h.fireSync(effect, map, x, y, ctx)) {\n            didSomething = true;\n        }\n    }\n    // bookkeeping\n    if (didSomething &&\n        map.isVisible(x, y) &&\n        !(effect.flags & Flags.E_NO_MARK_FIRED)) {\n        effect.flags |= Flags.E_FIRED;\n    }\n    // do the next effect - if applicable\n    if (effect.next &&\n        (didSomething || effect.flags & Flags.E_NEXT_ALWAYS) &&\n        !GWU.data.gameHasEnded) {\n        const nextInfo = typeof effect.next === 'string' ? from(effect.next) : effect.next;\n        if (effect.flags & Flags.E_NEXT_EVERYWHERE) {\n            grid.forEach(async (v, i, j) => {\n                if (!v)\n                    return;\n                fireSync(nextInfo, map, i, j, ctx);\n            });\n        }\n        else {\n            fireSync(nextInfo, map, x, y, ctx);\n        }\n    }\n    GWU.grid.free(grid);\n    return didSomething;\n}\n","import * as GWU from 'gw-utils';\nimport * as EFFECT from '../install';\n//////////////////////////////////////////////\n// EMIT\nexport class EmitEffect {\n    make(src, dest) {\n        if (!src.emit)\n            return true;\n        if (typeof src.emit !== 'string') {\n            throw new Error('emit effects must be string name to emit: { emit: \"EVENT\" }');\n        }\n        dest.emit = src.emit;\n        return true;\n    }\n    async fire(config, _map, x, y, ctx) {\n        if (config.emit) {\n            await GWU.events.emit(config.emit, x, y, ctx);\n            return true;\n        }\n        return false;\n    }\n    fireSync(config, _map, _x, _y, _ctx) {\n        if (!config.emit)\n            return false;\n        throw new Error('Cannot use \"emit\" effects in build steps.');\n    }\n}\nEFFECT.installHandler('emit', new EmitEffect());\n","import * as EFFECT from '../install';\n//////////////////////////////////////////////\n// FN\nexport class FnEffect {\n    make(src, dest) {\n        if (!src.fn)\n            return true;\n        if (typeof src.fn !== 'function') {\n            throw new Error('fn effects must be functions.');\n        }\n        dest.fn = src.fn;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.fn) {\n            return await config.fn(config, map, x, y, ctx);\n        }\n        return false;\n    }\n    fireSync(config, map, x, y, ctx) {\n        if (config.fn) {\n            const result = config.fn(config, map, x, y, ctx);\n            if (result === true || result === false) {\n                return result;\n            }\n            throw new Error('Cannot use async function effects in build steps.');\n        }\n        return false;\n    }\n}\nEFFECT.installHandler('fn', new FnEffect());\n","import * as GWU from 'gw-utils';\nimport * as EFFECT from '../install';\nimport { Effect as Flags } from '../../flags';\n//////////////////////////////////////////////\n// MESSAGE\nexport class MessageEffect {\n    make(src, dest) {\n        if (!src.message)\n            return true;\n        if (typeof src.message !== 'string') {\n            throw new Error('Emit must be configured with name of event to emit');\n        }\n        dest.message = src.message;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (!config.message)\n            return false;\n        const fired = !!(config.flags & Flags.E_FIRED);\n        if (config.message &&\n            config.message.length &&\n            !fired &&\n            map.isVisible(x, y)) {\n            GWU.message.addAt(x, y, config.message, ctx);\n            return true;\n        }\n        return false;\n    }\n    fireSync(config, _map, _x, _y, _ctx) {\n        if (!config.message)\n            return false;\n        throw new Error('Cannot use \"message\" effects in build steps.');\n    }\n}\nEFFECT.installHandler('message', new MessageEffect());\n","import * as EFFECT from '../install';\n//////////////////////////////////////////////\n// ActivateMachine\nexport class ActivateMachineEffect {\n    make(src, dest) {\n        if (!src.activateMachine)\n            return true;\n        dest.activateMachine = true;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.activateMachine) {\n            const cell = map.cell(x, y);\n            const machine = cell.machineId;\n            if (!machine)\n                return false;\n            return await map.activateMachine(machine, x, y, ctx);\n        }\n        return false;\n    }\n    fireSync(config, map, x, y, ctx) {\n        if (config.activateMachine) {\n            const cell = map.cell(x, y);\n            const machine = cell.machineId;\n            if (!machine)\n                return false;\n            return map.activateMachineSync(machine, x, y, ctx);\n        }\n        return false;\n    }\n}\nEFFECT.installHandler('activateMachine', new ActivateMachineEffect());\n","import * as EFFECT from '../install';\nimport * as FIRE from '../fire';\n//////////////////////////////////////////////\n// EMIT\nexport class EffectEffect {\n    make(src, dest) {\n        if (!src.effect)\n            return true;\n        dest.effect = src.effect;\n        return true;\n    }\n    async fire(config, map, x, y, ctx) {\n        if (config.effect) {\n            return await FIRE.fire(config.effect, map, x, y, ctx);\n        }\n        return false;\n    }\n    fireSync(config, map, x, y, ctx) {\n        if (config.effect) {\n            return FIRE.fireSync(config.effect, map, x, y, ctx);\n        }\n        return false;\n    }\n}\nEFFECT.installHandler('effect', new EffectEffect());\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../../flags';\nimport * as Tile from '../../tile';\nimport * as Effect from '..';\nimport { Actor } from '../../actor';\nimport { Item } from '../../item';\nexport class SpawnEffect {\n    make(src, dest) {\n        var _a, _b, _c, _d, _e, _f, _g;\n        if (!src.tile)\n            return true; // no error\n        let config = src.tile;\n        if (typeof config === 'string') {\n            const parts = config.split(/[,|]/).map((p) => p.trim());\n            config = {\n                tile: parts[0],\n                grow: Number.parseInt(parts[1] || '0'),\n                decrement: Number.parseInt(parts[2] || '0'),\n            };\n        }\n        const info = {\n            grow: (_b = (_a = config.grow) !== null && _a !== void 0 ? _a : config.spread) !== null && _b !== void 0 ? _b : 0,\n            decrement: (_c = config.decrement) !== null && _c !== void 0 ? _c : 0,\n            flags: GWU.flag.from(Flags.Effect, config.flags),\n            volume: (_d = config.volume) !== null && _d !== void 0 ? _d : 0,\n            next: (_e = config.next) !== null && _e !== void 0 ? _e : null,\n        };\n        const id = (_f = config.tile) !== null && _f !== void 0 ? _f : config.id;\n        if (typeof id === 'string') {\n            info.tile = id;\n        }\n        else {\n            throw new Error('Invalid tile spawn config: ' + id);\n        }\n        if (!info.tile) {\n            throw new Error('Must have tile.');\n        }\n        const match = (_g = config.matchTile) !== null && _g !== void 0 ? _g : config.match;\n        if (typeof match === 'string') {\n            info.matchTile = match;\n        }\n        else if (match) {\n            throw new Error('Invalid tile spawn match tile: ' + config.matchTile);\n        }\n        dest.tile = info;\n        return true;\n    }\n    async fire(effect, map, x, y, ctx) {\n        let didSomething = false;\n        const spawned = this.fireSync(effect, map, x, y, ctx);\n        if (spawned) {\n            didSomething = true;\n            // await spawnMap.forEachAsync( (v, x, y) => {\n            //     if (!v) return;\n            //     await map.applyInstantEffects(x, y);\n            // });\n            // if (applyEffects) {\n            // if (PLAYER.xLoc == i && PLAYER.yLoc == j && !PLAYER.status.levitating && refresh) {\n            // \tflavorMessage(tileFlavor(PLAYER.xLoc, PLAYER.yLoc));\n            // }\n            // if (cell.actor || cell.item) {\n            // \tfor(let t of cell.tiles()) {\n            // \t\tawait t.applyInstantEffects(map, i, j, cell);\n            // \t\tif (Data.gameHasEnded) {\n            // \t\t\treturn true;\n            // \t\t}\n            // \t}\n            // }\n            // if (tile.flags & TileFlags.T_IS_FIRE) {\n            // \tif (cell.flags & CellFlags.HAS_ITEM) {\n            // \t\ttheItem = map.itemAt(i, j);\n            // \t\tif (theItem.flags & Flags.Item.ITEM_FLAMMABLE) {\n            // \t\t\tawait burnItem(theItem);\n            // \t\t}\n            // \t}\n            // }\n            // }\n        }\n        // GWU.grid.free(spawnMap);\n        return didSomething;\n    }\n    fireSync(effect, map, x, y, ctx) {\n        if (!effect.tile)\n            return false; // did nothing\n        const id = effect.tile.tile;\n        const tile = Tile.tiles[id] || null;\n        if (!tile) {\n            throw new Error('Failed to find tile for effect: ' + id);\n        }\n        const abortIfBlocking = !!(effect.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n        const isBlocking = !!(abortIfBlocking &&\n            !(effect.flags & Flags.Effect.E_PERMIT_BLOCKING) &&\n            (tile.blocksPathing() ||\n                effect.flags & Flags.Effect.E_TREAT_AS_BLOCKING));\n        let didSomething = false;\n        didSomething = computeSpawnMap(effect, map, x, y, ctx);\n        if (!didSomething) {\n            return false;\n        }\n        if (abortIfBlocking &&\n            isBlocking &&\n            this.mapDisruptedBy(map, ctx.grid)) {\n            // GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (effect.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, ctx.grid)) {\n                didSomething = true;\n            }\n        }\n        if (effect.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, ctx.grid)) {\n                didSomething = true;\n            }\n        }\n        if (effect.flags & Flags.Effect.E_CLEAR_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (clearCells(map, ctx.grid, effect.flags)) {\n                didSomething = true;\n            }\n        }\n        const spawned = spawnTiles(effect.flags, ctx.grid, map, tile, effect.tile.volume, ctx.machine);\n        return spawned;\n    }\n    mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n        const walkableGrid = GWU.grid.alloc(map.width, map.height);\n        let disrupts = false;\n        // Get all walkable locations after lake added\n        GWU.xy.forRect(map.width, map.height, (i, j) => {\n            const lakeX = i + blockingToMapX;\n            const lakeY = j + blockingToMapY;\n            if (blockingGrid.get(lakeX, lakeY)) {\n                if (map.cellInfo(i, j).isStairs()) {\n                    disrupts = true;\n                }\n            }\n            else if (!map.cellInfo(i, j).blocksMove()) {\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        // console.log('WALKABLE GRID');\n        // walkableGWU.grid.dump();\n        GWU.grid.free(walkableGrid);\n        return disrupts;\n    }\n}\nEffect.installHandler('tile', new SpawnEffect());\n// tick\n// Spawn\nexport function spawnTiles(flags, spawnMap, map, tile, volume = 0, machine) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = !!(flags & Flags.Effect.E_BLOCKED_BY_OTHER_LAYERS);\n    const superpriority = !!(flags & Flags.Effect.E_SUPERPRIORITY);\n    const blockedByActors = !!(flags & Flags.Effect.E_BLOCKED_BY_ACTORS);\n    const blockedByItems = !!(flags & Flags.Effect.E_BLOCKED_BY_ITEMS);\n    // const applyEffects = ctx.refreshCell;\n    volume = volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            // const isRoot = spawnMap[i][j] === 1;\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.hasTile(tile)) {\n                // If the new cell already contains the fill terrain,\n                // if (tile.depth == Flags.Depth.GAS) {\n                //     spawnMap[i][j] = 1;\n                //     cell.gasVolume += volume;\n                // } else if (tile.depth == Flags.Depth.LIQUID) {\n                //     spawnMap[i][j] = 1;\n                //     cell.liquidVolume += volume;\n                // }\n            }\n            else if (map.setTile(i, j, tile, {\n                volume,\n                superpriority,\n                blockedByOtherLayers,\n                blockedByActors,\n                blockedByItems,\n                machine,\n            })) {\n                // if the fill won't violate the priority of the most important terrain in this cell:\n                spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                // map.redrawCell(cell);\n                // if (volume && cell.gas) {\n                //     cell.volume += (feat.volume || 0);\n                // }\n                cell.flags.cell |= Flags.Cell.EVENT_FIRED_THIS_TURN;\n                if (flags & Flags.Effect.E_PROTECTED) {\n                    cell.flags.cell |= Flags.Cell.EVENT_PROTECTED;\n                }\n                accomplishedSomething = true;\n                // debug('- tile', i, j, 'tile=', tile.id);\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.setMapFlag(Flags.Map.MAP_CHANGED);\n    }\n    return accomplishedSomething;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.tile.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cellInfo(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cellInfo(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cellInfo(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cellInfo(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.tile.matchTile &&\n        !isStart &&\n        !cell.hasTile(effect.tile.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, map, x, y, ctx) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const config = effect.tile;\n    let startProb = config.grow || 0;\n    let probDec = config.decrement || 0;\n    const spawnMap = ctx.grid;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, x, y, true)) {\n        return false;\n    }\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\n// export function spreadCircle(\n//     this: any,\n//     ctx: Effect.EffectCtx,\n//     spawnMap: GWU.grid.NumGrid\n// ) {\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     let radius = 0;\n//     startProb = startProb || 100;\n//     if (startProb >= 100) {\n//         probDec = probDec || 100;\n//     }\n//     while (map.rng.chance(startProb)) {\n//         startProb -= probDec;\n//         ++radius;\n//     }\n//     // startProb = 100;\n//     // probDec = 0;\n//     spawnMap.updateCircle(x, y, radius, (_v, i, j) => {\n//         if (!cellIsOk(this, i, j, ctx)) return 0;\n//         // const dist = Math.floor(GWU.utils.distanceBetween(x, y, i, j));\n//         // const prob = startProb - dist * probDec;\n//         // if (!map.rng.chance(prob)) return 0;\n//         return 1;\n//     });\n//     // spawnMap[x][y] = 1;\n//     // if (!isOk(flags, x, y, ctx)) {\n//     //     spawnMap[x][y] = 0;\n//     // }\n//     return true;\n// }\n// export function spreadLine(\n//     this: any,\n//     ctx: Effect.EffectCtx,\n//     spawnMap: GWU.grid.NumGrid\n// ) {\n//     let x2, y2;\n//     let madeChange;\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     if (startProb) {\n//         madeChange = true;\n//         if (startProb >= 100) {\n//             probDec = probDec || 100;\n//         }\n//         x2 = x;\n//         y2 = y;\n//         const dir = GWU.xy.DIRS[map.rng.number(4)];\n//         while (madeChange) {\n//             madeChange = false;\n//             x2 = x2 + dir[0];\n//             y2 = y2 + dir[1];\n//             if (\n//                 spawnMap.hasXY(x2, y2) &&\n//                 !spawnMap[x2][y2] &&\n//                 cellIsOk(this, x2, y2, ctx) &&\n//                 map.rng.chance(startProb)\n//             ) {\n//                 spawnMap[x2][y2] = 1;\n//                 madeChange = true;\n//                 startProb -= probDec;\n//             }\n//         }\n//     }\n//     if (!cellIsOk(this, x, y, ctx)) {\n//         spawnMap[x][y] = 0;\n//     }\n//     return true;\n// }\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let i = 0, j = 0;\n    let didSomething = false;\n    for (i = 0; i < map.width; i++) {\n        for (j = 0; j < map.height; j++) {\n            if (!blockingMap[i][j])\n                continue;\n            const cell = map.cell(i, j);\n            if (!cell.hasActor())\n                continue;\n            GWU.list.forEach(cell.actor, (obj) => {\n                if (!(obj instanceof Actor))\n                    return;\n                const monst = obj;\n                const loc = map.rng.matchingLocNear(i, j, (x, y) => {\n                    if (!map.hasXY(x, y))\n                        return false;\n                    if (blockingMap[x][y])\n                        return false;\n                    const c = map.cell(x, y);\n                    return !monst.forbidsCell(c);\n                });\n                if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                    map.moveActor(loc[0], loc[1], monst);\n                    // map.redrawXY(loc[0], loc[1]);\n                    didSomething = true;\n                }\n            });\n        }\n    }\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    blockingMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (!cell.hasItem())\n            return;\n        GWU.list.forEach(cell.item, (obj) => {\n            if (!(obj instanceof Item))\n                return;\n            const item = obj;\n            const loc = map.rng.matchingLocNear(i, j, (x, y) => {\n                if (!map.hasXY(x, y))\n                    return false;\n                if (blockingMap[x][y])\n                    return false;\n                const dest = map.cell(x, y);\n                return !item.forbidsCell(dest);\n            });\n            if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                map.moveItem(loc[0], loc[1], item);\n                // map.redrawXY(loc[0], loc[1]);\n                didSomething = true;\n            }\n        });\n    });\n    return didSomething;\n}\nclass ClearTileEffect {\n    make(src, dest) {\n        if (!src.clear)\n            return true;\n        let config = src.clear;\n        let layers = 0;\n        if (typeof config === 'string') {\n            config = config.split(/[,|]/).map((t) => t.trim());\n        }\n        if (config === true) {\n            layers = Flags.Depth.ALL_LAYERS;\n        }\n        else if (typeof config === 'number') {\n            layers = config;\n        }\n        else if (Array.isArray(config)) {\n            layers = config.reduce((out, v) => {\n                if (typeof v === 'number')\n                    return out | v;\n                const depth = Flags.Depth[v] || 0;\n                return out | depth;\n            }, 0);\n        }\n        else {\n            throw new Error('clear effect must have number or string config.');\n        }\n        dest.clear = layers;\n        return layers > 0;\n    }\n    fire(config, map, x, y, ctx) {\n        return this.fireSync(config, map, x, y, ctx);\n    }\n    fireSync(config, map, x, y, _ctx) {\n        if (!config.clear)\n            return false;\n        if (!map)\n            return false;\n        const cell = map.cell(x, y);\n        return cell.clearDepth(config.clear);\n    }\n}\nEffect.installHandler('clear', new ClearTileEffect());\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nimport * as Flags from '../flags';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.effects = {};\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.effects) {\n            Object.assign(this.effects, config.effects);\n        }\n        if (this.hasEffect('fire')) {\n            this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n        }\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    hasEffect(name) {\n        return name in this.effects;\n    }\n    getName(arg) {\n        let opts = {};\n        if (arg === true || arg === false) {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `${color}${this.name}`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription() {\n        return this.description || this.getName();\n    }\n    getFlavor() {\n        return this.flavor || this.getName();\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { effects: {}, flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const effects = {};\n    Object.assign(effects, base.effects);\n    if (options.effects) {\n        Object.entries(options.effects).forEach(([key, value]) => {\n            if (value === null) {\n                delete effects[key];\n                return;\n            }\n            if (typeof value === 'string') {\n                effects[key] = value;\n                return;\n            }\n            effects[key] = Effect.make(value);\n        });\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        effects,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n    };\n    const tile = new Tile(config);\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import * as Tile from './tile';\n// These are the minimal set of tiles to make the diggers work\nTile.install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: [30, 30, 30, 20, 0, 0, 0],\n    bg: [2, 2, 10, 0, 2, 2, 0],\n    priority: 10,\n    article: 'the',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: { tile: 'DOOR_OPEN' },\n        open: { tile: 'DOOR_OPEN_ALWAYS' },\n    },\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            tile: 'DOOR',\n            flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY',\n        },\n        enter: null,\n        open: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n});\nTile.install('UP_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'upward staircase',\n    article: 'an',\n    effects: {\n        player: { emit: 'UP_STAIRS' },\n    },\n});\nTile.install('DOWN_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'downward staircase',\n    article: 'a',\n    effects: {\n        player: { emit: 'DOWN_STAIRS' },\n    },\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'an impregnable wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: [5, 8, 20, 10, 0, 4, 15, true],\n    bg: [10, 15, 41, 6, 5, 5, 5, true],\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: [5, 8, 10, 10, 0, 4, 15, true],\n    bg: [10, 30, 30, 6, 0, 10, 10, true],\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    depth: 'SURFACE', // 'LIQUID'?\n});\nTile.install('BRIDGE', {\n    ch: '=',\n    fg: [100, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n});\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\nimport './tiles';\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n}\n","import * as Tile from '../tile';\nimport * as Flags from '../flags';\nimport { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts = {}) {\n        const cell = this.map.cell(x, y);\n        const current = cell.depthTile(tile.depth) || Tile.tiles.NULL;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (cell.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && cell.hasItem())\n            return false;\n        if (opts.blockedByActors && cell.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && cell.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const ground = cell.depthTile(Flags.Depth.GROUND);\n            if (!ground || ground === Tile.tiles.NULL) {\n                this.setTile(x, y, Tile.get(tile.groundTile));\n            }\n        }\n        // if nothing changed... return false\n        if (!cell.setTile(tile))\n            return false;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            cell.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            cell.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            cell.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    async tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire, pressure plates and key-activated tiles.\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (!cell.hasCellFlag(Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM) &&\n                    cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)) {\n                    cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n                }\n                if (cell.hasEffect('noKey') && !this.map.hasKey(x, y)) {\n                    await cell.activate('noKey', this.map, x, y);\n                }\n            }\n        }\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        const tile = cell.depthTile(this.depth);\n        if (tile && tile !== Tile.tiles.NULL) {\n            dest.drawSprite(tile.sprite);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { MapLayer } from './mapLayer';\nexport class ActorLayer extends MapLayer {\n    constructor(map, name = 'actor') {\n        super(map, name);\n    }\n    async addActor(x, y, obj, _opts) {\n        const actor = obj;\n        if (actor.isDestroyed)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (actor.forbidsCell(cell))\n            return false;\n        if (!GWU.list.push(cell, 'actor', obj))\n            return false;\n        if (obj.isPlayer()) {\n            cell.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        obj.x = x;\n        obj.y = y;\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('key')) {\n            await cell.activate('key', this.map, x, y);\n        }\n        return true;\n    }\n    forceActor(x, y, actor, _opts) {\n        if (actor.isDestroyed)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (!GWU.list.push(cell, 'actor', actor))\n            return false;\n        if (actor.isPlayer()) {\n            cell.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        actor.x = x;\n        actor.y = y;\n        return true;\n    }\n    async removeActor(obj) {\n        const x = obj.x;\n        const y = obj.y;\n        const cell = this.map.cell(x, y);\n        if (!GWU.list.remove(cell, 'actor', obj))\n            return false;\n        if (obj.isPlayer()) {\n            cell.clearCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('nokey')) {\n            await cell.activate('key', this.map, x, y);\n        }\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        if (!cell.actor)\n            return;\n        dest.drawSprite(cell.actor.sprite);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { MapLayer } from './mapLayer';\nexport class ItemLayer extends MapLayer {\n    constructor(map, name = 'item') {\n        super(map, name);\n    }\n    async addItem(x, y, obj, _opts) {\n        const item = obj;\n        if (item.isDestroyed)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (item.forbidsCell(cell))\n            return false;\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('key')) {\n            await cell.activate('key', this.map, x, y);\n            if (obj.key.disposable) {\n                obj.destroy();\n                return true; // ??? didSomething?\n            }\n        }\n        if (!GWU.list.push(cell, 'item', obj))\n            return false;\n        obj.x = x;\n        obj.y = y;\n        obj.depth = this.depth;\n        return true;\n    }\n    forceItem(x, y, obj, _opts) {\n        const cell = this.map.cell(x, y);\n        if (!GWU.list.push(cell, 'item', obj))\n            return false;\n        obj.x = x;\n        obj.y = y;\n        obj.depth = this.depth;\n        return true;\n    }\n    async removeItem(obj) {\n        const x = obj.x;\n        const y = obj.y;\n        const cell = this.map.cell(x, y);\n        if (!GWU.list.remove(cell, 'item', obj))\n            return false;\n        if (obj.key && obj.key.matches(x, y) && cell.hasEffect('nokey')) {\n            await cell.activate('nokey', this.map, x, y);\n        }\n        return true;\n    }\n    putAppearance(dest, x, y) {\n        const cell = this.map.cell(x, y);\n        if (!cell.item)\n            return;\n        dest.drawSprite(cell.item.sprite);\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    clear() {\n        this.volume.fill(0);\n    }\n    setTile(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.setTile(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.changed = true;\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n        this.changed = other.changed;\n    }\n    async tick(_dt) {\n        if (!this.changed)\n            return false;\n        this.changed = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.changed = true;\n            }\n            else {\n                this.clearTile(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clearTile(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n    putAppearance(dest, x, y) {\n        const volume = this.volume[x][y];\n        if (!volume)\n            return;\n        const cell = this.map.cell(x, y);\n        const tile = cell.depthTile(this.depth);\n        if (tile) {\n            const opacity = this.calcOpacity(volume);\n            dest.drawSprite(tile.sprite, opacity);\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nimport * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    async tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    await this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.xy.DIRS[d];\n                        await this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    async exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = Effect.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && this.map.rng.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            await cell.activate(event, this.map, x, y, {\n                force: true,\n            });\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as Effect from '../effect';\nclass CellObjects {\n    constructor(cell) {\n        this.cell = cell;\n    }\n    eachItem(cb) {\n        let object = this.cell._item;\n        while (object) {\n            cb(object);\n            object = object.next;\n        }\n    }\n    eachActor(cb) {\n        let object = this.cell._actor;\n        while (object) {\n            cb(object);\n            object = object.next;\n        }\n    }\n    forEach(cb) {\n        this.eachItem(cb);\n        this.eachActor(cb);\n    }\n    some(cb) {\n        let object = this.cell._item;\n        while (object) {\n            if (cb(object))\n                return true;\n            object = object.next;\n        }\n        object = this.cell._actor;\n        while (object) {\n            if (cb(object))\n                return true;\n            object = object.next;\n        }\n        return false;\n    }\n    reduce(cb, start) {\n        let object = this.cell._item;\n        while (object) {\n            if (start === undefined) {\n                start = object;\n            }\n            else {\n                start = cb(start, object);\n            }\n            object = object.next;\n        }\n        object = this.cell._actor;\n        while (object) {\n            if (start === undefined) {\n                start = object;\n            }\n            else {\n                start = cb(start, object);\n            }\n            object = object.next;\n        }\n        return start;\n    }\n}\nexport class Cell {\n    constructor(groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        // keyId = 0;\n        // gasVolume: number = 0;\n        // liquidVolume: number = 0;\n        this._actor = null;\n        this._item = null;\n        this._objects = new CellObjects(this);\n        this.flags = { cell: 0 };\n        this.tiles = [TILE.tiles.NULL];\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this._actor = other._actor;\n        this._item = other._item;\n        // this.keyId = other.keyId;\n        this.machineId = other.machineId;\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag) {\n        return (this.tiles.some((t) => t && t.flags.entity & flag) ||\n            this._objects.some((o) => !!(o.flags.entity & flag)));\n    }\n    hasAllEntityFlags(flags) {\n        return (this.entityFlags() & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags() {\n        return (this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0) |\n            this._objects.reduce((out, o) => out | o.flags.entity, 0));\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    itemFlags() {\n        let flags = 0;\n        this._objects.eachItem((i) => {\n            flags |= i.flags.item;\n        });\n        return flags;\n    }\n    actorFlags() {\n        let flags = 0;\n        this._objects.eachActor((a) => {\n            flags |= a.flags.actor;\n        });\n        return flags;\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return (this.tiles.some((t) => t && t.blocksVision()) ||\n            this._objects.some((o) => o.blocksVision()));\n    }\n    blocksPathing() {\n        return (this.tiles.some((t) => t && t.blocksPathing()) ||\n            this._objects.some((o) => o.blocksPathing()));\n    }\n    blocksMove() {\n        return (this.tiles.some((t) => t && t.blocksMove()) ||\n            this._objects.some((o) => o.blocksMove()));\n    }\n    blocksEffects() {\n        return (this.tiles.some((t) => t && t.blocksEffects()) ||\n            this._objects.some((o) => o.blocksEffects()));\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isEmpty() {\n        return (this.tiles.every((t) => !t || t === TILE.tiles.NULL) &&\n            this._actor == null &&\n            this._item == null);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile)\n            return false;\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        if (current.light !== tile.light) {\n            this.setCellFlag(Flags.Cell.LIGHT_CHANGED);\n        }\n        if (current.blocksVision() !== tile.blocksVision()) {\n            this.setCellFlag(Flags.Cell.FOV_CHANGED);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this._actor = null;\n        this._item = null;\n        if (tile) {\n            this.setTile(tile);\n        }\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    async activate(event, map, x, y, ctx = {}) {\n        ctx.cell = this;\n        let didSomething = false;\n        if (ctx.depth !== undefined) {\n            const tile = (ctx.tile = this.depthTile(ctx.depth));\n            if (tile && tile.effects) {\n                const ev = tile.effects[event];\n                didSomething = await this._activate(ev, map, x, y, ctx);\n            }\n        }\n        else {\n            // console.log('fire event - %s', event);\n            for (ctx.tile of this.tiles) {\n                if (!ctx.tile || !ctx.tile.effects)\n                    continue;\n                const ev = ctx.tile.effects[event];\n                // console.log(' - ', ev);\n                if (await this._activate(ev, map, x, y, ctx)) {\n                    didSomething = true;\n                    break;\n                }\n                // }\n            }\n        }\n        return didSomething;\n    }\n    build(event, map, x, y, ctx = {}) {\n        ctx.cell = this;\n        let didSomething = false;\n        if (ctx.depth !== undefined) {\n            const tile = (ctx.tile = this.depthTile(ctx.depth));\n            if (tile && tile.effects) {\n                const ev = tile.effects[event];\n                didSomething = this._build(ev, map, x, y, ctx);\n            }\n        }\n        else {\n            // console.log('fire event - %s', event);\n            for (ctx.tile of this.tiles) {\n                if (!ctx.tile || !ctx.tile.effects)\n                    continue;\n                const ev = ctx.tile.effects[event];\n                // console.log(' - ', ev);\n                if (this._build(ev, map, x, y, ctx)) {\n                    didSomething = true;\n                    break;\n                }\n                // }\n            }\n        }\n        return didSomething;\n    }\n    async _activate(effect, map, x, y, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.effects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = await Effect.fire(effect, map, x, y, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    _build(effect, map, x, y, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.effects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = Effect.fireSync(effect, map, x, y, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    get item() {\n        return this._item;\n    }\n    set item(val) {\n        this._item = val;\n        if (val) {\n            this.setCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        else {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        this.needsRedraw = true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this._actor;\n    }\n    set actor(val) {\n        this._actor = val;\n        if (val) {\n            this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        }\n        else {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        var _a, _b, _c, _d;\n        if ((_b = (_a = this._actor) === null || _a === void 0 ? void 0 : _a.sprite) === null || _b === void 0 ? void 0 : _b.ch)\n            return this._actor.sprite.ch;\n        if ((_d = (_c = this._item) === null || _c === void 0 ? void 0 : _c.sprite) === null || _d === void 0 ? void 0 : _d.ch)\n            return this._item.sprite.ch;\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nexport class CellMemory {\n    constructor() {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.keyId = 0;\n        this.flags = {\n            cell: 0,\n            item: 0,\n            actor: 0,\n            tile: 0,\n            tileMech: 0,\n            object: 0,\n        };\n        this.blocks = {\n            vision: false,\n            effects: false,\n            move: false,\n            pathing: false,\n        };\n        this._tile = TILE.tiles.NULL;\n        this._item = null;\n        this._actor = null;\n        this._hasKey = false;\n        this.snapshot = new GWU.sprite.Mixer();\n    }\n    clear() {\n        this.snapshot.blackOut();\n        this._item = null;\n        this._actor = null;\n        this._tile = TILE.tiles.NULL;\n        this.flags.cell = 0;\n        this.flags.object = 0;\n        this.flags.tile = 0;\n        this.flags.tileMech = 0;\n        this.blocks.effects = false;\n        this.blocks.move = false;\n        this.blocks.pathing = false;\n        this.blocks.vision = false;\n        this.machineId = 0;\n        this.chokeCount = 0;\n    }\n    store(cell) {\n        this._item = null;\n        if (cell.hasItem()) {\n            this._item = cell.item;\n        }\n        this._actor = null;\n        if (cell.hasActor()) {\n            this._actor = cell.actor;\n        }\n        this._tile = cell.tile;\n        this.flags.cell = cell.cellFlags();\n        this.flags.tile = cell.tileFlags();\n        this.flags.tileMech = cell.tileMechFlags();\n        this.flags.object = cell.entityFlags();\n        this.flags.item = cell.itemFlags();\n        this.flags.actor = cell.actorFlags();\n        this.blocks.effects = cell.blocksEffects();\n        this.blocks.move = cell.blocksMove();\n        this.blocks.pathing = cell.blocksPathing();\n        this.blocks.vision = cell.blocksVision();\n        this.chokeCount = cell.chokeCount;\n        this.machineId = cell.machineId;\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get needsRedraw() {\n        return this.hasCellFlag(Flags.Cell.NEEDS_REDRAW);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.flags.tile & flags) == flags;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.object & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.object & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags() {\n        return this.flags.object;\n    }\n    tileFlags() {\n        return this.flags.tile;\n    }\n    tileMechFlags() {\n        return this.flags.tileMech;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    blocksVision() {\n        return this.blocks.vision;\n    }\n    blocksPathing() {\n        return this.blocks.pathing;\n    }\n    blocksMove() {\n        return this.blocks.move;\n    }\n    blocksEffects() {\n        return this.blocks.effects;\n    }\n    isWall() {\n        return this.blocksVision() && this.blocksMove();\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    get tile() {\n        return this._tile;\n    }\n    hasTile(tile) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this._tile === tile;\n    }\n    hasItem() {\n        return !!this._item;\n    }\n    get item() {\n        return this._item;\n    }\n    hasActor() {\n        return !!this._actor;\n    }\n    hasPlayer() {\n        return !!(this.flags.cell & Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this._actor;\n    }\n    getDescription() {\n        throw new Error('Method not implemented.');\n    }\n    getFlavor() {\n        throw new Error('Method not implemented.');\n    }\n    getName(_opts) {\n        throw new Error('Method not implemented.');\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport * as Layer from '../layer';\nimport { CellMemory } from './cellMemory';\nimport * as Effect from '../effect';\nexport class Map {\n    constructor(width, height, opts = {}) {\n        this._seed = 0;\n        this.rng = GWU.rng.random;\n        this.width = width;\n        this.height = height;\n        this.flags = { map: 0 };\n        this.layers = [];\n        this.cells = GWU.grid.make(width, height, () => new Cell());\n        this.memory = GWU.grid.make(width, height, () => new CellMemory());\n        if (opts.seed) {\n            this._seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        this.fov = new GWU.fov.FovSystem(this, opts);\n        this.properties = {};\n        this.initLayers();\n    }\n    get seed() {\n        return this._seed;\n    }\n    set seed(v) {\n        this._seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    cellInfo(x, y, useMemory = false) {\n        if (useMemory)\n            return this.memory[x][y];\n        return this.cell(x, y);\n    }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n        this.addLayer(Flags.Depth.SURFACE, new Layer.FireLayer(this, 'surface'));\n        this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n        this.addLayer(Flags.Depth.ITEM, new Layer.ItemLayer(this, 'item'));\n        this.addLayer(Flags.Depth.ACTOR, new Layer.ActorLayer(this, 'actor'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // DRAW\n    drawInto(dest, opts = {}) {\n        const buffer = dest instanceof GWU.canvas.Canvas ? dest.buffer : dest;\n        if (typeof opts === 'boolean')\n            opts = { force: opts };\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                // const cell = this.cell(x, y);\n                // if (\n                //     cell.needsRedraw ||\n                //     this.light.lightChanged(x, y) ||\n                //     this.fov.fovChanged(x, y)\n                // ) {\n                this.getAppearanceAt(x, y, mixer);\n                buffer.drawSprite(x, y, mixer);\n                // }\n            }\n        }\n    }\n    // items\n    itemAt(x, y) {\n        return this.cell(x, y).item;\n    }\n    eachItem(cb) {\n        this.cells.forEach((cell) => {\n            GWU.list.forEach(cell.item, cb);\n        });\n    }\n    async addItem(x, y, item) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && (await layer.addItem(x, y, item))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    forceItem(x, y, item) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && layer.forceItem(x, y, item)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async removeItem(item) {\n        const layer = this.layers[item.depth];\n        return layer.removeItem(item);\n    }\n    async moveItem(x, y, item) {\n        if (!this.hasXY(x, y))\n            return false;\n        const layer = this.layers[item.depth];\n        if (!(await layer.removeItem(item)))\n            return false;\n        return this.addItem(x, y, item);\n    }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    actorAt(x, y) {\n        return this.cell(x, y).actor;\n    }\n    eachActor(cb) {\n        this.cells.forEach((cell) => {\n            GWU.list.forEach(cell.actor, cb);\n        });\n    }\n    async addActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && (await layer.addActor(x, y, actor))) {\n                return true;\n            }\n        }\n        return false;\n    }\n    forceActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        for (let layer of this.layers) {\n            if (layer && layer.forceActor(x, y, actor)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    async removeActor(actor) {\n        const layer = this.layers[actor.depth];\n        return layer.removeActor(actor);\n    }\n    async moveActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        const layer = this.layers[actor.depth];\n        if (!(await layer.removeActor(actor)))\n            return false;\n        return this.addActor(x, y, actor);\n    }\n    // Information\n    isVisible(x, y) {\n        return this.fov.isAnyKindOfVisible(x, y);\n    }\n    hasKey(x, y) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cells[x][y];\n        return cell._objects.some((e) => !!e.key && e.key.matches(x, y));\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        this.cells.dump(fmt || ((c) => c.dump()), log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        this.fov.needsUpdate = true;\n        this.layers.forEach((l) => l.clear());\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cell(i, j);\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile, useMemory = false) {\n        return this.cellInfo(x, y, useMemory).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof Layer.TileLayer))\n            return false;\n        return layer.setTile(x, y, tile, opts);\n    }\n    clearTiles(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clearTiles(tile);\n    }\n    async tick(dt) {\n        let didSomething = await this.fireAll('tick');\n        for (let layer of this.layers) {\n            if (layer && (await layer.tick(dt))) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cells[x][y]);\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.flags.map = src.flags.map;\n        this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        Object.assign(this.properties, src.properties);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    async fire(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.activate(event, this, x, y, ctx);\n    }\n    fireSync(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.build(event, this, x, y, ctx);\n    }\n    async fireAll(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        await willFire.forEachAsync(async (w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    await cell.activate(event, this, x, y, {\n                        force: true,\n                        depth,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    fireAllSync(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        willFire.forEach((w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    cell.activate(event, this, x, y, {\n                        force: true,\n                        depth,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    async activateMachine(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cells[x][y];\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        (await cell.activate('machine', this, x, y, ctx)) ||\n                            didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    activateMachineSync(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cells[x][y];\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        cell.build('machine', this, x, y, ctx) || didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    getAppearanceAt(x, y, dest) {\n        dest.blackOut();\n        const cell = this.cell(x, y);\n        const isVisible = this.fov.isAnyKindOfVisible(x, y);\n        if (cell.needsRedraw && isVisible) {\n            this.layers.forEach((layer) => layer.putAppearance(dest, x, y));\n            if (dest.dances) {\n                cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n            }\n            else {\n                cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n            }\n            dest.bake();\n            this.memory[x][y].putSnapshot(dest);\n            cell.needsRedraw = false;\n        }\n        else {\n            this.memory[x][y].getSnapshot(dest);\n        }\n        if (isVisible) {\n            const light = this.light.getLight(x, y);\n            dest.multiply(light);\n        }\n        else if (this.fov.isRevealed(x, y)) {\n            dest.scale(50);\n        }\n        else {\n            dest.blackOut();\n        }\n        if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n            GWU.color.separate(dest.fg, dest.bg);\n        }\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(_cb) {\n        // TODO !!\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    onCellRevealed(_x, _y) {\n        // if (DATA.automationActive) {\n        // if (cell.item) {\n        //     const theItem: GW.types.ItemType = cell.item;\n        //     if (\n        //         theItem.hasObjectFlag(ObjectFlags.L_INTERRUPT_WHEN_SEEN)\n        //     ) {\n        //         GW.message.add(\n        //             'you see itemMessageColoritem.',\n        //             {\n        //                 item: theItem,\n        //                 actor: DATA.player,\n        //             }\n        //         );\n        //     }\n        // }\n        // if (\n        //     !(this.fov.isMagicMapped(x, y)) &&\n        //     this.site.hasObjectFlag(\n        //         x,\n        //         y,\n        //         ObjectFlags.L_INTERRUPT_WHEN_SEEN\n        //     )\n        // ) {\n        //     const tile = cell.tileWithLayerFlag(\n        //         ObjectFlags.L_INTERRUPT_WHEN_SEEN\n        //     );\n        //     if (tile) {\n        //         GW.message.add(\n        //             'you see backgroundMessageColoritem.',\n        //             {\n        //                 actor: DATA.player,\n        //                 item: tile.name,\n        //             }\n        //         );\n        //     }\n        // }\n    }\n    redrawCell(x, y, clearMemory) {\n        if (clearMemory) {\n            this.clearMemory(x, y);\n        }\n        this.cells[x][y].needsRedraw = true;\n    }\n    clearMemory(x, y) {\n        this.memory[x][y].clear();\n    }\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        this.memory[x][y].store(cell);\n    }\n}\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n    }\n    map.light.update();\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount = cellCount;\n                                            map.cell(i2, j2).flags.cell &= ~Flags.Cell\n                                                .IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        this.layerVersion = [];\n        this.lightVersion = 0;\n        this.fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        if (this.map.fov.changed) {\n            this.fovVersion = this.version;\n            this.map.fov.changed = false;\n        }\n        if (snap.version !== this.fovVersion) {\n            snap.map.fov.copy(this.map.fov);\n        }\n        // layers\n        this.map.layers.forEach((layer, index) => {\n            const snapLayer = snap.map.layers[index];\n            if (layer.changed) {\n                this.layerVersion[index] = this.version;\n            }\n            if (this.layerVersion[index] !== snap.version) {\n                snapLayer.copy(layer);\n            }\n        });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        if (snap.version < this.fovVersion || this.map.fov.changed) {\n            this.map.fov.copy(snap.map.fov);\n            this.fovVersion = snap.version;\n        }\n        // layers\n        this.layerVersion.forEach((v, index) => {\n            if (v < snap.version)\n                return;\n            const destLayer = this.map.layers[index];\n            if (v > snap.version || destLayer.changed) {\n                const srcLayer = snap.map.layers[index];\n                destLayer.copy(srcLayer);\n                this.layerVersion[index] = snap.version;\n            }\n        });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function getCellPathCost(map, x, y) {\n    const cell = map.cell(x, y);\n    if (cell.blocksMove())\n        return GWU.path.OBSTRUCTION;\n    if (cell.blocksPathing())\n        return GWU.path.FORBIDDEN;\n    if (cell.hasActor())\n        return 10;\n    return 1;\n}\nexport function fillCostMap(map, costMap) {\n    costMap.update((_v, x, y) => getCellPathCost(map, x, y));\n}\nexport function getPathBetween(map, x0, y0, x1, y1, options = {}) {\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = GWU.grid.alloc(map.width, map.height);\n    fillCostMap(map, costMap);\n    GWU.path.calculateDistances(distanceMap, x0, y0, costMap, options.eightWays, GWU.xy.straightDistanceBetween(x0, y0, x1, y1) + 1);\n    const path = GWU.path.getPath(distanceMap, x1, y1, (x, y) => map.cell(x, y).blocksMove(), options.eightWays);\n    GWU.grid.free(costMap);\n    GWU.grid.free(distanceMap);\n    return path;\n}\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","TileMech","Cell","NEEDS_REDRAW","LIGHT_CHANGED","FOV_CHANGED","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_TRAP_FREE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","KeyInfo","[object Object]","x","y","disposable","this","EntityKind","config","tags","id","name","flavor","description","sprite","make","split","map","t","trim","slice","_item","_cell","verb","kind","key","depth","light","flags","entity","next","isDestroyed","hasEntityFlag","Flags.Entity","L_DESTROYED","tag","includes","cell","forbidsCell","getName","getDescription","getFlavor","getVerb","Entity.Entity","super","actor","Flags.Depth","ACTOR","hasActorFlag","Flags.Actor","IS_PLAYER","Entity.EntityKind","opts","ItemKind","_options","kinds","get","makeKind","info","Object","assign","randomKind","match","forbidTags","forEach","startsWith","push","substring","Array","isArray","matches","values","filter","k","length","arraysIntersect","rng","random","item","options","quantity","ITEM","made","makeOptions","Kind.get","Error","Kind.randomKind","JSON","stringify","Kind.ItemKind","Kind.makeKind","_a","fn","from","Flags","chance","handlers","v","effect","effects","reset","E_FIRED","install","installHandler","handler","async","fire","ctx_","ctx","force","grid","alloc","width","height","didSomething","allHandlers","h","E_NEXT_ALWAYS","data","gameHasEnded","nextInfo","E_NEXT_EVERYWHERE","forEachAsync","i","j","isVisible","E_NO_MARK_FIRED","free","fireSync","EmitEffect","src","dest","emit","_map","events","_x","_y","_ctx","FnEffect","result","MessageEffect","message","fired","addAt","ActivateMachineEffect","activateMachine","machine","machineId","activateMachineSync","EffectEffect","FIRE.fire","FIRE.fireSync","SpawnEffect","_b","_c","_d","_e","_f","_g","tile","parts","p","grow","Number","parseInt","decrement","spread","Flags.Effect","volume","matchTile","Tile.tiles","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","isBlocking","E_PERMIT_BLOCKING","blocksPathing","E_TREAT_AS_BLOCKING","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","spawnTiles","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","xy","forRect","lakeX","lakeY","cellInfo","isStairs","blocksMove","first","floodFill","spawnMap","accomplishedSomething","blockedByOtherLayers","E_BLOCKED_BY_OTHER_LAYERS","superpriority","E_SUPERPRIORITY","blockedByActors","blockedByItems","hasTile","setTile","Flags.Cell","EVENT_FIRED_THIS_TURN","E_PROTECTED","EVENT_PROTECTED","setMapFlag","Flags.Map","MAP_CHANGED","cellIsOk","isStart","hasXY","hasCellFlag","blocksEffects","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","ok","eachNeighbor","E_NO_TOUCH_WALLS","dir","x2","y2","madeChange","startProb","probDec","fill","count","DIRS","clearAll","clear","clearDepth","GAS","LIQUID","SURFACE","GROUND","blockingMap","hasActor","list","obj","monst","loc","matchingLocNear","c","moveActor","hasItem","moveItem","layers","ALL_LAYERS","reduce","out","e","entries","index","dissipate","priority","groundTile","article","tileMech","hasEffect","Flags.Tile","T_IS_FLAMMABLE","hasTileFlag","T_PATHING_BLOCKER","arg","color","fg","toString","base","extends","tiles","text","replace","search","delta","undefined","value","Effect.make","Flags.TileMech","ch","bg","opacity","all","args","enter","open","tick","close","player","MapLayer","changed","properties","_other","_tile","_actor","_dt","TileLayer","current","depthTile","NULL","blocksLayer","highestPriority","ground","Tile.get","glowLightChanged","setCellFlag","CAUGHT_FIRE_THIS_TURN","clearCellFlag","hasKey","activate","drawSprite","ActorLayer","_opts","isPlayer","remove","ItemLayer","destroy","GasLayer","other","copy","startingVolume","update","d","Math","max","clearTile","floor","min","total","highestVolume","startingTile","highestTile","needsRedraw","updateCellVolume","calcOpacity","ObjectFlags","TileFlags","TileMechFlags","CellFlags","FireLayer","exposeToFire","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","Effect.from","hasTileMechFlag","TM_EXPLOSIVE_PROMOTE","x0","y0","n","event","CellObjects","cb","object","eachItem","eachActor","start","chokeCount","_objects","TILE.tiles","TILE.get","some","o","entityFlags","tileFlags","tileMechFlags","a","CHANGED","TILE.Tile","highestPriorityTile","find","blocksVision","TILE.flags","T_BLOCKS_OTHER_LAYERS","every","hasAllEntityFlags","tileFlag","tileMechFlag","ev","_activate","_build","Effect.effects","Effect.fire","Effect.fireSync","val","CellMemory","keyId","blocks","vision","move","pathing","_hasKey","snapshot","Mixer","blackOut","cellFlags","itemFlags","actorFlags","_seed","cells","memory","seed","LightSystem","fov","FovSystem","initLayers","useMemory","addLayer","Layer.TileLayer","Layer.FireLayer","Layer.GasLayer","Layer.ItemLayer","Layer.ActorLayer","layer","buffer","canvas","Canvas","mixer","getAppearanceAt","addItem","forceItem","removeItem","hasPlayer","addActor","forceActor","removeActor","isAnyKindOfVisible","fmt","log","console","dump","needsUpdate","l","boundary","isBoundaryXY","clearTiles","dt","fireAll","constructor","build","willFire","promoteChance","w","originX","originY","putAppearance","dances","COLORS_DANCE","bake","putSnapshot","getSnapshot","getLight","multiply","isRevealed","scale","L_VISUALLY_DISTINCT","separate","eachGlowLight","_cb","isDark","clearMemory","store","updateChokepoints","updateCounts","passMap","L_SECRETLY_PASSABLE","passableArcCount","oldX","CLOCK_DIRS","oldY","newX","newY","cellCount","floodFillCount","i2","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","eachCell","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","up","left","designationSurvives","Snapshot","version","prefab","charToTile","isStringArray","len","line","updateChokeCounts","layerVersion","lightVersion","fovVersion","cellVersion","snap","srcCell","snapLayer","destCell","destLayer","srcLayer","getCellPathCost","path","OBSTRUCTION","FORBIDDEN","fillCostMap","costMap","_v","x1","y1","distanceMap","calculateDistances","eightWays","straightDistanceBetween","getPath"],"mappings":"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"}