{"version":3,"file":"gw-map.min.js","sources":["../js/flags/depth.js","../js/flags/entity.js","../js/flags/actor.js","../js/flags/item.js","../js/flags/tile.js","../js/flags/tileMech.js","../js/flags/cell.js","../js/flags/map.js","../js/flags/effect.js","../js/flags/horde.js","../js/entity/key.js","../js/entity/entity.js","../js/entity/kind.js","../js/actor/pain.js","../js/actor/stat.js","../js/actor/status.js","../js/actor/action.js","../js/actor/actor.js","../js/effect/effect.js","../js/tile/tile.js","../js/tile/index.js","../js/effect/types/basic.js","../js/effect/types/spread.js","../js/effect/handlers/emit.js","../js/effect/handlers/message.js","../js/effect/handlers/activateMachine.js","../js/effect/handlers/tile.js","../js/effect/handlers/clear.js","../js/effect/handlers/feature.js","../js/effect/handlers/nourish.js","../js/effect/handlers/stat.js","../js/map/cell.js","../js/layer/mapLayer.js","../js/layer/tileLayer.js","../js/layer/gasLayer.js","../js/layer/fireLayer.js","../js/draw/basic.js","../js/map/map.js","../js/memory/memory.js","../js/memory/system.js","../js/ai/ai.js","../js/ai/typical.js","../js/ai/utils.js","../js/actor/kind.js","../js/actor/make.js","../js/actor/actions/bump.js","../js/actor/actions/standStill.js","../js/fx/fx.js","../js/actor/actions/moveDir.js","../js/item/item.js","../js/item/kind.js","../js/item/make.js","../js/map/analyze.js","../js/map/snapshot.js","../js/map/utils.js","../js/path.js","../js/horde/horde.js","../js/horde/make.js","../js/command/command.js","../js/command/moveDir.js","../js/command/pickup.js","../js/player/attribute.js","../js/player/skill.js","../js/player/player.js","../js/player/kind.js","../js/player/make.js","../js/game/game.js","../js/tile/tiles.js"],"sourcesContent":["export var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"SURFACE\"] = 1] = \"SURFACE\";\n    Depth[Depth[\"ITEM\"] = 2] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 3] = \"ACTOR\";\n    Depth[Depth[\"LIQUID\"] = 4] = \"LIQUID\";\n    Depth[Depth[\"GAS\"] = 5] = \"GAS\";\n    Depth[Depth[\"FX\"] = 6] = \"FX\";\n    Depth[Depth[\"UI\"] = 7] = \"UI\";\n})(Depth || (Depth = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_DESTROYED\"] = Fl(1)] = \"L_DESTROYED\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(12)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_LIST_IN_SIDEBAR\"] = Fl(13)] = \"L_LIST_IN_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(14)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(15)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(16)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_ON_MAP\"] = Fl(17)] = \"L_ON_MAP\";\n    Entity[Entity[\"DEFAULT_ACTOR\"] = Entity.L_LIST_IN_SIDEBAR] = \"DEFAULT_ACTOR\";\n    Entity[Entity[\"DEFAULT_ITEM\"] = Entity.L_LIST_IN_SIDEBAR] = \"DEFAULT_ITEM\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_WALL_FLAGS\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_WALL_FLAGS\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_WALL_FLAGS |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Actor;\n(function (Actor) {\n    Actor[Actor[\"IS_PLAYER\"] = Fl(0)] = \"IS_PLAYER\";\n    Actor[Actor[\"HAS_MEMORY\"] = Fl(1)] = \"HAS_MEMORY\";\n    Actor[Actor[\"USES_FOV\"] = Fl(2)] = \"USES_FOV\";\n    Actor[Actor[\"STALE_COST_MAP\"] = Fl(3)] = \"STALE_COST_MAP\";\n    Actor[Actor[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Actor || (Actor = {}));\n","export var Item;\n(function (Item) {\n    Item[Item[\"DEFAULT\"] = 0] = \"DEFAULT\";\n})(Item || (Item = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_SHALLOW_WATER\"] = Fl(4)] = \"T_SHALLOW_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(5)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(6)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(7)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(8)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(9)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(10)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(11)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(12)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(13)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(14)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(15)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(16)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(17)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(18)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(19)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(20)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_BLOCKS_OTHER_LAYERS\"] = Fl(21)] = \"T_BLOCKS_OTHER_LAYERS\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n    Tile[Tile[\"T_ANY_LIQUID\"] = Tile.T_IS_DEEP_LIQUID | Tile.T_SHALLOW_WATER] = \"T_ANY_LIQUID\";\n})(Tile || (Tile = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(0)] = \"PRESSURE_PLATE_DEPRESSED\";\n    Cell[Cell[\"SEARCHED_FROM_HERE\"] = Fl(1)] = \"SEARCHED_FROM_HERE\";\n    Cell[Cell[\"KNOWN_TO_BE_SAFE\"] = Fl(2)] = \"KNOWN_TO_BE_SAFE\";\n    Cell[Cell[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(3)] = \"CAUGHT_FIRE_THIS_TURN\";\n    Cell[Cell[\"EVENT_FIRED_THIS_TURN\"] = Fl(4)] = \"EVENT_FIRED_THIS_TURN\";\n    Cell[Cell[\"EVENT_PROTECTED\"] = Fl(5)] = \"EVENT_PROTECTED\";\n    Cell[Cell[\"IS_IN_LOOP\"] = Fl(6)] = \"IS_IN_LOOP\";\n    Cell[Cell[\"IS_CHOKEPOINT\"] = Fl(7)] = \"IS_CHOKEPOINT\";\n    Cell[Cell[\"IS_GATE_SITE\"] = Fl(8)] = \"IS_GATE_SITE\";\n    Cell[Cell[\"IS_IN_ROOM_MACHINE\"] = Fl(9)] = \"IS_IN_ROOM_MACHINE\";\n    Cell[Cell[\"IS_IN_AREA_MACHINE\"] = Fl(10)] = \"IS_IN_AREA_MACHINE\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(11)] = \"IMPREGNABLE\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(13)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(14)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"STABLE_SNAPSHOT\"] = Fl(15)] = \"STABLE_SNAPSHOT\";\n    // These are to speed checks\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(16)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(17)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(18)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(19)] = \"HAS_ITEM\";\n    Cell[Cell[\"HAS_FX\"] = Fl(20)] = \"HAS_FX\";\n    Cell[Cell[\"HAS_TICK_EFFECT\"] = Fl(22)] = \"HAS_TICK_EFFECT\";\n    Cell[Cell[\"IS_WIRED\"] = Fl(26)] = \"IS_WIRED\";\n    Cell[Cell[\"IS_CIRCUIT_BREAKER\"] = Fl(27)] = \"IS_CIRCUIT_BREAKER\";\n    Cell[Cell[\"IS_POWERED\"] = Fl(28)] = \"IS_POWERED\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"CHANGED\"] = Cell.NEEDS_REDRAW] = \"CHANGED\";\n    Cell[Cell[\"IS_IN_MACHINE\"] = Cell.IS_IN_ROOM_MACHINE | Cell.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY |\n        Cell.SEARCHED_FROM_HERE |\n        Cell.PRESSURE_PLATE_DEPRESSED |\n        Cell.KNOWN_TO_BE_SAFE |\n        Cell.IS_IN_LOOP |\n        Cell.IS_CHOKEPOINT |\n        Cell.IS_GATE_SITE |\n        Cell.IS_IN_MACHINE |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"HAS_ANY_OBJECT\"] = Cell.HAS_ITEM | Cell.HAS_ANY_ACTOR] = \"HAS_ANY_OBJECT\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.NEEDS_REDRAW] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_NEEDS_REDRAW\"] = Fl(1)] = \"MAP_NEEDS_REDRAW\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_SIDEBAR_TILES_CHANGED\"] = Fl(10)] = \"MAP_SIDEBAR_TILES_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = 0] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Effect;\n(function (Effect) {\n    // E_ALWAYS_FIRE = Fl(10), // Fire even if the cell is marked as having fired this turn\n    Effect[Effect[\"E_NEXT_ALWAYS\"] = Fl(0)] = \"E_NEXT_ALWAYS\";\n    Effect[Effect[\"E_NEXT_EVERYWHERE\"] = Fl(1)] = \"E_NEXT_EVERYWHERE\";\n    Effect[Effect[\"E_FIRED\"] = Fl(2)] = \"E_FIRED\";\n    Effect[Effect[\"E_NO_MARK_FIRED\"] = Fl(3)] = \"E_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Effect[Effect[\"E_PROTECTED\"] = Fl(4)] = \"E_PROTECTED\";\n    // E_NO_REDRAW_CELL = Fl(),\n    Effect[Effect[\"E_TREAT_AS_BLOCKING\"] = Fl(5)] = \"E_TREAT_AS_BLOCKING\";\n    Effect[Effect[\"E_PERMIT_BLOCKING\"] = Fl(6)] = \"E_PERMIT_BLOCKING\";\n    Effect[Effect[\"E_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"E_ABORT_IF_BLOCKS_MAP\";\n    Effect[Effect[\"E_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"E_BLOCKED_BY_ITEMS\";\n    Effect[Effect[\"E_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"E_BLOCKED_BY_ACTORS\";\n    Effect[Effect[\"E_BLOCKED_BY_OTHER_LAYERS\"] = Fl(10)] = \"E_BLOCKED_BY_OTHER_LAYERS\";\n    Effect[Effect[\"E_SUPERPRIORITY\"] = Fl(11)] = \"E_SUPERPRIORITY\";\n    Effect[Effect[\"E_IGNORE_FOV\"] = Fl(12)] = \"E_IGNORE_FOV\";\n    // E_SPREAD_CIRCLE = Fl(13), // Spread in a circle around the spot (using FOV), radius calculated using spread+decrement\n    // E_SPREAD_LINE = Fl(14), // Spread in a line in one random direction\n    Effect[Effect[\"E_EVACUATE_CREATURES\"] = Fl(15)] = \"E_EVACUATE_CREATURES\";\n    Effect[Effect[\"E_EVACUATE_ITEMS\"] = Fl(16)] = \"E_EVACUATE_ITEMS\";\n    Effect[Effect[\"E_BUILD_IN_WALLS\"] = Fl(17)] = \"E_BUILD_IN_WALLS\";\n    Effect[Effect[\"E_MUST_TOUCH_WALLS\"] = Fl(18)] = \"E_MUST_TOUCH_WALLS\";\n    Effect[Effect[\"E_NO_TOUCH_WALLS\"] = Fl(19)] = \"E_NO_TOUCH_WALLS\";\n    Effect[Effect[\"E_CLEAR_GROUND\"] = Fl(21)] = \"E_CLEAR_GROUND\";\n    Effect[Effect[\"E_CLEAR_SURFACE\"] = Fl(22)] = \"E_CLEAR_SURFACE\";\n    Effect[Effect[\"E_CLEAR_LIQUID\"] = Fl(23)] = \"E_CLEAR_LIQUID\";\n    Effect[Effect[\"E_CLEAR_GAS\"] = Fl(24)] = \"E_CLEAR_GAS\";\n    Effect[Effect[\"E_CLEAR_TILE\"] = Fl(25)] = \"E_CLEAR_TILE\";\n    Effect[Effect[\"E_CLEAR_CELL\"] = Effect.E_CLEAR_GROUND |\n        Effect.E_CLEAR_SURFACE |\n        Effect.E_CLEAR_LIQUID |\n        Effect.E_CLEAR_GAS] = \"E_CLEAR_CELL\";\n    Effect[Effect[\"E_ONLY_IF_EMPTY\"] = Effect.E_BLOCKED_BY_ITEMS | Effect.E_BLOCKED_BY_ACTORS] = \"E_ONLY_IF_EMPTY\";\n    // E_NULLIFY_CELL = E_NULL_SURFACE | E_NULL_LIQUID | E_NULL_GAS,\n    // These should be effect types\n    Effect[Effect[\"E_ACTIVATE_DORMANT_MONSTER\"] = Fl(27)] = \"E_ACTIVATE_DORMANT_MONSTER\";\n    Effect[Effect[\"E_AGGRAVATES_MONSTERS\"] = Fl(28)] = \"E_AGGRAVATES_MONSTERS\";\n    Effect[Effect[\"E_RESURRECT_ALLY\"] = Fl(29)] = \"E_RESURRECT_ALLY\";\n})(Effect || (Effect = {}));\n","import * as GWU from 'gw-utils';\nconst Fl = GWU.flag.fl;\nexport var Horde;\n(function (Horde) {\n    Horde[Horde[\"HORDE_DIES_ON_LEADER_DEATH\"] = Fl(0)] = \"HORDE_DIES_ON_LEADER_DEATH\";\n    Horde[Horde[\"HORDE_IS_SUMMONED\"] = Fl(1)] = \"HORDE_IS_SUMMONED\";\n    Horde[Horde[\"HORDE_SUMMONED_AT_DISTANCE\"] = Fl(2)] = \"HORDE_SUMMONED_AT_DISTANCE\";\n    Horde[Horde[\"HORDE_NO_PERIODIC_SPAWN\"] = Fl(4)] = \"HORDE_NO_PERIODIC_SPAWN\";\n    Horde[Horde[\"HORDE_ALLIED_WITH_PLAYER\"] = Fl(5)] = \"HORDE_ALLIED_WITH_PLAYER\";\n    Horde[Horde[\"HORDE_NEVER_OOD\"] = Fl(15)] = \"HORDE_NEVER_OOD\";\n    // Move all these to tags?\n    // HORDE_LEADER_CAPTIVE = Fl(3), // the leader is in chains and the followers are guards\n    // HORDE_MACHINE_BOSS = Fl(6), // used in machines for a boss challenge\n    // HORDE_MACHINE_WATER_MONSTER = Fl(7), // used in machines where the room floods with shallow water\n    // HORDE_MACHINE_CAPTIVE = Fl(8), // powerful captive monsters without any captors\n    // HORDE_MACHINE_STATUE = Fl(9), // the kinds of monsters that make sense in a statue\n    // HORDE_MACHINE_TURRET = Fl(10), // turrets, for hiding in walls\n    // HORDE_MACHINE_MUD = Fl(11), // bog monsters, for hiding in mud\n    // HORDE_MACHINE_KENNEL = Fl(12), // monsters that can appear in cages in kennels\n    // HORDE_VAMPIRE_FODDER = Fl(13), // monsters that are prone to capture and farming by vampires\n    // HORDE_MACHINE_LEGENDARY_ALLY = Fl(14), // legendary allies\n    // HORDE_MACHINE_THIEF = Fl(16), // monsters that can be generated in the key thief area machines\n    // HORDE_MACHINE_GOBLIN_WARREN = Fl(17), // can spawn in goblin warrens\n    // HORDE_SACRIFICE_TARGET = Fl(18), // can be the target of an assassination challenge; leader will get scary light.\n    // HORDE_MACHINE_ONLY = HORDE_MACHINE_BOSS |\n    //     HORDE_MACHINE_WATER_MONSTER |\n    //     HORDE_MACHINE_CAPTIVE |\n    //     HORDE_MACHINE_STATUE |\n    //     HORDE_MACHINE_TURRET |\n    //     HORDE_MACHINE_MUD |\n    //     HORDE_MACHINE_KENNEL |\n    //     HORDE_VAMPIRE_FODDER |\n    //     HORDE_MACHINE_LEGENDARY_ALLY |\n    //     HORDE_MACHINE_THIEF |\n    //     HORDE_MACHINE_GOBLIN_WARREN |\n    //     HORDE_SACRIFICE_TARGET,\n})(Horde || (Horde = {}));\n","// TODO - Do we need the machine?\nexport class KeyInfo {\n    constructor(x, y, disposable) {\n        this.x = x;\n        this.y = y;\n        this.disposable = disposable;\n    }\n    matches(x, y) {\n        return this.x === x && this.y === y;\n    }\n}\nexport function makeKeyInfo(x, y, disposable) {\n    return new KeyInfo(x, y, disposable);\n}\n","import * as Flags from '../flags/entity';\nlet lastId = 0;\nexport class Entity {\n    constructor(kind) {\n        this._map = null;\n        this.key = null;\n        this.machineHome = 0;\n        this.depth = 1; // default - TODO - enum/const\n        this.light = null;\n        this.flags = { entity: 0 };\n        this.next = null;\n        this.x = -1;\n        this.y = -1;\n        this.kind = kind;\n        this.id = '' + ++lastId;\n    }\n    get map() {\n        return this._map;\n    }\n    addToMap(map, x, y) {\n        this.x = x;\n        this.y = y;\n        this.setEntityFlag(Flags.Entity.L_ON_MAP);\n        if (this._map === map) {\n            return false;\n        }\n        this._map = map;\n        this.kind.addToMap(this, map);\n        return true;\n    }\n    removeFromMap() {\n        this.clearEntityFlag(Flags.Entity.L_ON_MAP);\n        this.kind.removeFromMap(this);\n    }\n    get sprite() {\n        return this.kind.sprite;\n    }\n    get isDestroyed() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    isAt(x, y) {\n        return this.x === x && this.y === y;\n    }\n    clone() {\n        const other = new this.constructor(this.kind);\n        other.copy(this);\n        return other;\n    }\n    copy(other) {\n        this.depth = other.depth;\n        this.light = other.light;\n        Object.assign(this.flags, other.flags);\n        this.next = other.next;\n        this.x = other.x;\n        this.y = other.y;\n        this.kind = other.kind;\n        this.id = other.id;\n    }\n    canBeSeen() {\n        return this.kind.canBeSeen(this);\n    }\n    destroy() {\n        this.flags.entity |= Flags.Entity.L_DESTROYED;\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasAllEntityFlags(flags) {\n        return (this.flags.entity & flags) === flags;\n    }\n    setEntityFlag(flag) {\n        this.flags.entity |= flag;\n    }\n    clearEntityFlag(flag) {\n        this.flags.entity &= ~flag;\n    }\n    hasTag(tag) {\n        return this.kind.tags.includes(tag);\n    }\n    blocksMove() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksVision() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksPathing() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksEffects() {\n        return this.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    isKey(x, y) {\n        return this.key && this.key.matches(x, y);\n    }\n    forbidsCell(cell) {\n        return this.kind.forbidsCell(cell, this);\n    }\n    avoidsCell(cell) {\n        return this.kind.avoidsCell(cell, this);\n    }\n    getName(opts) {\n        return this.kind.getName(this, opts);\n    }\n    getDescription(opts) {\n        return this.kind.getDescription(this, opts);\n    }\n    getFlavor(opts) {\n        return this.kind.getFlavor(this, opts);\n    }\n    getVerb(verb) {\n        return this.kind.getVerb(this, verb);\n    }\n    drawStatus(buffer, bounds) {\n        return this.kind.drawStatus(this, buffer, bounds);\n    }\n    drawInto(dest, _observer) {\n        dest.drawSprite(this.sprite);\n    }\n    toString() {\n        return `${this.constructor.name}-${this.id} @ ${this.x},${this.y}`;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Entity } from './entity';\nexport class EntityKind {\n    constructor(config) {\n        this.tags = [];\n        this.requiredTileTags = [];\n        this.id = config.id || config.name;\n        this.name = config.name;\n        this.flavor = config.flavor || this.name;\n        this.description = config.description || this.flavor;\n        this.sprite = GWU.sprite.make(config.sprite ? config.sprite : config);\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        if (config.requiredTileTags) {\n            if (typeof config.requiredTileTags === 'string') {\n                this.requiredTileTags = config.requiredTileTags\n                    .split(/[,|]/)\n                    .map((t) => t.trim());\n            }\n            else {\n                this.requiredTileTags = config.requiredTileTags\n                    .slice()\n                    .map((t) => t.trim());\n            }\n        }\n    }\n    make(opts) {\n        const entity = new Entity(this);\n        this.init(entity, opts);\n        return entity;\n    }\n    init(entity, opts = {}) {\n        if (opts.machineHome) {\n            entity.machineHome = opts.machineHome;\n        }\n    }\n    addToMap(_entity, _map) { }\n    removeFromMap(_entity) { }\n    canBeSeen(_entity) {\n        return true;\n    }\n    forbidsCell(cell, _entity) {\n        if (this.requiredTileTags.length &&\n            !cell.hasAllTileTags(this.requiredTileTags)) {\n            return true;\n        }\n        return false;\n    }\n    avoidsCell(cell, _entity) {\n        if (this.requiredTileTags.length &&\n            !cell.hasAnyTileTag(this.requiredTileTags)) {\n            return true;\n        }\n        return false;\n    }\n    getName(_entity, _opts) {\n        return this.name;\n    }\n    getDescription(_entity, _opts) {\n        return this.description;\n    }\n    getFlavor(_entity, _opts) {\n        return this.flavor;\n    }\n    getVerb(_entity, verb) {\n        return verb;\n    }\n    drawStatus(entity, buffer, bounds) {\n        if (!entity.map)\n            return 0;\n        if (entity.isDestroyed)\n            return 0;\n        const mixer = new GWU.sprite.Mixer();\n        entity.map.getAppearanceAt(entity.x, entity.y, mixer);\n        buffer.drawSprite(bounds.x + 1, bounds.y, mixer);\n        buffer.wrapText(bounds.x + 3, bounds.y, bounds.width - 3, entity.getName(), 'purple');\n        return 1;\n    }\n}\nexport function make(opts, makeOpts = {}) {\n    const kind = new EntityKind(opts);\n    return kind.make(makeOpts);\n}\n","import * as GWU from 'gw-utils';\nexport class PainMessages {\n    constructor(msgs = []) {\n        this._msgs = [];\n        msgs.forEach((m) => this.add(m));\n    }\n    add(msg) {\n        this._msgs.push(msg);\n        return this;\n    }\n    get(pct, singular = true) {\n        const index = GWU.clamp(Math.floor(pct * this._msgs.length), 0, this._msgs.length - 1);\n        const msg = this._msgs[index];\n        return this._format(msg, singular);\n    }\n    _format(msg, singular = true) {\n        return msg.replace(/\\[(\\w+)\\|?(\\w*)\\]/g, singular ? '$1' : '$2');\n    }\n}\nexport const painMessages = {};\nexport function installPain(id, pain) {\n    if (Array.isArray(pain)) {\n        pain = new PainMessages(pain);\n    }\n    painMessages[id] = pain;\n}\nexport function getPain(id) {\n    const m = painMessages[id];\n    if (!m)\n        throw new Error('No such pain message index: ' + id);\n    return m;\n}\n","import * as GWU from 'gw-utils';\nexport class Stats {\n    constructor(opts = {}) {\n        this._max = {};\n        this._rate = {};\n        this._value = {};\n        this.init(opts);\n    }\n    get(name) {\n        return this._value[name];\n    }\n    getPct(name) {\n        return Math.round((100 * this._value[name]) / this._max[name]);\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    regen(name) {\n        return this._rate[name] || null;\n    }\n    init(opts) {\n        for (let name in opts) {\n            this.set(name, opts[name]);\n        }\n    }\n    set(name, v, max) {\n        if (typeof v !== 'number') {\n            const r = GWU.range.make(v);\n            v = r.value();\n        }\n        this._value[name] = v;\n        this._max[name] = max || v;\n    }\n    gain(name, amount, allowOver = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        let v = this._value[name] + amount;\n        if (!allowOver) {\n            v = Math.min(v, this._max[name]);\n        }\n        this._value[name] = v;\n    }\n    drain(name, amount) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._value[name] = Math.max(0, this._value[name] - amount);\n    }\n    raiseMax(name, amount, raiseValue = true) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] += amount;\n        if (raiseValue) {\n            this.gain(name, amount);\n        }\n    }\n    reduceMax(name, amount, lowerValue = false) {\n        if (typeof amount !== 'number') {\n            amount = GWU.range.value(amount);\n        }\n        this._max[name] = Math.max(0, this._max[name] - amount);\n        if (lowerValue) {\n            this.drain(name, amount);\n        }\n    }\n    setRegen(name, turns, count = 1) {\n        const r = (this._rate[name] = this._rate[name] || { elapsed: 0 });\n        r.turns = turns;\n        r.count = count;\n    }\n    regenAll() {\n        for (let name in this._max) {\n            const r = this._rate[name];\n            r.elapsed += 1;\n            if (r.elapsed >= r.turns) {\n                this.gain(name, r.count);\n                r.elapsed -= r.turns;\n            }\n        }\n    }\n    restore(name, value) {\n        if (value === undefined)\n            value = this._max[name];\n        this._value[name] = value;\n    }\n    adjust(name, type, amount) {\n        amount = GWU.range.from(amount);\n        const v = amount.value();\n        const c = this.get(name);\n        if (type === 'inc') {\n            this.gain(name, amount);\n        }\n        else if (type === 'dec') {\n            this.drain(name, amount);\n        }\n        else if (type === 'set') {\n            this.set(name, amount);\n        }\n        else if (type === 'min') {\n            const v = amount.value();\n            if (this.get(name) < v) {\n                this.set(name, v);\n            }\n        }\n        else if (type === 'max') {\n            if (this.get(name) > v) {\n                this.set(name, v);\n            }\n        }\n        else {\n            throw new Error('Invalid stat adjust type: ' + type);\n        }\n        return c !== this.get(name);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport class Status {\n    constructor() {\n        this._set = {};\n        this._time = {};\n        this._count = {};\n        this._done = {};\n        this._value = {};\n        this.changed = null;\n    }\n    clear(name) {\n        this.clearTime(name);\n        this.clearCount(name);\n        this.setOff(name);\n        return this._update(name);\n    }\n    get(name) {\n        return this._value[name] || false;\n    }\n    has(name) {\n        return this._value[name] || false;\n    }\n    _addDone(name, done) {\n        if (done) {\n            if (!this._done[name]) {\n                this._done[name] = done;\n            }\n        }\n    }\n    /**\n     * Sets the count for a status variable.\n     * If setting the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} count The count to set.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not setting the count turned the status on.\n     */\n    setCount(name, count, done) {\n        const status = this;\n        status._count[name] = Math.max(count, status._count[name] || 0);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Increments the count for the status by the given amount (1=default)\n     * If incrementing the count turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {number} [count=1] The count to incrmeent.\n     * @param {function} [done] The function to call whenever the count goes to 0.\n     * @returns {boolean} Whether or not incrementing the count turned the status on.\n     */\n    increment(name, count = 1, done) {\n        if (typeof count == 'function') {\n            done = count;\n            count = 1;\n        }\n        const status = this;\n        status._count[name] = (status._count[name] || 0) + count;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Decrements the count for the status by the given amount (1=default)\n     * If decrementing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @param {number} [count=1] The count to decrement.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    decrement(name, count = 1) {\n        const status = this;\n        status._count[name] = Math.max(0, (status._count[name] || 0) - count);\n        return this._update(name);\n    }\n    /**\n     * Clears all counts from the given status.\n     * If clearing the count turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * Also, if the status is turned off, and a done function was set, then it\n     * is called.\n     * @param {string} name The name of the status to adjust.\n     * @returns {boolean} Whether or not decrementing the count turned the status off.\n     */\n    clearCount(name) {\n        const status = this;\n        status._count[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Turns on the given status.\n     * @param {string} name The status to adjust.\n     * @param {function} [done] The function to call when the status is turned off.\n     * @returns {boolean} True if this turns on the status. (It could be on because of a time or count).\n     */\n    setOn(name, done) {\n        const status = this;\n        status._set[name] = true;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Turns off the given status.\n     *\n     * @param {string} name The status to adjust.\n     * @returns {boolean} True if this turns off the status. (It could be on because of a time or count).\n     */\n    setOff(name) {\n        const status = this;\n        status._set[name] = false;\n        return this._update(name);\n    }\n    /**\n     * Sets the time for a status variable.\n     * If setting the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to set.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not setting the time turned the status on.\n     */\n    setTime(name, value, done) {\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        const current = status._time[name] || 0;\n        status._time[name] = Math.max(value, current);\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Adds to the time for a status variable.\n     * If adding to the time turns on the status (it was off),\n     * then this function returns true.  Otherwise, false.\n     * The done variable is only set if there is no other done function\n     * already for this status.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to add.\n     * @param {function} [done] The function to call whenever the status goes false.\n     * @returns {boolean} Whether or not adding the time turned the status on.\n     */\n    addTime(name, value = 1, done) {\n        if (typeof value == 'function') {\n            done = value;\n            value = 1;\n        }\n        const status = this;\n        // if (value === true) {\n        //   return RUT.Status.setOn(source, name, done);\n        // }\n        value = GWU.range.make(value).value();\n        status._time[name] = (status._time[name] || 0) + value;\n        this._addDone(name, done);\n        return this._update(name);\n    }\n    /**\n     * Removes time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @param {GWU.range.RangeBase} time The time value to remove.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    removeTime(name, value = 1) {\n        const status = this;\n        value = GWU.range.make(value).value();\n        status._time[name] = Math.max(0, (status._time[name] || 0) - value);\n        return this._update(name);\n    }\n    /**\n     * Removes all time for a status variable.\n     * If removing to the time turns off the status (it was on),\n     * then this function returns true.  Otherwise, false.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean} Whether or not removing the time turned the status off.\n     */\n    clearTime(name) {\n        const status = this;\n        status._time[name] = 0;\n        return this._update(name);\n    }\n    /**\n     * Removes time for all status variables that have time.\n     * If removing the time turns off any status (it was on),\n     * then this function returns an object with all of those statuses as keys and false as the values.  Otherwise, false.\n     * @param {Status|object} source The object to set the status on.  If object.status is set then that is where the values are updated.\n     * @param {string} name The name of the status to set.\n     * @returns {boolean|object} false or an object with the names of the statuses that were cleared as keys and false as the values.\n     */\n    decayAllTimes(delta = 1) {\n        const status = this;\n        const cleared = {};\n        let noticed = false;\n        for (let name in status._time) {\n            if (this.removeTime(name, delta)) {\n                noticed = true;\n                cleared[name] = false;\n            }\n        }\n        return noticed ? cleared : false;\n    }\n    /**\n     * Updates the value of the status and returns whether or not this change\n     * turned the status on or off (true = change, false = no change)\n     * @param {string} name The name of the status to update\n     * @returns {boolean} True if the value was turned on or off, False otherwise.\n     */\n    _update(name) {\n        const status = this;\n        const rec = this._value;\n        let was = rec[name];\n        let value = (rec[name] =\n            status._set[name] ||\n                status._time[name] > 0 ||\n                status._count[name] > 0 ||\n                false);\n        const doneFn = this._done[name];\n        if (!value && doneFn) {\n            doneFn(this, name);\n            status._done[name] = null;\n        }\n        if (was && !value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: false');\n            return true;\n        }\n        else if (!was && value) {\n            if (this.changed)\n                this.changed(this, name);\n            // console.log('called changed: true');\n            return true;\n        }\n        return false;\n    }\n}\n","export const installedActions = {};\nexport function installAction(name, fn) {\n    installedActions[name.toLowerCase()] = fn;\n}\nexport function getAction(name) {\n    return installedActions[name.toLowerCase()] || null;\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { getAction } from './action';\nimport { Status } from './status';\nimport { Stats } from './stat';\nexport class Actor extends Entity.Entity {\n    constructor(kind) {\n        super(kind);\n        this.ai = null;\n        this.leader = null;\n        this.items = null; // inventory\n        this.fov = null;\n        this.memory = null;\n        this.visionDistance = 99;\n        this.data = {};\n        this._costMap = null;\n        this.next = null; // TODO - can we get rid of this?\n        // @ts-ignore - initialized in Entity\n        this.flags.actor = 0;\n        this.depth = Flags.Depth.ACTOR;\n        this.kind = kind;\n        this.stats = new Stats();\n        this.status = new Status();\n    }\n    copy(other) {\n        super.copy(other);\n        this.leader = other.leader;\n        this.items = other.items;\n        this.fov = other.fov;\n        this.memory = other.memory;\n        this.visionDistance = other.visionDistance;\n    }\n    destroy() {\n        this.setEntityFlag(Flags.Entity.L_DESTROYED);\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    hasAllActorFlags(flags) {\n        return (this.flags.actor & flags) === flags;\n    }\n    actorFlags() {\n        return this.flags.actor;\n    }\n    setActorFlag(flag) {\n        this.flags.actor |= flag;\n    }\n    clearActorFlag(flag) {\n        this.flags.actor &= ~flag;\n    }\n    isPlayer() {\n        return this.hasActorFlag(Flags.Actor.IS_PLAYER);\n    }\n    isDead() {\n        return this.hasEntityFlag(Flags.Entity.L_DESTROYED);\n    }\n    getAction(name) {\n        const action = this.kind.actions[name];\n        if (action === undefined)\n            return true; // default is to do any action\n        if (action === true) {\n            return getAction(name) || true;\n        }\n        else if (action === false) {\n            return false;\n        }\n        return action;\n    }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n    canSee(x, y) {\n        if (x instanceof Entity.Entity) {\n            return this.canSee(x.x, x.y) && this.kind.isAbleToSee(this, x);\n        }\n        if (this.fov) {\n            return this.fov.isDirectlyVisible(x, y);\n        }\n        else if (this.map) {\n            if (GWU.xy.distanceBetween(this.x, this.y, x, y) >\n                this.visionDistance) {\n                return false;\n            }\n            return GWU.xy.forLineBetween(this.x, this.y, x, y, (i, j) => {\n                if (this.map.cell(i, j).blocksVision())\n                    return false;\n            });\n        }\n        else {\n            return false; // need a map or an fov\n        }\n    }\n    canSeeOrSense(x, y) {\n        if (x instanceof Entity.Entity) {\n            return (this.canSeeOrSense(x.x, x.y) &&\n                (this.kind.isAbleToSee(this, x) ||\n                    this.kind.isAbleToSense(this, x)));\n        }\n        if (this.fov) {\n            return this.fov.isAnyKindOfVisible(x, y);\n        }\n        return this.canSee(x, y);\n    }\n    isAbleToSee(entity) {\n        return this.kind.isAbleToSee(this, entity);\n    }\n    isAbleToSense(entity) {\n        return this.kind.isAbleToSense(this, entity);\n    }\n    ////////////////// ACTOR\n    async act(game) {\n        if (this.ai) {\n            const r = await this.ai(game, this);\n            if (r)\n                return r;\n        }\n        if (this.kind.ai) {\n            const r = await this.kind.ai(game, this);\n            if (r)\n                return r;\n        }\n        // idle - always\n        return this.moveSpeed();\n    }\n    moveSpeed() {\n        return this.kind.moveSpeed;\n    }\n    startTurn() { }\n    endTurn(pct = 100) {\n        return Math.floor((pct * this.moveSpeed()) / 100);\n    }\n    ///////\n    willAttack(_other) {\n        return true;\n    }\n    ////////////////// INVENTORY\n    avoidsItem(_item) {\n        return false;\n    }\n    canAddItem(_item) {\n        return false;\n    }\n    addItem(_item) { }\n    pickupItem(item, opts) {\n        return this.kind.pickupItem(this, item, opts);\n    }\n    dropItem(item, opts) {\n        return this.kind.dropItem(this, item, opts);\n    }\n    // PATHFINDING\n    addToMap(map, x, y) {\n        const mapChanged = super.addToMap(map, x, y);\n        if (mapChanged) {\n            this.setActorFlag(Flags.Actor.STALE_COST_MAP);\n        }\n        return mapChanged;\n    }\n    removeFromMap() {\n        super.removeFromMap();\n        if (this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n    }\n    /*\n    Calculates and returns the actor's move cost map.\n    Used in pathfinding.\n    */\n    costMap() {\n        if (!this.map) {\n            throw new Error('Actor must have map to calculate costMap.');\n        }\n        const staleMap = this.hasActorFlag(Flags.Actor.STALE_COST_MAP);\n        if (staleMap && this._costMap) {\n            GWU.grid.free(this._costMap);\n            this._costMap = null;\n        }\n        if (!this._costMap) {\n            this._costMap = GWU.grid.alloc(this.map.width, this.map.height);\n        }\n        else if (!staleMap) {\n            return this._costMap;\n        }\n        const kind = this.kind;\n        const map = this.map;\n        this._costMap.update((_v, x, y) => {\n            const cell = map.cell(x, y);\n            if (kind.forbidsCell(cell, this)) {\n                return cell.hasEntityFlag(Flags.Entity.L_BLOCKS_DIAGONAL)\n                    ? GWU.path.OBSTRUCTION\n                    : GWU.path.FORBIDDEN;\n            }\n            else if (kind.avoidsCell(cell, this)) {\n                return GWU.path.AVOIDED;\n            }\n            return GWU.path.OK;\n        });\n        this.clearActorFlag(Flags.Actor.STALE_COST_MAP);\n        /*\n\n            if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n            && (!cellHasTMFlag(i, j, TM_IS_SECRET) || (discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)))\n            {\n                playerCostMap[i][j] = monsterCostMap[i][j] = cellHasTerrainFlag(i, j, T_OBSTRUCTS_DIAGONAL_MOVEMENT) ? PDS_OBSTRUCTION : PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_SACRED)) {\n                    playerCostMap[i][j] = 1;\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n            } else if (cellHasTerrainFlag(i, j, T_LAVA_INSTA_DEATH)) {\n        monsterCostMap[i][j] = PDS_FORBIDDEN;\n        if (player.status[STATUS_LEVITATING] || !player.status[STATUS_IMMUNE_TO_FIRE]) {\n            playerCostMap[i][j] = 1;\n        } else {\n            playerCostMap[i][j] = PDS_FORBIDDEN;\n        }\n            } else {\n                if (pmap[i][j].flags & HAS_MONSTER) {\n                    monst = monsterAtLoc(i, j);\n                    if ((monst.creatureState == MONSTER_SLEEPING\n                         || monst.turnsSpentStationary > 2\n             || (monst.info.flags & MONST_GETS_TURN_ON_ACTIVATION)\n                         || monst.creatureState == MONSTER_ALLY)\n                        && monst.creatureState != MONSTER_FLEEING)\n                    {\n                        playerCostMap[i][j] = 1;\n                        monsterCostMap[i][j] = PDS_FORBIDDEN;\n                        continue;\n                    }\n                }\n\n                if (cellHasTerrainFlag(i, j, (T_AUTO_DESCENT | T_IS_DF_TRAP))) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, T_IS_FIRE)) {\n                    monsterCostMap[i][j] = PDS_FORBIDDEN;\n          if (player.status[STATUS_IMMUNE_TO_FIRE]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = PDS_FORBIDDEN;\n          }\n                } else if (cellHasTerrainFlag(i, j, (T_IS_DEEP_WATER | T_SPONTANEOUSLY_IGNITES))) {\n          if (player.status[STATUS_LEVITATING]) {\n              playerCostMap[i][j] = 1;\n          } else {\n              playerCostMap[i][j] = 5;\n          }\n                    monsterCostMap[i][j] = 5;\n        } else if (cellHasTerrainFlag(i, j, T_OBSTRUCTS_PASSABILITY)\n                   && cellHasTMFlag(i, j, TM_IS_SECRET) && !(discoveredTerrainFlagsAtLoc(i, j) & T_OBSTRUCTS_PASSABILITY)\n                   && !(pmap[i][j].flags & IN_FIELD_OF_VIEW))\n             {\n            // Secret door that the player can't currently see\n            playerCostMap[i][j] = 100;\n            monsterCostMap[i][j] = 1;\n                } else {\n                    playerCostMap[i][j] = monsterCostMap[i][j] = 1;\n                }\n            }\n        }\n    }\n        */\n        return this._costMap;\n    }\n}\n","export const handlers = {};\nexport function installHandler(id, handler) {\n    handlers[id.toLowerCase()] = handler;\n}\nexport const effectTypes = {};\nexport function installType(id, type) {\n    effectTypes[id] = type;\n}\n// export class Effect {\n//     id = '';\n//     chance = 100 * 100; // 100%\n//     type: string; // self | bolt | beam | ball | burst | adjacent | spread\n//     aim: string; // actor | item | cell\n//     bolt: string | GWU.sprite.SpriteData | null = null;\n//     beam = false;\n//     range = 0;\n//     ball: string | GWU.sprite.SpriteData | null = null;\n//     radius = 0;\n//     center = false;\n//     effects: EffectFn[];\n//     good = false;\n//     seen = false;\n//     next: Effect | null = null;\n//     constructor(config: EffectConfig) {\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         this.aim = config.aim || 'actor';\n//         if (typeof config.chance === 'string') {\n//             // '20%' becomes 2000\n//             config.chance = Math.floor(Number.parseFloat(config.chance) * 100);\n//         }\n//         this.chance = config.chance || 100 * 100;\n//         const type = config.type || 'basic';\n//         const parts = type.split(':');\n//         if (type.startsWith('bolt') || type.startsWith('beam')) {\n//             // bolt:range:sprite\n//             this.type = parts[0];\n//             this.range = parts[1] ? Number.parseInt(parts[1]) : 99;\n//             this.bolt = parts[1] || 'missile';\n//             this.beam = type.startsWith('beam');\n//         } else if (\n//             type.startsWith('ball') ||\n//             type.startsWith('burst') ||\n//             type.startsWith('aura')\n//         ) {\n//             this.type = parts[0];\n//             this.radius = parts[1] ? Number.parseInt(parts[1]) : 2;\n//             this.range = parts[2] ? Number.parseInt(parts[2]) : 99;\n//             this.ball = parts[3] || 'explosion';\n//             this.center = !type.startsWith('aura');\n//         } else {\n//             this.type = 'basic';\n//         }\n//         if (typeof config.effects === 'string') {\n//             config.effects = [config.effects];\n//         } else if (typeof config.effects === 'function') {\n//             config.effects = [config.effects];\n//         }\n//         if (Array.isArray(config.effects)) {\n//             this.effects = config.effects.map((e) => {\n//                 if (typeof e === 'function') return e;\n//                 return effectFnFromString(e);\n//             });\n//         } else {\n//             this.effects = [];\n//             Object.entries(config.effects).forEach(([key, value]) => {\n//                 const handler = handlers[key.toLowerCase()];\n//                 if (handler) {\n//                     this.effects.push(handler(value));\n//                 } else if (typeof value === 'function') {\n//                     this.effects.push(value);\n//                 } else {\n//                     throw new Error('Unknown effect: ' + key);\n//                 }\n//             });\n//         }\n//         if (this.effects.length === 0) throw new Error('No effects!');\n//     }\n//     clone(): this {\n//         const other = new (this.constructor as new (\n//             config: EffectConfig\n//         ) => this)(this as EffectConfig);\n//         return other;\n//     }\n//     fire(map: Map.MapType, x: number, y: number, ctx: EffectCtx = {}): boolean {\n//         let didSomething = false;\n//         ctx.good = this.good;\n//         ctx.seen = this.seen;\n//         if (!this.chance || map.rng.chance(this.chance, 10000)) {\n//             // fire\n//             for (let effect of this.effects) {\n//                 if (GWU.data.gameHasEnded) break;\n//                 if (effect(map, x, y, ctx)) {\n//                     didSomething = true;\n//                 } else {\n//                     break;\n//                 }\n//             }\n//         }\n//         if (ctx.aware && didSomething) {\n//             this.seen = true;\n//         }\n//         this.good = ctx.good;\n//         return didSomething;\n//     }\n//     reset() {\n//         this.seen = false;\n//     }\n// }\n// export function effectFnFromString(e: string): EffectFn {\n//     const parts = e.split(':');\n//     if (parts.length === 0) throw new Error('Invalid effect string.');\n//     // @ts-ignore\n//     const name = parts.shift().toLowerCase();\n//     const handler = handlers[name] || null;\n//     if (!handler) {\n//         throw new Error('Failed to find effect handler: ' + name);\n//     }\n//     return handler(parts);\n// }\nexport function make(opts) {\n    if (!opts)\n        throw new Error('opts required to make effect.');\n    let config = {};\n    if (typeof opts === 'string') {\n        // Special case\n        if (opts.toLowerCase().startsWith('spread:')) {\n            const endPos = opts.indexOf(':', 8);\n            const tile = opts.substring(8, endPos);\n            config = {\n                type: 'spread:' + opts.substring(endPos),\n                effects: ['tile:' + tile],\n            };\n        }\n        else {\n            config = { type: 'basic', effects: [opts] };\n        }\n    }\n    else if (typeof opts === 'function') {\n        config = { type: 'basic', effects: [opts] };\n    }\n    else if (Array.isArray(opts)) {\n        config = { type: 'basic', effects: opts };\n    }\n    else {\n        // @ts-ignore\n        if (opts.effect) {\n            // @ts-ignore\n            opts.effects = [opts.effect];\n            delete opts.effect;\n        }\n        // object only\n        if (opts.effects) {\n            Object.assign(config, opts);\n            if (typeof config.effects === 'string') {\n                config.effects = [opts.effects];\n            }\n            else if (typeof config.effects === 'function') {\n                config.effects = [opts.effects];\n            }\n        }\n        else {\n            config.effects = {};\n            Object.entries(opts).forEach(([key, value]) => {\n                const handler = handlers[key.toLowerCase()];\n                if (handler !== undefined) {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                }\n                else if (typeof value === 'function') {\n                    // @ts-ignore\n                    config.effects[key] = value;\n                }\n                else {\n                    // @ts-ignore\n                    config[key] = value;\n                }\n            });\n        }\n    }\n    config.type = config.type || 'basic';\n    if (typeof config.type !== 'string')\n        throw new Error('Invalid effect type: ' + JSON.stringify(config.type));\n    const typeParts = config.type.split(':').map((t) => t.trim());\n    const typeName = typeParts.shift();\n    const makeFn = effectTypes[typeName.toLowerCase()];\n    if (!makeFn)\n        throw new Error('Invalid effect type: ' + typeName);\n    const effect = makeFn(config);\n    if (Array.isArray(config.effects)) {\n        config.effects.forEach((e) => {\n            if (typeof e === 'function') {\n                effect.effects.push(e);\n            }\n            else {\n                const parts = e.split(':').map((t) => t.trim());\n                if (parts.length === 1) {\n                    const effect = installedEffects[parts[0]];\n                    if (!effect)\n                        throw new Error('Failed to find effect with id: ' + parts[0]);\n                    effect.effects.push(effect.trigger.bind(effect));\n                }\n                else {\n                    const handler = handlers[parts[0].toLowerCase()];\n                    if (!handler)\n                        throw new Error('Unknown effect: ' + parts[0]);\n                    parts.shift();\n                    effect.effects.push(handler(parts));\n                }\n            }\n        });\n    }\n    else {\n        Object.entries(config.effects).forEach(([key, value]) => {\n            const handler = handlers[key.toLowerCase()];\n            if (!handler)\n                throw new Error('Failed to find handler type: ' + key);\n            effect.effects.push(handler(value));\n        });\n    }\n    if (config.next) {\n        effect.next = make(config.next);\n    }\n    return effect;\n}\nexport function from(opts) {\n    if (!opts)\n        throw new Error('Cannot make effect from null | undefined');\n    if (typeof opts === 'object' && 'trigger' in opts) {\n        return opts;\n    }\n    if (typeof opts === 'string') {\n        const effect = installedEffects[opts];\n        if (effect)\n            return effect;\n        throw new Error('Unknown effect - ' + opts);\n    }\n    return make(opts);\n}\nfunction isEffect(obj) {\n    return typeof obj === 'object' && 'trigger' in obj;\n}\n//////////////////////////////\n// INSTALL\nexport const installedEffects = {};\nexport function install(id, config) {\n    const effect = isEffect(config) ? config.clone() : make(config);\n    installedEffects[id] = effect;\n    return effect;\n}\nexport function installAll(effects) {\n    Object.entries(effects).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function resetAll() {\n    Object.values(installedEffects).forEach((e) => (e.seen = false));\n}\n","import * as GWU from 'gw-utils';\nimport { make as makeEffect } from '../effect/effect';\nimport * as Flags from '../flags';\nexport class Tile {\n    constructor(config) {\n        var _a, _b, _c, _d;\n        this.index = -1;\n        this.dissipate = 20 * 100; // 0%\n        this.effects = {};\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.groundTile = null;\n        this.tags = [];\n        this.id = config.id || 'n/a';\n        this.dissipate = (_a = config.dissipate) !== null && _a !== void 0 ? _a : this.dissipate;\n        this.priority = (_b = config.priority) !== null && _b !== void 0 ? _b : this.priority;\n        this.depth = (_c = config.depth) !== null && _c !== void 0 ? _c : this.depth;\n        this.light = config.light || null;\n        this.groundTile = config.groundTile || null;\n        this.sprite = GWU.sprite.make(config);\n        this.name = config.name || 'tile';\n        this.description = config.description || this.name;\n        this.flavor = config.flavor || this.name;\n        this.article = (_d = config.article) !== null && _d !== void 0 ? _d : null;\n        this.flags = config.flags || { entity: 0, tile: 0, tileMech: 0 };\n        if (config.effects) {\n            Object.assign(this.effects, config.effects);\n        }\n        if (this.hasEffect('fire')) {\n            this.flags.tile |= Flags.Tile.T_IS_FLAMMABLE;\n        }\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                config.tags\n                    .split(/[,|]/)\n                    .map((t) => t.trim())\n                    .forEach((t) => {\n                    this.tags.push(t);\n                });\n            }\n            else {\n                this.tags = config.tags.slice().map((t) => t.trim());\n            }\n        }\n    }\n    hasTag(tag) {\n        return this.tags.includes(tag);\n    }\n    hasAnyTag(tags) {\n        return GWU.arraysIntersect(this.tags, tags);\n    }\n    hasAllTags(tags) {\n        return tags.every((t) => this.tags.includes(t));\n    }\n    hasEntityFlag(flag) {\n        return !!(this.flags.entity & flag);\n    }\n    hasTileFlag(flag) {\n        return !!(this.flags.tile & flag);\n    }\n    hasTileMechFlag(flag) {\n        return !!(this.flags.tileMech & flag);\n    }\n    hasAllEntityFlags(flag) {\n        return (this.flags.entity & flag) === flag;\n    }\n    hasAllTileFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllTileMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksVision() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_VISION);\n    }\n    blocksMove() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_MOVE);\n    }\n    blocksPathing() {\n        return (this.blocksMove() || this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    blocksEffects() {\n        return !!(this.flags.entity & Flags.Entity.L_BLOCKS_EFFECTS);\n    }\n    hasEffect(name) {\n        return name in this.effects;\n    }\n    getName(arg) {\n        let opts = {};\n        if (typeof arg === 'boolean') {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = GWU.color.from(color).toString();\n            }\n            result = `${color}${this.name}`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription(opts) {\n        return this.description || this.getName(opts);\n    }\n    getFlavor(opts) {\n        return this.flavor || this.getName(opts);\n    }\n}\nexport function make(options) {\n    var _a, _b, _c, _d, _e, _f;\n    let base = { effects: {}, flags: {}, sprite: {}, priority: 50 };\n    if (options.extends) {\n        base = tiles[options.extends];\n        if (!base)\n            throw new Error('Failed to find base tile: ' + options.extends);\n    }\n    let priority = base.priority;\n    if (typeof options.priority === 'string') {\n        let text = options.priority.replace(/ /g, '');\n        let index = text.search(/[+-]/);\n        if (index == 0) {\n            priority = base.priority + Number.parseInt(text);\n        }\n        else if (index == -1) {\n            if (text.search(/[a-zA-Z]/) == 0) {\n                const tile = tiles[text];\n                if (!tile)\n                    throw new Error('Failed to find tile for priority - ' + text + '.');\n                priority = tile.priority;\n            }\n            else {\n                priority = Number.parseInt(text);\n            }\n        }\n        else {\n            const id = text.substring(0, index);\n            const delta = Number.parseInt(text.substring(index));\n            const tile = tiles[id];\n            if (!tile)\n                throw new Error('Failed to find tile for priority - ' + id + '.');\n            priority = tile.priority + delta;\n        }\n    }\n    else if (options.priority !== undefined) {\n        priority = options.priority;\n    }\n    const effects = {};\n    Object.assign(effects, base.effects);\n    if (options.effects) {\n        Object.entries(options.effects).forEach(([key, value]) => {\n            if (value === null) {\n                delete effects[key];\n                return;\n            }\n            if (typeof value === 'string' && !value.includes(':')) {\n                effects[key] = value;\n                return;\n            }\n            try {\n                effects[key] = makeEffect(value);\n            }\n            catch (e) {\n                throw new Error(`Failed to add effect to tile => ${key} : ${JSON.stringify(value)} : ` + e.message);\n            }\n        });\n    }\n    const flags = {\n        entity: GWU.flag.from(Flags.Entity, base.flags.entity, options.flags),\n        tile: GWU.flag.from(Flags.Tile, base.flags.tile, options.flags),\n        tileMech: GWU.flag.from(Flags.TileMech, base.flags.tileMech, options.flags),\n    };\n    let depth = base.depth || 0;\n    if (options.depth) {\n        if (typeof options.depth === 'string') {\n            depth = Flags.Depth[options.depth];\n        }\n        else {\n            depth = options.depth;\n        }\n    }\n    let light = base.light;\n    if (options.light) {\n        light = GWU.light.make(options.light);\n    }\n    else if (options.light === null) {\n        light = null;\n    }\n    const config = {\n        id: options.id,\n        flags,\n        dissipate: (_a = options.dissipate) !== null && _a !== void 0 ? _a : base.dissipate,\n        effects,\n        priority,\n        depth: depth,\n        light,\n        groundTile: options.groundTile || null,\n        ch: (_b = options.ch) !== null && _b !== void 0 ? _b : base.sprite.ch,\n        fg: (_c = options.fg) !== null && _c !== void 0 ? _c : base.sprite.fg,\n        bg: (_d = options.bg) !== null && _d !== void 0 ? _d : base.sprite.bg,\n        opacity: (_e = options.opacity) !== null && _e !== void 0 ? _e : base.sprite.opacity,\n        name: options.name || base.name,\n        description: options.description || base.description,\n        flavor: options.flavor || base.flavor,\n        article: (_f = options.article) !== null && _f !== void 0 ? _f : base.article,\n        tags: options.tags || null,\n    };\n    const tile = new Tile(config);\n    return tile;\n}\nexport const tiles = {};\nexport const all = [];\nexport function get(id) {\n    if (id instanceof Tile)\n        return id;\n    if (typeof id === 'string')\n        return tiles[id] || null;\n    return all[id] || null;\n}\nexport function install(id, ...args) {\n    let options = args[0];\n    if (args.length == 2) {\n        options = args[1];\n        options.extends = args[0];\n    }\n    options.id = id;\n    const tile = make(options);\n    tile.index = all.length;\n    all.push(tile);\n    tiles[id] = tile;\n    return tile;\n}\nexport function installAll(tiles) {\n    Object.entries(tiles).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\n","import { Tile, TileMech } from '../flags';\nexport const flags = { Tile, TileMech };\nexport * from './types';\nexport * from './tile';\n// import './tiles';\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nimport * as Flags from '../../flags';\nexport class BasicEffect {\n    constructor(config) {\n        this.effects = [];\n        this.chance = 100 * 100; // 100%\n        this.seen = false;\n        this.flags = 0;\n        this.next = null;\n        if (typeof config === 'object' && !Array.isArray(config)) {\n            this.flags = GWU.flag.from(Flags.Effect, config.flags);\n            this.chance = Number.parseInt(config.chance || '10000');\n        }\n    }\n    clone() {\n        const other = new this.constructor();\n        other.effects = this.effects.slice();\n        other.chance = this.chance;\n        other.seen = false;\n        other.flags = this.flags;\n        other.next = this.next;\n        return other;\n    }\n    trigger(loc, ctx = {}) {\n        if (!ctx.force && this.chance) {\n            const rng = ctx.rng || loc.map.rng || GWU.random;\n            if (!rng.chance(this.chance, 10000))\n                return false;\n        }\n        let didSomething = false;\n        for (let eff of this.effects) {\n            if (eff(loc, ctx)) {\n                didSomething = true;\n            }\n        }\n        if (this.next) {\n            const nextAlways = !!(this.flags & Flags.Effect.E_NEXT_ALWAYS);\n            if (didSomething || nextAlways) {\n                return this.next.trigger(loc, ctx);\n            }\n        }\n        return didSomething;\n    }\n}\nexport function makeBasicEffect(config) {\n    if (typeof config !== 'object') {\n        return new BasicEffect();\n    }\n    return new BasicEffect(config);\n}\nEffect.installType('basic', makeBasicEffect);\n","import * as GWU from 'gw-utils';\nimport { BasicEffect } from './basic';\nimport { installType } from '../effect';\nimport * as Flags from '../../flags';\nexport function makeSpreadEffect(config) {\n    return new SpreadEffect(config);\n}\ninstallType('spread', makeSpreadEffect);\nexport class SpreadEffect extends BasicEffect {\n    constructor(config) {\n        super(config);\n        this.grow = 0;\n        this.decrement = 0;\n        this.matchTile = '';\n        if (!config) {\n            config = { grow: 0, decrement: 0, flags: 0 };\n        }\n        if (typeof config === 'string') {\n            config = config.split(':').map((t) => t.trim());\n        }\n        if (Array.isArray(config)) {\n            if (config[0].toLowerCase() === 'spread') {\n                config.shift();\n            }\n            config = {\n                grow: config[0] || '0',\n                decrement: config[1] || '100',\n                flags: config[2] || '0',\n            };\n        }\n        else if (typeof config.type === 'string' &&\n            config.type.includes(':')) {\n            const parts = config.type.split(':').map((t) => t.trim());\n            if (parts[0].toLowerCase() === 'spread') {\n                parts.shift();\n            }\n            config.grow = parts[0] || '0';\n            config.decrement = parts[1] || '100';\n            config.flags = config.flags + '|' + parts[2];\n        }\n        this.grow = Number.parseInt(config.grow || 0);\n        this.decrement = Number.parseInt(config.decrement || 100);\n        this.flags = GWU.flag.from(Flags.Effect, config.flags || 0);\n        this.matchTile = config.matchTile || '';\n    }\n    clone() {\n        const other = super.clone();\n        other.grow = this.grow;\n        other.decrement = this.decrement;\n        other.matchTile = this.matchTile;\n        return other;\n    }\n    trigger(xy, ctx = {}) {\n        const abortIfBlocking = !!(this.flags & Flags.Effect.E_ABORT_IF_BLOCKS_MAP);\n        let didSomething = false;\n        const map = xy.map;\n        const spawnMap = GWU.grid.alloc(map.width, map.height);\n        didSomething = computeSpawnMap(this, xy, spawnMap);\n        if (!didSomething) {\n            GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (abortIfBlocking && mapDisruptedBy(map, spawnMap)) {\n            GWU.grid.free(spawnMap);\n            return false;\n        }\n        if (this.flags & Flags.Effect.E_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (this.flags & Flags.Effect.E_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (this.flags & Flags.Effect.E_CLEAR_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (clearCells(map, spawnMap, this.flags)) {\n                didSomething = true;\n            }\n        }\n        spawnMap.forEach((v, x, y) => {\n            if (!v)\n                return;\n            spawnMap[x][y] = 1; // convert from generations to off/on/success\n            for (let eff of this.effects) {\n                if (eff({ map, x, y }, ctx)) {\n                    didSomething = true;\n                    spawnMap[x][y] = 2;\n                }\n            }\n        });\n        if (this.next) {\n            const nextAlways = !!(this.flags & Flags.Effect.E_NEXT_ALWAYS);\n            if (didSomething || nextAlways) {\n                if (this.flags & Flags.Effect.E_NEXT_EVERYWHERE) {\n                    spawnMap.forEach((v, x, y) => {\n                        if (!v)\n                            return;\n                        if (v == 2 || nextAlways) {\n                            this.next.trigger({ map, x, y }, ctx);\n                        }\n                    });\n                }\n                else {\n                    this.next.trigger({ map, x: xy.x, y: xy.y }, ctx);\n                }\n            }\n        }\n        GWU.grid.free(spawnMap);\n        return didSomething;\n    }\n}\nexport function mapDisruptedBy(map, blockingGrid, blockingToMapX = 0, blockingToMapY = 0) {\n    const walkableGrid = GWU.grid.alloc(map.width, map.height);\n    let disrupts = false;\n    // Get all walkable locations after lake added\n    GWU.xy.forRect(map.width, map.height, (i, j) => {\n        const lakeX = i + blockingToMapX;\n        const lakeY = j + blockingToMapY;\n        if (blockingGrid.get(lakeX, lakeY)) {\n            if (map.cell(i, j).isStairs()) {\n                disrupts = true;\n            }\n        }\n        else if (!map.cell(i, j).blocksMove()) {\n            walkableGrid[i][j] = 1;\n        }\n    });\n    let first = true;\n    for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n        for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n            if (walkableGrid[i][j] == 1) {\n                if (first) {\n                    walkableGrid.floodFill(i, j, 1, 2);\n                    first = false;\n                }\n                else {\n                    disrupts = true;\n                }\n            }\n        }\n    }\n    // console.log('WALKABLE GRID');\n    // walkableGWU.grid.dump();\n    GWU.grid.free(walkableGrid);\n    return disrupts;\n}\n// Spread\nfunction cellIsOk(effect, map, x, y, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.hasCellFlag(Flags.Cell.EVENT_PROTECTED))\n        return false;\n    if (cell.blocksEffects() && !effect.matchTile && !isStart) {\n        return false;\n    }\n    if (effect.flags & Flags.Effect.E_BUILD_IN_WALLS) {\n        if (!map.cell(x, y).isWall())\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = true;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    else if (effect.flags & Flags.Effect.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (map.cell(x, y).isWall())\n            return false; // or on wall\n        GWU.xy.eachNeighbor(x, y, (i, j) => {\n            if (map.cell(i, j).isWall()) {\n                ok = false;\n            }\n        }, true);\n        if (!ok)\n            return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (effect.matchTile && !isStart && !cell.hasTile(effect.matchTile)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(effect, loc, spawnMap) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const map = loc.map;\n    let startProb = effect.grow || 0;\n    let probDec = effect.decrement || 0;\n    spawnMap.fill(0);\n    if (!cellIsOk(effect, map, loc.x, loc.y, true)) {\n        return false;\n    }\n    spawnMap[loc.x][loc.y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GWU.xy.DIRS[dir][0];\n                            y2 = j + GWU.xy.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                map.rng.chance(startProb) &&\n                                cellIsOk(effect, map, x2, y2, false)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    return count > 0;\n}\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.Effect.E_CLEAR_CELL) === Flags.Effect.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.Effect.E_CLEAR_GAS) {\n                cell.clearDepth(Flags.Depth.GAS);\n            }\n            if (flags & Flags.Effect.E_CLEAR_LIQUID) {\n                cell.clearDepth(Flags.Depth.LIQUID);\n            }\n            if (flags & Flags.Effect.E_CLEAR_SURFACE) {\n                cell.clearDepth(Flags.Depth.SURFACE);\n            }\n            if (flags & Flags.Effect.E_CLEAR_GROUND) {\n                cell.clearDepth(Flags.Depth.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let didSomething = false;\n    map.eachActor((a) => {\n        if (!blockingMap[a.x][a.y])\n            return;\n        const loc = map.rng.matchingLocNear(a.x, a.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const c = map.cell(x, y);\n            return !a.forbidsCell(c);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeActor(a);\n            map.addActor(loc[0], loc[1], a);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    map.eachItem((i) => {\n        if (!blockingMap[i.x][i.y])\n            return;\n        const loc = map.rng.matchingLocNear(i.x, i.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            if (blockingMap[x][y])\n                return false;\n            const dest = map.cell(x, y);\n            return !i.forbidsCell(dest);\n        });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(i);\n            map.addItem(loc[0], loc[1], i);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// EMIT\nexport function makeEmitHandler(config) {\n    if (Array.isArray(config))\n        config = config[0];\n    if (typeof config !== 'string')\n        throw new Error('Invalid EMIT handler config - ' + config);\n    return emitEffect.bind(undefined, config);\n}\nexport function emitEffect(id, loc, ctx) {\n    return loc.map.events.emit(id, loc, ctx);\n}\ninstallHandler('emit', makeEmitHandler);\n","import * as GWU from 'gw-utils';\nimport { installHandler } from '../effect';\n//////////////////////////////////////////////\n// MESSAGE\nexport function makeMessageHandler(src) {\n    if (Array.isArray(src))\n        src = src[0];\n    if (typeof src !== 'string') {\n        throw new Error('Need message for message effect.');\n    }\n    const info = {\n        msg: src,\n    };\n    return messageEffect.bind(undefined, info);\n}\nexport function messageEffect(info, loc, ctx) {\n    const seen = ctx.seen;\n    const msg = info.msg;\n    if (msg &&\n        msg.length &&\n        ctx.aware &&\n        !seen\n    // && map.isVisible(x, y)\n    ) {\n        GWU.message.addAt(loc.x, loc.y, msg, ctx);\n        return true;\n    }\n    return false;\n}\ninstallHandler('msg', makeMessageHandler);\n","import { installHandler } from '../effect';\n//////////////////////////////////////////////\n// ActivateMachine\nexport function makeActivateMachine() {\n    return activateMachine.bind(undefined);\n}\nexport function activateMachine(loc, ctx) {\n    const cell = loc.map.cell(loc.x, loc.y);\n    const machine = cell.machineId;\n    if (!machine)\n        return false;\n    return loc.map.activateMachine(machine, loc.x, loc.y, ctx);\n}\ninstallHandler('activateMachine', makeActivateMachine);\n","import { installHandler } from '../effect';\nexport function makeTileHandler(src) {\n    if (!src)\n        throw new Error('Tile effect needs configuration.');\n    if (typeof src === 'string') {\n        src = { id: src };\n    }\n    else if (Array.isArray(src)) {\n        src = { id: src[0] };\n    }\n    else if (!src.id) {\n        throw new Error('Tile effect needs configuration with id.');\n    }\n    const opts = src;\n    if (opts.id.includes('!')) {\n        opts.superpriority = true;\n    }\n    if (opts.id.includes('~')) {\n        opts.blockedByActors = true;\n        opts.blockedByItems = true;\n    }\n    opts.id = opts.id.replace(/[!~]*/g, '');\n    return tileEffect.bind(opts);\n}\nexport function tileEffect(loc, ctx) {\n    this.machine = ctx.machine || 0;\n    const didSomething = loc.map.setTile(loc.x, loc.y, this.id, this);\n    return didSomething;\n}\ninstallHandler('tile', makeTileHandler);\n","import * as Flags from '../../flags';\nimport { installHandler } from '../effect';\nexport function makeClearHandler(config) {\n    let layers = 0;\n    if (!config) {\n        layers = Flags.Depth.ALL_LAYERS;\n    }\n    else if (typeof config === 'number') {\n        layers = config;\n    }\n    else if (typeof config === 'string') {\n        const parts = config.split(/[,|]/g);\n        layers = parts.reduce((out, v) => {\n            if (typeof v === 'number')\n                return out | v;\n            const depth = Flags.Depth[v] || 0;\n            return out | depth;\n        }, 0);\n    }\n    else {\n        throw new Error('Invalid config for clear effect: ' + JSON.stringify(config));\n    }\n    return clearEffect.bind(undefined, layers);\n}\nexport function clearEffect(layers, loc, _ctx) {\n    if (!layers)\n        return false;\n    const cell = loc.map.cell(loc.x, loc.y);\n    return cell.clearDepth(layers);\n}\ninstallHandler('clear', makeClearHandler);\n","import * as Effect from '../effect';\nexport function makeFeatureHandler(id) {\n    if (Array.isArray(id))\n        id = id[0];\n    if (id && typeof id !== 'string') {\n        id = id.id;\n    }\n    if (!id || !id.length)\n        throw new Error('Feature effect needs ID');\n    return featureEffect.bind(undefined, id);\n}\nexport function featureEffect(id, loc, ctx) {\n    const feat = Effect.installedEffects[id];\n    if (!feat) {\n        throw new Error('Failed to find feature: ' + id);\n    }\n    return feat.trigger(loc, ctx);\n}\nEffect.installHandler('feature', makeFeatureHandler);\nEffect.installHandler('effect', makeFeatureHandler);\nEffect.installHandler('id', makeFeatureHandler);\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nexport function makeNourishEffect(opts) {\n    if (!opts)\n        throw new Error('Invalid Nourish config.');\n    let info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.type = opts[0] || 'inc';\n        info.amount = GWU.range.make(opts[1] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(opts.amount || 1);\n    }\n    else {\n        throw new Error('Invalid Nourish config: ' + JSON.stringify(opts));\n    }\n    return nourishEffect.bind(undefined, info);\n}\nexport function nourishEffect(config, loc, _ctx) {\n    if (!config.amount)\n        return false;\n    // who am I nourishing?\n    const actor = loc.map.actorAt(loc.x, loc.y);\n    if (!actor) {\n        return false;\n    }\n    const stats = actor.stats;\n    const c = stats.get('food');\n    if (!stats.adjust('food', config.type, config.amount))\n        return false;\n    const n = stats.get('food');\n    if (n < c && n / stats.max('food') < 0.1) {\n        GWU.message.addAt(actor.x, actor.y, nourishEffect.default.pukeMsg, {\n            actor,\n        });\n    }\n    return true;\n}\nnourishEffect.default = {\n    pukeMsg: '%you vomit.',\n};\nEffect.installHandler('nourish', makeNourishEffect);\n","import * as GWU from 'gw-utils';\nimport * as Effect from '../effect';\nexport function makeStatEffect(opts) {\n    if (!opts)\n        throw new Error('Invalid Stat config.');\n    const info = {};\n    if (typeof opts === 'string') {\n        opts = opts.split(':').map((t) => t.trim());\n    }\n    if (Array.isArray(opts)) {\n        info.stat = opts[0];\n        info.type = opts[1] || 'inc';\n        info.amount = GWU.range.make(opts[2] || 1);\n    }\n    else if (opts.type || opts.amount) {\n        info.stat = opts.stat;\n        info.type = opts.type || 'inc';\n        info.amount = GWU.range.make(info.amount || 1);\n    }\n    else {\n        throw new Error('Invalid stat effect configuration: ' + JSON.stringify(opts));\n    }\n    return statEffect.bind(undefined, info);\n}\nexport function statEffect(config, loc, _ctx) {\n    if (!config.amount)\n        return false;\n    // who am I nourishing?\n    const actor = loc.map.actorAt(loc.x, loc.y);\n    if (!actor) {\n        return false;\n    }\n    // sustain?\n    const stats = actor.stats;\n    if (!stats.adjust('food', config.type, config.amount))\n        return false;\n    return true;\n}\nEffect.installHandler('stat', makeStatEffect);\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport * as TILE from '../tile';\nimport * as Effect from '../effect';\nGWU.color.install('cellStatusName', 'light_blue');\n// class CellEntities {\n//     cell: Cell;\n//     constructor(cell: Cell) {\n//         this.cell = cell;\n//     }\n//     eachItem(cb: EachCb<Item>): void {\n//         let object: Item | null = this.cell._item;\n//         while (object) {\n//             cb(object);\n//             object = object.next;\n//         }\n//     }\n//     eachActor(cb: EachCb<Actor>): void {\n//         let object: Actor | null = this.cell._actor;\n//         while (object) {\n//             cb(object);\n//             object = object.next;\n//         }\n//     }\n//     forEach(cb: EachCb<Entity>): void {\n//         this.eachItem(cb);\n//         this.eachActor(cb);\n//     }\n//     some(cb: MatchCb<Entity>): boolean {\n//         let object: Entity | null = this.cell._item;\n//         while (object) {\n//             if (cb(object)) return true;\n//             object = object.next;\n//         }\n//         object = this.cell._actor;\n//         while (object) {\n//             if (cb(object)) return true;\n//             object = object.next;\n//         }\n//         return false;\n//     }\n//     reduce(cb: ReduceCb<Entity>, start?: any): any {\n//         let object: Entity | null = this.cell._item;\n//         while (object) {\n//             if (start === undefined) {\n//                 start = object;\n//             } else {\n//                 start = cb(start, object);\n//             }\n//             object = object.next;\n//         }\n//         object = this.cell._actor;\n//         while (object) {\n//             if (start === undefined) {\n//                 start = object;\n//             } else {\n//                 start = cb(start, object);\n//             }\n//             object = object.next;\n//         }\n//         return start;\n//     }\n// }\nexport class Cell {\n    // toFire: Partial<Effect.EffectCtx>[] = [];\n    constructor(map, x, y, groundTile) {\n        this.chokeCount = 0;\n        this.machineId = 0;\n        this.x = -1;\n        this.y = -1;\n        // this._entities = new CellEntities(this);\n        this.flags = { cell: Flags.Cell.NEEDS_REDRAW };\n        this.tiles = [TILE.tiles.NULL];\n        this.map = map;\n        this.x = x;\n        this.y = y;\n        this.snapshot = GWU.sprite.makeMixer();\n        if (groundTile) {\n            const tile = TILE.get(groundTile);\n            this.setTile(tile);\n        }\n    }\n    getSnapshot(dest) {\n        dest.copy(this.snapshot);\n    }\n    putSnapshot(src) {\n        this.snapshot.copy(src);\n    }\n    get hasStableSnapshot() {\n        return this.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    }\n    get hasStableMemory() {\n        return this.hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    copy(other) {\n        Object.assign(this.flags, other.flags);\n        this.chokeCount = other.chokeCount;\n        this.tiles.length = other.tiles.length;\n        for (let i = 0; i < this.tiles.length; ++i) {\n            this.tiles[i] = other.tiles[i];\n        }\n        this.machineId = other.machineId;\n        // this._actor = other.actor;\n        // this._item = other.item;\n        this.map = other.map;\n        this.x = other.x;\n        this.y = other.y;\n        other.getSnapshot(this.snapshot);\n    }\n    hasCellFlag(flag) {\n        return !!(this.flags.cell & flag);\n    }\n    setCellFlag(flag) {\n        this.flags.cell |= flag;\n    }\n    clearCellFlag(flag) {\n        this.flags.cell &= ~flag;\n    }\n    hasEntityFlag(flag, checkEntities = false) {\n        var _a, _b;\n        if (this.tiles.some((t) => t && t.flags.entity & flag))\n            return true;\n        if (!checkEntities)\n            return false;\n        if (this.hasItem()) {\n            if ((_a = this.item) === null || _a === void 0 ? void 0 : _a.hasEntityFlag(flag))\n                return true;\n        }\n        if (this.hasActor()) {\n            if ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.hasEntityFlag(flag))\n                return true;\n        }\n        return false;\n    }\n    hasAllEntityFlags(flags, checkEntities = false) {\n        return (this.entityFlags(checkEntities) & flags) == flags;\n    }\n    hasTileFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tile & flag);\n    }\n    hasAllTileFlags(flags) {\n        return (this.tileFlags() & flags) == flags;\n    }\n    hasTileMechFlag(flag) {\n        return this.tiles.some((t) => t && t.flags.tileMech & flag);\n    }\n    hasAllTileMechFlags(flags) {\n        return (this.tileMechFlags() & flags) == flags;\n    }\n    hasTileTag(tag) {\n        return this.tiles.some((tile) => tile && tile.hasTag(tag));\n    }\n    hasAllTileTags(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAllTags(tags);\n        });\n    }\n    hasAnyTileTag(tags) {\n        return this.tiles.some((tile) => {\n            return tile && tile.hasAnyTag(tags);\n        });\n    }\n    cellFlags() {\n        return this.flags.cell;\n    }\n    entityFlags(withEntities = false) {\n        var _a, _b;\n        let flag = this.tiles.reduce((out, t) => out | (t ? t.flags.entity : 0), 0);\n        if (withEntities) {\n            if (this.hasItem()) {\n                flag |= ((_a = this.item) === null || _a === void 0 ? void 0 : _a.flags.entity) || 0;\n            }\n            if (this.hasActor()) {\n                flag |= ((_b = this.actor) === null || _b === void 0 ? void 0 : _b.flags.entity) || 0;\n            }\n        }\n        return flag;\n    }\n    tileFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tile : 0), 0);\n    }\n    tileMechFlags() {\n        return this.tiles.reduce((out, t) => out | (t ? t.flags.tileMech : 0), 0);\n    }\n    get needsRedraw() {\n        return !!(this.flags.cell & Flags.Cell.NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags.cell |= Flags.Cell.NEEDS_REDRAW;\n            this.flags.cell &= ~Flags.Cell.STABLE_SNAPSHOT;\n            this.map.needsRedraw = true;\n        }\n        else {\n            this.flags.cell &= ~Flags.Cell.NEEDS_REDRAW;\n        }\n    }\n    get changed() {\n        return !!(this.flags.cell & Flags.Cell.CHANGED);\n    }\n    depthPriority(depth) {\n        const tile = this.tiles[depth];\n        return tile ? tile.priority : TILE.tiles.NULL.priority;\n    }\n    highestPriority() {\n        return this.tiles.reduce((out, t) => Math.max(out, t ? t.priority : 0), TILE.tiles.NULL.priority);\n    }\n    depthTile(depth) {\n        return this.tiles[depth] || null;\n    }\n    hasTile(tile) {\n        if (!tile)\n            return this.tiles.some((t) => t);\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n        }\n        return this.tiles.includes(tile);\n    }\n    hasDepthTile(depth) {\n        const t = this.tiles[depth];\n        return !!t && t !== TILE.tiles.NULL;\n    }\n    highestPriorityTile() {\n        return this.tiles.reduce((out, tile) => {\n            if (!tile)\n                return out;\n            if (tile.priority >= out.priority)\n                return tile; // higher depth will get picked with >=\n            return out;\n        }, TILE.tiles.NULL);\n    }\n    get tile() {\n        return this.highestPriorityTile();\n    }\n    eachTile(cb) {\n        this.tiles.forEach((t) => t && cb(t));\n    }\n    tileWithObjectFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.entity & flag) || null;\n    }\n    tileWithFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tile & flag) || null;\n    }\n    tileWithMechFlag(flag) {\n        return this.tiles.find((t) => t && t.flags.tileMech & flag) || null;\n    }\n    blocksVision() {\n        return this.tiles.some((t) => t && t.blocksVision());\n    }\n    blocksPathing() {\n        return this.tiles.some((t) => t && t.blocksPathing());\n    }\n    blocksMove() {\n        return this.tiles.some((t) => t && t.blocksMove());\n    }\n    blocksEffects() {\n        return this.tiles.some((t) => t && t.blocksEffects());\n    }\n    blocksLayer(depth) {\n        return this.tiles.some((t) => t &&\n            !!(t.flags.tile & TILE.flags.Tile.T_BLOCKS_OTHER_LAYERS) &&\n            t.depth != depth);\n    }\n    // Tests\n    isNull() {\n        return this.tiles.every((t) => !t || t === TILE.tiles.NULL);\n    }\n    isPassable() {\n        return !this.blocksMove();\n    }\n    isWall() {\n        return this.hasAllEntityFlags(Flags.Entity.L_WALL_FLAGS);\n    }\n    isStairs() {\n        return this.hasTileFlag(Flags.Tile.T_HAS_STAIRS);\n    }\n    isFloor() {\n        // Floor tiles do not block anything...\n        return (!this.hasEntityFlag(Flags.Entity.L_BLOCKS_EVERYTHING) &&\n            !this.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER));\n    }\n    isGateSite() {\n        return this.hasCellFlag(Flags.Cell.IS_GATE_SITE);\n    }\n    isSecretlyPassable() {\n        return this.hasEntityFlag(Flags.Entity.L_SECRETLY_PASSABLE);\n    }\n    // hasKey(): boolean {\n    //     return this._entities.some(\n    //         (e) => !!e.key && e.key.matches(this.x, this.y)\n    //     );\n    // }\n    // @returns - whether or not the change results in a change to the cell tiles.\n    //          - If there is a change to cell lighting, the cell will have the\n    //          - LIGHT_CHANGED flag set.\n    setTile(tile, opts = {}) {\n        if (!(tile instanceof TILE.Tile)) {\n            tile = TILE.get(tile);\n            if (!tile)\n                return false;\n        }\n        const current = this.tiles[tile.depth] || TILE.tiles.NULL;\n        if (current === tile)\n            return false;\n        if (!opts.superpriority) {\n            // if (current !== tile) {\n            //     this.gasVolume = 0;\n            //     this.liquidVolume = 0;\n            // }\n            // Check priority, etc...\n            if (current.priority > tile.priority) {\n                return false;\n            }\n        }\n        if (this.blocksLayer(tile.depth))\n            return false;\n        if (opts.blockedByItems && this.hasItem())\n            return false;\n        if (opts.blockedByActors && this.hasActor())\n            return false;\n        if (opts.blockedByOtherLayers && this.highestPriority() > tile.priority)\n            return false;\n        // TODO - Are we blocked by other layer (L_BLOCKS_SURFACE on an already present tile)?\n        if (tile.depth > Flags.Depth.GROUND && tile.groundTile) {\n            const ground = this.depthTile(Flags.Depth.GROUND);\n            if (!ground || ground === TILE.tiles.NULL) {\n                this.tiles[0] = TILE.get(tile.groundTile);\n            }\n        }\n        this.tiles[tile.depth] = tile;\n        this.needsRedraw = true;\n        if (tile.hasEntityFlag(Flags.Entity.L_BLOCKS_SURFACE)) {\n            this.clearDepth(Flags.Depth.SURFACE);\n        }\n        if (opts.machine) {\n            this.machineId = opts.machine;\n        }\n        if (current.light !== tile.light) {\n            this.map.light.glowLightChanged = true;\n        }\n        if (current.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR) !==\n            tile.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR)) {\n            this.map.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        if (tile.hasTileFlag(Flags.Tile.T_IS_FIRE)) {\n            this.setCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN);\n        }\n        // if (volume) {\n        //     if (tile.depth === Depth.GAS) {\n        //         this.gasVolume = volume;\n        //     }\n        //     if (tile.depth === Depth.LIQUID) {\n        //         this.liquidVolume = volume;\n        //     }\n        // }\n        return true;\n    }\n    clearTiles(tile) {\n        this.tiles[0] = TILE.tiles.NULL;\n        for (let i = 1; i < this.tiles.length; ++i) {\n            this.tiles[i] = null;\n        }\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.needsRedraw = true;\n    }\n    clear(tile) {\n        this.tiles = [TILE.tiles.NULL];\n        this.flags.cell = 0;\n        this.needsRedraw = true;\n        this.chokeCount = 0;\n        this.machineId = 0;\n        if (tile) {\n            this.setTile(tile);\n        }\n        this.snapshot.blackOut();\n    }\n    clearDepth(depth) {\n        if (depth == 0) {\n            this.tiles[0] = TILE.tiles.NULL;\n            this.needsRedraw = true;\n            return true;\n        }\n        else if (this.tiles[depth] !== null) {\n            this.tiles[depth] = null;\n            this.needsRedraw = true;\n            return true;\n        }\n        return false;\n    }\n    clearDepthsWithFlags(tileFlag, tileMechFlag = 0) {\n        for (let i = 0; i < this.tiles.length; ++i) {\n            const tile = this.tiles[i];\n            if (!tile)\n                continue;\n            if (!tile.hasTileFlag(tileFlag))\n                continue;\n            if (tileMechFlag && !tile.hasTileMechFlag(tileMechFlag))\n                continue;\n            this.clearDepth(i);\n        }\n    }\n    // Lights\n    eachGlowLight(cb) {\n        this.tiles.forEach((tile) => {\n            if (tile && tile.light)\n                cb(tile.light);\n        });\n    }\n    // Effects\n    tileWithEffect(name) {\n        return this.tiles.find((t) => t === null || t === void 0 ? void 0 : t.hasEffect(name)) || null;\n    }\n    fireEvent(event, ctx = {}) {\n        // ctx.cell = this;\n        let didSomething = false;\n        // console.log('fire event - %s', event);\n        for (const tile of this.tiles) {\n            if (!tile || !tile.effects)\n                continue;\n            const ev = tile.effects[event];\n            if (ev) {\n                const r = this._activate(ev, ctx);\n                if (r) {\n                    didSomething = true;\n                }\n            }\n        }\n        return didSomething;\n    }\n    _activate(effect, ctx) {\n        if (typeof effect === 'string') {\n            effect = Effect.installedEffects[effect];\n        }\n        let didSomething = false;\n        if (effect) {\n            // console.log(' - spawn event @%d,%d - %s', x, y, name);\n            didSomething = effect.trigger(this, ctx);\n            // cell.debug(\" - spawned\");\n        }\n        return didSomething;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles) {\n            if (tile && tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // // Items\n    hasItem() {\n        return this.hasCellFlag(Flags.Cell.HAS_ITEM);\n    }\n    get item() {\n        return this.map.itemAt(this.x, this.y);\n    }\n    canAddItem(_item) {\n        return true;\n    }\n    canRemoveItem(_item) {\n        return true;\n    }\n    _addItem(_item) {\n        this.setCellFlag(Flags.Cell.HAS_ITEM);\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeItem(item) {\n        let hasItems = false;\n        let foundIndex = -1;\n        this.map.items.forEach((obj, index) => {\n            if (obj === item) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasItems = true;\n            }\n        });\n        if (!hasItems) {\n            this.clearCellFlag(Flags.Cell.HAS_ITEM);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    // // Actors\n    hasActor() {\n        return this.hasCellFlag(Flags.Cell.HAS_ACTOR);\n    }\n    hasPlayer() {\n        return this.hasCellFlag(Flags.Cell.HAS_PLAYER);\n    }\n    get actor() {\n        return this.map.actorAt(this.x, this.y);\n    }\n    canAddActor(_actor) {\n        return true;\n    }\n    canRemoveActor(_actor) {\n        return true;\n    }\n    _addActor(actor) {\n        this.setCellFlag(Flags.Cell.HAS_ACTOR);\n        if (actor.isPlayer()) {\n            this.setCellFlag(Flags.Cell.HAS_PLAYER);\n        }\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    _removeActor(actor) {\n        let hasActor = false;\n        let foundIndex = -1;\n        this.map.actors.forEach((obj, index) => {\n            if (obj === actor) {\n                foundIndex = index;\n            }\n            else if (obj.x === this.x && obj.y === this.y) {\n                hasActor = true;\n            }\n        });\n        if (!hasActor) {\n            this.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.HAS_PLAYER);\n        }\n        if (foundIndex < 0)\n            return false;\n        this.needsRedraw = true;\n        // this.clearCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        return true;\n    }\n    hasFx() {\n        return !!(this.flags.cell & Flags.Cell.HAS_FX);\n    }\n    get fx() {\n        return this.map.fxAt(this.x, this.y);\n    }\n    _addFx(_fx) {\n        this.setCellFlag(Flags.Cell.HAS_FX);\n        this.needsRedraw = true;\n    }\n    _removeFx(_fx) {\n        if (!this.fx) {\n            this.clearCellFlag(Flags.Cell.HAS_FX);\n        }\n        this.needsRedraw = true;\n    }\n    getDescription() {\n        return this.highestPriorityTile().description;\n    }\n    getFlavor() {\n        return this.highestPriorityTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.highestPriorityTile().getName(opts);\n    }\n    dump() {\n        if (this.hasActor()) {\n            const actor = this.map.actorAt(this.x, this.y);\n            if (actor && actor.sprite.ch)\n                return actor.sprite.ch;\n        }\n        if (this.hasItem()) {\n            const item = this.map.itemAt(this.x, this.y);\n            if (item && item.sprite.ch)\n                return item.sprite.ch;\n        }\n        if (this.hasTileFlag(Flags.Tile.T_BRIDGE)) {\n            return '=';\n        }\n        return this.highestPriorityTile().sprite.ch || ' ';\n    }\n    drawStatus(buffer, bounds) {\n        const lines = buffer.wrapText(bounds.x + 1, bounds.y, bounds.width - 1, this.getName(), 'cellStatusName');\n        return lines;\n    }\n    toString() {\n        return `Cell @ ${this.x},${this.y}`;\n    }\n}\n","export class MapLayer {\n    constructor(map, name = 'layer') {\n        this.changed = false;\n        this.map = map;\n        this.depth = -1;\n        this.properties = {};\n        this.name = name;\n    }\n    copy(_other) { }\n    clear() { }\n    setTile(_x, _y, _tile, _opts) {\n        return false;\n    }\n    clearTile(_x, _y) {\n        return false;\n    }\n    addActor(_x, _y, _actor) {\n        return false;\n    }\n    forceActor(_x, _y, _actor) {\n        return false;\n    }\n    removeActor(_actor) {\n        return false;\n    }\n    addItem(_x, _y, _item) {\n        return false;\n    }\n    forceItem(_x, _y, _item) {\n        return false;\n    }\n    removeItem(_item) {\n        return false;\n    }\n    // Time based changes to the layer (e.g. dissipate gasses)\n    tick(_dt) {\n        return false;\n    }\n}\n","import { MapLayer } from './mapLayer';\nexport class TileLayer extends MapLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    setTile(x, y, tile, opts) {\n        const cell = this.map.cell(x, y);\n        return cell.setTile(tile, opts);\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        return cell.clearDepth(this.depth);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // // Bookkeeping for fire, pressure plates and key-activated tiles.\n        // for (let x = 0; x < this.map.width; ++x) {\n        //     for (let y = 0; y < this.map.height; ++y) {\n        //         const cell = this.map.cell(x, y);\n        //         if (\n        //             !cell.hasCellFlag(\n        //                 Flags.Cell.HAS_ANY_ACTOR | Flags.Cell.HAS_ITEM\n        //             ) &&\n        //             cell.hasCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED)\n        //         ) {\n        //             cell.clearCellFlag(Flags.Cell.PRESSURE_PLATE_DEPRESSED);\n        //         }\n        //     }\n        // }\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nexport class GasLayer extends TileLayer {\n    constructor(map, name = 'gas') {\n        super(map, name);\n        this.volume = GWU.grid.alloc(map.width, map.height, 0);\n    }\n    clear() {\n        this.volume.fill(0);\n    }\n    setTile(x, y, tile, opts = {}) {\n        if (!opts.volume)\n            return false;\n        const cell = this.map.cell(x, y);\n        if (cell.depthTile(tile.depth) === tile) {\n            this.volume[x][y] += opts.volume;\n            return true;\n        }\n        if (!super.setTile(x, y, tile, opts)) {\n            return false;\n        }\n        this.volume[x][y] = opts.volume;\n        this.changed = true;\n        return true;\n    }\n    clearTile(x, y) {\n        const cell = this.map.cell(x, y);\n        if (cell.clearDepth(this.depth)) {\n            this.volume[x][y] = 0;\n            return true;\n        }\n        return false;\n    }\n    copy(other) {\n        this.volume.copy(other.volume);\n        this.changed = other.changed;\n    }\n    tick(_dt) {\n        if (!this.changed)\n            return false;\n        this.changed = false;\n        const startingVolume = this.volume;\n        this.volume = GWU.grid.alloc(this.map.width, this.map.height);\n        // dissipate the gas...\n        this.dissipate(startingVolume);\n        // spread the gas...\n        this.spread(startingVolume);\n        GWU.grid.free(startingVolume);\n        return true;\n    }\n    dissipate(volume) {\n        volume.update((v, x, y) => {\n            if (!v)\n                return 0;\n            const tile = this.map.cell(x, y).depthTile(this.depth);\n            if (tile && tile.dissipate) {\n                let d = Math.max(0.5, (v * tile.dissipate) / 10000); // 1000 = 10%\n                v = Math.max(0, v - d);\n            }\n            if (v) {\n                this.changed = true;\n            }\n            else {\n                this.clearTile(x, y);\n            }\n            return v;\n        });\n    }\n    calcOpacity(volume) {\n        return Math.floor(Math.min(volume, 10) * 10);\n    }\n    updateCellVolume(x, y, startingVolume) {\n        let total = 0;\n        let count = 0;\n        let highestVolume = 0;\n        const cell = this.map.cell(x, y);\n        let startingTile = cell.depthTile(this.depth);\n        let highestTile = startingTile;\n        if (cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n            this.volume[x][y] = 0;\n            if (startingVolume[x][y]) {\n                this.clearTile(x, y);\n            }\n            return;\n        }\n        for (let i = Math.max(0, x - 1); i < Math.min(x + 2, startingVolume.width); ++i) {\n            for (let j = Math.max(0, y - 1); j < Math.min(y + 2, startingVolume.height); ++j) {\n                const v = startingVolume[i][j];\n                if (!cell.hasEntityFlag(Flags.Entity.L_BLOCKS_GAS)) {\n                    ++count;\n                    if (v > highestVolume) {\n                        highestVolume = v;\n                        highestTile = this.map.cell(i, j).depthTile(this.depth);\n                    }\n                }\n                total += v;\n            }\n        }\n        const v = Math.floor((total * 10) / count) / 10;\n        this.volume[x][y] = v;\n        if (v > 0 && highestTile) {\n            if (!startingTile || startingTile !== highestTile) {\n                cell.setTile(highestTile);\n            }\n        }\n        if (v > 0) {\n            cell.needsRedraw = true;\n        }\n    }\n    spread(startingVolume) {\n        for (let x = 0; x < startingVolume.width; ++x) {\n            for (let y = 0; y < startingVolume.height; ++y) {\n                this.updateCellVolume(x, y, startingVolume);\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { TileLayer } from './tileLayer';\nimport * as Effect from '../effect';\nconst Depth = Flags.Depth;\nconst ObjectFlags = Flags.Entity;\nconst TileFlags = Flags.Tile;\nconst TileMechFlags = Flags.TileMech;\nconst CellFlags = Flags.Cell;\nexport class FireLayer extends TileLayer {\n    constructor(map, name = 'tile') {\n        super(map, name);\n    }\n    tick(_dt) {\n        // Run any tick effects\n        // Bookkeeping for fire\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                cell.clearCellFlag(CellFlags.CAUGHT_FIRE_THIS_TURN);\n            }\n        }\n        // now spread the fire...\n        for (let x = 0; x < this.map.width; ++x) {\n            for (let y = 0; y < this.map.height; ++y) {\n                const cell = this.map.cell(x, y);\n                if (cell.hasTileFlag(TileFlags.T_IS_FIRE) &&\n                    !(cell.flags.cell & CellFlags.CAUGHT_FIRE_THIS_TURN)) {\n                    this.exposeToFire(x, y, false);\n                    for (let d = 0; d < 4; ++d) {\n                        const dir = GWU.xy.DIRS[d];\n                        this.exposeToFire(x + dir[0], y + dir[1]);\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.map.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        cell.eachTile((tile) => {\n            if (tile.hasTileFlag(TileFlags.T_EXTINGUISHES_FIRE) &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        });\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        cell.eachTile((tile) => {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.depth === Depth.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = Effect.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        });\n        if (alwaysIgnite ||\n            (ignitionChance && this.map.rng.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                GWU.xy.eachNeighbor(x, y, (x0, y0) => {\n                    const n = this.map.cell(x0, y0);\n                    if (n.hasEntityFlag(ObjectFlags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            // cell.eachTile( (tile) => {\n            //     if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n            //         if (tile.depth === Depth.GAS) {\n            //             cell.gasVolume = 0;\n            //         } else if (tile.depth === Depth.LIQUID) {\n            //             cell.liquidVolume = 0;\n            //         }\n            //     }\n            // });\n            cell.fireEvent(event, {\n                force: true,\n            });\n            cell.needsRedraw = true;\n        }\n        return fireIgnited;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nexport class BasicDrawer {\n    isAnyKindOfVisible(_cell) {\n        return true;\n    }\n    drawInto(dest, map, opts = {}) {\n        const buffer = dest instanceof GWU.buffer.Buffer ? dest : dest.buffer;\n        const offsetX = opts.offsetX || 0;\n        const offsetY = opts.offsetY || 0;\n        const mixer = new GWU.sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                if (map.hasXY(x + offsetX, y + offsetY)) {\n                    const cell = map.cell(x + offsetX, y + offsetY);\n                    this.drawCell(mixer, cell, opts.fov);\n                    buffer.drawSprite(x, y, mixer);\n                }\n            }\n        }\n    }\n    drawCell(dest, cell, fov) {\n        dest.blackOut();\n        // const isVisible = fov ? fov.isAnyKindOfVisible(cell.x, cell.y) : true;\n        const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        if (cell.needsRedraw || needSnapshot) {\n            this.getAppearance(dest, cell);\n            cell.putSnapshot(dest);\n            cell.needsRedraw = false;\n            cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n        }\n        else {\n            cell.getSnapshot(dest);\n        }\n        this.applyLight(dest, cell, fov);\n        if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT |\n            Flags.Entity.L_LIST_IN_SIDEBAR, true)) {\n            [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n        }\n        return true;\n    }\n    // getCellAppearance(cell: CellType, dest: GWU.sprite.Mixer) {\n    //     dest.blackOut();\n    //     const isVisible = true; // this.fov.isAnyKindOfVisible(x, y);\n    //     const isRevealed = true; // this.fov.isRevealed(x, y);\n    //     const needSnapshot = !cell.hasCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     if (needSnapshot || (cell.needsRedraw && isVisible)) {\n    //         this.layers.forEach((layer) => layer.putAppearance(dest, cell));\n    //         if (dest.dances) {\n    //             cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n    //         } else {\n    //             cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n    //         }\n    //         dest.bake();\n    //         cell.putSnapshot(dest);\n    //         cell.needsRedraw = false;\n    //         cell.setCellFlag(Flags.Cell.STABLE_SNAPSHOT);\n    //     } else {\n    //         cell.getSnapshot(dest);\n    //     }\n    //     if (isVisible) {\n    //         const light = this.light.getLight(cell.x, cell.y);\n    //         dest.multiply(light);\n    //     } else if (isRevealed) {\n    //         dest.scale(50);\n    //     } else {\n    //         dest.blackOut();\n    //     }\n    //     if (cell.hasEntityFlag(Flags.Entity.L_VISUALLY_DISTINCT)) {\n    //         [dest.fg, dest.bg] = GWU.color.separate(dest.fg, dest.bg);\n    //     }\n    // }\n    getAppearance(dest, cell) {\n        const ground = cell.tiles[Flags.Depth.GROUND];\n        const surface = cell.tiles[Flags.Depth.SURFACE];\n        const liquid = cell.tiles[Flags.Depth.LIQUID];\n        const gas = cell.tiles[Flags.Depth.GAS]; // How to get volume!?!?!?!\n        dest.drawSprite(ground.sprite);\n        if (surface) {\n            dest.drawSprite(surface.sprite);\n        }\n        if (liquid) {\n            dest.drawSprite(liquid.sprite);\n        }\n        if (cell.hasItem()) {\n            const item = cell.map.itemAt(cell.x, cell.y);\n            if (item)\n                item.drawInto(dest);\n        }\n        if (cell.hasActor()) {\n            const actor = cell.map.actorAt(cell.x, cell.y);\n            if (actor)\n                actor.drawInto(dest);\n        }\n        if (gas) {\n            const opacity = GWU.rng.cosmetic.number(50) + 25;\n            dest.drawSprite(gas.sprite, opacity);\n        }\n        if (cell.hasFx()) {\n            const fx = cell.map.fxAt(cell.x, cell.y);\n            if (fx)\n                dest.drawSprite(fx.sprite);\n        }\n        if (dest.dances) {\n            cell.setCellFlag(Flags.Cell.COLORS_DANCE);\n        }\n        else {\n            cell.clearCellFlag(Flags.Cell.COLORS_DANCE);\n        }\n        dest.bake();\n    }\n    applyLight(dest, cell, fov) {\n        const isVisible = !fov || fov.isAnyKindOfVisible(cell.x, cell.y);\n        const isRevealed = !fov || fov.isRevealed(cell.x, cell.y);\n        const light = cell.map.light.getLight(cell.x, cell.y);\n        dest.multiply(light);\n        // TODO - is Clairy\n        // TODO - is Telepathy\n        if (fov && fov.isCursor(cell.x, cell.y)) {\n            dest.invert();\n        }\n        else if (!isVisible) {\n            if (isRevealed) {\n                dest.scale(50);\n            }\n            else {\n                dest.blackOut();\n            }\n        }\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nimport { Cell } from './cell';\nimport * as TILE from '../tile';\nimport * as Layer from '../layer';\n// import { CellMemory } from './cellMemory';\nimport * as Effect from '../effect';\nimport { BasicDrawer } from '../draw/basic';\nexport class Map {\n    constructor(width, height, opts = {}) {\n        // _memory: GWU.grid.Grid<CellMemory>;\n        // machineCount = 0;\n        // _seed = 0;\n        this.rng = GWU.rng.random;\n        // id = 'MAP';\n        this.actors = [];\n        this.items = [];\n        this.fx = [];\n        this._animations = [];\n        this.events = new GWU.events.EventEmitter();\n        this.flags = { map: 0 };\n        this.layers = [];\n        this.properties = { seed: 0, machineCount: 0 };\n        if (opts.id) {\n            this.properties.id = opts.id;\n        }\n        this.drawer = opts.drawer || new BasicDrawer();\n        this.cells = GWU.grid.make(width, height, (x, y) => new Cell(this, x, y));\n        // this._memory = GWU.grid.make(\n        //     width,\n        //     height,\n        //     (x, y) => new CellMemory(this, x, y)\n        // );\n        if (opts.seed) {\n            this.properties.seed = opts.seed;\n            this.rng = GWU.rng.make(opts.seed);\n        }\n        this.light = new GWU.light.LightSystem(this, opts);\n        // this.fov = new GWU.fov.FovSystem(this, opts);\n        this.initLayers();\n    }\n    get seed() {\n        return this.properties.seed;\n    }\n    set seed(v) {\n        this.properties.seed = v;\n        this.rng = GWU.rng.make(v);\n    }\n    get width() {\n        return this.cells.width;\n    }\n    get height() {\n        return this.cells.height;\n    }\n    // memory(x: number, y: number): CellMemory {\n    //     return this._memory[x][y];\n    // }\n    // knowledge(x: number, y: number): CellInfoType {\n    //     if (this.fov.isAnyKindOfVisible(x, y)) return this.cell(x,y);\n    //     return this._memory[x][y];\n    // }\n    // LAYERS\n    initLayers() {\n        this.addLayer(Flags.Depth.GROUND, new Layer.TileLayer(this, 'ground'));\n        this.addLayer(Flags.Depth.SURFACE, new Layer.FireLayer(this, 'surface'));\n        this.addLayer(Flags.Depth.GAS, new Layer.GasLayer(this, 'gas'));\n    }\n    addLayer(depth, layer) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        layer.depth = depth;\n        this.layers[depth] = layer;\n    }\n    removeLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        if (!depth)\n            throw new Error('Cannot remove layer with depth=0.');\n        delete this.layers[depth];\n    }\n    getLayer(depth) {\n        if (typeof depth !== 'number') {\n            depth = Flags.Depth[depth];\n        }\n        return this.layers[depth] || null;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return x == 0 || y == 0 || x == this.width - 1 || y == this.height - 1;\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    _cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(cb) {\n        this.cells.forEach((cell, x, y) => cb(cell, x, y, this));\n    }\n    // items\n    hasItem(x, y) {\n        return this.cell(x, y).hasItem();\n    }\n    itemAt(x, y) {\n        return this.items.find((i) => i.isAt(x, y)) || null;\n    }\n    eachItem(cb) {\n        this.items.forEach(cb);\n    }\n    addItem(x, y, item, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this._cell(x, y);\n        // if (!cell.canAddItem(item)) return false;\n        if (cell._addItem(item)) {\n            const index = this.items.indexOf(item);\n            if (index < 0) {\n                this.items.push(item);\n            }\n            item.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddItemEffects(item, cell);\n            }\n            if (index < 0) {\n                this.events.emit('item', this, item, true);\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddItemEffects(item, cell) {\n        if (item.key &&\n            item.key.matches(cell.x, cell.y) &&\n            cell.hasEffect('key')) {\n            cell.fireEvent('key', {\n                key: item,\n                item,\n            });\n        }\n        else if (cell.hasEffect('add_item')) {\n            cell.fireEvent('add_item', {\n                key: item,\n                item,\n            });\n        }\n    }\n    addItemNear(x, y, item, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this._cell(i, j);\n            if (cell.hasItem())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (item.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addItem(loc[0], loc[1], item, fireEffects);\n    }\n    removeItem(item, fireEffects = false) {\n        const cell = this._cell(item.x, item.y);\n        // if (!cell.canRemoveItem(item)) return false;\n        if (cell._removeItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, cell);\n            }\n            GWU.arrayDelete(this.items, item);\n            item.removeFromMap();\n            this.events.emit('item', this, item, false);\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveItemEffects(item, cell) {\n        if (item.isKey(cell.x, cell.y) && cell.hasEffect('no_key')) {\n            cell.fireEvent('no_key', {\n                key: item,\n                item,\n            });\n        }\n        else if (cell.hasEffect('remove_item')) {\n            cell.fireEvent('remove_item', {\n                key: item,\n                item,\n            });\n        }\n    }\n    moveItem(item, x, y, fireEffects = false) {\n        if (item.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this._cell(item.x, item.y);\n        const newCell = this._cell(x, y);\n        // if (!currentCell.canRemoveItem(item)) return false;\n        // if (!newCell.canAddItem(item)) return false;\n        currentCell._removeItem(item);\n        if (newCell._addItem(item)) {\n            if (fireEffects) {\n                this._fireRemoveItemEffects(item, currentCell);\n                this._fireAddItemEffects(item, newCell);\n            }\n            item.addToMap(this, x, y);\n        }\n        return true;\n    }\n    //  moveItem(item: Item, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = item.x;\n    //     const oldY = item.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[item.depth] as Layer.ItemLayer;\n    //     if (!( layer.removeItem(item))) return false;\n    //     if (!( this.addItem(x, y, item))) {\n    //         layer.forceItem(item.x, item.y, item);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (item.lastSeen) {\n    //     //         this._memory[item.lastSeen.x][item.lastSeen.y].removeItem(item);\n    //     //         this.clearCellFlag(\n    //     //             item.lastSeen.x,\n    //     //             item.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         item.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.item = item;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     item.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    // Actors\n    hasPlayer(x, y) {\n        return this.cell(x, y).hasPlayer();\n    }\n    actorAt(x, y) {\n        return this.actors.find((a) => a.isAt(x, y)) || null;\n    }\n    eachActor(cb) {\n        this.actors.forEach(cb);\n    }\n    addActor(x, y, actor, fireEffects = false) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this._cell(x, y);\n        if (!cell.canAddActor(actor))\n            return false;\n        if (cell._addActor(actor)) {\n            const index = this.actors.indexOf(actor);\n            if (index < 0) {\n                this.actors.push(actor);\n            }\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireAddActorEffects(actor, cell);\n            }\n            if (index < 0) {\n                this.events.emit('actor', this, actor, true);\n            }\n            return true;\n        }\n        return false;\n    }\n    _fireAddActorEffects(actor, cell) {\n        if (actor.isKey(cell.x, cell.y) && cell.hasEffect('key')) {\n            cell.fireEvent('key', {\n                key: actor,\n                actor,\n            });\n        }\n        else if (actor.isPlayer() && cell.hasEffect('add_player')) {\n            cell.fireEvent('add_player', {\n                player: actor,\n                actor,\n            });\n        }\n        else if (cell.hasEffect('add_actor')) {\n            cell.fireEvent('add_actor', {\n                actor,\n            });\n        }\n    }\n    addActorNear(x, y, actor, fireEffects = false) {\n        const loc = this.rng.matchingLocNear(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            const cell = this.cell(i, j);\n            if (cell.hasActor())\n                return false;\n            if (cell.blocksMove())\n                return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            return true;\n        });\n        if (!loc || loc[0] < 0)\n            return false;\n        return this.addActor(loc[0], loc[1], actor, fireEffects);\n    }\n    removeActor(actor, fireEffects = false) {\n        const cell = this._cell(actor.x, actor.y);\n        if (!cell.canRemoveActor(actor))\n            return false;\n        if (cell._removeActor(actor)) {\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, cell);\n            }\n            actor.removeFromMap();\n            GWU.arrayDelete(this.actors, actor);\n            this.events.emit('actor', this, actor, false);\n            return true;\n        }\n        return false;\n    }\n    _fireRemoveActorEffects(actor, cell) {\n        if (actor.isKey(actor.x, actor.y) && cell.hasEffect('no_key')) {\n            cell.fireEvent('no_key', {\n                key: actor,\n                actor,\n            });\n        }\n        else if (actor.isPlayer() && cell.hasEffect('remove_player')) {\n            cell.fireEvent('remove_player', {\n                actor,\n                player: actor,\n            });\n        }\n        else if (cell.hasEffect('remove_actor')) {\n            cell.fireEvent('remove_actor', {\n                actor,\n            });\n        }\n    }\n    moveActor(actor, x, y, fireEffects = false) {\n        if (actor.map !== this)\n            throw new Error('Actor not on this map!');\n        const currentCell = this._cell(actor.x, actor.y);\n        const newCell = this._cell(x, y);\n        // if (!currentCell.canRemoveActor(actor)) return false;\n        // if (!newCell.canAddActor(actor)) return false;\n        currentCell._removeActor(actor);\n        if (newCell._addActor(actor)) {\n            actor.addToMap(this, x, y);\n            if (fireEffects) {\n                this._fireRemoveActorEffects(actor, currentCell);\n                this._fireAddActorEffects(actor, newCell);\n            }\n        }\n        return true;\n    }\n    //  moveActor(actor: Actor, dir: GWU.xy.Loc | number): boolean {\n    //     if (typeof dir === 'number') {\n    //         dir = GWU.xy.DIRS[dir];\n    //     }\n    //     const oldX = actor.x;\n    //     const oldY = actor.y;\n    //     const x = oldX + dir[0];\n    //     const y = oldY + dir[1];\n    //     if (!this.hasXY(x, y)) return false;\n    //     const layer = this.layers[actor.depth] as Layer.ActorLayer;\n    //     if (!( layer.removeActor(actor))) return false;\n    //     if (!( layer.addActor(x, y, actor))) {\n    //         layer.forceActor(actor.x, actor.y, actor);\n    //         return false;\n    //     }\n    //     // const wasVisible = this.fov.isAnyKindOfVisible(oldX, oldY);\n    //     // const isVisible = this.fov.isAnyKindOfVisible(x, y);\n    //     // if (isVisible && !wasVisible) {\n    //     //     if (actor.lastSeen) {\n    //     //         this._memory[actor.lastSeen.x][actor.lastSeen.y].removeActor(\n    //     //             actor\n    //     //         );\n    //     //         this.clearCellFlag(\n    //     //             actor.lastSeen.x,\n    //     //             actor.lastSeen.y,\n    //     //             Flags.Cell.STABLE_SNAPSHOT\n    //     //         );\n    //     //         actor.lastSeen = null;\n    //     //     }\n    //     // } else if (wasVisible && !isVisible) {\n    //     //     const mem = this._memory[x][y];\n    //     //     mem.actor = actor;\n    //     //     this.clearCellFlag(x, y, Flags.Cell.STABLE_SNAPSHOT);\n    //     //     actor.lastSeen = this.cell(x, y);\n    //     // }\n    //     return true;\n    // }\n    fxAt(x, y) {\n        return this.fx.find((i) => i.isAt(x, y)) || null;\n    }\n    eachFx(cb) {\n        this.fx.forEach(cb);\n    }\n    addFx(x, y, fx) {\n        const cell = this.get(x, y);\n        if (!cell)\n            return false;\n        fx.x = x;\n        fx.y = y;\n        cell._addFx(fx);\n        this.fx.push(fx);\n        this.events.emit('fx', this, fx, true);\n        return true;\n    }\n    moveFx(fx, x, y) {\n        const current = this.get(fx.x, fx.y);\n        const updated = this.get(x, y);\n        if (!updated)\n            return false;\n        current._removeFx(fx);\n        fx.x = x;\n        fx.y = y;\n        updated._addFx(fx);\n        return true;\n    }\n    removeFx(fx) {\n        const cell = this.get(fx.x, fx.y);\n        GWU.arrayDelete(this.fx, fx);\n        if (cell) {\n            cell._removeFx(fx);\n        }\n        this.events.emit('fx', this, fx, false);\n        return true;\n    }\n    // Information\n    // isVisible(x: number, y: number): boolean {\n    //     return this.fov.isAnyKindOfVisible(x, y);\n    // }\n    hasKey(x, y) {\n        const actor = this.actorAt(x, y);\n        if (actor && actor.isKey(x, y))\n            return true;\n        const item = this.itemAt(x, y);\n        if (item && item.isKey(x, y))\n            return true;\n        return false;\n    }\n    count(cb) {\n        return this.cells.count((cell, x, y) => cb(cell, x, y, this));\n    }\n    dump(fmt, log = console.log) {\n        const getCh = (cell) => {\n            return cell.dump();\n        };\n        this.cells.dump(fmt || getCh, log);\n    }\n    // flags\n    hasMapFlag(flag) {\n        return !!(this.flags.map & flag);\n    }\n    setMapFlag(flag) {\n        this.flags.map |= flag;\n    }\n    clearMapFlag(flag) {\n        this.flags.map &= ~flag;\n    }\n    get needsRedraw() {\n        return this.hasMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    set needsRedraw(v) {\n        if (v)\n            this.setMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n        else\n            this.clearMapFlag(Flags.Map.MAP_NEEDS_REDRAW);\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).hasCellFlag(flag);\n    }\n    setCellFlag(x, y, flag) {\n        this.cell(x, y).setCellFlag(flag);\n    }\n    clearCellFlag(x, y, flag) {\n        this.cell(x, y).clearCellFlag(flag);\n    }\n    hasEntityFlag(x, y, flag) {\n        return this.cell(x, y).hasEntityFlag(flag);\n    }\n    hasTileFlag(x, y, flag) {\n        return this.cell(x, y).hasTileFlag(flag);\n    }\n    clear() {\n        this.light.glowLightChanged = true;\n        // this.fov.needsUpdate = true;\n        this.layers.forEach((l) => l.clear());\n    }\n    clearCell(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clear(tile);\n    }\n    // Skips all the logic checks and just forces a clean cell with the given tile\n    fill(tile, boundary) {\n        tile = TILE.get(tile);\n        boundary = TILE.get(boundary || tile);\n        let i, j;\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                const cell = this.cells[i][j];\n                cell.clear(this.isBoundaryXY(i, j) ? boundary : tile);\n            }\n        }\n    }\n    hasTile(x, y, tile\n    // useMemory = false\n    ) {\n        return this.cell(x, y).hasTile(tile);\n        // if (!useMemory) return this.cell(x, y).hasTile(tile);\n        // return this.memory(x, y).hasTile(tile);\n    }\n    forceTile(x, y, tile) {\n        return this.setTile(x, y, tile, { superpriority: true });\n    }\n    setTile(x, y, tile, opts) {\n        if (!(tile instanceof TILE.Tile)) {\n            const name = tile;\n            tile = TILE.get(name);\n            if (!tile)\n                throw new Error('Failed to find tile: ' + name);\n        }\n        if (opts === true) {\n            opts = { superpriority: true };\n        }\n        const depth = tile.depth || 0;\n        const layer = this.layers[depth] || this.layers[0];\n        if (!(layer instanceof Layer.TileLayer))\n            return false;\n        return layer.setTile(x, y, tile, opts);\n    }\n    clearTiles(x, y, tile) {\n        const cell = this.cell(x, y);\n        cell.clearTiles(tile);\n    }\n    tick(dt) {\n        let didSomething = false;\n        this._animations.forEach((a) => {\n            didSomething = a.tick(dt) || didSomething;\n        });\n        this._animations = this._animations.filter((a) => a.isRunning());\n        didSomething = this.fireAll('tick') || didSomething;\n        for (let layer of this.layers) {\n            if (layer && layer.tick(dt)) {\n                didSomething = true;\n            }\n        }\n        return didSomething;\n    }\n    copy(src) {\n        if (this.constructor !== src.constructor)\n            throw new Error('Maps must be same type to copy.');\n        if (this.width !== src.width || this.height !== src.height)\n            throw new Error('Maps must be same size to copy');\n        this.cells.forEach((c, x, y) => {\n            c.copy(src.cell(x, y));\n        });\n        this.layers.forEach((l, depth) => {\n            l.copy(src.layers[depth]);\n        });\n        this.actors = src.actors.slice();\n        this.items = src.items.slice();\n        this.flags.map = src.flags.map;\n        // this.fov.needsUpdate = true;\n        this.light.copy(src.light);\n        this.rng = src.rng;\n        this.properties = Object.assign({}, src.properties);\n    }\n    clone() {\n        // @ts-ignore\n        const other = new this.constructor(this.width, this.height);\n        other.copy(this);\n        return other;\n    }\n    fire(event, x, y, ctx = {}) {\n        const cell = this.cell(x, y);\n        return cell.fireEvent(event, ctx);\n    }\n    fireAll(event, ctx = {}) {\n        let didSomething = false;\n        const willFire = GWU.grid.alloc(this.width, this.height);\n        // Figure out which tiles will fire - before we change everything...\n        this.cells.forEach((cell, x, y) => {\n            cell.clearCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN | Flags.Cell.EVENT_PROTECTED);\n            cell.eachTile((tile) => {\n                const ev = tile.effects[event];\n                if (!ev)\n                    return;\n                const effect = Effect.from(ev);\n                if (!effect)\n                    return;\n                let promoteChance = 0;\n                // < 0 means try to fire my neighbors...\n                if (effect.chance < 0) {\n                    promoteChance = 0;\n                    GWU.xy.eachNeighbor(x, y, (i, j) => {\n                        const n = this.cell(i, j);\n                        if (!n.hasEntityFlag(Flags.Entity.L_BLOCKS_EFFECTS) &&\n                            n.depthTile(tile.depth) !=\n                                cell.depthTile(tile.depth) &&\n                            !n.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN)) {\n                            // TODO - Should this break from the loop after doing this once or keep going?\n                            promoteChance += -1 * effect.chance;\n                        }\n                    }, true);\n                }\n                else {\n                    promoteChance = effect.chance || 100 * 100; // 100%\n                }\n                if (!cell.hasCellFlag(Flags.Cell.CAUGHT_FIRE_THIS_TURN) &&\n                    this.rng.chance(promoteChance, 10000)) {\n                    willFire[x][y] |= GWU.flag.fl(tile.depth);\n                    // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                }\n            });\n        });\n        // Then activate them - so that we don't activate the next generation as part of the forEach\n        ctx.force = true;\n        willFire.forEach((w, x, y) => {\n            if (!w)\n                return;\n            const cell = this.cell(x, y);\n            if (cell.hasCellFlag(Flags.Cell.EVENT_FIRED_THIS_TURN))\n                return;\n            for (let depth = 0; depth <= Flags.Depth.GAS; ++depth) {\n                if (w & GWU.flag.fl(depth)) {\n                    cell.fireEvent(event, {\n                        force: true,\n                    });\n                }\n            }\n        });\n        GWU.grid.free(willFire);\n        return didSomething;\n    }\n    activateMachine(machineId, originX, originY, ctx = {}) {\n        let didSomething = false;\n        ctx.originX = originX;\n        ctx.originY = originY;\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.machineId !== machineId)\n                    continue;\n                if (cell.hasEffect('machine')) {\n                    didSomething =\n                        cell.fireEvent('machine', ctx) || didSomething;\n                }\n            }\n        }\n        return didSomething;\n    }\n    // DRAW\n    drawInto(dest, opts) {\n        this.drawer.drawInto(dest, this, opts);\n    }\n    getAppearanceAt(x, y, dest) {\n        const cell = this.cell(x, y);\n        return this.drawer.drawCell(dest, cell);\n    }\n    // // LightSystemSite\n    hasActor(x, y) {\n        return this.cell(x, y).hasActor();\n    }\n    eachGlowLight(cb) {\n        this.cells.forEach((cell, x, y) => {\n            cell.eachGlowLight((light) => cb(x, y, light));\n            // cell.clearCellFlag(Flags.Cell.LIGHT_CHANGED);\n        });\n    }\n    eachDynamicLight(_cb) { }\n    // FOV System Site\n    eachViewport(_cb) {\n        // TODO !!\n    }\n    lightingChanged() {\n        return this.light.changed;\n    }\n    hasVisibleLight(x, y) {\n        return !this.light.isDark(x, y);\n    }\n    blocksVision(x, y) {\n        return this.cell(x, y).blocksVision();\n    }\n    // redrawCell(x: number, y: number): void {\n    //     // if (clearMemory) {\n    //     //     this.clearMemory(x, y);\n    //     // }\n    //     this.cell(x, y).needsRedraw = true;\n    // }\n    // Animator\n    addAnimation(a) {\n        this._animations.push(a);\n    }\n    removeAnimation(a) {\n        GWU.arrayDelete(this._animations, a);\n    }\n}\nexport function make(w, h, opts = {}, boundary) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n    }\n    if (boundary) {\n        opts.boundary = boundary;\n    }\n    if (opts.tile === true) {\n        opts.tile = 'FLOOR';\n    }\n    if (opts.boundary === true) {\n        opts.boundary = 'WALL';\n    }\n    const map = new Map(w, h, opts);\n    if (opts.tile) {\n        map.fill(opts.tile, opts.boundary);\n        map.light.update();\n    }\n    // if (!DATA.map) {\n    //     DATA.map = map;\n    // }\n    // // In case we reveal the map or make it all visible we need our memory set correctly\n    // map.cells.forEach((_c, x, y) => {\n    //     if (map.fov.isRevealed(x, y)) {\n    //         map.storeMemory(x, y, true); // with snapshot\n    //     }\n    // });\n    return map;\n}\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    map.light.update();\n    return map;\n}\n","import * as GWU from 'gw-utils';\nimport { Map } from '../map/map';\nimport * as Flags from '../flags';\nexport class Memory extends Map {\n    constructor(map) {\n        super(map.width, map.height);\n        // this.actor = actor;\n        this.source = map;\n        this.cells.forEach((c) => c.setCellFlag(Flags.Cell.STABLE_MEMORY));\n    }\n    cell(x, y) {\n        let cell = this.cells[x][y];\n        if (!cell.hasCellFlag(Flags.Cell.STABLE_MEMORY)) {\n            cell = this.source.cell(x, y);\n        }\n        return cell;\n    }\n    memory(x, y) {\n        return this.cells[x][y];\n    }\n    isMemory(x, y) {\n        return this.cells[x][y].hasCellFlag(Flags.Cell.STABLE_MEMORY);\n    }\n    setTile() {\n        throw new Error('Cannot set tiles on memory.');\n    }\n    addItem() {\n        throw new Error('Cannot add Items to memory!');\n    }\n    removeItem() {\n        throw new Error('Cannot remove Items from memory!');\n    }\n    //  moveItem(): boolean {\n    //     throw new Error('Cannot move Items on memory!');\n    // }\n    eachItem(cb) {\n        this.source.eachItem((i) => {\n            if (!this.isMemory(i.x, i.y)) {\n                cb(i);\n                const i2 = this.items.find((other) => other.id == i.id);\n                if (i2) {\n                    const mem = this.cell(i2.x, i2.y);\n                    mem.clearCellFlag(Flags.Cell.HAS_ITEM | Flags.Cell.STABLE_SNAPSHOT);\n                    GWU.arrayDelete(this.items, i2);\n                }\n            }\n        });\n        this.items.forEach(cb);\n    }\n    addActor() {\n        throw new Error('Cannot add Actors to memory!');\n    }\n    removeActor() {\n        throw new Error('Cannot remove Actors from memory!');\n    }\n    //  moveActor(): boolean {\n    //     throw new Error('Cannot move Actors on memory!');\n    // }\n    eachActor(cb) {\n        this.source.eachActor((a) => {\n            if (!this.isMemory(a.x, a.y)) {\n                cb(a);\n                const a2 = this.actors.find((other) => other.id == a.id);\n                if (a2) {\n                    const mem = this.cell(a2.x, a2.y);\n                    mem.clearCellFlag(Flags.Cell.HAS_ACTOR | Flags.Cell.STABLE_SNAPSHOT);\n                    GWU.arrayDelete(this.actors, a2);\n                }\n            }\n        });\n        this.actors.forEach(cb);\n    }\n    storeMemory(x, y) {\n        const mem = this.cells[x][y];\n        const currentList = mem.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR, true);\n        // cleanup any old items+actors\n        if (mem.hasItem()) {\n            this.items = this.items.filter((i) => i.x !== x || i.y !== y);\n        }\n        if (mem.hasActor()) {\n            this.actors = this.actors.filter((a) => a.x !== x || a.y !== y);\n        }\n        const cell = this.source.cell(x, y);\n        mem.copy(cell);\n        mem.setCellFlag(Flags.Cell.STABLE_MEMORY);\n        mem.map = this; // so that drawing this cell results in using the right map\n        let newList = mem.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR);\n        // add any current items+actors\n        if (cell.hasItem()) {\n            const item = this.source.itemAt(x, y);\n            if (item) {\n                const copy = item.clone();\n                copy._map = this; // memory is map\n                this.items.push(copy);\n                if (copy.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR)) {\n                    newList = true;\n                }\n            }\n        }\n        if (cell.hasActor()) {\n            const actor = this.source.actorAt(x, y);\n            if (actor) {\n                const copy = actor.clone();\n                copy._map = this; // memory is map\n                this.actors.push(copy);\n                if (copy.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR)) {\n                    newList = true;\n                }\n            }\n        }\n        if (currentList != newList) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n        this.light.setLight(x, y, this.source.light.getLight(x, y));\n    }\n    forget(x, y) {\n        const mem = this.memory(x, y);\n        const currentList = mem.hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR, true);\n        // cleanup any old items+actors\n        if (mem.hasItem()) {\n            this.items = this.items.filter((i) => i.x !== x || i.y !== y);\n        }\n        if (mem.hasActor()) {\n            this.actors = this.actors.filter((a) => a.x !== x || a.y !== y);\n        }\n        mem.clearCellFlag(Flags.Cell.STABLE_MEMORY);\n        let newList = this.source\n            .cell(x, y)\n            .hasEntityFlag(Flags.Entity.L_LIST_IN_SIDEBAR, true);\n        if (currentList != newList) {\n            this.setMapFlag(Flags.Map.MAP_SIDEBAR_TILES_CHANGED);\n        }\n    }\n    onFovChange(x, y, isVisible) {\n        if (!isVisible) {\n            this.storeMemory(x, y);\n        }\n        else {\n            this.forget(x, y);\n        }\n    }\n}\n","import { Memory } from './memory';\nconst cache = {};\nexport function store(actor, map, memory) {\n    let actorMemory = cache[actor.id];\n    if (!actorMemory) {\n        cache[actor.id] = actorMemory = {};\n    }\n    actorMemory[map.properties.id] = memory;\n}\nexport function get(actor, map) {\n    let actorMemory = cache[actor.id];\n    if (actorMemory) {\n        const memory = actorMemory[map.properties.id];\n        if (memory)\n            return memory;\n    }\n    return new Memory(map);\n}\n","export const ais = {};\nexport function install(name, fn) {\n    ais[name] = fn;\n}\n","import * as GWU from 'gw-utils';\nimport { getAction } from '../actor/action';\nimport * as AI from './ai';\nexport class AICtx {\n    constructor(game, actor, target) {\n        this.item = null;\n        this.count = 0;\n        this.game = game;\n        this.actor = actor;\n        this.target = target || null;\n        this.distanceMap = GWU.grid.alloc(game.map.width, game.map.height);\n        if (target) {\n            const costMap = actor.costMap();\n            GWU.path.calculateDistances(this.distanceMap, target.x, target.y, costMap);\n        }\n    }\n    start() {\n        ++this.count;\n        return this;\n    }\n    done(result) {\n        --this.count;\n        if (this.count == 0) {\n            GWU.grid.free(this.distanceMap);\n        }\n        return result;\n    }\n}\n/*\nhttp://roguebasin.com/index.php/Roguelike_Intelligence_-_Stateless_AIs\n-- Typical AI\n*/\nexport async function typical(game, actor) {\n    if (actor.isDead())\n        return -1;\n    const map = actor.map;\n    if (!map)\n        return -1; // actor not on map ?!?!\n    const target = game.player;\n    if (!target.canSee(actor.x, actor.y)) {\n        // TODO - Use scent, menory, other teammates info, ...\n        // TODO - Wander\n        return standStill(game, actor);\n    }\n    const damagePct = 100 - actor.stats.getPct('health');\n    const morale = actor.stats.get('morale');\n    const chargeChance = 100;\n    const retreatChance = 0;\n    const ctx = new AICtx(game, actor, target).start();\n    let result = 0;\n    if (damagePct > morale) {\n        if (canRunAwayFrom(game, actor, target, ctx)) {\n            result = await runAwayFrom(game, actor, target, ctx);\n        }\n        else if (canAttack(game, actor, target, ctx)) {\n            result = await attack(game, actor, target, ctx);\n        }\n        return ctx.done(result);\n    }\n    else if (tooFarFrom(game, actor, target, ctx) &&\n        canAttack(game, actor, target, ctx) &&\n        canMoveToward(game, actor, target, ctx)) {\n        if (GWU.random.chance(chargeChance)) {\n            result = await moveToward(game, actor, target, ctx);\n        }\n        else {\n            result = await attack(game, actor, target, ctx);\n        }\n        return ctx.done(result);\n    }\n    else if (tooCloseTo(game, actor, target, ctx) &&\n        canAttack(game, actor, target, ctx) &&\n        canMoveAwayFrom(game, actor, target, ctx)) {\n        if (GWU.random.chance(retreatChance)) {\n            result = await moveAwayFrom(game, actor, target, ctx);\n        }\n        else {\n            result = await attack(game, actor, target, ctx);\n        }\n        return ctx.done(result);\n    }\n    else if (canAttack(game, actor, target, ctx)) {\n        result = await attack(game, actor, target, ctx);\n        return ctx.done(result);\n    }\n    else if (tooFarFrom(game, actor, target, ctx) &&\n        canMoveToward(game, actor, target, ctx)) {\n        result = await moveToward(game, actor, target, ctx);\n        return ctx.done(result);\n    }\n    else if (tooCloseTo(game, actor, target, ctx) &&\n        canMoveAwayFrom(game, actor, target, ctx)) {\n        result = await moveAwayFrom(game, actor, target, ctx);\n        return ctx.done(result);\n    }\n    // Wander?\n    // Scent?\n    result = await standStill(game, actor, ctx);\n    return ctx.done(result);\n}\nAI.install('typical', typical);\nAI.install('default', typical);\nexport function canMoveToward(game, actor, target, ctx) {\n    // can move?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    const distanceMap = ctx.distanceMap;\n    const canMoveDiagonal = false;\n    // look for distance > current around me\n    let center = distanceMap[actor.x][actor.y];\n    let count = 0;\n    GWU.xy.eachNeighbor(actor.x, actor.y, (x, y) => {\n        if (distanceMap[x][y] < center) {\n            ++count;\n        }\n    }, canMoveDiagonal);\n    return ctx.done(count > 0);\n}\nexport async function moveToward(game, actor, target, ctx) {\n    // pathfinding?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    // distanceMap.dump();\n    const map = game.map;\n    const step = GWU.path.nextStep(ctx.distanceMap, actor.x, actor.y, (x, y) => {\n        const cell = map.cell(x, y);\n        if (!cell)\n            return true;\n        if (cell.hasActor() && cell.actor !== target)\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    });\n    let result = 0;\n    if (!step || (step[0] == 0 && step[1] == 0)) {\n        result = await standStill(game, actor, ctx);\n        return ctx.done(result);\n    }\n    const moveDir = getAction('moveDir');\n    if (!moveDir)\n        throw new Error('No moveDir action found for Actors!');\n    result = await moveDir(game, actor, { dir: step });\n    return ctx.done(result);\n}\nexport function canMoveAwayFrom(game, actor, target, ctx) {\n    // can move?\n    ctx = (ctx || new AICtx(game, actor, target)).start();\n    const distanceMap = ctx.distanceMap;\n    const canMoveDiagonal = false;\n    // look for distance > current around me\n    let center = distanceMap[actor.x][actor.y];\n    let count = 0;\n    GWU.xy.eachNeighbor(actor.x, actor.y, (x, y) => {\n        const d = distanceMap[x][y];\n        if (d >= GWU.path.NO_PATH)\n            return;\n        if (distanceMap[x][y] > center) {\n            ++count;\n        }\n    }, canMoveDiagonal);\n    return ctx.done(count > 0);\n}\nexport async function moveAwayFrom(_game, actor, _target, _ctx) {\n    // safety/strategy?\n    // always move using safety map?\n    return actor.moveSpeed();\n}\nexport function canRunAwayFrom(_game, _actor, _target, _ctx) {\n    // can move?\n    return false;\n}\nexport async function runAwayFrom(_game, actor, _target, _ctx) {\n    // move toward loop if away from player\n    return actor.moveSpeed();\n}\nexport function canAttack(_game, _actor, _target, _ctx) {\n    // has attack?\n    // attach affects player?\n    return false;\n}\nexport async function attack(_game, actor, _target, _ctx) {\n    return actor.moveSpeed();\n}\nexport function tooFarFrom(_game, _actor, _target, _ctx) {\n    return false;\n}\nexport function tooCloseTo(_game, _actor, _target, _ctx) {\n    return false;\n}\nexport async function standStill(_game, actor, _ctx) {\n    return actor.moveSpeed();\n}\n","import * as GWU from 'gw-utils';\nimport * as Flags from '../flags';\nexport function fillSafetyMap(safetyMap, actor, target) {\n    const costGrid = GWU.grid.alloc(actor.costMap());\n    GWU.path.calculateDistances(safetyMap, target.x, target.y, costGrid, true);\n    safetyMap.update((v) => v * -1); // Can set factor to be < -1 e.g. -1.2\n    actor.map.actors.forEach((a) => {\n        if (a.willAttack(actor)) {\n            costGrid[a.x][a.y] = GWU.path.FORBIDDEN; // This is why we allocate a copy\n        }\n    });\n    actor.map.eachCell((c, x, y) => {\n        if (c.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n            safetyMap[x][y] -= GWU.path.AVOIDED; // loop cells are extra good\n        }\n    });\n    GWU.path.rescan(safetyMap, costGrid, true);\n    safetyMap.update((v) => (v <= -30000 ? 30000 : v));\n    GWU.grid.free(costGrid);\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Actor } from './actor';\nimport * as Memory from '../memory';\nimport * as AI from '../ai';\nexport class ActorKind extends Entity.EntityKind {\n    constructor(opts) {\n        super(opts);\n        this.flags = {\n            actor: Flags.Actor.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.vision = {};\n        this.actions = {};\n        this.bump = [];\n        this.moveSpeed = 100;\n        this.ai = null;\n        if (opts.flags) {\n            this.flags.actor = GWU.flag.from(Flags.Actor, this.flags.actor, opts.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, opts.flags);\n        }\n        if (opts.vision) {\n            this.vision.normal = opts.vision;\n        }\n        this.stats = opts.stats || {};\n        if (opts.actions) {\n            Object.assign(this.actions, opts.actions);\n        }\n        if (opts.moveSpeed) {\n            this.moveSpeed = opts.moveSpeed;\n        }\n        if (opts.ai) {\n            if (typeof opts.ai === 'string') {\n                opts.ai = AI.ais[opts.ai];\n            }\n            if (typeof opts.ai === 'function') {\n                this.ai = opts.ai;\n            }\n            else {\n                opts.ai = AI.ais['default'];\n            }\n        }\n        if (opts.bump) {\n            if (typeof opts.bump === 'string') {\n                opts.bump = opts.bump.split(/[|,]/g).map((t) => t.trim());\n            }\n            if (typeof opts.bump === 'function') {\n                opts.bump = [opts.bump];\n            }\n            if (Array.isArray(opts.bump)) {\n                this.bump = opts.bump.slice();\n            }\n        }\n    }\n    make(options) {\n        const actor = new Actor(this);\n        this.init(actor, options);\n        return actor;\n    }\n    init(actor, options = {}) {\n        super.init(actor, options);\n        Object.assign(actor.flags, this.flags);\n        if (options.fov) {\n            actor.fov = options.fov;\n        }\n        if (options.memory) {\n            actor.memory = options.memory;\n        }\n        if (this.vision.normal) {\n            actor.visionDistance = this.vision.normal;\n        }\n        actor.stats.init(this.stats);\n    }\n    addToMap(actor, map) {\n        super.addToMap(actor, map);\n        if (this.hasActorFlag(Flags.Actor.HAS_MEMORY)) {\n            actor.memory = Memory.get(actor, map);\n        }\n        if (this.hasActorFlag(Flags.Actor.USES_FOV)) {\n            actor.fov = new GWU.fov.FovSystem(map);\n            actor.fov.follow = actor;\n            if (actor.memory) {\n                actor.fov.callback = actor.memory;\n            }\n        }\n    }\n    removeFromMap(actor) {\n        super.removeFromMap(actor);\n        if (actor._map && actor.memory) {\n            Memory.store(actor, actor._map, actor.memory);\n        }\n    }\n    hasActorFlag(flag) {\n        return !!(this.flags.actor & flag);\n    }\n    canSeeEntity(_actor, _entity) {\n        return true;\n    }\n    isAbleToSee(_actor, _entity) {\n        return true;\n    }\n    isAbleToSense(_actor, _entity) {\n        return true;\n    }\n    forbidsCell(cell, actor) {\n        if (super.forbidsCell(cell, actor))\n            return true;\n        if (cell.blocksMove())\n            return true;\n        return false;\n    }\n    avoidsCell(cell, actor) {\n        if (super.avoidsCell(cell, actor))\n            return true;\n        if (cell.blocksMove())\n            return true;\n        if (cell.blocksPathing())\n            return true;\n        return false;\n    }\n    getFlavor(actor, opts) {\n        const flavor = actor.isPlayer() ? 'yourself' : this.flavor;\n        if (opts && opts.action) {\n            return flavor + ' standing';\n        }\n        return flavor;\n    }\n    pickupItem(actor, item, _opts) {\n        if (!GWU.list.push(actor, 'items', item))\n            return false;\n        // TODO - Pickup effects\n        return true;\n    }\n    dropItem(actor, item, _opts) {\n        if (!GWU.list.remove(actor, 'items', item))\n            return false;\n        // TODO - Drop effects\n        return true;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ActorKind } from './kind';\nexport function make(id, makeOptions) {\n    const kind = get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ActorKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ActorKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ActorKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ActorKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import { getAction, installAction } from '../action';\n// BUMP\n//\n// prefixes:\n// @ = only for player\n// + = only for ally\n// - = only for opposed\n// = = only for same kind\n// $ = use my action (if used with one of the above, this comes last)\n//\nexport async function bump(game, actor, ctx = {}) {\n    const other = ctx.actor;\n    if (other) {\n        const bumpActions = other.getBumpActions();\n        for (let action of bumpActions) {\n            if (typeof action === 'string') {\n                if (action.startsWith('$')) {\n                    const selfName = action.substring(1);\n                    let selfAction = other.getAction(selfName);\n                    if (selfAction === false) {\n                        throw new Error('Cannot have bump action for self action that actor cannot do: ' +\n                            action);\n                    }\n                    if (selfAction === true) {\n                        const baseAction = getAction(selfName);\n                        if (!baseAction) {\n                            throw new Error('Cannot have bump self action for unknown action: ' +\n                                selfName);\n                        }\n                        selfAction = baseAction;\n                    }\n                    const ctx2 = Object.assign({}, ctx, { actor });\n                    const result = await selfAction(game, other, ctx2);\n                    if (result)\n                        return result;\n                }\n                else {\n                    const config = actor.getAction(action);\n                    if (config === true) {\n                        const baseAction = getAction(action);\n                        if (!baseAction)\n                            throw new Error('Cannot find action for bump: ' + action);\n                        action = baseAction;\n                    }\n                    else if (config === false) {\n                        throw new Error('Cannot configure actor with bump action they cannot do: ' +\n                            action);\n                    }\n                    else {\n                        action = config;\n                    }\n                    const result = await action(game, actor, ctx);\n                    if (result)\n                        return result;\n                }\n            }\n            else {\n                const result = await action(game, actor, ctx);\n                if (result)\n                    return result;\n            }\n        }\n    }\n    const item = ctx.item;\n    if (item) {\n        // TODO - Item Actions\n    }\n    return 0;\n}\ninstallAction('bump', bump);\n","import { installAction } from '../action';\nexport async function standStill(_game, actor, _ctx) {\n    return actor.moveSpeed();\n}\ninstallAction('standStill', standStill);\ninstallAction('idle', standStill);\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\n// export class SpriteFX extends FX {\n//     sprite: GWU.sprite.SpriteConfig;\n//     stepCount: number;\n//     x: number;\n//     y: number;\n//     constructor(\n//         map: MapType,\n//         sprite: string | GWU.sprite.SpriteConfig,\n//         x: number,\n//         y: number,\n//         opts: SpriteFxOptions = {}\n//     ) {\n//         const count = opts.blink || 1;\n//         const duration = opts.duration || 1000;\n//         opts.speed = opts.speed || duration / (2 * count - 1);\n//         super(map, opts);\n//         if (typeof sprite === 'string') {\n//             const name = sprite;\n//             sprite = GWU.sprite.sprites[sprite];\n//             if (!sprite) throw new Error('Cannot find sprite! ' + name);\n//         }\n//         this.sprite = sprite;\n//         this.x = x || 0;\n//         this.y = y || 0;\n//         this.stepCount = 2 * count - 1;\n//     }\n//     start() {\n//         this.map.addFx(this.x, this.y, this.sprite);\n//         return super.start();\n//     }\n//     step() {\n//         --this.stepCount;\n//         if (this.stepCount <= 0) return this.stop();\n//         if (this.stepCount % 2 == 0) {\n//             this.map.removeFx(this);\n//         } else {\n//             this.map.addFx(this.x, this.y, this);\n//         }\n//     }\n//     stop(result?: any) {\n//         this.map.removeFx(this);\n//         return super.stop(result);\n//     }\n//     moveDir(dx: number, dy: number) {\n//         return this.moveTo(this.x + dx, this.y + dy);\n//     }\n//     moveTo(x: number, y: number) {\n//         this.map.moveFx(x, y, this);\n//         return true;\n//     }\n// }\nexport async function flashSprite(map, x, y, sprite, duration = 100, count = 1, animator) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ visible: true })\n        .to({ visible: false })\n        .repeat(count)\n        .repeatDelay(duration)\n        .duration(duration)\n        .onUpdate((obj) => {\n        if (obj.visible) {\n            map.addFx(x, y, entity);\n        }\n        else {\n            map.removeFx(entity);\n        }\n    });\n    // realTime\n    animator = animator || GWU.io.loop;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nGWU.sprite.install('bump', 'white', 50);\nexport async function hit(map, target, sprite, duration, animator) {\n    sprite = sprite || 'hit';\n    duration = duration || 200;\n    await flashSprite(map, target.x, target.y, sprite, duration, 1, animator);\n}\nGWU.sprite.install('hit', 'red', 50);\nexport async function miss(map, target, sprite, duration, animator) {\n    sprite = sprite || 'miss';\n    duration = duration || 200;\n    await flashSprite(map, target.x, target.y, sprite, duration, 1, animator);\n}\nGWU.sprite.install('miss', 'green', 50);\nexport async function fadeInOut(map, x, y, sprite, duration = 100, animator) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite).clone();\n    }\n    else {\n        sprite = GWU.sprite.make(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    map.addFx(x, y, entity);\n    const tween = GWU.tween\n        .make({ opacity: 0 })\n        .to({ opacity: 100 })\n        .repeat(2)\n        .yoyo(true)\n        .duration(Math.floor(duration / 2))\n        .onUpdate((obj) => {\n        entity.sprite.opacity = obj.opacity;\n        map.cell(x, y).needsRedraw = true; // we changed the sprite so redraw\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n    });\n    // realTime\n    animator = animator || GWU.io.loop;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nexport async function moveSprite(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const entity = Entity.make({ name: 'FX', sprite });\n    const from = { x: GWU.xy.x(source), y: GWU.xy.y(source) };\n    map.addFx(from.x, from.y, entity);\n    let duration = opts.duration ||\n        Math.ceil(16 * (GWU.xy.maxAxisFromTo(source, target) / (opts.speed || 8)));\n    if (GWU.xy.isLoc(target)) {\n        target = { x: target[0], y: target[1] };\n    }\n    const tween = GWU.tween\n        .make(from)\n        .to(target)\n        .duration(duration)\n        .onUpdate((vals) => {\n        // tweens dont update every step, so...\n        // draw line from current pos to vals pos\n        // check each step for blocking...\n        // end at either vals or last blocking spot\n        const dest = { x: entity.x, y: entity.y };\n        const ok = GWU.xy.forLineBetween(dest.x, dest.y, vals.x, vals.y, (x, y) => {\n            if (opts.stepFn) {\n                if (opts.stepFn(x, y)) {\n                    if (!opts.stopBeforeWalls) {\n                        dest.x = x;\n                        dest.y = y;\n                    }\n                    return false;\n                }\n            }\n            else if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (!opts.stopBeforeWalls) {\n                    dest.x = x;\n                    dest.y = y;\n                }\n                return false;\n            }\n            dest.x = x;\n            dest.y = y;\n        });\n        map.moveFx(entity, dest.x, dest.y);\n        if (!ok) {\n            tween.stop();\n        }\n    })\n        .onFinish(() => {\n        map.removeFx(entity);\n        return entity;\n    });\n    const animator = opts.animator || map;\n    animator.addAnimation(tween);\n    return tween.start();\n}\nexport function bolt(map, source, target, sprite, opts = {}) {\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport async function projectile(map, source, target, sprite, opts = {}) {\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    if (sprite.ch && sprite.ch.length == 4) {\n        const dir = GWU.xy.dirFromTo(source, target);\n        let index = 0;\n        if (dir[0] && dir[1]) {\n            index = 2;\n            if (dir[0] != dir[1]) {\n                // remember up is -y\n                index = 3;\n            }\n        }\n        else if (dir[0]) {\n            index = 1;\n        }\n        const ch = sprite.ch[index];\n        sprite = GWU.sprite.make(ch, sprite.fg, sprite.bg);\n    }\n    else if (sprite.ch && sprite.ch.length !== 1) {\n        throw new Error('projectile requires 4 chars - vert,horiz,diag-left,diag-right (e.g: \"|-\\\\/\")');\n    }\n    return moveSprite(map, source, target, sprite, opts);\n}\nexport function beam(map, from, to, sprite, opts = {}) {\n    opts.fade = opts.fade || 100;\n    if (opts.stopAtWalls === undefined)\n        opts.stopAtWalls = true;\n    const line = [];\n    GWU.xy.forLineFromTo(from, to, (x, y) => {\n        if (!map.hasXY(x, y))\n            return false;\n        if (opts.stepFn && opts.stepFn(x, y))\n            return false;\n        if (opts.stopAtWalls || opts.stopBeforeWalls) {\n            if (map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE)) {\n                if (opts.stopBeforeWalls)\n                    return false;\n                line.push([x, y]);\n                return false;\n            }\n        }\n        line.push([x, y]);\n        return true;\n    });\n    const duration = opts.duration || Math.ceil(16 * (line.length / (opts.speed || 8)));\n    const animator = opts.animator || map;\n    const promises = [];\n    let lastIndex = -1;\n    const tween = GWU.tween\n        .make({ index: 0 })\n        .to({ index: line.length - 1 })\n        .duration(duration)\n        .onUpdate((vals) => {\n        while (lastIndex < vals.index) {\n            ++lastIndex;\n            const loc = line[lastIndex] || [-1, -1];\n            promises.push(fadeInOut(map, loc[0], loc[1], sprite, opts.fade, animator));\n        }\n    })\n        .onFinish(async () => {\n        await Promise.all(promises);\n        const loc = line[line.length - 1];\n        return { x: loc[0], y: loc[1] };\n    });\n    animator.addAnimation(tween);\n    return tween.start();\n}\nfunction isInShape(shape, cx, cy, allowCenter, x, y) {\n    const sx = Math.abs(x - cx);\n    const sy = Math.abs(y - cy);\n    if (sx == 0 && sy == 0 && !allowCenter)\n        return false;\n    switch (shape) {\n        case '+':\n            return sx == 0 || sy == 0;\n        case 'x':\n        case 'X':\n            return sx == sy;\n        case '*':\n            return sx == 0 || sy == 0 || sx == sy;\n        default:\n            return true;\n    }\n}\nfunction checkExplosionOpts(opts) {\n    opts.speed = opts.speed || 2;\n    opts.fade = opts.fade || 100;\n    opts.shape = opts.shape || 'o';\n    if (opts.center === undefined) {\n        opts.center = true;\n    }\n}\nexport function explosion(map, x, y, radius, sprite, opts = {}) {\n    checkExplosionOpts(opts);\n    opts.animator = opts.animator || map;\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    if (typeof sprite === 'string') {\n        sprite = GWU.sprite.from(sprite);\n    }\n    const grid = GWU.grid.alloc(map.width, map.height);\n    const fov = new GWU.fov.FOV({\n        isBlocked(x, y) {\n            return map.hasEntityFlag(x, y, Flags.Entity.L_BLOCKS_MOVE);\n        },\n        hasXY(x, y) {\n            return map.hasXY(x, y);\n        },\n    });\n    fov.calculate(x, y, radius, (x1, y1) => {\n        grid[x1][y1] = 1;\n    });\n    const duration = opts.duration || 32 * (radius / opts.speed);\n    const promises = [];\n    const tween = GWU.tween\n        .make({ r: 0 })\n        .to({ r: radius })\n        .duration(duration)\n        .onUpdate((vals) => {\n        const minX = Math.max(0, x - vals.r);\n        const minY = Math.max(0, y - vals.r);\n        const maxX = Math.min(map.width - 1, x + vals.r);\n        const maxY = Math.min(map.height - 1, y + vals.r);\n        for (let x1 = minX; x1 <= maxX; ++x1) {\n            for (let y1 = minY; y1 <= maxY; ++y1) {\n                if (grid[x1][y1] &&\n                    GWU.xy.distanceBetween(x, y, x1, y1) <= vals.r) {\n                    grid[x1][y1] = 0;\n                    if (isInShape(opts.shape, x, y, opts.center, x1, y1)) {\n                        promises.push(fadeInOut(map, x1, y1, sprite, opts.fade, opts.animator));\n                    }\n                }\n            }\n        }\n    })\n        .onFinish(async (_obj, success) => {\n        GWU.grid.free(grid);\n        await Promise.all(promises);\n        return success;\n    });\n    opts.animator.addAnimation(tween);\n    return tween.start();\n}\n/*\nexport function explosionFor(\n    map: MapType,\n    grid: GWU.grid.NumGrid,\n    x: number,\n    y: number,\n    radius: number,\n    sprite: string | GWU.sprite.SpriteConfig,\n    opts: ExplosionOptions = {}\n) {\n    checkExplosionOpts(opts);\n    // opts.stepFn = opts.stepFn || ((x, y) => !map.isObstruction(x, y));\n    const animation = new ExplosionFX(\n        map,\n        grid,\n        x,\n        y,\n        radius,\n        sprite,\n        opts.speed,\n        opts.fade,\n        opts.shape,\n        opts.center,\n        opts.stepFn\n    );\n    return opts.playFn!(animation);\n}\n*/\n","import { installAction } from '../action';\nimport { bump } from './bump';\nimport { standStill } from './standStill';\nimport * as FX from '../../fx';\nexport async function moveDir(game, actor, ctx = {}) {\n    //\n    const step = ctx.dir;\n    if (!step)\n        throw new Error('moveDir called with no direction!');\n    const newX = actor.x + step[0];\n    const newY = actor.y + step[1];\n    const map = game.map;\n    const currentCell = map.cell(actor.x, actor.y);\n    const newCell = map.cell(newX, newY);\n    let result = 0;\n    if (newCell.blocksMove()) {\n        FX.hit(map, newCell, 'hit', 100);\n        return actor.moveSpeed();\n    }\n    // can we leave?\n    if (!currentCell.canRemoveActor(actor)) {\n        // canActorLeave must add appropriate message\n        return actor.moveSpeed();\n    }\n    // is there an actor there?\n    if (newCell.hasActor() || newCell.hasItem()) {\n        const ctx2 = { actor: newCell.actor, item: newCell.item };\n        result = await bump(game, actor, ctx2);\n        if (result)\n            return result;\n    }\n    // can we enter?\n    if (!newCell.canAddActor(actor)) {\n        return actor.moveSpeed();\n    }\n    if (!map.moveActor(actor, newX, newY)) {\n        result = await standStill(game, actor, ctx);\n        return result;\n    }\n    result = actor.moveSpeed();\n    return result;\n}\ninstallAction('moveDir', moveDir);\n","import { Entity } from '../entity';\nimport { Depth } from '../flags';\nexport class Item extends Entity {\n    constructor(kind) {\n        super(kind);\n        this.quantity = 1;\n        this.next = null;\n        // @ts-ignore - initialized in constructor\n        this.flags.item = 0;\n        this.depth = Depth.ITEM;\n        this.kind = kind;\n    }\n    copy(other) {\n        super.copy(other);\n        this.quantity = other.quantity;\n    }\n    itemFlags() {\n        return this.flags.item;\n    }\n    hasItemFlag(flag) {\n        return !!(this.flags.item & flag);\n    }\n    hasAllItemFlags(flags) {\n        return (this.flags.item & flags) === flags;\n    }\n    getAction(name) {\n        const action = this.kind.actions[name];\n        return action;\n    }\n    getBumpActions() {\n        return this.kind.bump;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Entity from '../entity';\nimport * as Flags from '../flags';\nimport { Item } from './item';\nexport class ItemKind extends Entity.EntityKind {\n    constructor(config) {\n        super(config);\n        this.flags = {\n            item: Flags.Item.DEFAULT,\n            entity: Flags.Entity.DEFAULT_ACTOR,\n        };\n        this.actions = {};\n        this.bump = [];\n        if (config.flags) {\n            this.flags.item = GWU.flag.from(Flags.Item, this.flags.item, config.flags);\n            this.flags.entity = GWU.flag.from(Flags.Entity, this.flags.entity, config.flags);\n        }\n        if (config.actions) {\n            Object.entries(config.actions).forEach(([key, value]) => {\n                this.actions[key] = value;\n            });\n        }\n        if (config.bump) {\n            if (typeof config.bump === 'string' ||\n                typeof config.bump === 'function') {\n                config.bump = [config.bump];\n            }\n            if (Array.isArray(config.bump)) {\n                this.bump = config.bump.slice();\n            }\n        }\n    }\n    make(options) {\n        const item = new Item(this);\n        this.init(item, options);\n        return item;\n    }\n    init(item, options = {}) {\n        super.init(item, options);\n        Object.assign(item.flags, this.flags);\n        item.quantity = options.quantity || 1;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { ItemKind } from './kind';\nexport function make(id, makeOptions) {\n    const kind = get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function makeRandom(opts, makeOptions) {\n    const kind = randomKind(opts);\n    if (!kind)\n        throw new Error('Failed to find item kind matching - ' + JSON.stringify(opts));\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n    }\n    else if (info instanceof ItemKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport const kinds = {};\nexport function install(id, kind) {\n    if (kind instanceof ItemKind) {\n        kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof ItemKind)\n        return id;\n    return kinds[id];\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new ItemKind(config);\n}\nexport function randomKind(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    const matches = Object.values(kinds).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        return true;\n    });\n    const rng = opts.rng || GWU.rng.random;\n    return rng.item(matches) || null;\n}\n","import * as GWU from 'gw-utils';\nimport { Entity as ObjectFlags } from '../flags/entity';\nimport * as Flags from '../flags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GWU.grid.alloc(map.width, map.height);\n    const grid = GWU.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.blocksPathing() || cell.blocksMove()) &&\n                !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= Flags.Cell.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cell(i, j).flags.cell &= ~Flags.Cell.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cell(i, j).flags.cell & Flags.Cell.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GWU.xy.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    const newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cell(i, j).flags.cell |=\n                                    Flags.Cell.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cell(i, j).chokeCount = 30000;\n                // Not sure why this was done in Brogue\n                // if (map.cell(i, j).flags.cell & Flags.Cell.IS_IN_ROOM_MACHINE) {\n                //     passMap[i][j] = 0;\n                // }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cell(i, j);\n                if (passMap[i][j] &&\n                    cell.flags.cell & Flags.Cell.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GWU.xy.DIRS[dir][0];\n                        const newY = j + GWU.xy.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cell(newX, newY).flags.cell &\n                                Flags.Cell.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cell(i2, j2).chokeCount) {\n                                            map.cell(i2, j2).chokeCount = cellCount;\n                                            map.cell(i2, j2).flags.cell &= ~Flags.Cell\n                                                .IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cell |= Flags.Cell.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GWU.grid.free(passMap);\n    GWU.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    function getCount(x, y) {\n        let count = passMap[x][y] == 2 ? 5000 : 1;\n        if (map.cell(x, y).flags.cell & Flags.Cell.IS_IN_AREA_MACHINE) {\n            count = 10000;\n        }\n        return count;\n    }\n    let count = 0;\n    const todo = [[startX, startY]];\n    const free = [];\n    while (todo.length) {\n        const item = todo.pop();\n        free.push(item);\n        const x = item[0];\n        const y = item[1];\n        if (results[x][y])\n            continue;\n        results[x][y] = 1;\n        count += getCount(x, y);\n        for (let dir = 0; dir < 4; dir++) {\n            const newX = x + GWU.xy.DIRS[dir][0];\n            const newY = y + GWU.xy.DIRS[dir][1];\n            if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                passMap[newX][newY] &&\n                !results[newX][newY]) {\n                const item = free.pop() || [-1, -1];\n                item[0] = newX;\n                item[1] = newY;\n                todo.push(item);\n            }\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.eachCell(resetLoopiness);\n    checkLoopiness(map);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.blocksPathing() || cell.blocksMove()) &&\n        !cell.hasEntityFlag(ObjectFlags.L_SECRETLY_PASSABLE)) {\n        cell.flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cell |= Flags.Cell.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    const todo = GWU.grid.alloc(map.width, map.height, 1);\n    let tryAgain = true;\n    while (tryAgain) {\n        tryAgain = false;\n        todo.forEach((v, x, y) => {\n            if (!v)\n                return;\n            const cell = map.cell(x, y);\n            todo[x][y] = 0;\n            if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                return;\n            }\n            // find an unloopy neighbor to start on\n            for (sdir = 0; sdir < 8; sdir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[sdir][0];\n                newY = y + GWU.xy.CLOCK_DIRS[sdir][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const cell = map.cell(newX, newY);\n                if (!cell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    break;\n                }\n            }\n            if (sdir == 8) {\n                // no unloopy neighbors\n                return; // leave cell loopy\n            }\n            // starting on this unloopy neighbor,\n            // work clockwise and count up:\n            // (a) the number of strings of loopy neighbors, and\n            // (b) the length of the longest such string.\n            numStrings = maxStringLength = currentStringLength = 0;\n            inString = false;\n            for (dir = sdir; dir < sdir + 8; dir++) {\n                newX = x + GWU.xy.CLOCK_DIRS[dir % 8][0];\n                newY = y + GWU.xy.CLOCK_DIRS[dir % 8][1];\n                if (!map.hasXY(newX, newY))\n                    continue;\n                const newCell = map.cell(newX, newY);\n                if (newCell.hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                    currentStringLength++;\n                    if (!inString) {\n                        numStrings++;\n                        inString = true;\n                        if (numStrings > 1) {\n                            break; // more than one string here; leave loopy\n                        }\n                    }\n                }\n                else if (inString) {\n                    if (currentStringLength > maxStringLength) {\n                        maxStringLength = currentStringLength;\n                    }\n                    currentStringLength = 0;\n                    inString = false;\n                }\n            }\n            if (inString && currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            if (numStrings == 1 && maxStringLength <= 4) {\n                cell.clearCellFlag(Flags.Cell.IS_IN_LOOP);\n                // console.log(x, y, numStrings, maxStringLength);\n                // map.dump((c) =>\n                //     c.hasCellFlag(Flags.Cell.IS_IN_LOOP) ? '*' : ' '\n                // );\n                for (dir = 0; dir < 8; dir++) {\n                    newX = x + GWU.xy.CLOCK_DIRS[dir][0];\n                    newY = y + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) &&\n                        map.cell(newX, newY).hasCellFlag(Flags.Cell.IS_IN_LOOP)) {\n                        todo[newX][newY] = 1;\n                        tryAgain = true;\n                    }\n                }\n            }\n        });\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cell(x, y);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cell(x, y - 1);\n                const left = map.cell(x - 1, y);\n                if (up.flags.cell & Flags.Cell.IS_IN_LOOP &&\n                    left.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GWU.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cell & Flags.Cell.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GWU.xy.CLOCK_DIRS[dir][0];\n                    let newY = j + GWU.xy.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cell(newX, newY).flags.cell &\n                            Flags.Cell.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cell(i, j).flags.cell &= ~Flags.Cell.IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GWU.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import * as GWU from 'gw-utils';\nimport { Map } from './map';\nexport class Snapshot {\n    constructor(map) {\n        this.map = new Map(map.width, map.height);\n        this.version = 0;\n    }\n}\nexport class SnapshotManager {\n    constructor(map) {\n        this.version = 0;\n        this.layerVersion = [];\n        this.lightVersion = 0;\n        // fovVersion = 0;\n        this.free = [];\n        this.map = map;\n        this.cellVersion = GWU.grid.make(map.width, map.height);\n        this.layerVersion = map.layers.map(() => 1);\n    }\n    takeNew() {\n        ++this.version;\n        const snap = this.free.length\n            ? this.free.pop()\n            : new Snapshot(this.map);\n        snap.map.flags.map = this.map.flags.map;\n        this.cellVersion.update((v, x, y) => {\n            const srcCell = this.map.cell(x, y);\n            if (srcCell.changed) {\n                v = this.version;\n            }\n            if (v !== snap.version) {\n                const destCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n            }\n            return v;\n        });\n        // systems\n        if (this.map.light.changed) {\n            this.lightVersion = this.version;\n            this.map.light.changed = false;\n        }\n        if (snap.version !== this.lightVersion) {\n            snap.map.light.copy(this.map.light);\n        }\n        // if (this.map.fov.changed) {\n        //     this.fovVersion = this.version;\n        //     this.map.fov.changed = false;\n        // }\n        // if (snap.version !== this.fovVersion) {\n        //     snap.map.fov.copy(this.map.fov);\n        // }\n        // layers\n        this.map.layers.forEach((layer, index) => {\n            const snapLayer = snap.map.layers[index];\n            if (layer.changed) {\n                this.layerVersion[index] = this.version;\n            }\n            if (this.layerVersion[index] !== snap.version) {\n                snapLayer.copy(layer);\n            }\n        });\n        snap.version = this.version;\n        return snap;\n    }\n    revertMapTo(snap) {\n        this.cellVersion.update((v, x, y) => {\n            if (v < snap.version)\n                return v;\n            const destCell = this.map.cell(x, y);\n            if (v > snap.version || destCell.changed) {\n                const srcCell = snap.map.cell(x, y);\n                destCell.copy(srcCell);\n                return snap.version;\n            }\n            return v;\n        });\n        // systems\n        if (snap.version < this.lightVersion || this.map.light.changed) {\n            this.map.light.copy(snap.map.light);\n            this.lightVersion = snap.version;\n        }\n        // if (snap.version < this.fovVersion || this.map.fov.changed) {\n        //     this.map.fov.copy(snap.map.fov);\n        //     this.fovVersion = snap.version;\n        // }\n        // layers\n        this.layerVersion.forEach((v, index) => {\n            if (v < snap.version)\n                return;\n            const destLayer = this.map.layers[index];\n            if (v > snap.version || destLayer.changed) {\n                const srcLayer = snap.map.layers[index];\n                destLayer.copy(srcLayer);\n                this.layerVersion[index] = snap.version;\n            }\n        });\n        this.version = snap.version;\n    }\n    release(snap) {\n        this.free.push(snap);\n    }\n}\n","import * as GWU from 'gw-utils';\nexport function isHallway(map, x, y) {\n    return (GWU.xy.arcCount(x, y, (i, j) => {\n        return map.cell(i, j).isPassable();\n    }) > 1);\n}\n","import * as GWU from 'gw-utils';\nexport function getCellPathCost(map, x, y) {\n    const cell = map.cell(x, y);\n    if (cell.blocksMove())\n        return GWU.path.OBSTRUCTION;\n    if (cell.blocksPathing())\n        return GWU.path.FORBIDDEN;\n    if (cell.hasActor())\n        return 10;\n    return 1;\n}\nexport function fillCostMap(map, costMap) {\n    costMap.update((_v, x, y) => getCellPathCost(map, x, y));\n}\nexport function getPathBetween(map, x0, y0, x1, y1, options = {}) {\n    const distanceMap = GWU.grid.alloc(map.width, map.height);\n    const costMap = GWU.grid.alloc(map.width, map.height);\n    fillCostMap(map, costMap);\n    GWU.path.calculateDistances(distanceMap, x0, y0, costMap, options.eightWays, GWU.xy.straightDistanceBetween(x0, y0, x1, y1) + 1);\n    const path = GWU.path.getPath(distanceMap, x1, y1, (x, y) => map.cell(x, y).blocksMove(), options.eightWays);\n    GWU.grid.free(costMap);\n    GWU.grid.free(distanceMap);\n    return path;\n}\n","import * as GWU from 'gw-utils';\nimport { Horde as Flags } from '../flags/horde';\nimport * as Map from '../map';\nimport * as Actor from '../actor';\nexport class Horde {\n    // requiredTile: string | null = null;\n    constructor(config) {\n        this.tags = [];\n        this.members = {};\n        // blueprintId: string | null = null;\n        this.flags = { horde: 0 };\n        if (config.tags) {\n            if (typeof config.tags === 'string') {\n                this.tags = config.tags.split(/[,|]/).map((t) => t.trim());\n            }\n            else {\n                this.tags = config.tags.slice();\n            }\n        }\n        this.leader = config.leader;\n        if (config.members) {\n            Object.entries(config.members).forEach(([id, range]) => {\n                this.members[id] = GWU.range.make(range);\n            });\n        }\n        this.frequency = GWU.frequency.make(config.frequency || 100);\n        // this.blueprintId = config.blueprintId || null;\n        this.flags.horde = GWU.flag.from(Flags, config.flags);\n        // if (config.requiredTile) this.requiredTile = config.requiredTile;\n    }\n    spawn(map, x = -1, y = -1, opts = {}) {\n        var _a;\n        opts.canSpawn = opts.canSpawn || GWU.TRUE;\n        opts.rng = opts.rng || map.rng;\n        opts.machine = (_a = opts.machine) !== null && _a !== void 0 ? _a : 0;\n        const leader = this._spawnLeader(map, x, y, opts);\n        if (!leader)\n            return null;\n        this._spawnMembers(leader, map, opts);\n        return leader;\n    }\n    _spawnLeader(map, x, y, opts) {\n        const leaderKind = Actor.get(this.leader);\n        if (!leaderKind) {\n            throw new Error('Failed to find leader kind = ' + this.leader);\n        }\n        if (x >= 0 && y >= 0) {\n            if (leaderKind.avoidsCell(map.cell(x, y)))\n                return null;\n        }\n        const leader = Actor.make(leaderKind, { machineHome: opts.machine });\n        if (!leader)\n            throw new Error('Failed to make horde leader - ' + this.leader);\n        if (x < 0 || y < 0) {\n            [x, y] = this._pickLeaderLoc(leader, map, opts) || [-1, -1];\n            if (x < 0 || y < 0) {\n                return null;\n            }\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addLeader(leader, map, x, y, opts)) {\n            return null;\n        }\n        return leader;\n    }\n    _addLeader(leader, map, x, y, _opts) {\n        return map.addActor(x, y, leader);\n    }\n    _addMember(member, map, x, y, leader, _opts) {\n        member.leader = leader;\n        return map.addActor(x, y, member);\n    }\n    _spawnMembers(leader, map, opts) {\n        const entries = Object.entries(this.members);\n        if (entries.length == 0)\n            return 0;\n        let count = 0;\n        entries.forEach(([kindId, countRange]) => {\n            const count = countRange.value(opts.rng);\n            for (let i = 0; i < count; ++i) {\n                this._spawnMember(kindId, map, leader, opts);\n            }\n        });\n        return count;\n    }\n    _spawnMember(kindId, map, leader, opts) {\n        const kind = Actor.get(kindId);\n        if (!kind) {\n            throw new Error('Failed to find member kind = ' + kindId);\n        }\n        const member = Actor.make(kind, { machineHome: opts.machine });\n        if (!member)\n            throw new Error('Failed to make horde member - ' + kindId);\n        const [x, y] = this._pickMemberLoc(member, map, leader, opts) || [\n            -1, -1,\n        ];\n        if (x < 0 || y < 0) {\n            return null;\n        }\n        // pre-placement stuff?  machine? effect?\n        if (!this._addMember(member, map, x, y, leader, opts)) {\n            return null;\n        }\n        return member;\n    }\n    _pickLeaderLoc(leader, map, opts) {\n        let loc = opts.rng.matchingLoc(map.width, map.height, (x, y) => {\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            if (!opts.canSpawn(x, y))\n                return false;\n            if (leader.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n    _pickMemberLoc(actor, map, leader, opts) {\n        let loc = opts.rng.matchingLocNear(leader.x, leader.y, (x, y) => {\n            if (!map.hasXY(x, y))\n                return false;\n            const cell = map.cell(x, y);\n            if (cell.hasActor())\n                return false; // Brogue kills existing actors, but lets do this instead\n            // if (map.fov.isAnyKindOfVisible(x, y)) return false;\n            if (actor.avoidsCell(cell))\n                return false;\n            if (Map.isHallway(map, x, y)) {\n                return false;\n            }\n            return true;\n        });\n        return loc;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport { Horde } from './horde';\nimport { Horde as Flags } from '../flags/horde';\nexport const hordes = {};\nexport function install(id, horde) {\n    if (typeof horde === 'string') {\n        horde = { leader: horde };\n    }\n    if (!(horde instanceof Horde)) {\n        horde = new Horde(horde);\n    }\n    hordes[id] = horde;\n    return horde;\n}\nexport function installAll(hordes) {\n    Object.entries(hordes).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function from(id) {\n    if (id instanceof Horde) {\n        return id;\n    }\n    if (typeof id === 'string') {\n        return hordes[id];\n    }\n    return new Horde(id);\n}\nexport function random(opts = {}) {\n    const match = {\n        tags: [],\n        forbidTags: [],\n        flags: 0,\n        forbidFlags: 0,\n        depth: 0,\n    };\n    if (typeof opts === 'string') {\n        opts = {\n            tags: opts,\n        };\n    }\n    const rng = opts.rng || GWU.rng.random;\n    if (typeof opts.tags === 'string') {\n        opts.tags\n            .split(/[,|&]/)\n            .map((t) => t.trim())\n            .forEach((t) => {\n            if (t.startsWith('!')) {\n                match.forbidTags.push(t.substring(1).trim());\n            }\n            else {\n                match.tags.push(t);\n            }\n        });\n    }\n    else if (Array.isArray(opts.tags)) {\n        match.tags = opts.tags.slice();\n    }\n    if (typeof opts.forbidTags === 'string') {\n        match.forbidTags = opts.forbidTags.split(/[,|&]/).map((t) => t.trim());\n    }\n    else if (Array.isArray(opts.forbidTags)) {\n        match.forbidTags = opts.forbidTags.slice();\n    }\n    if (opts.flags) {\n        if (typeof opts.flags === 'string') {\n            opts.flags\n                .split(/[,|]/)\n                .map((t) => t.trim())\n                .forEach((flag) => {\n                if (flag.startsWith('!')) {\n                    const key = flag.substring(1);\n                    match.forbidFlags |= Flags[key];\n                }\n                else {\n                    match.flags |= Flags[flag];\n                }\n            });\n        }\n    }\n    if (opts.forbidFlags) {\n        match.forbidFlags = GWU.flag.from(Flags, opts.forbidFlags);\n    }\n    if (opts.depth) {\n        match.depth = opts.depth;\n    }\n    if (match.depth && opts.oodChance) {\n        while (rng.chance(opts.oodChance)) {\n            match.depth += 1;\n        }\n        match.forbidFlags |= Flags.HORDE_NEVER_OOD;\n    }\n    const matches = Object.values(hordes).filter((k) => {\n        if (match.tags.length && !GWU.arraysIntersect(match.tags, k.tags))\n            return false;\n        if (match.forbidTags && GWU.arraysIntersect(match.forbidTags, k.tags))\n            return false;\n        if (match.flags && !(k.flags.horde & match.flags)) {\n            return false;\n        }\n        if (match.forbidFlags && k.flags.horde & match.forbidFlags) {\n            return false;\n        }\n        return true;\n    });\n    if (match.depth) {\n        return rng.item(matches) || null;\n    }\n    const depth = match.depth;\n    const weights = matches.map((h) => h.frequency(depth));\n    const index = rng.weighted(weights);\n    if (index < 0)\n        return null;\n    return matches[index];\n}\n","export const actions = {};\nexport function install(name, fn) {\n    actions[name] = fn;\n}\nexport function get(name) {\n    return actions[name];\n}\n","import { install } from './command';\nimport * as Actor from '../actor';\n// COMMANDS\n// this === GAME\nexport async function moveDir(actor, e) {\n    const dir = e.dir;\n    if (!actor.map || !dir)\n        return -1;\n    return Actor.actions.moveDir(this, actor, e);\n}\ninstall('moveDir', moveDir);\n","import * as GWU from 'gw-utils';\nimport { install } from './command';\nexport async function pickup(actor, _ev) {\n    if (!actor.map)\n        return -1;\n    const playerAction = actor.getAction('pickup');\n    if (playerAction === false) {\n        GWU.message.addAt(actor.x, actor.y, 'You cannot pickup items.');\n        return actor.endTurn();\n    }\n    else if (typeof playerAction === 'function') {\n        // You have to do everything\n        const result = await playerAction(this, actor);\n        if (result)\n            return result; // handled\n    }\n    const item = actor.map.itemAt(actor.x, actor.y);\n    if (!item) {\n        GWU.message.addAt(actor.x, actor.y, 'Nothing to pickup.');\n        return 0;\n    }\n    if (actor.avoidsItem(item))\n        return 0;\n    const itemAction = item.getAction('pickup');\n    if (itemAction === false) {\n        GWU.message.addAt(actor.x, actor.y, 'You cannot pickup %{the.item}.', {\n            item,\n        });\n        return 0;\n    }\n    else if (typeof itemAction === 'function') {\n        // You have to do everything\n        const result = await itemAction(this, actor, item);\n        if (result)\n            return result; // handled\n    }\n    // logs error messages\n    if (!actor.canAddItem(item)) {\n        return 0;\n    }\n    if (!actor.map.removeItem(item)) {\n        return 0;\n    }\n    actor.addItem(item);\n    return actor.endTurn();\n}\ninstall('pickup', pickup);\n","/*\n    Attributes\n    ========================\n\n    To configure attributes, set the defaults:\n\n    Attribute.install(')\n\n    const attr = new Attributes(10);\n\n    attr.set('str', 10);\n    attr.set('dex', 10);\n    ...\n    attr.set('chr', 10);\n\n    // to get the current value\n    attr.get('str');\n\n    // To raise an attribute permanently\n    attr.gain('chr', 1);\n\n    // To raise an attribute temporarily\n    attr.gain('chr', 1, false);\n\n    // To lower an attribute permanently\n    attr.drain('chr', 1, true);\n\n    // to lower an attribute temporarily\n    attr.drain('chr', 1);\n\n    // to restore (remove) all temporary changes\n    attr.restore();\n\n    // to add a temporary change that can be removed by itself\n    attr.addBonus('str', 1);\n\n    // to remove the bonus\n    attr.clearBonus('str', 1);\n\n    // adjustments (bonuses) are also possible via:\n    attr.adjust('str', { bonus: 1 });\n\n    // But adjustments can also set the\n    attr.adjust('str', { fixed: 14 });      // temporarily sets base\n    attr.adjust('str', { base: 21 });       // resets the base\n    attr.adjust('str', { restore: true });  // removes all bonuses/penalties\n    attr.adjust('str', { min: 10 });        // limits value\n    attr.adjust('str', { max: 30 });        // limits value\n    attr.adjust('str', { sustain: true });  // turns off lowering values\n*/\nexport class Attributes {\n    constructor(baseValues) {\n        this._base = {};\n        this._max = {};\n        this._bonus = {};\n        this._sustain = {};\n        this._value = {};\n        this.changed = null;\n        this.init(baseValues);\n    }\n    init(baseValues) {\n        for (let k in attributes) {\n            const v = typeof baseValues === 'number' ? baseValues : attributes[k];\n            this.set(k, v);\n        }\n        if (typeof baseValues !== 'number') {\n            for (let k in baseValues) {\n                this.set(k, baseValues[k]);\n            }\n        }\n    }\n    forEach(fn) {\n        Object.keys(attributes).forEach((k) => fn(this.get(k)));\n    }\n    // modifier(name: string) {\n    //     return Math.floor((this.get(name) - 10) / 2);\n    // }\n    get(name) {\n        return this._value[name] || 0;\n    }\n    set(name, value = 0) {\n        this._value[name] = value;\n        this._base[name] = value;\n        this._max[name] = value;\n        this._bonus[name] = [];\n        return value;\n    }\n    base(name) {\n        return this._base[name] || 0;\n    }\n    max(name) {\n        return this._max[name] || 0;\n    }\n    sustain(name) {\n        return this._sustain[name] || false;\n    }\n    gain(name, delta, raiseMax = true) {\n        if (delta < 0 && this._sustain[name])\n            return 0;\n        this._base[name] += delta;\n        if (raiseMax && this._base[name] > this._max[name]) {\n            this._max[name] = this._base[name];\n        }\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    drain(name, loss, lowerMax = false) {\n        if (loss < 0)\n            loss = -loss;\n        const changed = this.gain(name, -loss, false);\n        if (changed && lowerMax) {\n            this._max[name] = this._base[name];\n        }\n        return changed;\n    }\n    restore(name) {\n        this._base[name] = this._max[name];\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    addBonus(name, bonus) {\n        return this._addBonus(name, { bonus });\n    }\n    _addBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        if (this._value[name] === undefined) {\n            this.set(name, 0);\n        }\n        this._bonus[name].push(bonus);\n        let old = this.get(name);\n        return this._calcValue(name) - old;\n    }\n    clearBonus(name, bonus) {\n        return this._clearBonus(name, { bonus });\n    }\n    _clearBonus(name, bonus) {\n        if (typeof bonus === 'number')\n            bonus = { bonus };\n        let arr = this._bonus[name] || [];\n        let key = JSON.stringify(bonus);\n        let index = arr.findIndex((o) => {\n            return JSON.stringify(o) == key;\n        });\n        if (index > -1) {\n            arr.splice(index, 1);\n            let old = this.get(name);\n            return this._calcValue(name) - old;\n        }\n        return 0;\n    }\n    _calcValue(name) {\n        let allAdjustments = {};\n        this._bonus[name].forEach((adj) => this._applyAdjustment(allAdjustments, adj));\n        this._sustain[name] = allAdjustments.sustain || false;\n        let value = this._base[name] || 0;\n        if (allAdjustments.fixed !== undefined) {\n            value = allAdjustments.fixed;\n        }\n        else {\n            value += allAdjustments.bonus || 0;\n            if (allAdjustments.min !== undefined) {\n                value = Math.max(allAdjustments.min, value);\n            }\n            if (allAdjustments.max !== undefined) {\n                value = Math.min(allAdjustments.max, value);\n            }\n        }\n        return (this._value[name] = value);\n    }\n    adjust(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.gain(name, adj.base);\n        }\n        else if (adj.restore) {\n            delta = this.restore(name);\n            if (delta == 0)\n                delta = undefined;\n        }\n        else {\n            delta = this._addBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    clearAdjustment(name, adj) {\n        let delta = undefined;\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        if (adj.base) {\n            delta = this.drain(name, adj.base, true);\n        }\n        else if (adj.restore) {\n            // do nothing...\n        }\n        else {\n            delta = this._clearBonus(name, adj);\n        }\n        if (this.changed && delta !== undefined)\n            this.changed(this, name);\n        return delta;\n    }\n    _applyAdjustment(total, opts) {\n        if (opts.bonus) {\n            total.bonus = (total.bonus || 0) + opts.bonus;\n        }\n        if (opts.fixed !== undefined) {\n            total.fixed = Math.max(total.fixed || 0, opts.fixed);\n        }\n        if (opts.min !== undefined) {\n            total.min = Math.max(total.min || 0, opts.min);\n        }\n        if (opts.max !== undefined) {\n            total.max = Math.max(total.max || 0, opts.max);\n        }\n        if (opts.sustain !== undefined) {\n            total.sustain = opts.sustain;\n        }\n    }\n}\nexport const attributes = {};\nexport function installAttribute(attr) {\n    if (typeof attr === 'string') {\n        attributes[attr] = 0;\n        return;\n    }\n    // clear existing\n    Object.keys(attributes).forEach((k) => {\n        delete attributes[k];\n    });\n    Object.assign(attributes, attr);\n}\nexport function makeAttributes(defaults) {\n    return new Attributes(defaults);\n}\n/*\nfunction adjust(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = undefined;\n        if (a.base) {\n            delta = being.attributes.addBase(a.name, a.base);\n        } else if (a.restore) {\n            delta = being.attributes.restoreBase(a.name);\n            if (delta == 0) delta = undefined;\n        } else {\n            delta = being.attributes.addBonus(a.name, a);\n        }\n        if (delta !== undefined) {\n            out[a.name] = delta;\n        }\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n\n    return results;\n};\n\n function clearAdjustment(being, ...args) {\n    let adj;\n    if (args.length == 1 && typeof args[0] == 'number') {\n        adj = RUT.Attributes.map((key) => {\n            return { name: key, bonus: args[0] };\n        });\n    } else {\n        adj = normalize_adjustment(args);\n    }\n\n    let results = adj.reduce((out, a) => {\n        let delta = 0;\n        delta += being.attributes.clearBonus(a.name, a);\n\n        out[a.name] = delta;\n        return out;\n    }, {});\n    being.changed({ attributes: results });\n    return results;\n};\n\nRUT.Attribute.rollAttributes = function (opts = {}) {\n    let dice = [];\n    let total = 0;\n\n    if (RUT.Calc.isValue(opts)) opts = { value: opts };\n    Object.defaults(opts, RUT.Config.Attribute.rollAttributes);\n\n    let attributes = RUT.Config.Attributes;\n\n    let min_average = Math.max(opts.min_average - 5, 0);\n    let max_average = Math.min(opts.max_average - 5, RUT.Config.ATTRIBUTE_MAX);\n\n    let min_total = min_average * attributes.length;\n    let max_total = max_average * attributes.length;\n\n    do {\n        total = 0;\n        dice = [];\n        for (let i = 0; i < 18; ++i) {\n            dice.push(RUT.RNG.rollDie(3 + (i % 3)));\n            total += dice[i];\n        }\n    } while (total <= min_total || total > max_total);\n\n    let values = attributes.reduce((out, name, i) => {\n        let index = 3 * i;\n        let value = 5 + dice[index] + dice[index + 1] + dice[index + 2];\n        if (opts.value) {\n            value = RUT.Calc.calc(opts.value);\n        } else if (opts[name]) {\n            value = RUT.Calc.calc(opts[name]);\n        }\n        out[name] = value;\n        return out;\n    }, {});\n    return values;\n};\nRUT.Config.Attribute.rollAttributes = { min_average: 11, max_average: 14 };\n*/\n/*\nexport function normalize_adjustment(args: ) {\n    if (args.length == 3) {\n        let opts = args[2];\n        if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        let name = `${args[0]}.${args[1]}`;\n        return [Object.assign({ name }, opts)];\n    }\n    if (args.length == 2) {\n        let opts = args[1];\n        if (opts === true || opts === false) {\n            opts = { has: opts };\n        } else if (RUT.Calc.isValue(opts)) {\n            opts = { bonus: opts };\n        }\n        return [Object.assign({ name: args[0] }, opts)];\n    }\n\n    let opts = args[0];\n    if (opts.name) {\n        return [opts];\n    }\n    if (opts.attribute) {\n        opts.name = opts.attribute;\n        return [opts];\n    }\n    if (opts.restore) {\n        if (opts.restore == 'all') {\n            return RUT.Attributes.map((a) => {\n                return { name: a, restore: true };\n            });\n        }\n        return [{ name: opts.restore, restore: true }];\n    }\n    if (opts.skill) {\n        opts.name = opts.skill;\n        return [opts];\n    }\n    if (opts.stat) {\n        opts.name = opts.stat;\n        return [opts];\n    }\n    if (opts.save) {\n        opts.name = opts.save;\n        return [opts];\n    }\n    // if (opts.saves) {\n    //   opts.name = opts.saves;\n    //   return [opts];\n    // }\n    if (opts.ability) {\n        opts.name = opts.ability;\n        return [opts];\n    }\n\n    // now we assume that each key is for a separate skill...\n    return Object.keys(opts).reduce((out, key) => {\n        let opt = opts[key];\n        if (key == 'reset' || key == 'restore') {\n            if (typeof opt == 'string') opt = [opt];\n            opt.forEach((a) => {\n                out.push({ name: a, restore: true });\n            });\n        } else {\n            if (typeof opt == 'number' || Array.isArray(opt)) {\n                opt = { bonus: opt };\n            } else if (opt === true || opt === false) {\n                opt = { has: opt };\n            } else if (opt == 'reset' || opt == 'restore') {\n                opt = { restore: true };\n            } else if (opt == 'sustain') {\n                opt = { sustain: true };\n            }\n            out.push(Object.assign({ name: key }, opt));\n        }\n        return out;\n    }, []);\n}\n*/\n","/*\nSkills\n\nSkills generally fall into 2 categories - binary and progressive.\n\n\n// Create a skills object\nconst skills = new Skills();\n\n// set skills\nskills.set('diving', true); // = { has: true, level: 0 }\nskills.set('diving', 10); // = { has: true, level: 10 }\n\nskills.remove('diving'); // {}\n\n// adjustments\nskills.adjust('diving', { bonus: 1 });\nskills.adjust('diving', { disadvantage: true });\nskills.adjust('diving', { advantage: 3 });\nskills.adjust('diving', { fixed: 10 });\nskills.adjust('diving', { critical: 5 });\n\n\n\n\n\n*/\nclass Skill {\n    constructor(name) {\n        this.name = name;\n    }\n    get has() {\n        return this._bool('_has');\n    }\n    get level() {\n        return this._int('_level');\n    }\n    get disadvantage() {\n        return this._bool('_disadvantage');\n    }\n    get advantage() {\n        return this._bool('_advantage');\n    }\n    get fixed() {\n        return this._int('_fixed');\n    }\n    get bonus() {\n        const b = this._int('_bonus') || 0;\n        if (!this._parent)\n            return b;\n        return b + this._parent.bonus;\n    }\n    get succeed() {\n        return this._bool('_succeed');\n    }\n    get fail() {\n        return this._bool('_fail');\n    }\n    set(value) {\n        if (value === false) {\n            this._has = false;\n            this._level = 0;\n        }\n        else {\n            this._has = true;\n            this._level = value === true ? 0 : value;\n        }\n    }\n    _value(name) {\n        if (this[name] !== undefined) {\n            // @ts-ignore\n            return this[name];\n        }\n        if (this._parent) {\n            // @ts-ignore\n            return this._parent._value(name);\n        }\n        return undefined;\n    }\n    _bool(name) {\n        return !!this._value(name);\n    }\n    _int(name) {\n        return this._value(name);\n    }\n    adjust(adj) {\n        Object.entries(adj).forEach(([key, value]) => {\n            key = '_' + key;\n            if (value === undefined)\n                return;\n            if (key === '_fixed') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = Math.max(value, this._fixed || 0);\n            }\n            else if (key === '_bonus') {\n                if (typeof value !== 'number') {\n                    throw new Error('fixed skill adjustment must be a number.');\n                }\n                value = value + (this._bonus || 0);\n            }\n            // @ts-ignore\n            this[key] = value;\n        });\n    }\n    clear(adj) {\n        Object.keys(adj).forEach((key) => {\n            key = '_' + key;\n            // @ts-ignore\n            if (this[key] !== undefined) {\n                // @ts-ignore\n                this[key] = undefined;\n            }\n        });\n    }\n}\nexport class Skills {\n    constructor(vals = {}) {\n        this._skills = {};\n        Object.entries(vals).forEach(([key, value]) => {\n            this.set(key, value);\n        });\n    }\n    set(name, value) {\n        const s = this.get(name);\n        s.set(value);\n        return s;\n    }\n    get(name) {\n        let s = this._skills[name];\n        if (s)\n            return s;\n        s = this._skills[name] = new Skill(name);\n        const index = name.lastIndexOf('.');\n        if (index > 0) {\n            s._parent = this.get(name.substring(0, index));\n        }\n        else {\n            s.set(false);\n        }\n        return s;\n    }\n    adjust(name, adj) {\n        if (typeof adj === 'number') {\n            adj = { bonus: adj };\n        }\n        let s = this.get(name);\n        s.adjust(adj);\n        return s;\n    }\n}\n","// import * as GWM from 'gw-map';\nimport { Actor } from '../actor';\nexport class Player extends Actor {\n    constructor(kind) {\n        super(kind);\n    }\n}\nPlayer.default = {\n    ch: '@',\n    fg: 'white',\n    name: 'You',\n};\n","import * as Actor from '../actor';\nimport * as Skills from './skill';\nimport * as Attributes from './attribute';\nimport { Player } from './player';\nimport * as Flags from '../flags';\nexport class PlayerKind extends Actor.ActorKind {\n    constructor(opts = {}) {\n        super((() => {\n            if (!opts.sprite) {\n                opts.ch = opts.ch || Player.default.ch;\n                opts.fg = opts.fg || Player.default.fg;\n            }\n            if (!opts.name) {\n                opts.name = Player.default.name;\n            }\n            return opts;\n        })());\n        this.flags.actor |= Flags.Actor.IS_PLAYER;\n        this.attributes = new Attributes.Attributes(opts.attributes || {});\n        this.skills = new Skills.Skills(opts.skills || {});\n    }\n    make(options) {\n        const actor = new Player(this);\n        this.init(actor, options);\n        return actor;\n    }\n}\n","import { PlayerKind } from './kind';\nimport * as Actor from '../actor';\nexport function make(id, makeOptions) {\n    const kind = Actor.get(id);\n    if (!kind)\n        throw new Error('Failed to find item kind - ' + id);\n    return kind.make(makeOptions);\n}\nexport function from(info, makeOptions) {\n    let kind;\n    if (typeof info === 'string') {\n        // @ts-ignore\n        kind = Actor.get(info);\n        if (!kind)\n            throw new Error('Failed to find item kind - ' + info);\n        if (!(kind instanceof PlayerKind))\n            throw new Error('Not a player kind.');\n    }\n    else if (info instanceof PlayerKind) {\n        kind = info;\n    }\n    else {\n        kind = makeKind(info);\n    }\n    return kind.make(makeOptions);\n}\nexport function install(id, kind) {\n    if (kind instanceof PlayerKind) {\n        Actor.kinds[id] = kind;\n        return kind;\n    }\n    const made = makeKind(kind);\n    made.id = id;\n    Actor.kinds[id] = made;\n    return made;\n}\nexport function get(id) {\n    if (id instanceof PlayerKind)\n        return id;\n    const k = Actor.kinds[id];\n    if (k && !(k instanceof PlayerKind)) {\n        throw new Error('No a player kind.');\n    }\n    return k;\n}\nexport function makeKind(info) {\n    const config = Object.assign({}, info);\n    return new PlayerKind(config);\n}\n","import * as GWU from 'gw-utils';\nimport * as Command from '../command';\nexport class Game {\n    constructor(opts) {\n        this.running = false;\n        this.keymap = {};\n        this.ui = opts.ui || new GWU.ui.UI(opts);\n        this._makeMap = opts.makeMap;\n        this._makePlayer = opts.makePlayer;\n        this._startMap = opts.startMap;\n        if (opts.keymap) {\n            Object.assign(this.keymap, opts.keymap);\n        }\n    }\n    async start() {\n        this.layer = new GWU.ui.Layer(this.ui);\n        this.buffer = this.layer.buffer;\n        this.io = this.layer.io;\n        this.running = true;\n        this.scheduler = new GWU.scheduler.Scheduler();\n        this.player = this._makePlayer();\n        this.map = this._makeMap(0);\n        this._startMap(this.map, this.player);\n        this.map.actors.forEach((a) => {\n            this.scheduler.push(a, a.moveSpeed());\n        });\n        this.draw();\n        while (this.running) {\n            await this.animate();\n            await this.runTurn();\n        }\n    }\n    draw() {\n        if (this.map && this.map.needsRedraw) {\n            this.map.drawInto(this.buffer);\n            this.buffer.render();\n        }\n    }\n    finish() {\n        this.running = false;\n        this.layer.finish();\n    }\n    async runTurn() {\n        const actor = this.scheduler.pop();\n        if (!actor) {\n            this.finish();\n            return;\n        }\n        let nextTime = 0;\n        while (nextTime === 0) {\n            if (actor === this.player) {\n                nextTime = await this.playerTurn(actor);\n            }\n            else if ('act' in actor) {\n                nextTime = await actor.act(this); // dt === 100 -- TODO\n            }\n            else if ('tick' in actor) {\n                nextTime = await actor.tick();\n            }\n            this.draw();\n        }\n        if (nextTime >= 0) {\n            this.scheduler.push(actor, nextTime);\n        }\n    }\n    async animate() {\n        if (!this.layer.io._tweens.length)\n            return;\n        const timer = setInterval(() => {\n            const tick = GWU.io.makeTickEvent(16);\n            this.layer.io.enqueue(tick);\n        }, 16);\n        while (this.layer.io._tweens.length) {\n            const ev = await this.layer.io.nextTick();\n            if (ev && ev.dt) {\n                this.layer.io._tweens.forEach((a) => a && a.tick(ev.dt));\n                this.layer.io._tweens = this.layer.io._tweens.filter((a) => a && a.isRunning());\n            }\n            this.draw();\n        }\n        clearInterval(timer);\n    }\n    async playerTurn(player) {\n        let done = 0;\n        const timer = setInterval(() => {\n            const tick = GWU.io.makeTickEvent(16);\n            this.layer.io.enqueue(tick);\n        }, 16);\n        while (!done && this.running) {\n            const ev = await this.layer.io.nextEvent(-1);\n            if (ev) {\n                if (ev.type === GWU.io.KEYPRESS) {\n                    const handler = GWU.io.handlerFor(ev, this.keymap);\n                    if (handler) {\n                        if (typeof handler === 'string') {\n                            const action = Command.get(handler);\n                            if (action) {\n                                done = await action.call(this, player, ev);\n                            }\n                        }\n                        else if (typeof handler === 'function') {\n                            done = await handler.call(this, player, ev);\n                        }\n                    }\n                }\n                else if (ev.type === GWU.io.TICK) {\n                    this.layer.tick(ev); // timeouts\n                }\n            }\n        }\n        clearInterval(timer);\n        return done;\n    }\n}\n","import * as GWU from 'gw-utils';\nimport * as Tile from './tile';\nimport '../effect/handlers';\nimport '../effect/types';\n// These are the minimal set of tiles to make the diggers work\nTile.install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([30, 30, 30]).rand(20, 0, 0, 0),\n    bg: GWU.color.from([2, 2, 10]).rand(0, 2, 2, 0),\n    priority: 10,\n    article: 'the',\n    flavor: 'the stone floor',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: 'TILE:DOOR_OPEN',\n        open: 'TILE:DOOR_OPEN_ALWAYS',\n    },\n    flavor: 'a closed door',\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            effects: 'TILE:DOOR~!',\n        },\n        enter: null,\n        open: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: 'TILE:DOOR~!',\n    },\n    flavor: 'an open door',\n});\nTile.install('UP_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'upward staircase',\n    article: 'an',\n    effects: {\n        player: 'EMIT:UP_STAIRS',\n    },\n    flavor: 'stairs leading upwards',\n});\nTile.install('DOWN_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'downward staircase',\n    article: 'a',\n    effects: {\n        player: 'EMIT:DOWN_STAIRS',\n    },\n    flavor: 'downward leading stairs',\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS',\n    article: 'a',\n    name: 'stone wall',\n    description: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: GWU.color.from([7, 7, 7]).rand(0, 3, 3, 3),\n    bg: GWU.color.from([40, 40, 40]).rand(10, 10, 0, 5),\n    priority: 100,\n    flags: 'L_WALL_FLAGS, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    description: 'A wall made from very hard stone.',\n    flavor: 'a very hard wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: GWU.color.from([5, 8, 20]).dance(10, 0, 4, 15),\n    bg: GWU.color.from([10, 15, 41]).dance(6, 5, 5, 5),\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n    flavor: 'some deep water',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: GWU.color.from([5, 8, 10]).dance(10, 0, 4, 15),\n    bg: GWU.color.from([10, 30, 30]).dance(6, 0, 10, 10),\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n    flags: 'T_SHALLOW_WATER',\n    // depth: 'LIQUID', // 'SURFACE'?\n    flavor: 'some shallow water',\n});\nTile.install('BRIDGE', {\n    ch: '\\u2630',\n    fg: [100, 40, 40],\n    priority: 40,\n    depth: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    groundTile: 'LAKE',\n    flavor: 'a bridge',\n});\n"],"names":["Depth","Fl","GWU","flag","fl","Entity","L_LIST_IN_SIDEBAR","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_WALL_FLAGS","Actor","Item","Tile","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","T_IS_DEEP_LIQUID","T_SHALLOW_WATER","TileMech","Cell","NEEDS_REDRAW","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_SAFE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","HAS_PLAYER","HAS_ACTOR","HAS_ANY_ACTOR","Map","Effect","E_CLEAR_GROUND","E_CLEAR_SURFACE","E_CLEAR_LIQUID","E_CLEAR_GAS","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Horde","KeyInfo","[object Object]","x","y","disposable","this","lastId","kind","_map","key","machineHome","depth","light","flags","entity","next","id","map","setEntityFlag","Flags.Entity","L_ON_MAP","addToMap","clearEntityFlag","removeFromMap","sprite","isDestroyed","hasEntityFlag","L_DESTROYED","other","constructor","copy","Object","assign","canBeSeen","tag","tags","includes","matches","cell","forbidsCell","avoidsCell","opts","getName","getDescription","getFlavor","verb","getVerb","buffer","bounds","drawStatus","dest","_observer","drawSprite","name","EntityKind","config","requiredTileTags","flavor","description","make","split","t","trim","slice","init","_entity","length","hasAllTileTags","hasAnyTileTag","_opts","mixer","Mixer","getAppearanceAt","wrapText","width","makeOpts","PainMessages","msgs","_msgs","forEach","m","add","msg","push","pct","singular","index","clamp","Math","floor","_format","replace","painMessages","Stats","_max","_rate","_value","round","set","v","max","range","value","amount","allowOver","min","raiseValue","gain","lowerValue","drain","turns","count","r","elapsed","undefined","type","from","c","get","Error","Status","_set","_time","_count","_done","changed","clearTime","clearCount","setOff","_update","done","_addDone","current","delta","status","cleared","noticed","removeTime","rec","was","doneFn","installedActions","installAction","fn","toLowerCase","getAction","Entity.Entity","super","ai","leader","items","fov","memory","visionDistance","data","_costMap","actor","Flags.Depth","ACTOR","stats","grid","free","hasActorFlag","Flags.Actor","IS_PLAYER","action","actions","bump","canSee","isAbleToSee","isDirectlyVisible","xy","distanceBetween","forLineBetween","i","j","blocksVision","canSeeOrSense","isAbleToSense","isAnyKindOfVisible","game","moveSpeed","_other","_item","item","pickupItem","dropItem","mapChanged","setActorFlag","STALE_COST_MAP","staleMap","alloc","height","update","_v","path","OBSTRUCTION","FORBIDDEN","AVOIDED","OK","clearActorFlag","handlers","installHandler","handler","effectTypes","installType","startsWith","endPos","indexOf","tile","substring","effects","Array","isArray","effect","entries","JSON","stringify","typeName","shift","makeFn","e","parts","installedEffects","trigger","bind","install","obj","clone","_a","_b","_c","_d","dissipate","priority","groundTile","article","tileMech","hasEffect","Flags.Tile","T_IS_FLAMMABLE","arraysIntersect","every","blocksMove","hasTileFlag","T_PATHING_BLOCKER","arg","color","result","fg","toString","options","_e","_f","base","extends","tiles","text","search","Number","parseInt","makeEffect","message","Flags.TileMech","ch","bg","opacity","all","args","BasicEffect","chance","seen","Flags.Effect","loc","ctx","force","rng","random","didSomething","eff","nextAlways","E_NEXT_ALWAYS","makeBasicEffect","makeSpreadEffect","SpreadEffect","grow","decrement","matchTile","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","spawnMap","computeSpawnMap","mapDisruptedBy","E_EVACUATE_CREATURES","evacuateCreatures","E_EVACUATE_ITEMS","evacuateItems","E_CLEAR_CELL","clearCells","E_NEXT_EVERYWHERE","blockingGrid","blockingToMapX","blockingToMapY","walkableGrid","disrupts","forRect","lakeX","lakeY","isStairs","first","floodFill","cellIsOk","isStart","hasXY","hasCellFlag","Flags.Cell","EVENT_PROTECTED","blocksEffects","E_BUILD_IN_WALLS","isWall","E_MUST_TOUCH_WALLS","ok","eachNeighbor","E_NO_TOUCH_WALLS","hasTile","dir","x2","y2","madeChange","startProb","probDec","fill","DIRS","clearAll","clear","clearDepth","GAS","LIQUID","SURFACE","GROUND","blockingMap","eachActor","a","matchingLocNear","removeActor","addActor","eachItem","removeItem","addItem","makeEmitHandler","emitEffect","events","emit","makeMessageHandler","src","info","messageEffect","aware","addAt","makeActivateMachine","activateMachine","machine","machineId","makeTileHandler","superpriority","blockedByActors","blockedByItems","tileEffect","setTile","makeClearHandler","layers","reduce","out","ALL_LAYERS","clearEffect","_ctx","makeFeatureHandler","featureEffect","feat","Effect.installedEffects","makeNourishEffect","nourishEffect","actorAt","adjust","n","default","pukeMsg","makeStatEffect","stat","statEffect","values","chokeCount","TILE.tiles","NULL","snapshot","makeMixer","TILE.get","hasStableSnapshot","STABLE_SNAPSHOT","hasStableMemory","getSnapshot","checkEntities","some","hasItem","hasActor","entityFlags","tileFlags","tileMechFlags","hasTag","hasAllTags","hasAnyTag","withEntities","needsRedraw","CHANGED","TILE.Tile","highestPriorityTile","cb","find","blocksPathing","TILE.flags","T_BLOCKS_OTHER_LAYERS","hasAllEntityFlags","L_BLOCKS_EVERYTHING","L_SECRETLY_PASSABLE","blocksLayer","blockedByOtherLayers","highestPriority","ground","depthTile","glowLightChanged","setMapFlag","Flags.Map","MAP_SIDEBAR_TILES_CHANGED","setCellFlag","CAUGHT_FIRE_THIS_TURN","blackOut","tileFlag","tileMechFlag","hasTileMechFlag","event","ev","_activate","itemAt","hasItems","foundIndex","clearCellFlag","_actor","isPlayer","actors","HAS_FX","fx","fxAt","_fx","T_BRIDGE","MapLayer","properties","_x","_y","_tile","_dt","TileLayer","GasLayer","volume","startingVolume","spread","d","clearTile","total","highestVolume","startingTile","highestTile","updateCellVolume","ObjectFlags","TileFlags","TileMechFlags","CellFlags","FireLayer","exposeToFire","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","eachTile","T_EXTINGUISHES_FIRE","Effect.from","fire","TM_EXPLOSIVE_PROMOTE","x0","y0","fireEvent","BasicDrawer","_cell","Buffer","offsetX","offsetY","drawCell","needSnapshot","getAppearance","putSnapshot","applyLight","L_VISUALLY_DISTINCT","separate","surface","liquid","gas","drawInto","cosmetic","number","hasFx","dances","COLORS_DANCE","bake","isVisible","isRevealed","getLight","multiply","isCursor","invert","scale","_animations","EventEmitter","seed","machineCount","drawer","cells","LightSystem","initLayers","addLayer","Layer.TileLayer","Layer.FireLayer","Layer.GasLayer","layer","isAt","fireEffects","_addItem","_fireAddItemEffects","_removeItem","_fireRemoveItemEffects","arrayDelete","isKey","currentCell","newCell","hasPlayer","canAddActor","_addActor","_fireAddActorEffects","player","canRemoveActor","_removeActor","_fireRemoveActorEffects","_addFx","updated","_removeFx","fmt","log","console","dump","hasMapFlag","MAP_NEEDS_REDRAW","clearMapFlag","l","boundary","isBoundaryXY","clearTiles","dt","tick","filter","isRunning","fireAll","willFire","EVENT_FIRED_THIS_TURN","promoteChance","w","originX","originY","eachGlowLight","_cb","isDark","h","Memory","source","isMemory","i2","a2","mem","currentList","newList","setLight","forget","storeMemory","cache","store","actorMemory","ais","AICtx","target","distanceMap","costMap","calculateDistances","async","typical","isDead","standStill","damagePct","getPct","morale","start","_game","safetyMap","costGrid","willAttack","eachCell","rescan","center","step","nextStep","moveDir","NO_PATH","_target","ActorKind","Entity.EntityKind","DEFAULT","DEFAULT_ACTOR","vision","normal","AI.ais","HAS_MEMORY","Memory.get","USES_FOV","FovSystem","follow","callback","Memory.store","list","remove","makeOptions","kinds","makeKind","randomKind","match","forbidTags","k","bumpActions","getBumpActions","selfName","selfAction","baseAction","ctx2","flashSprite","duration","animator","Entity.make","addFx","tween","visible","to","repeat","repeatDelay","onUpdate","removeFx","io","loop","addAnimation","hit","fadeInOut","yoyo","onFinish","moveSprite","ceil","maxAxisFromTo","speed","isLoc","vals","stepFn","stopBeforeWalls","moveFx","stop","isInShape","shape","cx","cy","allowCenter","sx","abs","sy","dirFromTo","fade","stopAtWalls","line","forLineFromTo","promises","lastIndex","Promise","radius","checkExplosionOpts","FOV","isBlocked","calculate","x1","y1","minX","minY","maxX","maxY","_obj","success","newX","newY","FX.hit","moveActor","pain","made","quantity","ITEM","ItemKind","Flags.Item","updateChokepoints","updateCounts","passMap","passableArcCount","oldX","CLOCK_DIRS","oldY","cellCount","floodFillCount","j2","results","startX","startY","getCount","todo","pop","updateLoopiness","resetLoopiness","checkLoopiness","cleanLoopiness","inString","sdir","numStrings","maxStringLength","currentStringLength","tryAgain","fillInnerLoopGrid","up","left","designationSurvives","Snapshot","version","isHallway","arcCount","isPassable","prefab","charToTile","isStringArray","len","updateChokeCounts","layerVersion","lightVersion","cellVersion","snap","srcCell","snapLayer","destCell","destLayer","srcLayer","getCellPathCost","fillCostMap","eightWays","straightDistanceBetween","getPath","members","horde","frequency","Flags","canSpawn","TRUE","_spawnLeader","_spawnMembers","leaderKind","Actor.get","Actor.make","_pickLeaderLoc","_addLeader","member","kindId","countRange","_spawnMember","_pickMemberLoc","_addMember","matchingLoc","Map.isHallway","hordes","forbidFlags","oodChance","HORDE_NEVER_OOD","weights","weighted","Actor.actions.moveDir","pickup","_ev","playerAction","endTurn","avoidsItem","itemAction","canAddItem","Attributes","baseValues","_base","_bonus","_sustain","attributes","keys","raiseMax","old","_calcValue","loss","lowerMax","bonus","_addBonus","_clearBonus","arr","findIndex","o","splice","allAdjustments","adj","_applyAdjustment","sustain","fixed","restore","Skill","has","_bool","level","_int","disadvantage","advantage","b","_parent","succeed","fail","_has","_level","_fixed","Skills","_skills","s","lastIndexOf","Player","PlayerKind","Actor.ActorKind","Attributes.Attributes","skills","Skills.Skills","attr","defaults","Actor.kinds","running","keymap","ui","UI","_makeMap","makeMap","_makePlayer","makePlayer","_startMap","startMap","Layer","scheduler","Scheduler","draw","animate","runTurn","render","finish","nextTime","playerTurn","act","_tweens","timer","setInterval","makeTickEvent","enqueue","nextTick","clearInterval","nextEvent","KEYPRESS","handlerFor","Command.get","call","TICK","rand","enter","open","close","dance"],"mappings":"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"}