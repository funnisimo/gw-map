import { utils as Utils, grid as Grid, color as Color, canvas as Canvas, types as Types } from "gw-utils";
import * as Cell from "./cell";
import * as Tile from "./tile";
import { Map as Flags, Layer as TileLayer } from "./flags";
import { Light } from "./light";
export { Flags };
export declare type MapEachFn = (cell: Cell.Cell, x: number, y: number, map: Map) => void;
export declare type MapMatchFn = (cell: Cell.Cell, x: number, y: number, map: Map) => boolean;
export declare type MapCostFn = (cell: Cell.Cell, x: number, y: number, map: Map) => number;
export interface MapMatchOptions {
    hallways: boolean;
    blockingMap: Grid.NumGrid;
    liquids: boolean;
    match: MapMatchFn;
    forbidCellFlags: number;
    forbidTileFlags: number;
    forbidTileMechFlags: number;
    tile: Tile.Tile;
    tries: number;
    deterministic: boolean;
}
interface LightInfo extends Utils.Chainable {
    light: Light;
    x: number;
    y: number;
    next: LightInfo | null;
}
export declare type MapLightFn = (light: Light, x: number, y: number) => void;
export interface DisruptsOptions {
    gridOffsetX: number;
    gridOffsetY: number;
    bounds: Types.Bounds | null;
}
export declare class Map implements Types.MapType {
    protected _width: number;
    protected _height: number;
    cells: Grid.Grid<Cell.Cell>;
    locations: any;
    config: any;
    protected _actors: any | null;
    protected _items: any | null;
    flags: number;
    ambientLight: Color.Color | null;
    lights: LightInfo | null;
    id: string;
    events: any;
    constructor(w: number, h: number, opts?: any);
    get width(): number;
    get height(): number;
    start(): Promise<void>;
    nullify(): void;
    dump(fmt?: (cell: Cell.Cell) => string): void;
    cell(x: number, y: number): Cell.Cell;
    eachCell(fn: MapEachFn): void;
    forEach(fn: MapEachFn): void;
    forRect(x: number, y: number, w: number, h: number, fn: MapEachFn): void;
    eachNeighbor(x: number, y: number, fn: MapEachFn, only4dirs?: boolean): void;
    hasXY(x: number, y: number): boolean;
    isBoundaryXY(x: number, y: number): boolean;
    changed(v?: boolean): number;
    hasCellFlag(x: number, y: number, flag: number): number;
    hasCellMechFlag(x: number, y: number, flag: number): number;
    hasTileFlag(x: number, y: number, flag: number): boolean;
    hasTileMechFlag(x: number, y: number, flag: number): boolean;
    setCellFlag(x: number, y: number, flag: number): void;
    redrawCell(cell: Cell.Cell): void;
    redrawXY(x: number, y: number): void;
    redrawAll(): void;
    revealAll(): void;
    markRevealed(x: number, y: number): void;
    isVisible(x: number, y: number): number;
    isAnyKindOfVisible(x: number, y: number): number;
    isOrWasAnyKindOfVisible(x: number, y: number): number;
    hasVisibleLight(x: number, y: number): boolean;
    setFlag(flag: number): void;
    setFlags(mapFlag?: number, cellFlag?: number, cellMechFlag?: number): void;
    clearFlag(flag: number): void;
    clearFlags(mapFlag?: number, cellFlag?: number, cellMechFlag?: number): void;
    setCellFlags(x: number, y: number, cellFlag?: number, cellMechFlag?: number): void;
    clearCellFlags(x: number, y: number, cellFlags?: number, cellMechFlags?: number): void;
    hasTile(x: number, y: number, tile: string): boolean;
    tileFlags(x: number, y: number, limitToPlayerKnowledge?: boolean): number;
    tileMechFlags(x: number, y: number, limitToPlayerKnowledge?: boolean): number;
    tileWithFlag(x: number, y: number, flag?: number): Tile.Tile | null;
    tileWithMechFlag(x: number, y: number, mechFlag?: number): Tile.Tile | null;
    hasKnownTileFlag(x: number, y: number, flagMask?: number): number;
    discoveredTileFlags(x: number, y: number): number;
    hasDiscoveredTileFlag(x: number, y: number, flag?: number): number;
    canBePassed(x: number, y: number, limitToPlayerKnowledge?: boolean): boolean;
    isPassableNow(x: number, y: number, limitToPlayerKnowledge?: boolean): boolean;
    isNull(x: number, y: number): boolean;
    isEmpty(x: number, y: number): boolean;
    isObstruction(x: number, y: number, limitToPlayerKnowledge?: boolean): boolean;
    isDoor(x: number, y: number, limitToPlayerKnowledge?: boolean): boolean;
    isLiquid(x: number, y: number, limitToPlayerKnowledge?: boolean): boolean;
    hasGas(x: number, y: number, limitToPlayerKnowledge?: boolean): boolean;
    blocksPathing(x: number, y: number, limitToPlayerKnowledge?: boolean): boolean;
    blocksVision(x: number, y: number): boolean;
    highestPriorityTile(x: number, y: number, skipGas?: boolean): Tile.Tile;
    tileFlavor(x: number, y: number): string | null;
    setTile(x: number, y: number, tileId: string | null, volume?: number): boolean;
    nullifyTileWithFlags(x: number, y: number, tileFlags: number, tileMechFlags?: number): void;
    nullifyCellLayers(x: number, y: number, nullLiquid?: boolean, nullSurface?: boolean, nullGas?: boolean): void;
    fill(tileId: string | null, boundaryTile?: string | null): void;
    neighborCount(x: number, y: number, matchFn: MapMatchFn, only4dirs?: boolean): number;
    passableArcCount(x: number, y: number): number;
    diagonalBlocked(x1: number, y1: number, x2: number, y2: number, limitToPlayerKnowledge?: boolean): boolean;
    fillCostGrid(costGrid: Grid.NumGrid, costFn: MapCostFn): void;
    matchingNeighbor(x: number, y: number, matcher: MapMatchFn, only4dirs?: boolean): number[] | null;
    matchingLocNear(x: number, y: number, opts: Partial<MapMatchOptions>): Utils.Loc;
    matchingLocNear(x: number, y: number, matcher: MapMatchFn, opts?: Partial<MapMatchOptions>): Utils.Loc;
    randomMatchingLoc(opts?: Partial<MapMatchOptions>): false | (number | undefined)[];
    addLight(x: number, y: number, light: Light): LightInfo;
    removeLight(info: LightInfo): void;
    eachGlowLight(fn: MapLightFn): void;
    eachDynamicLight(fn: MapLightFn): void;
    addFx(x: number, y: number, anim: Types.FxType): boolean;
    moveFx(x: number, y: number, anim: Types.FxType): boolean;
    removeFx(anim: Types.FxType): boolean;
    actorAt(x: number, y: number): Types.ActorType | null;
    addActor(x: number, y: number, theActor: Types.ActorType): boolean;
    addActorNear(x: number, y: number, theActor: Types.ActorType): boolean;
    moveActor(x: number, y: number, actor: Types.ActorType): boolean;
    removeActor(actor: Types.ActorType): boolean;
    deleteActorAt(x: number, y: number): boolean;
    itemAt(x: number, y: number): Types.ItemType | null;
    addItem(x: number, y: number, theItem: Types.ItemType): boolean;
    addItemNear(x: number, y: number, theItem: Types.ItemType): boolean;
    removeItem(theItem: Types.ItemType): boolean;
    gridDisruptsPassability(blockingGrid: Grid.NumGrid, opts?: Partial<DisruptsOptions>): boolean;
    calcFov(grid: Grid.NumGrid, x: number, y: number, maxRadius: number, forbiddenCellFlags?: number, forbiddenTileFlags?: Tile.Flags): void;
    losFromTo(a: Utils.XY, b: Utils.XY): boolean;
    storeMemory(x: number, y: number): void;
    storeMemories(): void;
    tick(): Promise<void>;
    resetEvents(): void;
}
export declare function make(w: number, h: number, floor: string, wall: string): Map;
export declare function make(w: number, h: number, floor: string): Map;
export declare function make(w: number, h: number, opts?: any): Map;
export declare function getCellAppearance(map: Map, x: number, y: number, dest: Canvas.Mixer): void;
export declare function addText(map: Map, x: number, y: number, text: string, fg: Color.ColorBase, bg: Color.ColorBase, layer: TileLayer): void;
export declare function updateGas(map: Map): void;
export declare function updateLiquid(map: Map): void;
