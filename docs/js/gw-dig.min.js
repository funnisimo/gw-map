!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("gw-map"),require("gw-utils")):"function"==typeof define&&define.amd?define(["exports","gw-map","gw-utils"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).GWD={},t.GWM,t.GWU)}(this,(function(t,e,i){"use strict";function s(t){if(t&&t.__esModule)return t;var e=Object.create(null);return t&&Object.keys(t).forEach((function(i){if("default"!==i){var s=Object.getOwnPropertyDescriptor(t,i);Object.defineProperty(e,i,s.get?s:{enumerable:!0,get:function(){return t[i]}})}})),e.default=t,Object.freeze(e)}var n,o,r=s(e),l=s(i);const a=r.tile.get("NULL").index,h=r.tile.get("FLOOR").index,c=r.tile.get("DOOR").index,g=null!==(o=null===(n=r.tile.get("DOOR_SECRET"))||void 0===n?void 0:n.index)&&void 0!==o?o:-1,u=r.tile.get("WALL").index,d=r.tile.get("LAKE").index,f=r.tile.get("SHALLOW").index,p=r.tile.get("BRIDGE").index,_=r.tile.get("UP_STAIRS").index,I=r.tile.get("DOWN_STAIRS").index,m=r.tile.get("IMPREGNABLE").index,S={[a]:"NULL",[h]:"FLOOR",[c]:"DOOR",[u]:"WALL",[m]:"IMPREGNABLE",[d]:"LAKE",[f]:"SHALLOW",[p]:"BRIDGE",[_]:"UP_STAIRS",[I]:"DOWN_STAIRS"},E=l.xy.DIRS;function O(t,e,i){let s,n,o,r,a,h;for(n=l.xy.NO_DIRECTION,s=0;s<4;s++)if(o=e+E[s][0],r=i+E[s][1],a=e-E[s][0],h=i-E[s][1],t.hasXY(a,h)&&t.hasXY(o,r)&&t.isFloor(a,h)){if(n!=l.xy.NO_DIRECTION)return l.xy.NO_DIRECTION;n=s}return n}function B(t){let e,i,s,n,o,r,a;const h=[[],[],[],[]],c=t.height,g=t.width;for(e=0;e<g;e++)for(i=0;i<c;i++)if(t.isDiggable(e,i)&&(r=O(t,e,i),r!=l.xy.NO_DIRECTION)){for(n=e+l.xy.DIRS[r][0],o=i+l.xy.DIRS[r][1],a=!1,s=0;s<10&&t.hasXY(n,o)&&!a;s++)t.isSet(n,o)&&(a=!0),n+=l.xy.DIRS[r][0],o+=l.xy.DIRS[r][1];a||h[r].push([e,i])}let u=[];for(r=0;r<4;r++){const e=t.rng.item(h[r])||[-1,-1];u[r]=[e[0],e[1]]}return u}function R(t,e,i=0,s=0){l.xy.forRect(t.width,t.height,((n,o)=>{const r=n-i,l=o-s,a=e.getTileIndex(r,l);a&&t.setTile(n,o,a)}))}function b(t,e){e.update(((e,i,s)=>t.isPassable(i,s)?1:l.path.OBSTRUCTION))}function T(t,e,i,s={}){var n,o,r;if(null!==(n=s.offsetX)&&void 0!==n||(s.offsetX=0),null!==(o=s.offsetY)&&void 0!==o||(s.offsetY=0),null!==(r=s.machine)&&void 0!==r||(s.machine=0),l.xy.arcCount(e,i,((e,i)=>t.isPassable(e,i)))<=1)return!1;const a=l.grid.alloc(t.width,t.height);a[e][i]=1;const h=A(t,a,s);return l.grid.free(a),h}function A(t,e,i={}){var s,n,o;null!==(s=i.offsetX)&&void 0!==s||(i.offsetX=0),null!==(n=i.offsetY)&&void 0!==n||(i.offsetY=0),null!==(o=i.machine)&&void 0!==o||(i.machine=0);const r=l.grid.alloc(t.width,t.height);let a=!1;if(l.xy.forRect(t.width,t.height,((s,n)=>{const o=s+i.offsetX,l=n+i.offsetY;e.get(o,l)?t.isStairs(s,n)&&(a=!0):!t.isPassable(s,n)||0!=t.getMachine(s,n)&&t.getMachine(s,n)!=i.machine||(r[s][n]=1)})),i.updateWalkable&&!i.updateWalkable(r))return!0;let h=!0;for(let t=0;t<r.width&&!a;++t)for(let e=0;e<r.height&&!a;++e)1==r[t][e]&&(h?(r.floodFill(t,e,1,2),h=!1):a=!0);return l.grid.free(r),a}function w(t,e,i=0,s=0){const n=l.grid.alloc(t.width,t.height);let o=0;if(l.xy.forRect(t.width,t.height,((r,l)=>{const a=r+i,h=l+s;e.get(a,h)?t.isStairs(r,l)&&(o=t.width*t.height):t.isPassable(r,l)&&(n[r][l]=1)})),o)return o;let r=!0,a=2,h=t.width*t.height;for(let t=0;t<n.width;++t)for(let e=0;e<n.height;++e)if(1==n[t][e]){const i=n.floodFill(t,e,1,a++);h=Math.min(h,i),r?r=!1:o=h}return l.grid.free(n),o}function N(t,e,i,s,n){const o=l.grid.alloc(t.width,t.height);b(t,o),l.path.calculateDistances(e,i,s,o,!1,n+1),l.grid.free(o)}function L(t,e){for(let i=0;i<t.width;i++)for(let s=0;s<t.height;s++)t.getMachine(i,s)!=e||t.hasCellFlag(i,s,r.flags.Cell.IS_WIRED|r.flags.Cell.IS_CIRCUIT_BREAKER)||t.setMachine(i,s,0)}class y{constructor(t,e){this.rng=l.rng.random,this.tiles=l.grid.alloc(t,e),this.doors=l.grid.alloc(t,e)}free(){l.grid.free(this.tiles),l.grid.free(this.doors)}clear(){this.tiles.fill(0),this.doors.fill(0)}dump(){this.tiles.dump()}drawInto(t){t.blackOut(),this.tiles.forEach(((e,i,s)=>{const n=r.tile.get(e);t.drawSprite(i,s,n.sprite)}))}setSeed(t){this.rng.seed(t)}get width(){return this.tiles.width}get height(){return this.tiles.height}hasXY(t,e){return this.tiles.hasXY(t,e)}isBoundaryXY(t,e){return this.tiles.isBoundaryXY(t,e)}isPassable(t,e){return this.isFloor(t,e)||this.isDoor(t,e)||this.isBridge(t,e)||this.isStairs(t,e)||this.isShallow(t,e)}isNothing(t,e){return this.tiles.get(t,e)===a}isDiggable(t,e){const i=this.tiles.get(t,e);return i===a||i===u}isFloor(t,e){return this.tiles.get(t,e)==h}isDoor(t,e){return this.tiles.get(t,e)===c}isSecretDoor(t,e){return this.tiles.get(t,e)===g}isBridge(t,e){return this.tiles.get(t,e)===p}isWall(t,e){const i=this.tiles.get(t,e);return i===u||i===m}blocksMove(t,e){return this.isNothing(t,e)||this.isWall(t,e)||this.isDeep(t,e)}blocksDiagonal(t,e){return this.isNothing(t,e)||this.isWall(t,e)}blocksPathing(t,e){return this.isNothing(t,e)||this.isWall(t,e)||this.isDeep(t,e)||this.isStairs(t,e)}blocksVision(t,e){return this.isNothing(t,e)||this.isWall(t,e)}blocksItems(t,e){return this.blocksPathing(t,e)||this.blocksPathing(t,e)}blocksEffects(t,e){return this.isWall(t,e)}isStairs(t,e){const i=this.tiles.get(t,e);return i===_||i===I}isDeep(t,e){return this.tiles.get(t,e)===d}isShallow(t,e){return this.tiles.get(t,e)===f}isAnyLiquid(t,e){return this.isDeep(t,e)||this.isShallow(t,e)}isSet(t,e){return(this.tiles.get(t,e)||0)>0}getTileIndex(t,e){return this.tiles.get(t,e)||0}setTile(t,e,i){if(i instanceof r.tile.Tile&&(i=i.index),"string"==typeof i){const t=r.tile.tiles[i];if(!t)throw new Error("Failed to find tie: "+i);i=t.index}return!!this.tiles.hasXY(t,e)&&(this.tiles[t][e]=i,!0)}clearCell(t,e,i){return this.setTile(t,e,i)}hasTile(t,e,i){if(i instanceof r.tile.Tile&&(i=i.index),"string"==typeof i){const t=r.tile.tiles[i];if(!t)throw new Error("Failed to find tie: "+i);i=t.index}return this.tiles.hasXY(t,e)&&this.tiles[t][e]==i}getMachine(t,e){return 0}updateDoorDirs(){this.doors.update(((t,e,i)=>O(this,e,i)))}getDoorDir(t,e){return this.doors[t][e]}}const M=r.flags.Cell;class D{constructor(t,e){this.needsAnalysis=!0,this.isUsed=!1,this.site=t,this.snapshot=e,this.needsAnalysis=this.site.needsAnalysis,this.isUsed=!0}restore(){this.site.snapshots.revertMapTo(this.snapshot),this.site.needsAnalysis=this.needsAnalysis,this.cancel()}cancel(){this.site.snapshots.release(this.snapshot)}}class C{constructor(t){this.machineCount=0,this.needsAnalysis=!0,this.map=t,this.doors=l.grid.alloc(t.width,t.height),this.snapshots=new r.map.SnapshotManager(t)}get rng(){return this.map.rng}get depth(){return this.map.data.depth||0}setSeed(t){this.map.seed=t}get width(){return this.map.width}get height(){return this.map.height}free(){l.grid.free(this.doors)}dump(){this.map.dump()}drawInto(t){this.map.drawInto(t)}hasXY(t,e){return this.map.hasXY(t,e)}isBoundaryXY(t,e){return this.map.isBoundaryXY(t,e)}hasCellFlag(t,e,i){return this.map.cell(t,e).hasCellFlag(i)}setCellFlag(t,e,i){this.needsAnalysis=!0,this.map.cell(t,e).setCellFlag(i)}clearCellFlag(t,e,i){this.needsAnalysis=!0,this.map.cell(t,e).clearCellFlag(i)}hasTile(t,e,i){return this.map.cell(t,e).hasTile(i)}setTile(t,e,i,s){return this.needsAnalysis=!0,this.map.setTile(t,e,i,s)}clearCell(t,e,i){return this.needsAnalysis=!0,this.map.clearTiles(t,e,i),!0}getTileIndex(t,e){if(!this.hasXY(t,e))return 0;return this.map.cell(t,e).highestPriorityTile().index}clear(){this.needsAnalysis=!0,this.map.cells.forEach((t=>t.clear()))}hasItem(t,e){return this.map.cell(t,e).hasItem()}makeItem(t,e){return r.item.make(t,e)}makeRandomItem(t,e){return t.rng=this.rng,r.item.makeRandom(t,e)}addItem(t,e,i){return this.needsAnalysis=!0,this.map.addItem(t,e,i)}hasActor(t,e){return this.map.hasActor(t,e)}spawnHorde(t,e,i,s={}){return t.spawn(this.map,e,i,s)}blocksMove(t,e){return this.map.cell(t,e).blocksMove()}blocksVision(t,e){return this.map.cell(t,e).blocksVision()}blocksDiagonal(t,e){return this.map.cell(t,e).hasEntityFlag(r.flags.Entity.L_BLOCKS_DIAGONAL)}blocksPathing(t,e){const i=this.map.cell(t,e);return i.hasEntityFlag(r.flags.Entity.L_BLOCKS_MOVE)||i.hasTileFlag(r.tile.flags.Tile.T_PATHING_BLOCKER)}blocksItems(t,e){return this.map.cell(t,e).hasEntityFlag(r.flags.Entity.L_BLOCKS_ITEMS)}blocksEffects(t,e){return this.map.cell(t,e).hasEntityFlag(r.flags.Entity.L_BLOCKS_EFFECTS)}isWall(t,e){return this.map.cell(t,e).isWall()}isStairs(t,e){return this.map.cell(t,e).isStairs()}isSet(t,e){return this.hasXY(t,e)&&!this.map.cell(t,e).isNull()}isDiggable(t,e){if(!this.hasXY(t,e))return!1;const i=this.map.cell(t,e);return!!i.isNull()||!!i.isWall()}isNothing(t,e){return this.hasXY(t,e)&&this.map.cell(t,e).isNull()}isFloor(t,e){return this.isPassable(t,e)}isBridge(t,e){return this.map.cell(t,e).hasTileFlag(r.tile.flags.Tile.T_BRIDGE)}isDoor(t,e){return this.map.cell(t,e).hasTileFlag(r.tile.flags.Tile.T_IS_DOOR)}isSecretDoor(t,e){return this.map.cell(t,e).hasEntityFlag(r.flags.Entity.L_SECRETLY_PASSABLE)}isDeep(t,e){return this.map.cell(t,e).hasTileFlag(r.tile.flags.Tile.T_DEEP_WATER)}isShallow(t,e){if(!this.hasXY(t,e))return!1;const i=this.map.cell(t,e);return!!i.depthTile(r.flags.Depth.LIQUID)&&!i.hasTileFlag(r.tile.flags.Tile.T_IS_DEEP_LIQUID)}isAnyLiquid(t,e){if(!this.hasXY(t,e))return!1;return this.map.cell(t,e).hasTileFlag(r.tile.flags.Tile.T_ANY_LIQUID)}isOccupied(t,e){return this.hasItem(t,e)||this.hasActor(t,e)}isPassable(t,e){const i=this.map.cell(t,e);return!i.blocksMove()&&(!!i.hasTileFlag(r.flags.Tile.T_BRIDGE)||!i.blocksPathing())}snapshot(){return new D(this,this.snapshots.takeNew())}getChokeCount(t,e){return this.map.cell(t,e).chokeCount}setChokeCount(t,e,i){this.map.cell(t,e).chokeCount=i}analyze(){this.needsAnalysis&&r.map.analyze(this.map),this.needsAnalysis=!1}buildEffect(t,e,i){return this.needsAnalysis=!0,t.trigger({map:this.map,x:e,y:i},{rng:this.rng})}nextMachineId(){return++this.map.data.machineCount}getMachine(t,e){return this.map.cell(t,e).machineId}setMachine(t,e,i,s=!0){this.needsAnalysis=!0,this.map.cell(t,e).machineId=i,0==i?this.map.clearCellFlag(t,e,M.IS_IN_MACHINE):this.map.setCellFlag(t,e,s?M.IS_IN_ROOM_MACHINE:M.IS_IN_AREA_MACHINE)}updateDoorDirs(){this.doors.update(((t,e,i)=>O(this,e,i)))}getDoorDir(t,e){return this.doors[t][e]}}var P=Object.freeze({__proto__:null,NOTHING:a,FLOOR:h,DOOR:c,SECRET_DOOR:g,WALL:u,DEEP:d,SHALLOW:f,BRIDGE:p,UP_STAIRS:_,DOWN_STAIRS:I,IMPREGNABLE:m,TILEMAP:S,directionOfDoorSite:O,chooseRandomDoorSites:B,copySite:R,fillCostGrid:b,siteDisruptedByXY:T,siteDisruptedBy:A,siteDisruptedSize:w,computeDistanceMap:N,clearInteriorFlag:L,GridSite:y,MapSnapshot:D,MapSite:C,digSiteFrom:function(t){return t instanceof r.map.Map?new C(t):t},buildSiteFrom:function(t){return t instanceof r.map.Map?new C(t):t}});class x extends l.xy.Bounds{constructor(t,e,i,s){super(t,e,i,s),this.doors=[]}translate(t,e){this.x+=t,this.y+=e,this.doors&&this.doors.forEach((i=>{i&&(i[0]<0||i[1]<0||(i[0]+=t,i[1]+=e))}))}}function k(t,e,i,s=1){const n=l.xy.DIRS[e],o=Math.min(t[0],t[0]+n[0]*(i-1)),r=Math.min(t[1],t[1]+n[1]*(i-1)),a=Math.abs(n[0]*i)||s,h=Math.abs(n[1]*i)||s;return new x(o,r,a,h)}class F extends l.xy.Bounds{constructor(t,e,i,s){super(t,e,i,s),this.doors=[],this.hall=null}get cx(){return this.x+Math.floor(this.width/2)}get cy(){return this.y+Math.floor(this.height/2)}translate(t,e){this.x+=t,this.y+=e,this.doors&&this.doors.forEach((i=>{i&&(i[0]<0||i[1]<0||(i[0]+=t,i[1]+=e))})),this.hall&&this.hall.translate(t,e)}}function v(t,e={}){return t=t||{},e=e||{},Object.entries(e).forEach((([e,i])=>{let s=t[e];if("tile"===e)return void(void 0===s&&(t[e]=i));if(!0===i){if(!s)throw new Error("Missing required config for room digger: "+e)}else s=("number"==typeof i||Array.isArray(i),s||i);const n=l.range.make(s);t[e]=n})),t}class Y{constructor(t,e={}){this.options={},this.doors=[],this._setOptions(t,e)}_setOptions(t,e={}){this.options=v(t,e)}create(t){const e=this.carve(t);return e&&(e.doors&&0!=e.doors.length&&!e.doors.every((t=>!t||-1==t[0]))||(e.doors=B(t))),e}}var U={};class W extends Y{constructor(t={}){super(t,{choices:["DEFAULT"]})}_setOptions(t,e={}){const i=t.choices||e.choices;if(Array.isArray(i))this.randomRoom=t=>t.item(i);else{if("object"!=typeof i)throw new Error("Expected choices to be either array of room ids or weighted map - ex: { ROOM_ID: weight }");this.randomRoom=t=>t.weighted(i)}}carve(t){let e=this.randomRoom(t.rng);const i=U[e];return i||l.ERROR("Missing room digger choice: "+e),i.create(t)}}class G extends Y{constructor(t={}){super(t,{width:12,height:8})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),s=this.options.tile||h,n=l.grid.alloc(t.width,t.height,0),o=Math.floor(.5*e),r=e,a=Math.floor(.5*i),c=i,g=new l.blob.Blob({rng:t.rng,rounds:5,minWidth:o,minHeight:a,maxWidth:r,maxHeight:c,percentSeeded:55,birthParameters:"ffffftttt",survivalParameters:"ffffttttt"}).carve(n.width,n.height,((t,e)=>n[t][e]=1)),u=Math.floor((t.width-g.width)/2),d=u-g.x,f=Math.floor((t.height-g.height)/2),p=f-g.y;return n.forEach(((e,i,n)=>{e&&t.setTile(i+d,n+p,s)})),l.grid.free(n),new F(u,f,g.width,g.height)}}class X extends Y{constructor(t={}){super(t,{width:20,height:10})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),s=this.options.tile||h,n=Math.floor(.4*e),o=i,r=e,a=Math.floor(.5*i),c=Math.floor(t.width/2-n/2-1),g=t.height-o-2,u=Math.floor(t.width/2-r/2-1),d=t.height-a-2;l.xy.forRect(c,g,n,o,((e,i)=>t.setTile(e,i,s))),l.xy.forRect(u,d,r,a,((e,i)=>t.setTile(e,i,s)));const f=new F(Math.min(c,u),Math.min(g,d),Math.max(n,r),Math.max(o,a));return f.doors[l.xy.DOWN]=[Math.floor(t.width/2),t.height-2],f}}class H extends Y{constructor(t={}){super(t,{width:12,height:20})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),s=this.options.tile||h,n=e,o=Math.max(3,Math.floor(e*t.rng.range(25,75)/100)),r=Math.max(3,Math.floor(i*t.rng.range(25,75)/100)),a=i,c=Math.floor((t.width-n)/2),g=c+t.rng.range(2,Math.max(2,n-o-2)),u=Math.floor((t.height-a)/2),d=u+t.rng.range(2,Math.max(2,a-r-2));return l.xy.forRect(c,d,n,r,((e,i)=>t.setTile(e,i,s))),l.xy.forRect(g,u,o,a,((e,i)=>t.setTile(e,i,s))),new F(c,u,Math.max(n,o),Math.max(r,a))}}class $ extends Y{constructor(t={}){super(t,{width:7,height:7})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),s=this.options.tile||h;let n=Math.max(3,Math.floor(e*t.rng.range(25,50)/100)),o=Math.max(3,Math.floor(i*t.rng.range(25,50)/100));const r=Math.floor((t.width-e)/2),a=Math.floor((t.height-o)/2);l.xy.forRect(r,a,e,o,((e,i)=>t.setTile(e,i,s)));const c=Math.floor((t.width-n)/2),g=Math.floor((t.height-i)/2);return l.xy.forRect(c,g,n,i,((e,i)=>t.setTile(e,i,s))),new F(Math.min(r,c),Math.min(a,g),Math.max(e,n),Math.max(i,o))}}class K extends Y{constructor(t={}){super(t,{width:[3,6],height:[3,6]})}carve(t){const e=this.options.width.value(t.rng),i=this.options.height.value(t.rng),s=this.options.tile||h,n=Math.floor((t.width-e)/2),o=Math.floor((t.height-i)/2);return l.xy.forRect(n,o,e,i,((e,i)=>t.setTile(e,i,s))),new F(n,o,e,i)}}class V extends Y{constructor(t={}){super(t,{radius:[3,4]})}carve(t){const e=this.options.radius.value(t.rng),i=this.options.tile||h,s=Math.floor(t.width/2),n=Math.floor(t.height/2);return e>1&&l.xy.forCircle(s,n,e,((e,s)=>t.setTile(e,s,i))),new F(s-e,n-e,2*e+1,2*e+1)}}class z extends Y{constructor(t={}){super(t,{radius:[5,10],ringMinWidth:3,holeMinSize:3,holeChance:50})}carve(t){const e=this.options.radius.value(t.rng),i=this.options.ringMinWidth.value(t.rng),s=this.options.holeMinSize.value(t.rng),n=this.options.tile||h,o=Math.floor(t.width/2),r=Math.floor(t.height/2);return l.xy.forCircle(o,r,e,((e,i)=>t.setTile(e,i,n))),e>i+s&&t.rng.chance(this.options.holeChance.value(t.rng))&&l.xy.forCircle(o,r,t.rng.range(s,e-s),((e,i)=>t.setTile(e,i,0))),new F(o-e,r-e,2*e+1,2*e+1)}}class j extends Y{constructor(t={}){super(t,{count:[2,12],width:[5,20],height:[5,20]})}carve(t){let e,i,s,n=this.options.count.value(t.rng);const o=this.options.width.value(t.rng),r=this.options.height.value(t.rng),a=this.options.tile||h,c=Math.floor(t.width/2)-Math.floor(o/2),g=Math.floor(t.width/2)+Math.floor(o/2),u=Math.floor(t.height/2)-Math.floor(r/2),d=Math.floor(t.height/2)+Math.floor(r/2);let f=Math.floor(t.width/2),p=f,_=Math.floor(t.height/2),I=_;for(l.xy.forCircle(f,_,2,((e,i)=>t.setTile(e,i,a))),f-=2,p+=2,_-=2,I+=2,e=0;e<n;)if(i=t.rng.range(c,g),s=t.rng.range(u,d),t.isSet(i,s)){if(i-2<c)continue;if(i+2>g)continue;if(s-2<u)continue;if(s+2>d)continue;f=Math.min(i-2,f),p=Math.max(i+2,p),_=Math.min(s-2,_),I=Math.max(s+2,I),l.xy.forCircle(i,s,2,((e,i)=>t.setTile(e,i,a))),e++}return new F(f,_,p-f+1,I-_+1)}}function q(t,e){return U[t]=e,e}q("DEFAULT",new K);var Q=Object.freeze({__proto__:null,checkConfig:v,RoomDigger:Y,rooms:U,ChoiceRoom:W,choiceRoom:function(t,e){return new W(t).create(e)},Cavern:G,cavern:function(t,e){return new G(t).create(e)},BrogueEntrance:X,brogueEntrance:function(t,e){return new X(t).create(e)},Cross:H,cross:function(t,e){return new H(t).create(e)},SymmetricalCross:$,symmetricalCross:function(t,e){return new $(t).create(e)},Rectangular:K,rectangular:function(t,e){return new K(t).create(e)},Circular:V,circular:function(t,e){return new V(t).create(e)},BrogueDonut:z,brogueDonut:function(t,e){return new z(t).create(e)},ChunkyRoom:j,chunkyRoom:function(t,e){return new j(t).create(e)},install:q});const J=l.xy.DIRS;function Z(t,e,i){if(!t.hasXY(e[0],e[1]))return!1;if(!t.isDiggable(e[0],e[1]))return!1;const s=[e[0]-i[0],e[1]-i[1]];return!!t.hasXY(s[0],s[1])&&!!t.isFloor(s[0],s[1])}function tt(t,e){return l.clamp(function(t,e){if(!t)return 1;if("number"==typeof t)return t;if(e=null!=e?e:l.rng.random,Array.isArray(t))t=e.weighted(t)+1;else if("string"==typeof t)t=l.range.make(t).value(e);else if(t instanceof l.range.Range)t=t.value(e);else{const i=t;t=Number.parseInt(e.weighted(i))}return t}(t,e),1,3)}function et(t,e,i){return t==l.xy.UP||t==l.xy.DOWN?e[1].value(i):e[0].value(i)}function it(t,e,i){let s=l.xy.NO_DIRECTION;if(s==l.xy.NO_DIRECTION){const n=t.rng.sequence(4);for(let o=0;o<4;o++){s=n[o];const r=i[(o+1)%2].hi,a=e[s];if(a&&-1!=a[0]&&-1!=a[1]){const e=a[0]+Math.floor(J[s][0]*r),i=a[1]+Math.floor(J[s][1]*r);if(t.hasXY(e,i))break}s=l.xy.NO_DIRECTION}}return s}function st(t,e,i,s,n){let o,r;const l=t.rng.chance(n),a=[];for(let n=0;n<4;n++)o=e+J[n][0],r=i+J[n][1],n!=s&&!l||!t.hasXY(o,r)||t.isSet(o,r)||(a[n]=[o,r]);return a}class nt{constructor(t={}){this.config={width:1,length:[l.range.make("2-15"),l.range.make("2-9")],tile:h,obliqueChance:15,chance:100},this._setOptions(t)}_setOptions(t={}){if(t.width&&(this.config.width=t.width),t.length&&"number"==typeof t.length){const e=l.range.make(t.length);this.config.length=[e,e]}t.tile&&(this.config.tile=t.tile),t.chance&&(this.config.chance=t.chance)}create(t,e=[]){if(e=e||B(t),!t.rng.chance(this.config.chance))return null;const i=it(t,e,this.config.length);if(i===l.xy.NO_DIRECTION)return null;if(!e[i])return null;const s=tt(this.config.width,t.rng),n=et(i,this.config.length,t.rng),o=e[i];return 1==s?this.dig(t,i,o,n):this.digWide(t,i,o,n,s)}_digLine(t,e,i,s){let n=e[0],o=e[1];const r=this.config.tile;for(let e=0;e<s;e++)t.setTile(n,o,r),n+=i[0],o+=i[1];return n-=i[0],o-=i[1],[n,o]}dig(t,e,i,s){const n=J[e],[o,r]=this._digLine(t,i,n,s),l=k(i,e,s);return l.doors=st(t,o,r,e,this.config.obliqueChance),l}digWide(t,e,i,s,n){const o=l.xy.DIRS[e],r=[i[0]-o[1],i[1]-o[0]],a=[i[0]+o[1],i[1]+o[0]];this._digLine(t,i,o,s);let h=1,c=i[0],g=i[1];h<n&&Z(t,r,o)&&(this._digLine(t,r,o,s),c=Math.min(r[0],c),g=Math.min(r[1],g),++h),h<n&&Z(t,a,o)&&(this._digLine(t,a,o,s),c=Math.min(a[0],c),g=Math.min(a[1],g),++h);const u=k([c,g],e,s,n);return u.doors=[],u.doors[e]=[i[0]+s*o[0],i[1]+s*o[1]],u}}function ot(t,e,i){return new nt(t).create(e,i)}var rt={};function lt(t,e){return rt[t]=e,e}lt("DEFAULT",new nt({chance:15}));var at=Object.freeze({__proto__:null,isDoorLoc:Z,pickWidth:tt,pickLength:et,pickHallDirection:it,pickHallExits:st,HallDigger:nt,dig:ot,halls:rt,install:lt});class ht{constructor(t={}){this.options={height:15,width:30,minSize:5,tries:20,count:1,canDisrupt:!1,wreathTile:f,wreathChance:50,wreathSize:1,tile:d},l.object.assignObject(this.options,t)}create(t){let e,i,s,n,o,r,a,h,c,g,u,p=0;r=this.options.height||15,a=this.options.width||30,h=this.options.minSize||5,c=this.options.tries||20,g=this.options.count||1,u=this.options.canDisrupt||!1;const _=!!t.rng.chance(this.options.wreathChance),I=this.options.wreathTile||f,m=this.options.wreathSize||1,S=this.options.tile||d,E=l.grid.alloc(t.width,t.height,0);let O=0;for(;O<g&&p<g;){const d=Math.round((a-h)*(g-O)/g)+h,f=Math.round((r-h)*(g-O)/g)+h,B=new l.blob.Blob({rng:t.rng,rounds:5,minWidth:4,minHeight:4,maxWidth:d,maxHeight:f,percentSeeded:55});E.fill(0);const R=B.carve(E.width,E.height,((t,e)=>E[t][e]=1));let b=!1;for(s=0;s<c&&!b;s++)if(n=t.rng.range(1-R.x,E.width-R.width-R.x-2),o=t.rng.range(1-R.y,E.height-R.height-R.y-2),u||!this.isDisruptedBy(t,E,-n,-o)){for(b=!0,e=0;e<R.width;e++)for(i=0;i<R.height;i++)if(E[e+R.x][i+R.y]){const s=e+R.x+n,r=i+R.y+o;t.setTile(s,r,S),_&&(t.hasTile(s,r,I)&&t.clearCell(s,r,I),l.xy.forCircle(s,r,m,((e,i)=>{t.isPassable(e,i)&&!E[e-n][i-o]&&t.setTile(e,i,I)})))}break}b?(++p,O=0):++O}return l.grid.free(E),p}isDisruptedBy(t,e,i=0,s=0){const n=l.grid.alloc(t.width,t.height);let o=!1;l.xy.forRect(t.width,t.height,((r,l)=>{const a=r+i,h=l+s;e.get(a,h)?t.isStairs(r,l)&&(o=!0):t.isPassable(r,l)&&(n[r][l]=1)}));let r=!0;for(let t=0;t<n.width&&!o;++t)for(let e=0;e<n.height&&!o;++e)1==n[t][e]&&(r?(n.floodFill(t,e,1,2),r=!1):o=!0);return l.grid.free(n),o}}var ct=Object.freeze({__proto__:null,Lakes:ht});class gt{constructor(t={}){this.options={minDistance:20,maxLength:5},l.object.assignObject(this.options,t)}create(t){let e,i,s,n,o,r,a,c=0;const g=this.options.maxLength,u=this.options.minDistance,d=l.grid.alloc(t.width,t.height),f=l.grid.alloc(t.width,t.height),_=[[1,0],[0,1]];f.update(((e,i,s)=>t.isPassable(i,s)?1:l.path.OBSTRUCTION));const I=t.rng.sequence(t.width*t.height);for(s=0;s<I.length;s++)if(r=Math.floor(I[s]/t.height),a=I[s]%t.height,t.isPassable(r,a)&&(t.isBridge(r,a)||!t.isAnyLiquid(r,a)))for(o=0;o<=1;o++){const s=_[o];if(e=r+s[0],i=a+s[1],n=g,t.isAnyLiquid(e,i)&&!t.isBridge(e,i))for(n=0;n<g&&(e+=s[0],i+=s[1],!t.isBridge(e,i)&&t.isAnyLiquid(e,i));++n);if(t.isPassable(e,i)&&n<g&&(l.path.calculateDistances(d,e,i,f,!1),d[r][a]>u&&d[r][a]<l.path.NO_PATH)){for(;r!==e||a!==i;)this.isBridgeCandidate(t,r,a,s)?(t.setTile(r,a,p),f[r][a]=1):(t.setTile(r,a,h),f[r][a]=1),r+=s[0],a+=s[1];++c;break}}return l.grid.free(d),l.grid.free(f),c}isBridgeCandidate(t,e,i,s){return!!t.isBridge(e,i)||!!t.isAnyLiquid(e,i)}}var ut=Object.freeze({__proto__:null,Bridges:gt});class dt{constructor(t={}){this.options={up:!0,down:!0,minDistance:10,start:!1,upTile:_,downTile:I,wall:m},l.object.assignObject(this.options,t)}create(t){let e=!1!==this.options.up,i=!1!==this.options.down;const s=this.options.minDistance||Math.floor(Math.max(t.width,t.height)/2),n={};let o=null,r=null;const a=this.isStairXY.bind(this,t);if(this.options.start&&"string"!=typeof this.options.start){let e=this.options.start;e=!0===e?t.rng.matchingLoc(t.width,t.height,a):t.rng.matchingLocNear(l.xy.x(e),l.xy.y(e),a),n.start=e}if(Array.isArray(this.options.up)&&Array.isArray(this.options.down)){const e=this.options.up;o=t.rng.matchingLocNear(l.xy.x(e),l.xy.y(e),a);const i=this.options.down;r=t.rng.matchingLocNear(l.xy.x(i),l.xy.y(i),a)}else if(Array.isArray(this.options.up)&&!Array.isArray(this.options.down)){const e=this.options.up;o=t.rng.matchingLocNear(l.xy.x(e),l.xy.y(e),a),i&&(r=t.rng.matchingLoc(t.width,t.height,((t,e)=>!(l.xy.distanceBetween(t,e,o[0],o[1])<s)&&a(t,e))))}else if(Array.isArray(this.options.down)&&!Array.isArray(this.options.up)){const i=this.options.down;r=t.rng.matchingLocNear(l.xy.x(i),l.xy.y(i),a),e&&(o=t.rng.matchingLoc(t.width,t.height,((t,e)=>!(l.xy.distanceBetween(t,e,r[0],r[1])<s)&&a(t,e))))}else e?(o=t.rng.matchingLoc(t.width,t.height,a),i&&(r=t.rng.matchingLoc(t.width,t.height,((t,e)=>!(l.xy.distanceBetween(t,e,o[0],o[1])<s)&&a(t,e))))):i&&(r=t.rng.matchingLoc(t.width,t.height,a));return o&&(n.up=o.slice(),this.setupStairs(t,o[0],o[1],this.options.upTile,this.options.wall),"up"===this.options.start?n.start=n.up:n.end=n.up),r&&(n.down=r.slice(),this.setupStairs(t,r[0],r[1],this.options.downTile,this.options.wall),"down"===this.options.start?n.start=n.down:n.end=n.down),o||r?n:null}hasXY(t,e,i){return!(e<0||i<0)&&!(e>=t.width||i>=t.height)}isStairXY(t,e,i){let s=0;if(!this.hasXY(t,e,i)||!t.isDiggable(e,i))return!1;for(let n=0;n<4;++n){const o=l.xy.DIRS[n];if(!this.hasXY(t,e+o[0],i+o[1]))return!1;if(!this.hasXY(t,e-o[0],i-o[1]))return!1;if(t.isFloor(e+o[0],i+o[1])){if(s+=1,!t.isDiggable(e-o[0]+o[1],i-o[1]+o[0]))return!1;if(!t.isDiggable(e-o[0]-o[1],i-o[1]-o[0]))return!1}else if(!t.isDiggable(e+o[0],i+o[1]))return!1}return 1==s}setupStairs(t,e,i,s,n){const o=t.rng.sequence(4);let r=null;for(let s=0;s<o.length;++s){r=l.xy.DIRS[s];const n=e+r[0],o=i+r[1];if(t.isFloor(n,o)&&t.isDiggable(e-r[0],i-r[1]))break;r=null}r||l.ERROR("No stair direction found!"),t.setTile(e,i,s);const a=l.xy.CLOCK_DIRS.findIndex((t=>t[0]==r[0]&&t[1]==r[1]));for(let s=0;s<l.xy.CLOCK_DIRS.length;++s){const o=s?s-1:7,r=(s+1)%8;if(s==a||o==a||r==a)continue;const h=l.xy.CLOCK_DIRS[s];t.setTile(e+h[0],i+h[1],n)}return!0}}var ft=Object.freeze({__proto__:null,Stairs:dt});class pt{constructor(t={}){this.options={minDistance:100,maxLength:1,doorChance:50},l.object.assignObject(this.options,t)}create(t){let e,i,s,n,o,r,a,g,u;const d=Math.min(this.options.minDistance,Math.floor(Math.max(t.width,t.height)/2)),f=this.options.maxLength,p=l.grid.alloc(t.width,t.height),_=l.grid.alloc(t.width,t.height),I=[[1,0],[0,1]];function m(e,i,s){return!!t.hasXY(e,i)&&(!!t.hasXY(e+s[1],i+s[0])&&(!!t.hasXY(e-s[1],i-s[0])&&(!t.isSet(e,i)&&(!t.isSet(e+s[1],i+s[0])&&!t.isSet(e-s[1],i-s[0])))))}function S(e,i,s){return!!t.hasXY(e,i)&&(!!t.hasXY(e+s[1],i+s[0])&&(!!t.hasXY(e-s[1],i-s[0])&&(!!t.isSet(e,i)||(!!t.isSet(e+s[1],i+s[0])||!!t.isSet(e-s[1],i-s[0])))))}b(t,_);let E=0;const O=t.rng.sequence(t.width*t.height);for(o=0;o<O.length;o++)if(g=Math.floor(O[o]/t.height),u=O[o]%t.height,!t.isSet(g,u))for(a=0;a<=1;a++){let o=I[a];if(m(g,u,o)){if(r=f,t.hasXY(g+o[0],u+o[1])&&t.isPassable(g+o[0],u+o[1])){if(!t.hasXY(g-o[0],u-o[1])||t.isDoor(g-o[0],u-o[1]))continue}else{if(!t.hasXY(g-o[0],u-o[1])||!t.isPassable(g-o[0],u-o[1]))continue;if(!t.hasXY(g+o[0],u+o[1])||t.isDoor(g+o[0],u+o[1]))continue;o=o.map((t=>-1*t))}for(e=g+o[0],i=u+o[1],s=g,n=u,r=0;r<f&&(s-=o[0],n-=o[1],!S(s,n,o));++r);if(r<f&&(l.path.calculateDistances(p,e,i,_,!1),p[s][n]>d&&p[s][n]<3e4)){for(;s!==e||n!==i;)t.isNothing(s,n)&&(t.setTile(s,n,h),_[s][n]=1),s+=o[0],n+=o[1];const r=t.rng.chance(this.options.doorChance)?c:h;t.setTile(g,u,r),++E;break}}}return l.grid.free(p),l.grid.free(_),E}}var _t=Object.freeze({__proto__:null,LoopDigger:pt,digLoops:function(t,e={}){return new pt(e).create(t)}});class It{onDigFirstRoom(){}onRoomCandidate(){}onRoomFailed(){}onRoomSuccess(){}onLoopsAdded(){}onLakesAdded(){}onBridgesAdded(){}onStairsAdded(){}onBuildError(){}onBlueprintPick(){}onBlueprintCandidates(){}onBlueprintStart(){}onBlueprintInterior(){}onBlueprintFail(){}onBlueprintSuccess(){}onStepStart(){}onStepCandidates(){}onStepInstanceSuccess(){}onStepInstanceFail(){}onStepSuccess(){}onStepFail(){}}const mt=l.flag.fl;var St,Et;!function(t){t[t.BS_OUTSOURCE_ITEM_TO_MACHINE=mt(1)]="BS_OUTSOURCE_ITEM_TO_MACHINE",t[t.BS_BUILD_VESTIBULE=mt(2)]="BS_BUILD_VESTIBULE",t[t.BS_ADOPT_ITEM=mt(3)]="BS_ADOPT_ITEM",t[t.BS_BUILD_AT_ORIGIN=mt(4)]="BS_BUILD_AT_ORIGIN",t[t.BS_PERMIT_BLOCKING=mt(5)]="BS_PERMIT_BLOCKING",t[t.BS_TREAT_AS_BLOCKING=mt(6)]="BS_TREAT_AS_BLOCKING",t[t.BS_NEAR_ORIGIN=mt(7)]="BS_NEAR_ORIGIN",t[t.BS_FAR_FROM_ORIGIN=mt(8)]="BS_FAR_FROM_ORIGIN",t[t.BS_IN_VIEW_OF_ORIGIN=mt(9)]="BS_IN_VIEW_OF_ORIGIN",t[t.BS_IN_PASSABLE_VIEW_OF_ORIGIN=mt(10)]="BS_IN_PASSABLE_VIEW_OF_ORIGIN",t[t.BS_HORDE_TAKES_ITEM=mt(11)]="BS_HORDE_TAKES_ITEM",t[t.BS_HORDE_SLEEPING=mt(12)]="BS_HORDE_SLEEPING",t[t.BS_HORDE_FLEEING=mt(13)]="BS_HORDE_FLEEING",t[t.BS_HORDES_DORMANT=mt(14)]="BS_HORDES_DORMANT",t[t.BS_ITEM_IS_KEY=mt(15)]="BS_ITEM_IS_KEY",t[t.BS_ITEM_IDENTIFIED=mt(16)]="BS_ITEM_IDENTIFIED",t[t.BS_ITEM_PLAYER_AVOIDS=mt(17)]="BS_ITEM_PLAYER_AVOIDS",t[t.BS_EVERYWHERE=mt(18)]="BS_EVERYWHERE",t[t.BS_ALTERNATIVE=mt(19)]="BS_ALTERNATIVE",t[t.BS_ALTERNATIVE_2=mt(20)]="BS_ALTERNATIVE_2",t[t.BS_BUILD_IN_WALLS=mt(21)]="BS_BUILD_IN_WALLS",t[t.BS_BUILD_ANYWHERE_ON_LEVEL=mt(22)]="BS_BUILD_ANYWHERE_ON_LEVEL",t[t.BS_REPEAT_UNTIL_NO_PROGRESS=mt(23)]="BS_REPEAT_UNTIL_NO_PROGRESS",t[t.BS_IMPREGNABLE=mt(24)]="BS_IMPREGNABLE",t[t.BS_NO_BLOCK_ORIGIN=mt(25)]="BS_NO_BLOCK_ORIGIN",t[t.BS_NOT_IN_HALLWAY=mt(27)]="BS_NOT_IN_HALLWAY",t[t.BS_ALLOW_BOUNDARY=mt(28)]="BS_ALLOW_BOUNDARY",t[t.BS_SKELETON_KEY=mt(29)]="BS_SKELETON_KEY",t[t.BS_KEY_DISPOSABLE=mt(30)]="BS_KEY_DISPOSABLE"}(St||(St={}));class Ot{constructor(t={}){var e;if(this.tile=-1,this.flags=0,this.pad=0,this.item=null,this.horde=null,this.effect=null,this.chance=0,this.tile=null!==(e=t.tile)&&void 0!==e?e:-1,t.flags&&(this.flags=l.flag.from(St,t.flags)),t.pad&&(this.pad=t.pad),this.count=l.range.make(t.count||1),"string"==typeof t.item?this.item={tags:t.item}:this.item=t.item||null,t.horde&&("string"==typeof t.horde?this.horde={tags:t.horde}:!0===t.horde?this.horde={random:!0}:this.horde=t.horde),t.effect&&(this.effect=r.effect.from(t.effect)),this.item&&this.flags&St.BS_ADOPT_ITEM)throw new Error("Cannot have blueprint step with item and BS_ADOPT_ITEM.");if(this.buildAtOrigin&&this.count.hi>1)throw new Error("Cannot have count > 1 for step with BS_BUILD_AT_ORIGIN.");if(this.buildAtOrigin&&this.repeatUntilNoProgress)throw new Error("Cannot have BS_BUILD_AT_ORIGIN and BS_REPEAT_UNTIL_NO_PROGRESS together in a build step.");if(this.hordeTakesItem&&!this.horde)throw new Error("Cannot have BS_HORDE_TAKES_ITEM without a horde configured.")}get allowBoundary(){return!!(this.flags&St.BS_ALLOW_BOUNDARY)}get notInHallway(){return!!(this.flags&St.BS_NOT_IN_HALLWAY)}get buildInWalls(){return!!(this.flags&St.BS_BUILD_IN_WALLS)}get buildAnywhere(){return!!(this.flags&St.BS_BUILD_ANYWHERE_ON_LEVEL)}get repeatUntilNoProgress(){return!!(this.flags&St.BS_REPEAT_UNTIL_NO_PROGRESS)}get permitBlocking(){return!!(this.flags&St.BS_PERMIT_BLOCKING)}get treatAsBlocking(){return!!(this.flags&(St.BS_TREAT_AS_BLOCKING|St.BS_NO_BLOCK_ORIGIN))}get noBlockOrigin(){return!!(this.flags&St.BS_NO_BLOCK_ORIGIN)}get adoptItem(){return!!(this.flags&St.BS_ADOPT_ITEM)}get itemIsKey(){return!!(this.flags&St.BS_ITEM_IS_KEY)}get keyIsDisposable(){return!!(this.flags&St.BS_KEY_DISPOSABLE)}get outsourceItem(){return!!(this.flags&St.BS_OUTSOURCE_ITEM_TO_MACHINE)}get impregnable(){return!!(this.flags&St.BS_IMPREGNABLE)}get buildVestibule(){return!!(this.flags&St.BS_BUILD_VESTIBULE)}get hordeTakesItem(){return!!(this.flags&St.BS_HORDE_TAKES_ITEM)}get generateEverywhere(){return!!(this.flags&St.BS_EVERYWHERE&~St.BS_BUILD_AT_ORIGIN)}get buildAtOrigin(){return!!(this.flags&St.BS_BUILD_AT_ORIGIN)}get buildsInstances(){return!!(this.effect||-1!=this.tile||this.item||this.horde||this.adoptItem)}makeItem(t){return this.item?this.item.id?t.site.makeItem(this.item.id,this.item.make):t.site.makeRandomItem(this.item,this.item.make):null}markCandidates(t,e,i=[0,1e4]){Bt(t,this);const s=t.blueprint;let n=0;return e.update(((e,o,r)=>{const l=bt(t,s,this,o,r,i);return l===Et.OK&&n++,l})),n}makePersonalSpace(t,e,i,s){let n=0;if(this.pad<1)return 0;for(let t=e-this.pad;t<=e+this.pad;t++)for(let e=i-this.pad;e<=i+this.pad;e++)s.hasXY(t,e)&&1==s[t][e]&&(s[t][e]=0,++n);return n}toString(){let t=[];return this.tile&&t.push("tile: "+this.tile),this.effect&&t.push("effect: "+JSON.stringify(this.effect)),this.item&&t.push("item: "+JSON.stringify(this.item)),this.horde&&t.push("horde: "+JSON.stringify(this.horde)),this.pad>1&&t.push("pad: "+this.pad),(this.count.lo>1||this.count.hi>1)&&t.push("count: "+this.count.toString()),this.chance&&t.push("chance: "+this.chance),this.flags&&t.push("flags: "+l.flag.toString(St,this.flags)),"{ "+t.join(", ")+" }"}}function Bt(t,e){if(e.flags&(St.BS_IN_VIEW_OF_ORIGIN|St.BS_IN_PASSABLE_VIEW_OF_ORIGIN)){const i=t.site;if(e.flags&St.BS_IN_PASSABLE_VIEW_OF_ORIGIN){new l.fov.FOV({isBlocked:(t,e)=>i.blocksPathing(t,e)||i.blocksVision(t,e),hasXY:(t,e)=>i.hasXY(t,e)}).calculate(t.originX,t.originY,50,((e,i)=>{t.viewMap[e][i]=1}))}else{new l.fov.FOV({isBlocked:(t,e)=>i.blocksVision(t,e),hasXY:(t,e)=>i.hasXY(t,e)}).calculate(t.originX,t.originY,50,((e,i)=>{t.viewMap[e][i]=1}))}t.viewMap[t.originX][t.originY]=1}}function Rt(t,e){const i=[0,1e4];return e.flags&St.BS_NEAR_ORIGIN&&(i[1]=t.distance25),e.flags&St.BS_FAR_FROM_ORIGIN&&(i[0]=t.distance75),i}function bt(t,e,i,s,n,o){const a=t.site;if(i.notInHallway&&l.xy.arcCount(s,n,((t,e)=>a.hasXY(t,e)&&a.isPassable(t,e)))>1)return Et.IN_HALLWAY;if((0==s||s==a.width-1||0==n||n==a.height-1)&&!i.allowBoundary)return Et.ON_BOUNDARY;if(i.buildAtOrigin)return s==t.originX&&n==t.originY?Et.OK:Et.MUST_BE_ORIGIN;if(e.isRoom&&s==t.originX&&n==t.originY)return Et.NOT_ORIGIN;if(t.occupied[s][n])return Et.OCCUPIED;if(i.flags&(St.BS_IN_VIEW_OF_ORIGIN|St.BS_IN_PASSABLE_VIEW_OF_ORIGIN)&&!t.viewMap[s][n])return Et.NOT_IN_VIEW;let h=1e4;if(a.isWall(s,n)?l.xy.eachNeighbor(s,n,((e,i)=>{t.distanceMap.hasXY(e,i)&&!a.blocksPathing(e,i)&&h>t.distanceMap[e][i]+1&&(h=t.distanceMap[e][i]+1)}),!0):h=t.distanceMap[s][n],h>o[1])return Et.TOO_FAR;if(h<o[0])return Et.TOO_CLOSE;if(i.buildInWalls){const e=a.getMachine(s,n);if(!t.interior[s][n]&&(!e||e==t.machineNumber)&&a.isWall(s,n)){let e=!1,o=!1;return l.xy.eachNeighbor(s,n,((s,n)=>{if(o)return;if(!a.hasXY(s,n))return;if(!t.interior[s][n]&&!i.buildAnywhere)return;const r=a.getMachine(s,n);a.blocksPathing(s,n)||r&&r!=t.machineNumber||s==t.originX&&n==t.originY||(i.notInHallway&&l.xy.arcCount(s,n,((t,e)=>a.hasXY(t,e)&&a.isPassable(t,e)))>1?(o=!0,e=!1):e=!0)}),!0),e?Et.OK:Et.INVALID_WALL}return Et.NOT_CANDIDATE}return a.isWall(s,n)?Et.INVALID_WALL:i.buildAnywhere?i.item&&a.blocksItems(s,n)||a.hasCellFlag(s,n,r.flags.Cell.IS_CHOKEPOINT|r.flags.Cell.IS_IN_LOOP|r.flags.Cell.IS_IN_MACHINE)?Et.BLOCKED:Et.OK:t.interior[s][n]?Et.OK:Et.FAILED}!function(t){t[t.NOT_CANDIDATE=0]="NOT_CANDIDATE",t[t.OK=1]="OK",t[t.IN_HALLWAY=2]="IN_HALLWAY",t[t.ON_BOUNDARY=3]="ON_BOUNDARY",t[t.MUST_BE_ORIGIN=4]="MUST_BE_ORIGIN",t[t.NOT_ORIGIN=5]="NOT_ORIGIN",t[t.OCCUPIED=6]="OCCUPIED",t[t.NOT_IN_VIEW=7]="NOT_IN_VIEW",t[t.TOO_FAR=8]="TOO_FAR",t[t.TOO_CLOSE=9]="TOO_CLOSE",t[t.INVALID_WALL=10]="INVALID_WALL",t[t.BLOCKED=11]="BLOCKED",t[t.FAILED=12]="FAILED"}(Et||(Et={}));const Tt=l.flag.fl;var At;!function(t){t[t.BP_ROOM=Tt(0)]="BP_ROOM",t[t.BP_VESTIBULE=Tt(1)]="BP_VESTIBULE",t[t.BP_REWARD=Tt(2)]="BP_REWARD",t[t.BP_ADOPT_ITEM=Tt(3)]="BP_ADOPT_ITEM",t[t.BP_PURGE_PATHING_BLOCKERS=Tt(4)]="BP_PURGE_PATHING_BLOCKERS",t[t.BP_PURGE_INTERIOR=Tt(5)]="BP_PURGE_INTERIOR",t[t.BP_PURGE_LIQUIDS=Tt(6)]="BP_PURGE_LIQUIDS",t[t.BP_SURROUND_WITH_WALLS=Tt(7)]="BP_SURROUND_WITH_WALLS",t[t.BP_IMPREGNABLE=Tt(8)]="BP_IMPREGNABLE",t[t.BP_OPEN_INTERIOR=Tt(9)]="BP_OPEN_INTERIOR",t[t.BP_MAXIMIZE_INTERIOR=Tt(10)]="BP_MAXIMIZE_INTERIOR",t[t.BP_REDESIGN_INTERIOR=Tt(11)]="BP_REDESIGN_INTERIOR",t[t.BP_TREAT_AS_BLOCKING=Tt(12)]="BP_TREAT_AS_BLOCKING",t[t.BP_REQUIRE_BLOCKING=Tt(13)]="BP_REQUIRE_BLOCKING",t[t.BP_NO_INTERIOR_FLAG=Tt(14)]="BP_NO_INTERIOR_FLAG",t[t.BP_NOT_IN_HALLWAY=Tt(15)]="BP_NOT_IN_HALLWAY"}(At||(At={}));class wt{constructor(t={}){if(this.tags=[],this.flags=0,this.steps=[],this.id="n/a",t.tags&&("string"==typeof t.tags&&(t.tags=t.tags.split(/[,|]/).map((t=>t.trim()))),this.tags=t.tags),this.frequency=l.frequency.make(t.frequency||100),t.size?(this.size=l.range.make(t.size),this.size.lo<=0&&(this.size.lo=1),this.size.hi<this.size.lo&&(this.size.hi=this.size.lo)):this.size=l.range.make([1,1]),t.flags&&(this.flags=l.flag.from(At,t.flags)),t.steps&&(this.steps=t.steps.map((t=>new Ot(t)))),t.id&&(this.id=t.id),this.flags&At.BP_ADOPT_ITEM&&!this.steps.some((t=>!!t.adoptItem||!(!t.hordeTakesItem||t.item))))throw new Error("Blueprint calls for BP_ADOPT_ITEM, but has no adoptive step.")}get isRoom(){return!!(this.flags&At.BP_ROOM)}get isReward(){return!!(this.flags&At.BP_REWARD)}get isVestiblue(){return!!(this.flags&At.BP_VESTIBULE)}get adoptsItem(){return!!(this.flags&At.BP_ADOPT_ITEM)}get treatAsBlocking(){return!!(this.flags&At.BP_TREAT_AS_BLOCKING)}get requireBlocking(){return!!(this.flags&At.BP_REQUIRE_BLOCKING)}get purgeInterior(){return!!(this.flags&At.BP_PURGE_INTERIOR)}get purgeBlockers(){return!!(this.flags&At.BP_PURGE_PATHING_BLOCKERS)}get purgeLiquids(){return!!(this.flags&At.BP_PURGE_LIQUIDS)}get surroundWithWalls(){return!!(this.flags&At.BP_SURROUND_WITH_WALLS)}get makeImpregnable(){return!!(this.flags&At.BP_IMPREGNABLE)}get maximizeInterior(){return!!(this.flags&At.BP_MAXIMIZE_INTERIOR)}get openInterior(){return!!(this.flags&At.BP_OPEN_INTERIOR)}get noInteriorFlag(){return!!(this.flags&At.BP_NO_INTERIOR_FLAG)}get notInHallway(){return!!(this.flags&At.BP_NOT_IN_HALLWAY)}qualifies(t,e){return!(e&&e.length&&("string"==typeof e&&(e=e.split(/[,|]/).map((t=>t.trim()))),!e.every((t=>this.tags.includes(t)))))&&!(~this.flags&t||this.flags&At.BP_ADOPT_ITEM&~t||this.flags&At.BP_VESTIBULE&~t)}pickComponents(t){const e=[St.BS_ALTERNATIVE,St.BS_ALTERNATIVE_2],i=new Array(this.steps.length).fill(!0);for(let s=0;s<=1;s++){let n=0;for(let t=0;t<i.length;t++)this.steps[t].flags&e[s]&&(i[t]=!1,n++);if(n>0){let o=t.range(1,n);for(let t=0;t<i.length;t++)if(this.steps[t].flags&e[s]){if(1==o){i[t]=!0;break}o--}}}return this.steps.filter(((t,e)=>i[e]))}fillInterior(t){const e=t.interior,i=t.site;if(e.fill(0),this.isRoom)return Mt(t,t.originX,t.originY);if(this.isVestiblue)return yt(t,this);{let s=t.distanceMap;N(i,s,t.originX,t.originY,this.size.hi);const n=i.rng.sequence(i.width*i.height);let o=0,l=this.size.value();for(let t=0;t<1e3&&o<l;t++)for(let a=0;a<n.length&&o<l;a++){const l=Math.floor(n[a]/i.height),h=n[a]%i.height;if(s[l][h]==t&&(e[l][h]=1,o++,i.isOccupied(l,h)||i.hasCellFlag(l,h,r.flags.Cell.IS_IN_MACHINE)))return 0}return o}}}function Nt(t){const e=t.site,i=t.candidates,s=t.blueprint;if(i.fill(0),s.isRoom)i.update(((t,i,n)=>e.hasCellFlag(i,n,r.flags.Cell.IS_GATE_SITE)&&s.size.contains(e.getChokeCount(i,n))?1:0));else{if(s.isVestiblue)throw new Error("ERROR: Attempted to build a vestiblue without a location being provided.");i.update(((t,i,n)=>{if(!e.isPassable(i,n))return 0;if(s.notInHallway){return l.xy.arcCount(i,n,((t,i)=>e.isPassable(t,i)))<=1?1:0}return 1}))}return i.count((t=>1==t))}function Lt(t){const e=t.site,i=t.candidates,s=e.rng.matchingLoc(e.width,e.height,((t,e)=>1==i[t][e]));return!s||s[0]<0||s[1]<0?null:s}function yt(t,e){let i=!0;const s=t.site,n=t.interior;if(n.fill(0),1==e.size.hi)return n[t.originX][t.originY]=1,1;const o=s.getChokeCount(t.originX,t.originY);if(o>1e4)return 0;const r=[-1,-1];let a=o;l.xy.eachNeighbor(t.originX,t.originY,((t,e)=>{const i=s.getChokeCount(t,e);i!=o&&(i>1e4||i<0||(r[0]=t,r[1]=e,a=i))}),!0);const h=a-o;if(e.size.contains(h)){const t=n.floodFill(r[0],r[1],((t,e,n)=>(s.isOccupied(e,n)&&(i=!1),s.getChokeCount(e,n)===a)),1);if(i&&e.size.contains(t))return h}let c=0;const g=e.size.value(s.rng),u=t.distanceMap;N(s,u,t.originX,t.originY,e.size.hi);const d=s.rng.sequence(s.width*s.height);i=!0;for(let t=0;t<1e3&&c<g;t++)for(let e=0;e<d.length&&c<g;++e){const r=Math.floor(d[e]/s.height),l=d[e]%s.height;u[r][l]==t&&(s.isOccupied(r,l)&&(i=!1,c=g),s.getChokeCount(r,l)<=o||(n[r][l]=1,c+=1))}return c}function Mt(t,e,i){const s=t.interior,n=t.site;let o=1;s[e][i]=1;const a=n.getChokeCount(e,i);for(let h=0;h<4;h++){const c=e+l.xy.DIRS[h][0],g=i+l.xy.DIRS[h][1];if(n.hasXY(c,g)&&!s[c][g]){if(n.isOccupied(c,g)||n.hasCellFlag(c,g,r.flags.Cell.IS_IN_MACHINE)&&!n.hasCellFlag(c,g,r.flags.Cell.IS_GATE_SITE))return 0;if(n.getChokeCount(c,g)<=a&&!n.hasCellFlag(c,g,r.flags.Cell.IS_IN_MACHINE)){let e=Mt(t,c,g);if(e<=0)return 0;o+=e}}}return o}function Dt(t,e=1){const i=t.interior,s=t.site;let n=0,o=!0,r=0,a=t.blueprint.size.hi,h=0;for(;o&&r<a;)o=!1,r=0,++h,i.forEach(((t,a,c)=>{t&&(++r,t==h&&l.xy.eachNeighbor(a,c,((t,a)=>{if(!i.hasXY(t,a)||i[t][a])return;if(i.isBoundaryXY(t,a))return;n=0;let c=!0;l.xy.eachNeighbor(t,a,((t,e)=>{i[t][e]?++n:s.isWall(t,e)?s.getMachine(t,e)&&(c=!1):c=!1}),!1),!c||n<e||(i[t][a]=h+1,++r,s.blocksPathing(t,a)&&s.clearCell(t,a,"FLOOR"),o=!0)}),!0))}));i.update((t=>t>0?1:0))}function Ct(t){const e=t.interior,i=t.site,s=t.blueprint;s.maximizeInterior?Dt(t,1):s.openInterior&&Dt(t,4),s.purgeInterior?e.forEach(((t,e,s)=>{t&&i.clearCell(e,s,h)})):(s.purgeBlockers&&e.forEach(((t,e,s)=>{t&&i.blocksPathing(e,s)&&i.clearCell(e,s,h)})),s.purgeLiquids&&e.forEach(((t,e,s)=>{t&&i.isAnyLiquid(e,s)&&i.clearCell(e,s,h)}))),s.surroundWithWalls&&e.forEach(((t,s,n)=>{t&&!i.hasCellFlag(s,n,r.flags.Cell.IS_GATE_SITE)&&l.xy.eachNeighbor(s,n,((t,s)=>{e.hasXY(t,s)&&(e[t][s]||i.isWall(t,s)||i.hasCellFlag(t,s,r.flags.Cell.IS_GATE_SITE)||i.hasCellFlag(t,s,r.flags.Cell.IS_IN_MACHINE)||i.blocksPathing(t,s)||i.clearCell(t,s,u))}),!1)})),s.makeImpregnable&&e.forEach(((t,s,n)=>{t&&!i.hasCellFlag(s,n,r.flags.Cell.IS_GATE_SITE)&&(i.setCellFlag(s,n,r.flags.Cell.IMPREGNABLE),l.xy.eachNeighbor(s,n,((t,s)=>{e.hasXY(t,s)&&(e[t][s]||i.hasCellFlag(t,s,r.flags.Cell.IS_GATE_SITE)||i.setCellFlag(t,s,r.flags.Cell.IMPREGNABLE))}),!1))}));const n=t.machineNumber;e.forEach(((t,e,o)=>{t&&(s.noInteriorFlag||i.setMachine(e,o,n,s.isRoom),i.isSecretDoor(e,o)&&i.setTile(e,o,c))}))}const Pt={};function xt(t){return t instanceof wt?t:Pt[t]}class kt{onDigFirstRoom(t){console.group("dig first room"),t.dump(),console.groupEnd()}onRoomCandidate(t,e){console.group("room candidate: "+t.toString()),e.dump(),console.groupEnd()}onRoomFailed(t,e,i,s){console.log("Room Failed - ",s)}onRoomSuccess(t,e){console.group("Added Room - "+e.toString()),t.dump(),console.groupEnd()}onLoopsAdded(t){console.log("loops added")}onLakesAdded(t){console.log("lakes added")}onBridgesAdded(t){console.log("bridges added")}onStairsAdded(t){console.log("stairs added")}onBuildError(t){console.log(`onBuildError - error: ${t}`)}onBlueprintPick(t,e,i){console.log(`onBlueprintPick - ${t.blueprint.id}, depth = ${i}, matchingFlags = ${l.flag.toString(At,e)}`)}onBlueprintCandidates(t){const e=`onBlueprintCandidates - ${t.blueprint.id}`;console.group(e),t.candidates.dump(),console.groupEnd()}onBlueprintStart(t){console.group(`onBlueprintStart - ${t.blueprint.id} @ ${t.originX},${t.originY} : stepCount: ${t.blueprint.steps.length}, size: [${t.blueprint.size.toString()}], flags: ${l.flag.toString(At,t.blueprint.flags)}`)}onBlueprintInterior(t){console.group(`onBlueprintInterior - ${t.blueprint.id}`),t.interior.dump(),console.groupEnd()}onBlueprintFail(t,e){console.log(`onBlueprintFail - ${t.blueprint.id} @ ${t.originX},${t.originY} : error: ${e}`),console.groupEnd()}onBlueprintSuccess(t){console.log(`onBlueprintSuccess - ${t.blueprint.id} @ ${t.originX},${t.originY}`),console.groupEnd()}onStepStart(t,e){console.group(`onStepStart - ${t.blueprint.id}[${t.blueprint.steps.indexOf(e)+1}/${t.blueprint.steps.length}] @ ${t.originX},${t.originY} : count: [${e.count.toString()}], flags: ${l.flag.toString(St,e.flags)}`),console.log(e.toString())}onStepCandidates(t,e,i,s){const n=i.count((t=>1==t));console.log(`onStepCandidates - ${t.blueprint.id}[${t.blueprint.steps.indexOf(e)+1}/${t.blueprint.steps.length}] @ ${t.originX},${t.originY} : wantCount: ${s}, have: ${n}`),i.dump(),0==n&&(console.log("No candidates - check interior"),t.interior.dump())}onStepInstanceSuccess(t,e,i,s){console.log(`onStepInstance @ ${i},${s}`)}onStepInstanceFail(t,e,i,s,n){console.log(`onStepInstanceFail @ ${i},${s} - error: ${n}`)}onStepSuccess(t,e){console.log(`onStepSuccess - ${t.blueprint.id}[${t.blueprint.steps.indexOf(e)+1}/${t.blueprint.steps.length}] @ ${t.originX},${t.originY} : count: [${e.count.toString()}], flags: ${l.flag.toString(St,e.flags)}`),console.groupEnd()}onStepFail(t,e,i){console.log(`onStepFail - ${t.blueprint.id}[${t.blueprint.steps.indexOf(e)+1}/${t.blueprint.steps.length}] @ ${t.originX},${t.originY} : error : ${i}`),console.groupEnd()}}class Ft{constructor(t={}){var e,i;this.seed=0,this.rooms={fails:20},this.doors={chance:15},this.halls={chance:15},this.loops={},this.lakes={},this.bridges={},this.stairs={},this.boundary=!0,this.locations={},this._locs={},this.goesUp=!1,this.seed=t.seed||0,"number"==typeof t.rooms&&(t.rooms={count:t.rooms}),l.object.setOptions(this.rooms,t.rooms),this.goesUp=t.goesUp||!1,t.startLoc&&(this._locs.start=t.startLoc),t.endLoc&&(this._locs.end=t.endLoc),!1===t.doors?t.doors={chance:0}:!0===t.doors&&(t.doors={chance:100}),l.object.setOptions(this.doors,t.doors),!1===t.halls?t.halls={chance:0}:!0===t.halls&&(t.halls={}),l.object.setOptions(this.halls,t.halls),!1===t.loops?this.loops=null:(!0===t.loops&&(t.loops={}),"number"==typeof t.loops&&(t.loops={maxLength:t.loops}),t.loops=t.loops||{},t.loops.doorChance=null!==(e=t.loops.doorChance)&&void 0!==e?e:null===(i=t.doors)||void 0===i?void 0:i.chance,l.object.setOptions(this.loops,t.loops)),!1===t.lakes?this.lakes=null:(!0===t.lakes&&(t.lakes={}),"number"==typeof t.lakes&&(t.lakes={count:t.lakes}),l.object.setOptions(this.lakes,t.lakes)),!1===t.bridges?this.bridges=null:("number"==typeof t.bridges&&(t.bridges={maxLength:t.bridges}),!0===t.bridges&&(t.bridges={}),l.object.setOptions(this.bridges,t.bridges)),!1===t.stairs?this.stairs=null:("object"!=typeof t.stairs&&(t.stairs={}),l.object.setOptions(this.stairs,t.stairs),this.stairs.start=this.goesUp?"down":"up"),!0===t.log?this.log=new kt:t.log?this.log=t.log:this.log=new It}_makeRoomSite(t,e){const i=new y(t,e);return i.rng=this.site.rng,i}_createSite(t,e){if(t instanceof r.map.Map)this.site=new C(t);else{if(!e)throw new Error("Invlaid digger arguments.");this.site=new y(t,e)}}create(...t){this._createSite(t[0],t[1]);const e=this._create(this.site),i=t[2]||null;return i&&l.xy.forRect(this.site.width,this.site.height,((t,e)=>{const s=this.site.getTileIndex(t,e);s&&i(t,e,s)})),this.site.free(),e}_create(t){return this.start(t),this.addRooms(t),this.loops&&(this.addLoops(t,this.loops),this.log.onLoopsAdded(t)),this.lakes&&(this.addLakes(t,this.lakes),this.log.onLakesAdded(t)),this.bridges&&(this.addBridges(t,this.bridges),this.log.onBridgesAdded(t)),this.stairs&&(this.addStairs(t,this.stairs),this.log.onStairsAdded(t)),this.finish(t),!0}start(t){this.site=t;const e=this.seed||l.rng.random.number();if(t.setSeed(e),t.clear(),this.seq=t.rng.sequence(t.width*t.height),this.locations=Object.assign({},this._locs),!this.locations.start||this.locations.start[0]<0){const e=this.goesUp?"down":"up";this.stairs&&Array.isArray(this.stairs[e])?this.locations.start=this.stairs[e]:(this.locations.start=[Math.floor(t.width/2),t.height-2],this.stairs&&this.stairs[e]&&(this.stairs[e]=this.locations.start))}if(!this.locations.end||this.locations.end[0]<0){const t=this.goesUp?"up":"down";this.stairs&&Array.isArray(this.stairs[t])&&(this.locations.end=this.stairs[t])}}getDigger(t){if(!t)throw new Error("Missing digger!");if(t instanceof Y)return t;if("string"==typeof t){const e=U[t];if(!e)throw new Error("Failed to find digger - "+t);return e}return new W(t)}addRooms(t){let e=20;for(;--e&&!this.addFirstRoom(t););if(!e)throw new Error("Failed to place first room!");t.updateDoorDirs(),this.log.onDigFirstRoom(t);let i=0,s=1;const n=this.rooms.fails||20;for(;i<n;)if(this.addRoom(t)){if(i=0,t.updateDoorDirs(),t.rng.shuffle(this.seq),this.rooms.count&&++s>=this.rooms.count)break}else++i}addFirstRoom(t){const e=this._makeRoomSite(t.width,t.height);let i=this.getDigger(this.rooms.first||this.rooms.digger||"DEFAULT").create(e);return i&&!this._attachRoomAtLoc(t,e,i,this.locations.start)&&(i=null),e.free(),i}addRoom(t){const e=this._makeRoomSite(t.width,t.height);let i=this.getDigger(this.rooms.digger||"DEFAULT").create(e);if(i&&this.halls.chance){let t=ot(this.halls,e,i.doors);t&&(i.hall=t)}return i&&(this.log.onRoomCandidate(i,e),this._attachRoom(t,e,i)?this.log.onRoomSuccess(t,i):(this.log.onRoomFailed(t,i,e,"Did not fit."),i=null)),e.free(),i}_attachRoom(t,e,i){const s=i.hall?i.hall.doors:i.doors;let n=0;const o=this.seq.length;for(n=0;n<o;n++){const o=Math.floor(this.seq[n]/t.height),r=this.seq[n]%t.height,a=t.getDoorDir(o,r);if(a!=l.xy.NO_DIRECTION){const n=(a+2)%4,l=s[n];if(!l)continue;const h=o-l[0],c=r-l[1];if(-1!=l[0]&&this._roomFitsAt(t,e,i,h,c))return R(t,e,h,c),this._attachDoor(t,i,o,r,n),i.translate(h,c),!0}}return!1}_attachRoomAtLoc(t,e,i,s){const[n,o]=s,r=i.hall?i.hall.doors:i.doors,l=t.rng.sequence(4);for(let s of l){const l=r[(s+2)%4];if(!l||-1==l[0])continue;const a=n-l[0],h=o-l[1];if(this._roomFitsAt(t,e,i,a,h))return R(t,e,a,h),i.translate(a,h),!0}return!1}_roomFitsAt(t,e,i,s,n){let o,r,l,a,h,c;const g=i.hall||i,u=Math.min(i.left,g.left),d=Math.min(i.top,g.top),f=Math.max(i.right,g.right),p=Math.max(i.bottom,g.bottom);for(o=u;o<=f;o++)for(r=d;r<=p;r++)if(e.isSet(o,r)){if(l=o+s,a=r+n,!t.hasXY(l,a)||t.isBoundaryXY(l,a))return!1;for(h=l-1;h<=l+1;h++)for(c=a-1;c<=a+1;c++)if(!t.isNothing(h,c))return!1}return!0}_attachDoor(t,e,i,s,n){const o=this.doors;let r=!1;o.chance&&t.rng.chance(o.chance)&&(r=!0);const a=r?o.tile||c:h;if(t.setTile(i,s,a),e.hall&&1!=e.hall.width&&1!=e.hall.height)if(n===l.xy.UP||n===l.xy.DOWN){let e=!0,n=1;for(;e;)e=!1,t.isNothing(i-n,s)&&t.isSet(i-n,s-1)&&t.isSet(i-n,s+1)&&(t.setTile(i-n,s,a),e=!0),t.isNothing(i+n,s)&&t.isSet(i+n,s-1)&&t.isSet(i+n,s+1)&&(t.setTile(i+n,s,a),e=!0),++n}else{let e=!0,n=1;for(;e;)e=!1,t.isNothing(i,s-n)&&t.isSet(i-1,s-n)&&t.isSet(i+1,s-n)&&(t.setTile(i,s-n,a),e=!0),t.isNothing(i,s+n)&&t.isSet(i-1,s+n)&&t.isSet(i+1,s+n)&&(t.setTile(i,s+n,a),e=!0),++n}}addLoops(t,e){return new pt(e).create(t)}addLakes(t,e){return new ht(e).create(t)}addBridges(t,e){return new gt(e).create(t)}addStairs(t,e){const i=new dt(e).create(t);return i&&Object.assign(this.locations,i),!!i}finish(t){this._removeDiagonalOpenings(t),this._finishWalls(t),this._finishDoors(t)}_removeDiagonalOpenings(t){let e,i,s,n,o,r;do{for(r=!1,e=0;e<t.width-1;e++)for(i=0;i<t.height-1;i++)for(s=0;s<=1;s++)!t.blocksMove(e+s,i)&&t.blocksMove(e+(1-s),i)&&t.blocksDiagonal(e+(1-s),i)&&t.blocksMove(e+s,i+1)&&t.blocksDiagonal(e+s,i+1)&&!t.blocksMove(e+(1-s),i+1)&&(t.rng.chance(50)?(n=e+(1-s),o=i):(n=e+s,o=i+1),r=!0,t.setTile(n,o,h))}while(1==r)}_finishDoors(t){l.xy.forRect(t.width,t.height,((e,i)=>{t.isBoundaryXY(e,i)||t.isDoor(e,i)&&(t.isWall(e+1,i)?1:0)+(t.isWall(e-1,i)?1:0)+(t.isWall(e,i+1)?1:0)+(t.isWall(e,i-1)?1:0)!=2&&t.setTile(e,i,h,{superpriority:!0})}))}_finishWalls(t){const e=this.boundary?m:u;l.xy.forRect(t.width,t.height,((i,s)=>{t.isNothing(i,s)&&(t.isBoundaryXY(i,s)?t.setTile(i,s,e):t.setTile(i,s,u))}))}}class vt{constructor(t,e){this.originX=-1,this.originY=-1,this.distance25=-1,this.distance75=-1,this.machineNumber=0,this.depth=0,this.seed=0,this.site=t,this.blueprint=e,this.interior=l.grid.alloc(t.width,t.height),this.occupied=l.grid.alloc(t.width,t.height),this.viewMap=l.grid.alloc(t.width,t.height),this.distanceMap=l.grid.alloc(t.width,t.height),this.candidates=l.grid.alloc(t.width,t.height)}free(){l.grid.free(this.interior),l.grid.free(this.occupied),l.grid.free(this.viewMap),l.grid.free(this.distanceMap),l.grid.free(this.candidates)}get rng(){return this.site.rng}reset(t,e){this.interior.fill(0),this.occupied.fill(0),this.viewMap.fill(0),this.distanceMap.fill(0),this.originX=t,this.originY=e,this.distance25=0,this.distance75=0,this.seed&&this.site.setSeed(this.seed)}calcDistances(t){this.distanceMap.fill(0),N(this.site,this.distanceMap,this.originX,this.originY,t);let e=0;const i=new Array(100).fill(0);this.interior.forEach(((t,s,n)=>{if(!t)return;const o=this.distanceMap[s][n];o<100&&(i[o]++,e++)}));let s=Math.round(e/4),n=Math.round(3*e/4);for(let t=0;t<100;t++){if(s<=i[t]){s=t;break}s-=i[t]}for(let t=0;t<100;t++){if(n<=i[t]){n=t;break}n-=i[t]}this.distance25=s,this.distance75=n}}class Yt{constructor(t={}){this.blueprints=null,t.blueprints&&(Array.isArray(t.blueprints)||(t.blueprints=Object.values(t.blueprints)),this.blueprints=t.blueprints.map((t=>xt(t)))),!0===t.log?this.log=new kt:this.log=t.log||new It}_pickRandom(t,e,i){i=i||l.rng.random;const s=this.blueprints||Object.values(Pt),n=s.map((i=>i.qualifies(t)?i.frequency(e):0));return s[i.weighted(n)]||null}buildRandom(t,e=At.BP_ROOM,i=-1,s=-1,n=null){t instanceof r.map.Map&&(t=new C(t));const o=t.depth;let a=0;for(;a<10;){const r=this._pickRandom(e,o,t.rng);if(!r)return this.log.onBuildError(`Failed to find matching blueprint: requiredMachineFlags : ${l.flag.toString(At,e)}, depth: ${o}`),null;const h=new vt(t,r);if(h.site.analyze(),this.log.onBlueprintPick(h,e,o),this._buildAt(h,i,s,n))return{x:i,y:s};++a}return null}build(t,e,i=-1,s=-1,n=null){if(t instanceof r.map.Map&&(t=new C(t)),"string"==typeof e){const t=e;if(!(e=Pt[t]))throw new Error("Failed to find blueprint - "+t)}const o=new vt(t,e);return o.site.analyze(),this._buildAt(o,i,s,n)}_buildAt(t,e=-1,i=-1,s=null){if(e>=0&&i>=0)return this._build(t,e,i,s);let n=this._markCandidates(t);if(!n)return null;let o=20;for(;n--&&o--;){const e=Lt(t)||!1;if(e&&this._build(t,e[0],e[1],s))return{x:e[0],y:e[1]}}return this.log.onBlueprintFail(t,"No suitable locations found to build blueprint."),null}_build(t,e,i,s=null){if(t.reset(e,i),this.log.onBlueprintStart(t,s),!this._computeInterior(t))return null;const n=t.site.snapshot();t.machineNumber=t.site.nextMachineId(),Ct(t),t.calcDistances(t.blueprint.size.hi);const o=t.blueprint.pickComponents(t.site.rng);for(let e=0;e<o.length;e++){const i=o[e];if(!this._buildStep(t,i,s))return this.log.onBlueprintFail(t,`Failed to build step ${e+1}.`),n.restore(),null}return t.blueprint.noInteriorFlag&&L(t.site,t.machineNumber),this.log.onBlueprintSuccess(t),n.cancel(),{x:e,y:i}}_markCandidates(t){const e=Nt(t);return e<=0?(this.log.onBlueprintFail(t,"No suitable candidate locations found."),0):(this.log.onBlueprintCandidates(t),e)}_computeInterior(t){let e=null,i=t.blueprint.fillInterior(t);return i?t.blueprint.size.contains(i)?t.blueprint.treatAsBlocking&&A(t.site,t.interior,{machine:t.site.machineCount})?e="Interior blocks map.":t.blueprint.requireBlocking&&w(t.site,t.interior)<100&&(e="Interior does not block enough cells."):e=`Interior wrong size - have: ${i}, want: ${t.blueprint.size.toString()}`:e="Interior error.",e?(this.log.onBlueprintFail(t,e),!1):(this.log.onBlueprintInterior(t),!0)}_buildStep(t,e,i){let s=0,n=0;const o=t.site;this.log.onStepStart(t,e,i);const r=Rt(t,e);let a=0;if(e.buildVestibule){if(!this.buildRandom(t.site,At.BP_VESTIBULE,t.originX,t.originY))return this.log.onStepFail(t,e,"Failed to build vestibule"),!1}if(!e.buildsInstances)return this.log.onStepSuccess(t,e),!0;const h=l.grid.alloc(o.width,o.height);let c=!1;do{if(c=!1,e.buildAtOrigin)h[t.originX][t.originY]=1,a=1,s=1;else if(a=e.markCandidates(t,h,r),s=e.generateEverywhere||e.repeatUntilNoProgress?a:e.count.value(o.rng),this.log.onStepCandidates(t,e,h,s),h.update((t=>1==t?1:0)),!a||a<e.count.lo)return this.log.onStepFail(t,e,`Only ${a} qualifying tiles - want ${e.count.toString()}.`),!1;let l=0,g=0;for(;a>0&&n<s;){e.buildAtOrigin?(l=t.originX,g=t.originY):[l,g]=t.rng.matchingLoc(h.width,h.height,((t,e)=>1==h[t][e])),h[l][g]=0,a--;const s=t.site.snapshot();this._buildStepInstance(t,e,l,g,i)?(a-=e.makePersonalSpace(t,l,g,h),n++,c=!0,s.cancel()):s.restore()}}while(c&&e.repeatUntilNoProgress);return l.grid.free(h),e.count.contains(n)||e.generateEverywhere||e.repeatUntilNoProgress?(this.log.onStepSuccess(t,e),!0):(this.log.onStepFail(t,e,`Failed to build enough instances - want: ${e.count.toString()}, built: ${n}`),!1)}_buildStepInstance(t,e,i,s,n=null){let o=!0,l=!0;const a=t.site;if(o&&e.treatAsBlocking){const n={machine:a.machineCount};e.noBlockOrigin&&(n.updateWalkable=e=>(e[t.originX][t.originY]=1,!0)),T(a,i,s,n)&&(this.log.onStepInstanceFail(t,e,i,s,"instance blocks map"),o=!1)}if(o&&e.effect&&(o=a.buildEffect(e.effect,i,s),l=o,o||this.log.onStepInstanceFail(t,e,i,s,"Failed to build effect - "+JSON.stringify(e.effect))),o&&-1!==e.tile){const n=r.tile.get(e.tile);n?e.permitBlocking||!n.blocksMove()||e.treatAsBlocking||T(a,i,s,{machine:a.machineCount})&&(this.log.onStepInstanceFail(t,e,i,s,"tile blocks site"),o=!1):(o=!1,this.log.onStepInstanceFail(t,e,i,s,"failed to find tile - "+e.tile)),o&&(o=a.setTile(i,s,n),l=l||o,o||this.log.onStepInstanceFail(t,e,i,s,"failed to set tile - "+n.id))}let h=n;if(o&&e.item){const n=e.makeItem(t);if(n)if(e.itemIsKey&&(n.key=r.entity.makeKeyInfo(i,s,!!e.keyIsDisposable)),e.outsourceItem){this.buildRandom(t.site,At.BP_ADOPT_ITEM,-1,-1,n)?l=!0:(this.log.onStepInstanceFail(t,e,i,s,"Failed to build machine to adopt item - "+n.kind.id),o=!1)}else e.hordeTakesItem?h=n:(o=a.addItem(i,s,n),l=l||o,o||this.log.onStepInstanceFail(t,e,i,s,"Failed to add item to site - "+n.kind.id));else o=!1,this.log.onStepInstanceFail(t,e,i,s,"Failed to make random item - "+JSON.stringify(e.item))}else if(o&&e.adoptItem){if(!n)throw new Error("Failed to build blueprint because there is no adopted item.");o&&(o=a.addItem(i,s,n),o?l=!0:this.log.onStepInstanceFail(t,e,i,s,"Failed to add adopted item to site - "+n.kind.id))}let c=null;if(o&&e.horde){let n;if(e.horde.random?n=r.horde.random({rng:a.rng}):e.horde.id?n=r.horde.from(e.horde.id):(e.horde.rng=a.rng,n=r.horde.random(e.horde)),n){const g=a.spawnHorde(n,i,s,{machine:a.machineCount});if(g){if(l=!0,h&&e.hordeTakesItem&&(c=g,c.pickupItem(h,{admin:!0})||(o=!1)),e.horde.effect){const t=r.effect.from(e.horde.effect);a.buildEffect(t,i,s)}}else o=!1,this.log.onStepInstanceFail(t,e,i,s,"Failed to build horde - "+n)}else o=!1,this.log.onStepInstanceFail(t,e,i,s,"Failed to pick horde - "+JSON.stringify(e.horde))}return o&&l&&(t.blueprint.noInteriorFlag||a.setMachine(i,s,t.machineNumber,t.blueprint.isRoom),e.impregnable&&a.setCellFlag(i,s,r.flags.Cell.IMPREGNABLE),this.log.onStepInstanceSuccess(t,e,i,s)),o&&l}}function Ut(t,e,i,s,n){const o=new Yt(n),r=new C(e);return o.build(r,t,i,s)}var Wt=Object.freeze({__proto__:null,BuildData:vt,get StepFlags(){return St},BuildStep:Ot,updateViewMap:Bt,calcDistanceBound:Rt,get CandidateType(){return Et},cellIsCandidate:bt,Builder:Yt,build:Ut,get Flags(){return At},Blueprint:wt,markCandidates:Nt,pickCandidateLoc:Lt,computeVestibuleInterior:yt,maximizeInterior:Dt,prepareInterior:Ct,blueprints:Pt,install:function(t,e){return e instanceof wt||(e=new wt(e)),Pt[t]=e,e.id=t,e},random:function(t,e,i){const s=Object.values(Pt).filter((i=>i.qualifies(t)&&i.frequency(e)));return(i=i||l.rng.random).item(s)},get:xt,make:function(t){return new wt(t)}}),Gt=Object.freeze({__proto__:null,NullLogger:It,ConsoleLogger:kt});class Xt extends r.horde.Horde{constructor(t){super(t),this.machine=null,this.machine=t.blueprint||null}_addLeader(t,e,i,s,n){return this.machine&&Ut(this.machine,e,i,s),!!super._addLeader(t,e,i,s,n)}}var Ht=Object.freeze({__proto__:null,MachineHorde:Xt});t.Digger=Ft,t.Dungeon=class{constructor(t={}){this.config={levels:1,width:80,height:34,rooms:{fails:20},boundary:!0},this.seeds=[],this.stairLocs=[],l.object.setOptions(this.config,t),this.config.seed&&l.rng.random.seed(this.config.seed),"boolean"!=typeof this.config.stairs&&this.config.stairs||(this.config.stairs={}),this.config.rooms?"number"==typeof this.config.rooms&&(this.config.rooms={count:this.config.rooms}):this.config.rooms={},this._initSeeds(),this._initStairLocs()}get length(){return this.config.levels}_initSeeds(){for(let t=0;t<this.config.levels;++t)this.seeds[t]=l.rng.random.number(2**32)}_initStairLocs(){let t=this.config.startLoc||[Math.floor(this.config.width/2),this.config.height-2];const e=this.config.stairDistance||Math.floor(Math.max(this.config.width/2,this.config.height/2));let i=!1;for(let s=0;s<this.config.levels;++s){let n;this.stairLocs[s]&&this.stairLocs[s][1]&&this.stairLocs[s][1][0]>0?(n=this.stairLocs[s][1],i=l.xy.distanceBetween(t[0],t[1],n[0],n[1])<e):n=l.rng.random.matchingLoc(this.config.width,this.config.height,((i,s)=>l.xy.distanceBetween(t[0],t[1],i,s)>e)),this.stairLocs[s]=[[t[0],t[1]],[n[0],n[1]]],t=n}if(i)for(let t=this.config.levels-1;t>0;--t){let[i,s]=this.stairLocs[t];if(l.xy.distanceBetween(i[0],i[1],s[0],s[1])>e)break;i=l.rng.random.matchingLoc(this.config.width,this.config.height,((t,i)=>l.xy.distanceBetween(s[0],s[1],t,i)>e)),this.stairLocs[t][0]=i,this.stairLocs[t-1][1]=i}}getLevel(t,e){if(t<0||t>this.config.levels)throw new Error("Invalid level id: "+t);const[i,s]=this.stairLocs[t],n=Object.assign({},this.config.stairs);this.config.goesUp?(n.down=i,n.up=s,0==t&&this.config.startTile&&(n.downTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(n.upTile=this.config.endTile)):(n.down=s,n.up=i,0==t&&this.config.startTile&&(n.upTile=this.config.startTile),t==this.config.levels-1&&this.config.endTile&&(n.downTile=this.config.endTile));const o=Object.assign({},this.config.rooms);0===t&&this.config.entrance&&(o.first=this.config.entrance);let l=this.config.width,a=this.config.height;e instanceof r.map.Map&&(l=e.width,a=e.height);const h={seed:this.seeds[t],loops:this.config.loops,lakes:this.config.lakes,bridges:this.config.bridges,rooms:o,stairs:n,boundary:this.config.boundary,goesUp:this.config.goesUp,width:l,height:a};return this._makeLevel(t,h,e)}_makeLevel(t,e,i){const s=new Ft(e);let n=!1;if(n=i instanceof r.map.Map?s.create(i):s.create(this.config.width,this.config.height,i),this.stairLocs[t]=[s.locations.start,s.locations.end],i instanceof r.map.Map){const e=this.stairLocs[t];this.config.goesUp?(i.locations.down=i.locations.start=e[0],i.locations.up=i.locations.end=e[1]):(i.locations.down=i.locations.start=e[1],i.locations.up=i.locations.end=e[0])}return n}},t.Hall=x,t.Room=F,t.blueprint=Wt,t.bridge=ut,t.digMap=function(t,e={}){return new Ft(e).create(t)},t.hall=at,t.horde=Ht,t.lake=ct,t.log=Gt,t.loop=_t,t.makeHall=k,t.room=Q,t.site=P,t.stairs=ft,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=gw-dig.min.js.map
