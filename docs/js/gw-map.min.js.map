{"version":3,"file":"gw-map.min.js","sources":["../js/flags.js","../js/light.js","../js/layer.js","../js/tileEvent.js","../js/tile.js","../js/cell.js","../js/map.js","../js/tiles.js"],"sourcesContent":["import { flag as Flag } from \"gw-utils\";\nexport var Depth;\n(function (Depth) {\n    Depth[Depth[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Depth[Depth[\"GROUND\"] = 0] = \"GROUND\";\n    Depth[Depth[\"LIQUID\"] = 1] = \"LIQUID\";\n    Depth[Depth[\"SURFACE\"] = 2] = \"SURFACE\";\n    Depth[Depth[\"GAS\"] = 3] = \"GAS\";\n    Depth[Depth[\"ITEM\"] = 4] = \"ITEM\";\n    Depth[Depth[\"ACTOR\"] = 5] = \"ACTOR\";\n    Depth[Depth[\"PLAYER\"] = 6] = \"PLAYER\";\n    Depth[Depth[\"FX\"] = 7] = \"FX\";\n    Depth[Depth[\"UI\"] = 8] = \"UI\";\n})(Depth || (Depth = {}));\nconst Fl = Flag.fl;\nexport var Layer;\n(function (Layer) {\n    Layer[Layer[\"L_DYNAMIC\"] = Fl(0)] = \"L_DYNAMIC\";\n    Layer[Layer[\"L_SUPERPRIORITY\"] = Fl(1)] = \"L_SUPERPRIORITY\";\n    Layer[Layer[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Layer[Layer[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Layer[Layer[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Layer[Layer[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Layer[Layer[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Layer[Layer[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Layer[Layer[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Layer[Layer[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Layer[Layer[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Layer[Layer[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Layer[Layer[\"L_BLOCKED_BY_STAIRS\"] = Layer.L_BLOCKS_ITEMS |\n        Layer.L_BLOCKS_SURFACE |\n        Layer.L_BLOCKS_GAS |\n        Layer.L_BLOCKS_LIQUID |\n        Layer.L_BLOCKS_EFFECTS |\n        Layer.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Layer[Layer[\"L_BLOCKS_SCENT\"] = Layer.L_BLOCKS_MOVE | Layer.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Layer[Layer[\"L_DIVIDES_LEVEL\"] = Layer.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Layer[Layer[\"L_WAYPOINT_BLOCKER\"] = Layer.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Layer[Layer[\"L_IS_WALL\"] = Layer.L_BLOCKS_MOVE |\n        Layer.L_BLOCKS_VISION |\n        Layer.L_BLOCKS_LIQUID |\n        Layer.L_BLOCKS_GAS |\n        Layer.L_BLOCKS_EFFECTS |\n        Layer.L_BLOCKS_DIAGONAL] = \"L_IS_WALL\";\n    Layer[Layer[\"L_BLOCKS_EVERYTHING\"] = Layer.L_IS_WALL |\n        Layer.L_BLOCKS_ITEMS |\n        Layer.L_BLOCKS_ACTORS |\n        Layer.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Layer || (Layer = {}));\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Activation;\n(function (Activation) {\n    Activation[Activation[\"DFF_SUBSEQ_ALWAYS\"] = Fl(0)] = \"DFF_SUBSEQ_ALWAYS\";\n    Activation[Activation[\"DFF_SUBSEQ_EVERYWHERE\"] = Fl(1)] = \"DFF_SUBSEQ_EVERYWHERE\";\n    Activation[Activation[\"DFF_TREAT_AS_BLOCKING\"] = Fl(2)] = \"DFF_TREAT_AS_BLOCKING\";\n    Activation[Activation[\"DFF_PERMIT_BLOCKING\"] = Fl(3)] = \"DFF_PERMIT_BLOCKING\";\n    Activation[Activation[\"DFF_ACTIVATE_DORMANT_MONSTER\"] = Fl(4)] = \"DFF_ACTIVATE_DORMANT_MONSTER\";\n    Activation[Activation[\"DFF_BLOCKED_BY_OTHER_LAYERS\"] = Fl(6)] = \"DFF_BLOCKED_BY_OTHER_LAYERS\";\n    Activation[Activation[\"DFF_SUPERPRIORITY\"] = Fl(7)] = \"DFF_SUPERPRIORITY\";\n    Activation[Activation[\"DFF_AGGRAVATES_MONSTERS\"] = Fl(8)] = \"DFF_AGGRAVATES_MONSTERS\";\n    Activation[Activation[\"DFF_RESURRECT_ALLY\"] = Fl(9)] = \"DFF_RESURRECT_ALLY\";\n    Activation[Activation[\"DFF_EMIT_EVENT\"] = Fl(10)] = \"DFF_EMIT_EVENT\";\n    Activation[Activation[\"DFF_NO_REDRAW_CELL\"] = Fl(11)] = \"DFF_NO_REDRAW_CELL\";\n    Activation[Activation[\"DFF_ABORT_IF_BLOCKS_MAP\"] = Fl(12)] = \"DFF_ABORT_IF_BLOCKS_MAP\";\n    Activation[Activation[\"DFF_BLOCKED_BY_ITEMS\"] = Fl(13)] = \"DFF_BLOCKED_BY_ITEMS\";\n    Activation[Activation[\"DFF_BLOCKED_BY_ACTORS\"] = Fl(14)] = \"DFF_BLOCKED_BY_ACTORS\";\n    Activation[Activation[\"DFF_ALWAYS_FIRE\"] = Fl(15)] = \"DFF_ALWAYS_FIRE\";\n    Activation[Activation[\"DFF_NO_MARK_FIRED\"] = Fl(16)] = \"DFF_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Activation[Activation[\"DFF_PROTECTED\"] = Fl(19)] = \"DFF_PROTECTED\";\n    Activation[Activation[\"DFF_SPREAD_CIRCLE\"] = Fl(20)] = \"DFF_SPREAD_CIRCLE\";\n    Activation[Activation[\"DFF_SPREAD_LINE\"] = Fl(21)] = \"DFF_SPREAD_LINE\";\n    Activation[Activation[\"DFF_NULL_SURFACE\"] = Fl(22)] = \"DFF_NULL_SURFACE\";\n    Activation[Activation[\"DFF_NULL_LIQUID\"] = Fl(23)] = \"DFF_NULL_LIQUID\";\n    Activation[Activation[\"DFF_NULL_GAS\"] = Fl(24)] = \"DFF_NULL_GAS\";\n    Activation[Activation[\"DFF_EVACUATE_CREATURES\"] = Fl(25)] = \"DFF_EVACUATE_CREATURES\";\n    Activation[Activation[\"DFF_EVACUATE_ITEMS\"] = Fl(26)] = \"DFF_EVACUATE_ITEMS\";\n    Activation[Activation[\"DFF_BUILD_IN_WALLS\"] = Fl(27)] = \"DFF_BUILD_IN_WALLS\";\n    Activation[Activation[\"DFF_MUST_TOUCH_WALLS\"] = Fl(28)] = \"DFF_MUST_TOUCH_WALLS\";\n    Activation[Activation[\"DFF_NO_TOUCH_WALLS\"] = Fl(29)] = \"DFF_NO_TOUCH_WALLS\";\n    Activation[Activation[\"DFF_ONLY_IF_EMPTY\"] = Activation.DFF_BLOCKED_BY_ITEMS | Activation.DFF_BLOCKED_BY_ACTORS] = \"DFF_ONLY_IF_EMPTY\";\n    Activation[Activation[\"DFF_NULLIFY_CELL\"] = Activation.DFF_NULL_SURFACE | Activation.DFF_NULL_LIQUID | Activation.DFF_NULL_GAS] = \"DFF_NULLIFY_CELL\";\n})(Activation || (Activation = {}));\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_LIQUID\"] = Fl(0)] = \"T_LIQUID\";\n    Tile[Tile[\"T_SURFACE\"] = Fl(1)] = \"T_SURFACE\";\n    Tile[Tile[\"T_GAS\"] = Fl(2)] = \"T_GAS\";\n    Tile[Tile[\"T_BRIDGE\"] = Fl(11)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(12)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(13)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(14)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(15)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(16)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(17)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(18)] = \"T_ENTANGLES\";\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(24)] = \"T_IS_TRAP\";\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    Tile[Tile[\"T_SACRED\"] = Fl(26)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(27)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(28)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(29)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(30)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n})(Tile || (Tile = {}));\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    TileMech[TileMech[\"TM_IS_SECRET\"] = Fl(0)] = \"TM_IS_SECRET\";\n    TileMech[TileMech[\"TM_PROMOTES_WITH_KEY\"] = Fl(1)] = \"TM_PROMOTES_WITH_KEY\";\n    TileMech[TileMech[\"TM_PROMOTES_WITHOUT_KEY\"] = Fl(2)] = \"TM_PROMOTES_WITHOUT_KEY\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_STEP\"] = Fl(3)] = \"TM_PROMOTES_ON_STEP\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_ITEM_REMOVE\"] = Fl(4)] = \"TM_PROMOTES_ON_ITEM_REMOVE\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_PLAYER_ENTRY\"] = Fl(5)] = \"TM_PROMOTES_ON_PLAYER_ENTRY\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_SACRIFICE_ENTRY\"] = Fl(6)] = \"TM_PROMOTES_ON_SACRIFICE_ENTRY\";\n    TileMech[TileMech[\"TM_PROMOTES_ON_ELECTRICITY\"] = Fl(7)] = \"TM_PROMOTES_ON_ELECTRICITY\";\n    TileMech[TileMech[\"TM_ALLOWS_SUBMERGING\"] = Fl(8)] = \"TM_ALLOWS_SUBMERGING\";\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_EXTINGUISHES_FIRE\"] = Fl(14)] = \"TM_EXTINGUISHES_FIRE\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_REFLECTS_BOLTS\"] = Fl(16)] = \"TM_REFLECTS_BOLTS\";\n    TileMech[TileMech[\"TM_STAND_IN_TILE\"] = Fl(17)] = \"TM_STAND_IN_TILE\";\n    TileMech[TileMech[\"TM_LIST_IN_SIDEBAR\"] = Fl(18)] = \"TM_LIST_IN_SIDEBAR\";\n    TileMech[TileMech[\"TM_VISUALLY_DISTINCT\"] = Fl(19)] = \"TM_VISUALLY_DISTINCT\";\n    TileMech[TileMech[\"TM_BRIGHT_MEMORY\"] = Fl(20)] = \"TM_BRIGHT_MEMORY\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_CONNECTS_LEVEL\"] = Fl(22)] = \"TM_CONNECTS_LEVEL\";\n    TileMech[TileMech[\"TM_INTERRUPT_EXPLORATION_WHEN_SEEN\"] = Fl(23)] = \"TM_INTERRUPT_EXPLORATION_WHEN_SEEN\";\n    TileMech[TileMech[\"TM_INVERT_WHEN_HIGHLIGHTED\"] = Fl(24)] = \"TM_INVERT_WHEN_HIGHLIGHTED\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    TileMech[TileMech[\"TM_PROMOTES\"] = TileMech.TM_PROMOTES_WITH_KEY |\n        TileMech.TM_PROMOTES_WITHOUT_KEY |\n        TileMech.TM_PROMOTES_ON_STEP |\n        TileMech.TM_PROMOTES_ON_ITEM_REMOVE |\n        TileMech.TM_PROMOTES_ON_SACRIFICE_ENTRY |\n        TileMech.TM_PROMOTES_ON_ELECTRICITY |\n        TileMech.TM_PROMOTES_ON_PLAYER_ENTRY] = \"TM_PROMOTES\";\n})(TileMech || (TileMech = {}));\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"REVEALED\"] = Fl(0)] = \"REVEALED\";\n    Cell[Cell[\"VISIBLE\"] = Fl(1)] = \"VISIBLE\";\n    Cell[Cell[\"WAS_VISIBLE\"] = Fl(2)] = \"WAS_VISIBLE\";\n    Cell[Cell[\"IN_FOV\"] = Fl(3)] = \"IN_FOV\";\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(4)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_MONSTER\"] = Fl(5)] = \"HAS_MONSTER\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(6)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(7)] = \"HAS_ITEM\";\n    Cell[Cell[\"HAS_STAIRS\"] = Fl(8)] = \"HAS_STAIRS\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(9)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"CELL_CHANGED\"] = Fl(10)] = \"CELL_CHANGED\";\n    Cell[Cell[\"IS_IN_PATH\"] = Fl(12)] = \"IS_IN_PATH\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(13)] = \"IS_CURSOR\";\n    Cell[Cell[\"MAGIC_MAPPED\"] = Fl(14)] = \"MAGIC_MAPPED\";\n    Cell[Cell[\"ITEM_DETECTED\"] = Fl(15)] = \"ITEM_DETECTED\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(16)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"CLAIRVOYANT_VISIBLE\"] = Fl(17)] = \"CLAIRVOYANT_VISIBLE\";\n    Cell[Cell[\"WAS_CLAIRVOYANT_VISIBLE\"] = Fl(18)] = \"WAS_CLAIRVOYANT_VISIBLE\";\n    Cell[Cell[\"CLAIRVOYANT_DARKENED\"] = Fl(19)] = \"CLAIRVOYANT_DARKENED\";\n    Cell[Cell[\"IMPREGNABLE\"] = Fl(20)] = \"IMPREGNABLE\";\n    Cell[Cell[\"TELEPATHIC_VISIBLE\"] = Fl(22)] = \"TELEPATHIC_VISIBLE\";\n    Cell[Cell[\"WAS_TELEPATHIC_VISIBLE\"] = Fl(23)] = \"WAS_TELEPATHIC_VISIBLE\";\n    Cell[Cell[\"MONSTER_DETECTED\"] = Fl(24)] = \"MONSTER_DETECTED\";\n    Cell[Cell[\"WAS_MONSTER_DETECTED\"] = Fl(25)] = \"WAS_MONSTER_DETECTED\";\n    Cell[Cell[\"LIGHT_CHANGED\"] = Fl(27)] = \"LIGHT_CHANGED\";\n    Cell[Cell[\"CELL_LIT\"] = Fl(28)] = \"CELL_LIT\";\n    Cell[Cell[\"IS_IN_SHADOW\"] = Fl(29)] = \"IS_IN_SHADOW\";\n    Cell[Cell[\"CELL_DARK\"] = Fl(30)] = \"CELL_DARK\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.REVEALED |\n        Cell.MAGIC_MAPPED |\n        Cell.ITEM_DETECTED |\n        Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.HAS_STAIRS |\n        Cell.STABLE_MEMORY |\n        Cell.IMPREGNABLE] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"ANY_KIND_OF_VISIBLE\"] = Cell.VISIBLE | Cell.CLAIRVOYANT_VISIBLE | Cell.TELEPATHIC_VISIBLE] = \"ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"HAS_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_MONSTER] = \"HAS_ACTOR\";\n    Cell[Cell[\"IS_WAS_ANY_KIND_OF_VISIBLE\"] = Cell.VISIBLE |\n        Cell.WAS_VISIBLE |\n        Cell.CLAIRVOYANT_VISIBLE |\n        Cell.WAS_CLAIRVOYANT_VISIBLE |\n        Cell.TELEPATHIC_VISIBLE |\n        Cell.WAS_TELEPATHIC_VISIBLE] = \"IS_WAS_ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.VISIBLE | Cell.IN_FOV | Cell.NEEDS_REDRAW | Cell.CELL_CHANGED] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n///////////////////////////////////////////////////////\n// CELL MECH\nexport var CellMech;\n(function (CellMech) {\n    CellMech[CellMech[\"SEARCHED_FROM_HERE\"] = Fl(0)] = \"SEARCHED_FROM_HERE\";\n    CellMech[CellMech[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(1)] = \"PRESSURE_PLATE_DEPRESSED\";\n    CellMech[CellMech[\"KNOWN_TO_BE_TRAP_FREE\"] = Fl(2)] = \"KNOWN_TO_BE_TRAP_FREE\";\n    CellMech[CellMech[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(4)] = \"CAUGHT_FIRE_THIS_TURN\";\n    CellMech[CellMech[\"EVENT_FIRED_THIS_TURN\"] = Fl(5)] = \"EVENT_FIRED_THIS_TURN\";\n    CellMech[CellMech[\"EVENT_PROTECTED\"] = Fl(6)] = \"EVENT_PROTECTED\";\n    CellMech[CellMech[\"IS_IN_LOOP\"] = Fl(10)] = \"IS_IN_LOOP\";\n    CellMech[CellMech[\"IS_CHOKEPOINT\"] = Fl(11)] = \"IS_CHOKEPOINT\";\n    CellMech[CellMech[\"IS_GATE_SITE\"] = Fl(12)] = \"IS_GATE_SITE\";\n    CellMech[CellMech[\"IS_IN_ROOM_MACHINE\"] = Fl(13)] = \"IS_IN_ROOM_MACHINE\";\n    CellMech[CellMech[\"IS_IN_AREA_MACHINE\"] = Fl(14)] = \"IS_IN_AREA_MACHINE\";\n    CellMech[CellMech[\"IS_POWERED\"] = Fl(15)] = \"IS_POWERED\";\n    CellMech[CellMech[\"IS_IN_MACHINE\"] = CellMech.IS_IN_ROOM_MACHINE | CellMech.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    CellMech[CellMech[\"PERMANENT_MECH_FLAGS\"] = CellMech.SEARCHED_FROM_HERE |\n        CellMech.PRESSURE_PLATE_DEPRESSED |\n        CellMech.KNOWN_TO_BE_TRAP_FREE |\n        CellMech.IS_IN_LOOP |\n        CellMech.IS_CHOKEPOINT |\n        CellMech.IS_GATE_SITE |\n        CellMech.IS_IN_MACHINE] = \"PERMANENT_MECH_FLAGS\";\n})(CellMech || (CellMech = {}));\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_STABLE_GLOW_LIGHTS\"] = Fl(1)] = \"MAP_STABLE_GLOW_LIGHTS\";\n    Map[Map[\"MAP_STABLE_LIGHTS\"] = Fl(2)] = \"MAP_STABLE_LIGHTS\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(7)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DEFAULT\"] = Map.MAP_STABLE_LIGHTS | Map.MAP_STABLE_GLOW_LIGHTS | Map.MAP_FOV_CHANGED] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import { utils as Utils, range as Range, grid as Grid, color as Color, data as DATA, config as CONFIG, make as Make, } from \"gw-utils\";\nimport * as Flags from \"./flags\";\n// const LIGHT_SMOOTHING_THRESHOLD = 150;       // light components higher than this magnitude will be toned down a little\nexport const config = (CONFIG.light = { INTENSITY_DARK: 20 }); // less than 20% for highest color in rgb\nconst LIGHT_COMPONENTS = Color.make();\nexport class Light {\n    constructor(color, range, fadeTo, pass = false) {\n        this.fadeTo = 0;\n        this.passThroughActors = false;\n        this.id = null;\n        this.color = Color.from(color) || null; /* color */\n        this.radius = Range.make(range || 1);\n        this.fadeTo = fadeTo || 0;\n        this.passThroughActors = pass; // generally no, but miner light does (TODO - string parameter?  'false' or 'true')\n    }\n    copy(other) {\n        this.color = other.color;\n        this.radius.copy(other.radius);\n        this.fadeTo = other.fadeTo;\n        this.passThroughActors = other.passThroughActors;\n    }\n    get intensity() {\n        return intensity(this.color);\n    }\n    // Returns true if any part of the light hit cells that are in the player's field of view.\n    paint(map, x, y, maintainShadows = false, isMinersLight = false) {\n        if (!map)\n            return false;\n        let k;\n        // let colorComponents = [0,0,0];\n        let lightMultiplier;\n        let radius = this.radius.value();\n        let outerRadius = Math.ceil(radius);\n        // calcLightComponents(colorComponents, this);\n        LIGHT_COMPONENTS.copy(this.color).bake();\n        // console.log('paint', LIGHT_COMPONENTS.toString(true), x, y, outerRadius);\n        // the miner's light does not dispel IS_IN_SHADOW,\n        // so the player can be in shadow despite casting his own light.\n        const dispelShadows = !isMinersLight &&\n            !maintainShadows &&\n            intensity(LIGHT_COMPONENTS) > config.INTENSITY_DARK;\n        const fadeToPercent = this.fadeTo;\n        const grid = Grid.alloc(map.width, map.height, 0);\n        map.calcFov(grid, x, y, outerRadius, this.passThroughActors ? 0 : Flags.Cell.HAS_ACTOR, Flags.Layer.L_BLOCKS_VISION);\n        let overlappedFieldOfView = false;\n        grid.forCircle(x, y, outerRadius, (v, i, j) => {\n            if (!v)\n                return;\n            const cell = map.cell(i, j);\n            lightMultiplier = Math.floor(100 -\n                (100 - fadeToPercent) * (Utils.distanceBetween(x, y, i, j) / radius));\n            for (k = 0; k < 3; k++) {\n                cell.light[k] += Math.floor((LIGHT_COMPONENTS[k] * lightMultiplier) / 100);\n            }\n            if (dispelShadows) {\n                cell.flags &= ~Flags.Cell.IS_IN_SHADOW;\n            }\n            if (cell.flags & (Flags.Cell.IN_FOV | Flags.Cell.ANY_KIND_OF_VISIBLE)) {\n                overlappedFieldOfView = true;\n            }\n            // console.log(i, j, lightMultiplier, cell.light);\n        });\n        if (dispelShadows) {\n            const cell = map.cell(x, y);\n            cell.flags &= ~Flags.Cell.IS_IN_SHADOW;\n        }\n        Grid.free(grid);\n        return overlappedFieldOfView;\n    }\n}\nexport function intensity(color) {\n    return Math.max(color[0], color[1], color[2]);\n}\nexport function make(...args) {\n    if (args.length == 1) {\n        const config = args[0];\n        if (typeof config === \"string\") {\n            const cached = lights[config];\n            if (cached)\n                return cached;\n            const [color, radius, fadeTo, pass] = config\n                .split(/[,|]/)\n                .map((t) => t.trim());\n            return new Light(Color.from(color), Range.from(radius || 1), Number.parseInt(fadeTo || \"0\"), !!pass && pass !== \"false\");\n        }\n        else if (Array.isArray(config)) {\n            const [color, radius, fadeTo, pass] = config;\n            return new Light(color, radius, fadeTo, pass);\n        }\n        else if (config && config.color) {\n            return new Light(Color.from(config.color), Range.from(config.radius), Number.parseInt(config.fadeTo || \"0\"), config.pass);\n        }\n        else {\n            throw new Error(\"Unknown Light config - \" + config);\n        }\n    }\n    else {\n        const [color, radius, fadeTo, pass] = args;\n        return new Light(color, radius, fadeTo, pass);\n    }\n}\nMake.light = make;\nexport const lights = {};\nexport function from(...args) {\n    if (args.length != 1)\n        Utils.ERROR(\"Unknown Light config: \" + JSON.stringify(args));\n    const arg = args[0];\n    if (typeof arg === \"string\") {\n        const cached = lights[arg];\n        if (cached)\n            return cached;\n    }\n    return make(arg);\n}\nexport function install(id, ...args) {\n    let source;\n    if (args.length == 1) {\n        source = make(args[0]);\n    }\n    else {\n        source = make(args[0], args[1], args[2], args[3]);\n    }\n    lights[id] = source;\n    if (source)\n        source.id = id;\n    return source;\n}\nexport function installAll(config = {}) {\n    const entries = Object.entries(config);\n    entries.forEach(([name, info]) => {\n        install(name, info);\n    });\n}\n// export function calcLightComponents(colorComponents, theLight) {\n// \tconst randComponent = cosmetic.range(0, theLight.color.rand);\n// \tcolorComponents[0] = randComponent + theLight.color.red + cosmetic.range(0, theLight.color.redRand);\n// \tcolorComponents[1] = randComponent + theLight.color.green + cosmetic.range(0, theLight.color.greenRand);\n// \tcolorComponents[2] = randComponent + theLight.color.blue + cosmetic.range(0, theLight.color.blueRand);\n// }\nfunction updateDisplayDetail(map) {\n    map.eachCell((cell, _i, _j) => {\n        // clear light flags\n        cell.flags &= ~(Flags.Cell.CELL_LIT | Flags.Cell.CELL_DARK);\n        if (cell.light.some((v, i) => v !== cell.oldLight[i])) {\n            cell.lightChanged = true;\n        }\n        if (cell.isDark()) {\n            cell.flags |= Flags.Cell.CELL_DARK;\n        }\n        else if (!(cell.flags & Flags.Cell.IS_IN_SHADOW)) {\n            cell.flags |= Flags.Cell.CELL_LIT;\n        }\n    });\n}\n// export function backUpLighting(map: Map.Map, lights: LightDataGrid) {\n//   let k;\n//   map.eachCell((cell, i, j) => {\n//     for (k = 0; k < 3; k++) {\n//       lights[i][j][k] = cell.light[k];\n//     }\n//   });\n// }\n// export function restoreLighting(map: Map.Map, lights: LightDataGrid) {\n//   let k;\n//   map.eachCell((cell, i, j) => {\n//     for (k = 0; k < 3; k++) {\n//       cell.light[k] = lights[i][j][k];\n//     }\n//   });\n// }\nexport function recordOldLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.oldLight[k] = cell.light[k];\n            cell.lightChanged = false;\n        }\n    });\n}\nexport function zeroOutLights(map) {\n    let k;\n    const light = map.ambientLight ? map.ambientLight : [0, 0, 0];\n    map.eachCell((cell, _i, _j) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = light[k];\n        }\n        cell.flags |= Flags.Cell.IS_IN_SHADOW;\n    });\n}\nexport function recordGlowLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.glowLight[k] = cell.light[k];\n        }\n    });\n}\nexport function restoreGlowLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = cell.glowLight[k];\n        }\n    });\n}\nexport function updateLighting(map) {\n    // Copy Light over oldLight\n    recordOldLights(map);\n    if (!map.anyLightChanged)\n        return false;\n    // and then zero out Light.\n    zeroOutLights(map);\n    if (!map.staticLightChanged) {\n        restoreGlowLights(map);\n    }\n    else {\n        // GW.debug.log('painting glow lights.');\n        // Paint all glowing tiles.\n        map.eachStaticLight((light, x, y) => {\n            //   const light = lights[id];\n            if (light) {\n                light.paint(map, x, y);\n            }\n        });\n        recordGlowLights(map);\n        map.staticLightChanged = false;\n    }\n    // Cycle through monsters and paint their lights:\n    map.eachDynamicLight((light, x, y) => {\n        light.paint(map, x, y);\n        // if (monst.mutationIndex >= 0 && mutationCatalog[monst.mutationIndex].light != lights['NO_LIGHT']) {\n        //     paint(map, mutationCatalog[monst.mutationIndex].light, actor.x, actor.y, false, false);\n        // }\n        // if (actor.isBurning()) { // monst.status.burning && !(actor.kind.flags & Flags.Actor.AF_FIERY)) {\n        // \tpaint(map, lights.BURNING_CREATURE, actor.x, actor.y, false, false);\n        // }\n        // if (actor.isTelepathicallyRevealed()) {\n        // \tpaint(map, lights['TELEPATHY_LIGHT'], actor.x, actor.y, false, true);\n        // }\n    });\n    // Also paint telepathy lights for dormant monsters.\n    // for (monst of map.dormantMonsters) {\n    //     if (monsterTelepathicallyRevealed(monst)) {\n    //         paint(map, lights['TELEPATHY_LIGHT'], monst.xLoc, monst.yLoc, false, true);\n    //     }\n    // }\n    updateDisplayDetail(map);\n    // Miner's light:\n    const PLAYER = DATA.player;\n    if (PLAYER) {\n        const PLAYERS_LIGHT = lights.PLAYERS_LIGHT;\n        if (PLAYERS_LIGHT && PLAYERS_LIGHT.radius) {\n            PLAYERS_LIGHT.paint(map, PLAYER.x, PLAYER.y, true, true);\n        }\n    }\n    map.anyLightChanged = false;\n    // if (PLAYER.status.invisible) {\n    //     PLAYER.info.foreColor = playerInvisibleColor;\n    // } else if (playerInDarkness()) {\n    // \tPLAYER.info.foreColor = playerInDarknessColor;\n    // } else if (pmap[PLAYER.xLoc][PLAYER.yLoc].flags & IS_IN_SHADOW) {\n    // \tPLAYER.info.foreColor = playerInShadowColor;\n    // } else {\n    // \tPLAYER.info.foreColor = playerInLightColor;\n    // }\n    return true;\n}\n// TODO - Move?\nexport function playerInDarkness(map, PLAYER, darkColor) {\n    const cell = map.cell(PLAYER.x, PLAYER.y);\n    return cell.isDark(darkColor);\n    // return (\n    //   cell.light[0] + 10 < darkColor.r &&\n    //   cell.light[1] + 10 < darkColor.g &&\n    //   cell.light[2] + 10 < darkColor.b\n    // );\n}\n","import * as GW from \"gw-utils\";\nimport { Layer as Flags, Depth } from \"./flags\";\nimport * as Light from \"./light\";\nexport { Flags, Depth };\nexport class Layer {\n    constructor(config) {\n        this.priority = 50;\n        this.depth = 0;\n        this.light = null;\n        this.flags = { layer: 0 };\n        this.sprite = GW.make.sprite(config.sprite || config);\n        this.light = config.light ? Light.make(config.light) : null;\n        this.priority = GW.utils.first(config.priority, 50);\n        this.depth =\n            (config.depth && typeof config.depth !== \"number\"\n                ? Depth[config.depth]\n                : config.depth) || 0;\n        // @ts-ignore\n        this.flags.layer = GW.flag.from(Flags, config.layerFlags, config.flags, 0);\n    }\n}\nexport function make(config) {\n    return new Layer(config);\n}\nGW.make.layer = make;\n","import { utils as Utils, random, grid as Grid, events as Events, color as Color, flag as Flag, data as Data, message as Msg, make as Make, } from \"gw-utils\";\nimport { Depth, Activation as Flags, Tile as TileFlags, CellMech as CellMechFlags, Layer as LayerFlags, } from \"./flags\";\nimport * as Tile from \"./tile\";\nexport { Flags };\nexport class TileEvent {\n    constructor(opts = {}) {\n        if (typeof opts === \"function\") {\n            opts = {\n                fn: opts,\n            };\n        }\n        this.tile = opts.tile || null;\n        this.fn = opts.fn || null;\n        this.item = opts.item || null;\n        this.chance = opts.chance || 0;\n        this.volume = opts.volume || 0;\n        // spawning pattern:\n        this.spread = opts.spread || 0;\n        this.radius = opts.radius || 0;\n        this.decrement = opts.decrement || 0;\n        this.flags = Flag.from(Flags, opts.flags);\n        this.matchTile = opts.matchTile || opts.needs || 0; /* ENUM tileType */\n        this.next = opts.next || null; /* ENUM makeEventTypes */\n        this.message = opts.message || null;\n        this.lightFlare = opts.flare || null;\n        this.flashColor = opts.flash ? Color.from(opts.flash) : null;\n        // this.effectRadius = radius || 0;\n        this.messageDisplayed = false;\n        this.emit = opts.emit || null; // name of the event to emit when activated\n        this.id = opts.id || null;\n    }\n}\nexport function make(opts) {\n    if (!opts)\n        return null;\n    if (typeof opts === \"string\") {\n        opts = { tile: opts };\n    }\n    const te = new TileEvent(opts);\n    return te;\n}\nMake.tileEvent = make;\nexport const activations = {};\nexport function install(id, event) {\n    if (!(event instanceof TileEvent)) {\n        event = make(event);\n    }\n    activations[id] = event;\n    if (event)\n        event.id = id;\n    return event;\n}\nexport function installAll(events) {\n    Object.entries(events).forEach(([id, config]) => {\n        install(id, config);\n    });\n}\nexport function resetAllMessages() {\n    Object.values(activations).forEach((f) => {\n        if (f instanceof TileEvent) {\n            f.messageDisplayed = false;\n        }\n    });\n}\n// returns whether the feature was successfully generated (false if we aborted because of blocking)\nexport async function spawn(activation, ctx = {}) {\n    let i, j;\n    if (!activation)\n        Utils.ERROR(\"No activation.\");\n    if (!ctx)\n        Utils.ERROR(\"Context required - and must include map, x, y\");\n    let feat;\n    if (typeof activation === \"string\") {\n        // @ts-ignore\n        feat = activations[activation];\n        if (!feat)\n            Utils.ERROR(\"Unknown tile Event: \" + activation);\n    }\n    else if (typeof activation === \"function\") {\n        return activation(ctx);\n    }\n    else {\n        feat = activation;\n    }\n    const map = ctx.map;\n    const x = ctx.x;\n    const y = ctx.y;\n    if (x === undefined || y === undefined || !map) {\n        Utils.ERROR(\"MAP, x, y are required in context.\");\n    }\n    if (ctx.safe &&\n        map.hasCellMechFlag(x, y, CellMechFlags.EVENT_FIRED_THIS_TURN)) {\n        if (!(feat.flags & Flags.DFF_ALWAYS_FIRE)) {\n            // Activation.debug('spawn - already fired.');\n            return false;\n        }\n    }\n    // Activation.debug('spawn', x, y, 'id=', feat.id, 'tile=', feat.tile, 'item=', feat.item);\n    ctx.refreshCell = ctx.refreshCell || !(feat.flags & Flags.DFF_NO_REDRAW_CELL);\n    const abortIfBlocking = (ctx.abortIfBlocking =\n        ctx.abortIfBlocking || feat.flags & Flags.DFF_ABORT_IF_BLOCKS_MAP);\n    // if ((feat.flags & DFF_RESURRECT_ALLY) && !resurrectAlly(x, y))\n    // {\n    //     return false;\n    // }\n    if (feat.message &&\n        feat.message.length &&\n        !feat.messageDisplayed &&\n        map.isVisible(x, y)) {\n        feat.messageDisplayed = true;\n        Msg.add(feat.message);\n    }\n    let tile = null;\n    if (feat.tile) {\n        tile = Tile.tiles[feat.tile] || null;\n        if (!tile) {\n            Utils.ERROR(\"Unknown tile: \" + feat.tile);\n        }\n    }\n    let item = null;\n    if (feat.item && \"item\" in Make) {\n        item = Make.item(feat.item);\n        if (!item) {\n            Utils.ERROR(\"Unknown item: \" + feat.item);\n        }\n    }\n    // Blocking keeps track of whether to abort if it turns out that the DF would obstruct the level.\n    const blocking = (ctx.blocking =\n        abortIfBlocking &&\n            !(feat.flags & Flags.DFF_PERMIT_BLOCKING) &&\n            ((tile && tile.blocksPathing()) ||\n                (item && item.blocksMove()) ||\n                feat.flags & Flags.DFF_TREAT_AS_BLOCKING)\n            ? true\n            : false);\n    // Activation.debug('- blocking', blocking);\n    const spawnMap = Grid.alloc(map.width, map.height);\n    let didSomething = false;\n    computeSpawnMap(feat, spawnMap, ctx);\n    if (!blocking ||\n        !map.gridDisruptsPassability(spawnMap, { bounds: ctx.bounds })) {\n        if (feat.flags & Flags.DFF_EVACUATE_CREATURES) {\n            // first, evacuate creatures, so that they do not re-trigger the tile.\n            if (evacuateCreatures(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (feat.flags & Flags.DFF_EVACUATE_ITEMS) {\n            // first, evacuate items, so that they do not re-trigger the tile.\n            if (evacuateItems(map, spawnMap)) {\n                didSomething = true;\n            }\n        }\n        if (feat.flags & Flags.DFF_NULLIFY_CELL) {\n            // first, clear other tiles (not base/ground)\n            if (nullifyCells(map, spawnMap, feat.flags)) {\n                didSomething = true;\n            }\n        }\n        if (tile || item || feat.fn) {\n            if (await spawnTiles(feat, spawnMap, ctx, tile, item)) {\n                didSomething = true;\n            }\n        }\n    }\n    if (item) {\n        item.delete();\n    }\n    if (didSomething && feat.flags & Flags.DFF_PROTECTED) {\n        spawnMap.forEach((v, i, j) => {\n            if (!v)\n                return;\n            const cell = map.cell(i, j);\n            cell.mechFlags |= CellMechFlags.EVENT_PROTECTED;\n        });\n    }\n    if (didSomething) {\n        // if ((feat.flags & Flags.DFF_AGGRAVATES_MONSTERS) && feat.effectRadius) {\n        //     await aggravateMonsters(feat.effectRadius, x, y, /* Color. */gray);\n        // }\n        // if (refreshCell && feat.flashColor && feat.effectRadius) {\n        //     await colorFlash(feat.flashColor, 0, (IN_FOV | CLAIRVOYANT_VISIBLE), 4, feat.effectRadius, x, y);\n        // }\n        // if (refreshCell && feat.lightFlare) {\n        //     createFlare(x, y, feat.lightFlare);\n        // }\n    }\n    // if (refreshCell && feat.tile\n    // \t&& (tile.flags & (TileFlags.T_IS_FIRE | TileFlags.T_AUTO_DESCENT))\n    // \t&& map.hasTileFlag(PLAYER.xLoc, PLAYER.yLoc, (TileFlags.T_IS_FIRE | TileFlags.T_AUTO_DESCENT)))\n    // {\n    // \tawait applyInstantTileEffectsToCreature(PLAYER);\n    // }\n    // apply tile effects\n    if (didSomething) {\n        for (let i = 0; i < spawnMap.width; ++i) {\n            for (let j = 0; j < spawnMap.height; ++j) {\n                const v = spawnMap[i][j];\n                if (!v || Data.gameHasEnded)\n                    continue;\n                const cell = map.cell(i, j);\n                if (cell.actor || cell.item) {\n                    await cell.activate(\"enter\", { map, x: i, y: j, cell });\n                }\n            }\n        }\n    }\n    if (feat.emit) {\n        await Events.emit(feat.emit, ctx);\n        didSomething = true;\n    }\n    if (Data.gameHasEnded) {\n        Grid.free(spawnMap);\n        return didSomething;\n    }\n    //\tif (succeeded && feat.message[0] && !feat.messageDisplayed && isVisible(x, y)) {\n    //\t\tfeat.messageDisplayed = true;\n    //\t\tmessage(feat.message, false);\n    //\t}\n    if (feat.next && (didSomething || feat.flags & Flags.DFF_SUBSEQ_ALWAYS)) {\n        // Activation.debug('- subsequent: %s, everywhere=%s', feat.next, feat.flags & Flags.DFF_SUBSEQ_EVERYWHERE);\n        if (feat.flags & Flags.DFF_SUBSEQ_EVERYWHERE) {\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j]) {\n                        ctx.x = i;\n                        ctx.y = j;\n                        await spawn(feat.next, ctx);\n                    }\n                }\n            }\n            ctx.x = x;\n            ctx.y = y;\n        }\n        else {\n            await spawn(feat.next, ctx);\n        }\n    }\n    if (didSomething) {\n        if (tile &&\n            tile.flags.tile &\n                (TileFlags.T_DEEP_WATER | TileFlags.T_LAVA | TileFlags.T_AUTO_DESCENT)) {\n            Data.updateMapToShoreThisTurn = false;\n        }\n        // awaken dormant creatures?\n        // if (feat.flags & Flags.DFF_ACTIVATE_DORMANT_MONSTER) {\n        //     for (monst of map.dormant) {\n        //         if (monst.x == x && monst.y == y || spawnMap[monst.x][monst.y]) {\n        //             // found it!\n        //             toggleMonsterDormancy(monst);\n        //         }\n        //     }\n        // }\n    }\n    if (didSomething) {\n        spawnMap.forEach((v, i, j) => {\n            if (v)\n                map.redrawXY(i, j);\n        });\n        map.changed = true;\n        if (!(feat.flags & Flags.DFF_NO_MARK_FIRED)) {\n            spawnMap.forEach((v, i, j) => {\n                if (v) {\n                    map.setCellFlags(i, j, 0, CellMechFlags.EVENT_FIRED_THIS_TURN);\n                }\n            });\n        }\n    }\n    // Activation.debug('- spawn complete : @%d,%d, ok=%s, feat=%s', ctx.x, ctx.y, didSomething, feat.id);\n    Grid.free(spawnMap);\n    return didSomething;\n}\nfunction cellIsOk(feat, x, y, ctx = {}) {\n    const map = ctx.map;\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (feat.flags & Flags.DFF_BUILD_IN_WALLS) {\n        if (!cell.isWall())\n            return false;\n    }\n    else if (feat.flags & Flags.DFF_MUST_TOUCH_WALLS) {\n        let ok = false;\n        map.eachNeighbor(x, y, (c) => {\n            if (c.isWall()) {\n                ok = true;\n            }\n        });\n        if (!ok)\n            return false;\n    }\n    else if (feat.flags & Flags.DFF_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (cell.isWall())\n            return false; // or on wall\n        map.eachNeighbor(x, y, (c) => {\n            if (c.isWall()) {\n                ok = false;\n            }\n        });\n        if (!ok)\n            return false;\n    }\n    if (ctx.bounds && !ctx.bounds.containsXY(x, y))\n        return false;\n    if (feat.matchTile && !cell.hasTile(feat.matchTile))\n        return false;\n    if (cell.hasLayerFlag(LayerFlags.L_BLOCKS_EFFECTS) &&\n        !feat.matchTile &&\n        (ctx.x != x || ctx.y != y)) {\n        return false;\n    }\n    return true;\n}\nexport function computeSpawnMap(feat, spawnMap, ctx = {}) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    const map = ctx.map;\n    const x = ctx.x;\n    const y = ctx.y;\n    const bounds = ctx.bounds || null;\n    if (bounds) {\n        // Activation.debug('- bounds', bounds);\n    }\n    let startProb = feat.spread || 0;\n    let probDec = feat.decrement || 0;\n    if (feat.matchTile && typeof feat.matchTile === \"string\") {\n        const name = feat.matchTile;\n        const tile = Tile.tiles[name];\n        if (!tile) {\n            Utils.ERROR(\"Failed to find match tile with name:\" + name);\n        }\n        feat.matchTile = tile.id;\n    }\n    spawnMap.fill(0);\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let radius = feat.radius || 0;\n    if (feat.flags & Flags.DFF_SPREAD_CIRCLE) {\n        radius = 0;\n        startProb = startProb || 100;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        while (random.chance(startProb)) {\n            startProb -= probDec;\n            ++radius;\n        }\n        startProb = 100;\n        probDec = 0;\n    }\n    if (radius) {\n        startProb = startProb || 100;\n        spawnMap.updateCircle(x, y, radius, (_v, i, j) => {\n            if (!cellIsOk(feat, i, j, ctx))\n                return 0;\n            const dist = Math.floor(Utils.distanceBetween(x, y, i, j));\n            const prob = startProb - dist * probDec;\n            if (!random.chance(prob))\n                return 0;\n            return 1;\n        });\n        spawnMap[x][y] = 1;\n    }\n    else if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (feat.flags & Flags.DFF_SPREAD_LINE) {\n            x2 = x;\n            y2 = y;\n            const dir = Utils.DIRS[random.number(4)];\n            while (madeChange) {\n                madeChange = false;\n                x2 = x2 + dir[0];\n                y2 = y2 + dir[1];\n                if (spawnMap.hasXY(x2, y2) &&\n                    !spawnMap[x2][y2] &&\n                    cellIsOk(feat, x2, y2, ctx) &&\n                    random.chance(startProb)) {\n                    spawnMap[x2][y2] = 1;\n                    madeChange = true;\n                    startProb -= probDec;\n                }\n            }\n        }\n        else {\n            if (probDec <= 0)\n                probDec = startProb;\n            while (madeChange && startProb > 0) {\n                madeChange = false;\n                t++;\n                for (i = 0; i < map.width; i++) {\n                    for (j = 0; j < map.height; j++) {\n                        if (spawnMap[i][j] == t - 1) {\n                            for (dir = 0; dir < 4; dir++) {\n                                x2 = i + Utils.DIRS[dir][0];\n                                y2 = j + Utils.DIRS[dir][1];\n                                if (spawnMap.hasXY(x2, y2) &&\n                                    !spawnMap[x2][y2] &&\n                                    cellIsOk(feat, x2, y2, ctx) &&\n                                    random.chance(startProb)) {\n                                    spawnMap[x2][y2] = t;\n                                    madeChange = true;\n                                }\n                            }\n                        }\n                    }\n                }\n                startProb -= probDec;\n            }\n        }\n    }\n    if (!cellIsOk(feat, x, y, ctx)) {\n        spawnMap[x][y] = 0;\n    }\n}\nexport async function spawnTiles(feat, spawnMap, ctx, tile, item) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = feat.flags & Flags.DFF_BLOCKED_BY_OTHER_LAYERS;\n    const superpriority = feat.flags & Flags.DFF_SUPERPRIORITY;\n    const applyEffects = ctx.refreshCell;\n    const map = ctx.map;\n    const volume = ctx.volume || feat.volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.mechFlags & CellMechFlags.EVENT_PROTECTED)\n                continue;\n            if (tile) {\n                if (cell.tile(tile.depth) === tile) {\n                    // If the new cell already contains the fill terrain,\n                    if (tile.depth == Depth.GAS) {\n                        spawnMap[i][j] = 1;\n                        cell.gasVolume += volume;\n                    }\n                    else if (tile.depth == Depth.LIQUID) {\n                        spawnMap[i][j] = 1;\n                        cell.liquidVolume += volume;\n                    }\n                }\n                else if ((superpriority || cell.tile(tile.depth).priority < tile.priority) && // If the terrain in the layer to be overwritten has a higher priority number (unless superpriority),\n                    !cell.obstructsLayer(tile.depth) && // If we will be painting into the surface layer when that cell forbids it,\n                    (!cell.item || !(feat.flags & Flags.DFF_BLOCKED_BY_ITEMS)) &&\n                    (!cell.actor || !(feat.flags & Flags.DFF_BLOCKED_BY_ACTORS)) &&\n                    (!blockedByOtherLayers || cell.topmostTile().priority < tile.priority)) {\n                    // if the fill won't violate the priority of the most important terrain in this cell:\n                    spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                    map.setTile(i, j, tile, volume);\n                    // map.redrawCell(cell);\n                    // if (volume && cell.gas) {\n                    //     cell.volume += (feat.volume || 0);\n                    // }\n                    // debug('- tile', i, j, 'tile=', tile.id);\n                    // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                    accomplishedSomething = true;\n                }\n            }\n            if (item) {\n                if (superpriority || !cell.item) {\n                    if (!cell.hasLayerFlag(LayerFlags.L_BLOCKS_ITEMS)) {\n                        spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                        if (cell.item) {\n                            map.removeItem(cell.item);\n                        }\n                        const clone = item.clone();\n                        map.addItem(i, j, clone);\n                        // map.redrawCell(cell);\n                        // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                        accomplishedSomething = true;\n                        // Activation.debug('- item', i, j, 'item=', itemKind.id);\n                    }\n                }\n            }\n            if (feat.fn) {\n                ctx.spawnMap = spawnMap;\n                if (await feat.fn(i, j, ctx)) {\n                    spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                    // map.redrawCell(cell);\n                    // cell.mechFlags |= CellMechFlags.EVENT_FIRED_THIS_TURN;\n                    accomplishedSomething = true;\n                }\n            }\n            if (applyEffects) {\n                // if (PLAYER.xLoc == i && PLAYER.yLoc == j && !PLAYER.status.levitating && refresh) {\n                // \tflavorMessage(tileFlavor(PLAYER.xLoc, PLAYER.yLoc));\n                // }\n                // if (cell.actor || cell.item) {\n                // \tfor(let t of cell.tiles()) {\n                // \t\tawait t.applyInstantEffects(map, i, j, cell);\n                // \t\tif (Data.gameHasEnded) {\n                // \t\t\treturn true;\n                // \t\t}\n                // \t}\n                // }\n                // if (tile.flags & TileFlags.T_IS_FIRE) {\n                // \tif (cell.flags & CellFlags.HAS_ITEM) {\n                // \t\ttheItem = map.itemAt(i, j);\n                // \t\tif (theItem.flags & Flags.Item.ITEM_FLAMMABLE) {\n                // \t\t\tawait burnItem(theItem);\n                // \t\t}\n                // \t}\n                // }\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.changed = true;\n    }\n    return accomplishedSomething;\n}\nexport function nullifyCells(map, spawnMap, flags) {\n    let didSomething = false;\n    const nullSurface = flags & Flags.DFF_NULL_SURFACE;\n    const nullLiquid = flags & Flags.DFF_NULL_LIQUID;\n    const nullGas = flags & Flags.DFF_NULL_GAS;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        map.clearCellLayers(i, j, !!nullLiquid, !!nullSurface, !!nullGas);\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let i, j;\n    let didSomething = false;\n    for (i = 0; i < map.width; i++) {\n        for (j = 0; j < map.height; j++) {\n            if (!blockingMap[i][j])\n                continue;\n            const cell = map.cell(i, j);\n            if (!cell.actor)\n                continue;\n            const monst = cell.actor;\n            const loc = map.matchingLocNear(i, j, (cell) => {\n                return !monst.forbidsCell(cell);\n            }, { hallways: true, blockingMap });\n            if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                map.moveActor(loc[0], loc[1], monst);\n                // map.redrawXY(loc[0], loc[1]);\n                didSomething = true;\n            }\n        }\n    }\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    blockingMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (!cell.item)\n            return;\n        const item = cell.item;\n        const loc = map.matchingLocNear(i, j, (dest) => {\n            return !item.forbidsCell(dest);\n        }, { hallways: true, blockingMap });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(item);\n            map.addItem(loc[0], loc[1], item);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\n","import { flag as Flag, utils as Utils, color as Color, make as Make, } from \"gw-utils\";\nimport { Tile as Flags, TileMech as MechFlags } from \"./flags\";\nimport * as TileEvent from \"./tileEvent\";\nimport * as Layer from \"./layer\";\nexport { Flags, MechFlags };\n/** Tile Class */\nexport class Tile extends Layer.Layer {\n    /**\n     * Creates a new Tile object.\n     * @param {Object} [config={}] - The configuration of the Tile\n     * @param {String|Number|String[]} [config.flags=0] - Flags and MechFlags for the tile\n     * @param {String} [config.layer=GROUND] - Name of the layer for this tile\n     * @param {String} [config.ch] - The sprite character\n     * @param {String} [config.fg] - The sprite foreground color\n     * @param {String} [config.bg] - The sprite background color\n     */\n    constructor(config) {\n        super((() => {\n            if (!config.Extends)\n                return config;\n            if (typeof config.Extends === \"string\") {\n                config.Extends = tiles[config.Extends];\n                if (!config.Extends)\n                    throw new Error(\"Unknown tile base - \" + config.Extends);\n            }\n            const base = config.Extends;\n            config.ch = Utils.first(config.ch, base.sprite.ch, -1);\n            config.fg = Utils.first(config.fg, base.sprite.fg, -1);\n            config.bg = Utils.first(config.bg, base.sprite.bg, -1);\n            config.depth = Utils.first(config.depth, base.depth);\n            config.priority = Utils.first(config.priority, base.priority);\n            config.opacity = Utils.first(config.opacity, base.sprite.opacity);\n            config.light = Utils.first(config.light, base.light);\n            return config;\n        })());\n        this.flags = { layer: 0, tile: 0, tileMech: 0 };\n        this.activates = {};\n        this.flavor = null;\n        this.desc = null;\n        this.article = null;\n        this.dissipate = 2000; // 20 * 100 = 20%\n        this.defaultGround = null;\n        let base = config.Extends;\n        if (base) {\n            Utils.assignOmitting([\"sprite\", \"depth\", \"priority\", \"activates\", \"flags\", \"light\"], this, base);\n            if (base.activates) {\n                Object.assign(this.activates, base.activates);\n            }\n            Object.assign(this.flags, base.flags);\n        }\n        Utils.assignOmitting([\n            \"Extends\",\n            \"extends\",\n            \"flags\",\n            \"layerFlags\",\n            \"mechFlags\",\n            \"sprite\",\n            \"activates\",\n            \"ch\",\n            \"fg\",\n            \"bg\",\n            \"opacity\",\n            \"light\",\n            \"depth\",\n            \"priority\",\n            \"flags\",\n            \"ground\",\n            \"light\",\n        ], this, config);\n        this.name = config.name || (base ? base.name : config.id);\n        this.id = config.id;\n        if (config.ground) {\n            this.defaultGround = config.ground;\n        }\n        // @ts-ignore\n        this.flags.tile = Flag.from(Flags, this.flags.tile, config.flags);\n        // @ts-ignore\n        this.flags.layer = Flag.from(Layer.Flags, this.flags.layer, config.layerFlags || config.flags);\n        // @ts-ignore\n        this.flags.tileMech = Flag.from(MechFlags, this.flags.tileMech, config.mechFlags || config.flags);\n        if (config.activates) {\n            Object.entries(config.activates).forEach(([key, info]) => {\n                if (info) {\n                    const activation = TileEvent.make(info);\n                    this.activates[key] = activation;\n                }\n                else {\n                    delete this.activates[key];\n                }\n            });\n        }\n    }\n    /**\n     * Returns whether or not this tile as the given flag.\n     * Will return true if any bit in the flag is true, so testing with\n     * multiple flags will return true if any of them is set.\n     * @param {number} flag - The flag to check\n     * @returns {boolean} Whether or not the flag is set\n     */\n    hasAllFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllLayerFlags(flag) {\n        return (this.flags.layer & flag) === flag;\n    }\n    hasAllMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksPathing() {\n        return (this.flags.layer & Layer.Flags.L_BLOCKS_MOVE ||\n            this.flags.tile & Flags.T_PATHING_BLOCKER);\n    }\n    activatesOn(name) {\n        return !!this.activates[name];\n    }\n    getName(arg) {\n        let opts = {};\n        if (arg === true || arg === false) {\n            opts.article = arg;\n        }\n        else if (typeof arg === \"string\") {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || \"white\";\n            }\n            if (typeof color !== \"string\") {\n                color = Color.from(color).toString();\n            }\n            result = `${color}${this.name}`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === \"string\" ? opts.article : this.article || \"a\";\n            result = article + \" \" + result;\n        }\n        return result;\n    }\n    getDescription(opts = {}) {\n        return this.getName(opts);\n    }\n}\n// Types.Tile = Tile;\nexport function make(config) {\n    return new Tile(config);\n}\nMake.tile = make;\nexport const tiles = {};\nexport function install(...args) {\n    let id = args[0];\n    let base = args[1];\n    let config = args[2];\n    if (arguments.length == 1) {\n        config = args[0];\n        base = config.Extends || null;\n        id = config.id;\n    }\n    else if (arguments.length == 2) {\n        config = base;\n    }\n    if (typeof base === \"string\") {\n        config.Extends = tiles[base] || Utils.ERROR(\"Unknown base tile: \" + base);\n    }\n    // config.name = config.name || base.name || id.toLowerCase();\n    config.id = id;\n    const tile = make(config);\n    tiles[id] = tile;\n    return tile;\n}\n/**\n * Adds multiple tiles to the GW.tiles collection.\n * It extracts all the id:opts pairs from the config object and uses\n * them to call addTileKind.\n * @param {Object} config - The tiles to add in [id, config] pairs\n * @returns {void} Nothing\n * @see addTileKind\n */\nexport function installAll(config) {\n    Object.entries(config).forEach(([id, opts]) => {\n        opts.id = id;\n        install(id, opts);\n    });\n}\n","import { color as Color, canvas as Canvas, utils as Utils, config as CONFIG, data as DATA, random, make as Make, } from \"gw-utils\";\nimport { Tile, tiles as TILES } from \"./tile\";\nimport * as Activation from \"./tileEvent\";\nimport * as Light from \"./light\";\nimport * as Layer from \"./layer\";\nimport { Cell as Flags, CellMech as MechFlags, TileMech as TileMechFlags, Tile as TileFlags, Map as MapFlags, Layer as LayerFlags, Depth, } from \"./flags\";\nexport { Flags, MechFlags };\n// TODO - Move to gw-ui\nColor.install(\"cursorColor\", 25, 100, 150);\nCONFIG.cursorPathIntensity = 50;\nexport class CellMemory {\n    constructor() {\n        this.mixer = new Canvas.Mixer();\n        this.item = null;\n        this.itemQuantity = 0;\n        this.actor = null;\n        this.tile = null;\n        this.cellFlags = 0;\n        this.cellMechFlags = 0;\n        this.layerFlags = 0;\n        this.tileFlags = 0;\n        this.tileMechFlags = 0;\n    }\n    clear() {\n        this.mixer.nullify();\n        this.item = null;\n        this.itemQuantity = 0;\n        this.actor = null;\n        this.tile = null;\n        this.cellFlags = 0;\n        this.cellMechFlags = 0;\n        this.layerFlags = 0;\n        this.tileFlags = 0;\n        this.tileMechFlags = 0;\n    }\n    copy(other) {\n        const mixer = this.mixer;\n        Object.assign(this, other);\n        this.mixer = mixer;\n        this.mixer.copy(other.mixer);\n    }\n}\nexport class Cell {\n    constructor() {\n        this._tiles = [];\n        this.layers = null;\n        this._actor = null;\n        this._item = null;\n        this.data = {};\n        this.flags = Flags.CELL_DEFAULT; // non-terrain cell flags\n        this.mechFlags = 0;\n        this.gasVolume = 0; // quantity of gas in cell\n        this.liquidVolume = 0;\n        this.machineNumber = 0;\n        this.memory = new CellMemory();\n        this.light = [100, 100, 100];\n        this.oldLight = [100, 100, 100];\n        this.glowLight = [100, 100, 100];\n    }\n    copy(other) {\n        Utils.copyObject(this, other);\n    }\n    clear() {\n        for (let i = 0; i < this._tiles.length; ++i) {\n            this._tiles[i] = null;\n        }\n        this.layers = null;\n        this._actor = null;\n        this._item = null;\n        this.data = {};\n        this.flags = Flags.CELL_DEFAULT; // non-terrain cell flags\n        this.mechFlags = 0;\n        this.gasVolume = 0; // quantity of gas in cell\n        this.liquidVolume = 0;\n        this.machineNumber = 0;\n        this.memory.clear();\n        this.light = [100, 100, 100];\n        this.oldLight = [100, 100, 100];\n        this.glowLight = [100, 100, 100];\n    }\n    clearLayers(nullLiquid = false, nullSurface = false, nullGas = false) {\n        if (nullLiquid) {\n            this._tiles[1] = null;\n            this.liquidVolume = 0;\n        }\n        if (nullSurface) {\n            this._tiles[2] = null;\n        }\n        if (nullGas) {\n            this._tiles[3] = null;\n            this.gasVolume = 0;\n        }\n        this.flags |= Flags.CELL_CHANGED;\n    }\n    get ground() {\n        var _a;\n        return ((_a = this._tiles[Depth.GROUND]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get liquid() {\n        var _a;\n        return ((_a = this._tiles[Depth.LIQUID]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get surface() {\n        var _a;\n        return ((_a = this._tiles[Depth.SURFACE]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get gas() {\n        var _a;\n        return ((_a = this._tiles[Depth.GAS]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get groundTile() {\n        return this._tiles[Depth.GROUND] || TILES.NULL;\n    }\n    get liquidTile() {\n        return this._tiles[Depth.LIQUID] || TILES.NULL;\n    }\n    get surfaceTile() {\n        return this._tiles[Depth.SURFACE] || TILES.NULL;\n    }\n    get gasTile() {\n        return this._tiles[Depth.GAS] || TILES.NULL;\n    }\n    dump() {\n        if (this.actor)\n            return this.actor.sprite.ch;\n        if (this.item)\n            return this.item.sprite.ch;\n        for (let i = this._tiles.length - 1; i >= 0; --i) {\n            if (!this._tiles[i])\n                continue;\n            const tile = this._tiles[i] || TILES.NULL;\n            if (tile.sprite.ch)\n                return tile.sprite.ch;\n        }\n        return TILES.NULL.sprite.ch;\n    }\n    get changed() {\n        return (this.flags & Flags.CELL_CHANGED) > 0;\n    }\n    set changed(v) {\n        if (v) {\n            this.flags |= Flags.CELL_CHANGED;\n        }\n        else {\n            this.flags &= ~Flags.CELL_CHANGED;\n        }\n    }\n    isVisible() {\n        return this.flags & Flags.VISIBLE;\n    }\n    isAnyKindOfVisible() {\n        return (this.flags & Flags.ANY_KIND_OF_VISIBLE /* || CONFIG.playbackOmniscience */);\n    }\n    isOrWasAnyKindOfVisible() {\n        return (this.flags &\n            Flags.IS_WAS_ANY_KIND_OF_VISIBLE /* || CONFIG.playbackOmniscience */);\n    }\n    isRevealed(orMapped = false) {\n        const flag = Flags.REVEALED | (orMapped ? Flags.MAGIC_MAPPED : 0);\n        return (this.flags & flag) > 0;\n    }\n    listInSidebar() {\n        return this.hasTileMechFlag(TileMechFlags.TM_LIST_IN_SIDEBAR, true);\n    }\n    get needsRedraw() {\n        return (this.flags & Flags.NEEDS_REDRAW) > 0;\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags |= Flags.NEEDS_REDRAW;\n        }\n        else {\n            this.flags &= ~Flags.NEEDS_REDRAW;\n        }\n    }\n    // TODO - Use functions in LIGHT to check these on cell.light directly???\n    hasVisibleLight() {\n        return Light.intensity(this.light) > CONFIG.light.INTENSITY_DARK;\n    } // TODO\n    isDark(darkColor) {\n        const intensity = darkColor\n            ? Light.intensity(darkColor)\n            : CONFIG.light.INTENSITY_DARK;\n        return Light.intensity(this.light) <= intensity;\n    } // TODO\n    get lightChanged() {\n        return (this.flags & Flags.LIGHT_CHANGED) > 0;\n    }\n    set lightChanged(v) {\n        if (v) {\n            this.flags |= Flags.LIGHT_CHANGED | Flags.NEEDS_REDRAW;\n        }\n        else {\n            this.flags &= ~Flags.LIGHT_CHANGED;\n        }\n    }\n    tile(layer = Depth.GROUND) {\n        return this._tiles[layer] || TILES.NULL;\n    }\n    *tiles() {\n        for (let tile of this._tiles) {\n            if (tile) {\n                yield tile;\n            }\n        }\n    }\n    layerFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.layerFlags;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.layer;\n        }\n        return flags;\n    }\n    tileFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.tileFlags;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.tile;\n        }\n        return flags;\n    }\n    tileMechFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.tileMechFlags;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.tileMech;\n        }\n        return flags;\n    }\n    hasLayerFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = this.layerFlags(limitToPlayerKnowledge);\n        return !!(flag & flags);\n    }\n    hasAllLayerFlags(flag, limitToPlayerKnowledge = false) {\n        const flags = this.layerFlags(limitToPlayerKnowledge);\n        return (flag & flags) === flag;\n    }\n    hasTileFlag(flagMask, limitToPlayerKnowledge = false) {\n        const tileFlags = this.tileFlags(limitToPlayerKnowledge);\n        return !!(flagMask & tileFlags);\n    }\n    hasAllTileFlags(flags, limitToPlayerKnowledge = false) {\n        return (flags & this.tileFlags(limitToPlayerKnowledge)) === flags;\n    }\n    hasTileMechFlag(flagMask, limitToPlayerKnowledge = false) {\n        const mechFlags = this.tileMechFlags(limitToPlayerKnowledge);\n        return !!(flagMask & mechFlags);\n    }\n    hasAllTileMechFlags(flags, limitToPlayerKnowledge = false) {\n        return (flags & this.tileMechFlags(limitToPlayerKnowledge)) === flags;\n    }\n    setFlags(cellFlag = 0, cellMechFlag = 0) {\n        this.flags |= cellFlag;\n        this.mechFlags |= cellMechFlag;\n        // this.flags |= Flags.NEEDS_REDRAW;\n    }\n    clearFlags(cellFlag = 0, cellMechFlag = 0) {\n        this.flags &= ~cellFlag;\n        this.mechFlags &= ~cellMechFlag;\n        // if ((~cellFlag) & Flags.NEEDS_REDRAW) {\n        //   this.flags |= Flags.NEEDS_REDRAW;\n        // }\n    }\n    hasFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = limitToPlayerKnowledge && !this.isAnyKindOfVisible()\n            ? this.memory.cellFlags\n            : this.flags;\n        return (flag & flags) > 0;\n    }\n    hasMechFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = limitToPlayerKnowledge && !this.isAnyKindOfVisible()\n            ? this.memory.cellMechFlags\n            : this.mechFlags;\n        return (flag & flags) > 0;\n    }\n    hasTile(tile) {\n        let id;\n        if (tile instanceof Tile) {\n            id = tile.id;\n        }\n        else {\n            id = tile;\n        }\n        return this._tiles.some((t) => t && t.id === id);\n    }\n    // hasTileInGroup(...groups) {\n    //   if (groups.length == 1 && Array.isArray(groups[0])) {\n    //     groups = groups[0];\n    //   }\n    //   return this.layers.some( (tileId) => {\n    //     const tile = TILES[tileId] || TILES.NOTHING;\n    //     return Utils.intersect(groups, tile.groups);\n    //   });\n    // }\n    // promotedTileFlags() {\n    //   return this.successorTileFlags(\"promote\");\n    // }\n    // discoveredTileFlags() {\n    //   return this.successorTileFlags(\"discover\");\n    // }\n    // hasDiscoveredTileFlag(flag: number) {\n    //   // if (!this.hasTileMechFlag(TM_IS_SECRET)) return false;\n    //   return this.discoveredTileFlags() & flag;\n    // }\n    topmostTile(skipGas = false) {\n        let best = TILES.NULL;\n        let bestPriority = -10000;\n        for (let layer = Depth.GROUND; layer <= (skipGas ? Depth.LIQUID : Depth.GAS); ++layer) {\n            // @ts-ignore\n            const tile = this._tiles[layer];\n            if (!tile)\n                continue;\n            if (tile.priority > bestPriority) {\n                best = tile;\n                bestPriority = tile.priority;\n            }\n        }\n        return best;\n    }\n    tileWithFlag(tileFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags.tile & tileFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileWithMechFlag(mechFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags.tileMech & mechFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileDesc() {\n        return this.topmostTile().desc;\n    }\n    tileFlavor() {\n        return this.topmostTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.topmostTile().getName(opts);\n    }\n    isClear() {\n        return this.ground == null;\n    }\n    isEmpty() {\n        return !(this._actor || this._item);\n    }\n    isMoveableNow(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.layerFlags\n            : this.layerFlags(false);\n        return (layerFlags & LayerFlags.L_BLOCKS_MOVE) === 0;\n    }\n    isWalkableNow(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.layerFlags\n            : this.layerFlags(false);\n        if (layerFlags & LayerFlags.L_BLOCKS_MOVE)\n            return false;\n        const tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        if (!(tileFlags & TileFlags.T_IS_DEEP_LIQUID))\n            return true;\n        return (tileFlags & TileFlags.T_BRIDGE) > 0;\n    }\n    canBeWalked(limitToPlayerKnowledge = false) {\n        if (this.isWalkableNow(limitToPlayerKnowledge))\n            return true;\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.layerFlags\n            : this.layerFlags(false);\n        return (layerFlags & LayerFlags.L_SECRETLY_PASSABLE) > 0;\n    }\n    isWall(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory ? this.memory.layerFlags : this.layerFlags();\n        return (layerFlags & LayerFlags.L_IS_WALL) === LayerFlags.L_IS_WALL;\n    }\n    isObstruction(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory ? this.memory.layerFlags : this.layerFlags();\n        return !!(layerFlags & LayerFlags.L_BLOCKS_DIAGONAL);\n    }\n    isDoorway(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory ? this.memory.layerFlags : this.layerFlags();\n        return ((layerFlags & LayerFlags.L_BLOCKS_VISION) > 0 &&\n            (layerFlags & LayerFlags.L_BLOCKS_MOVE) === 0);\n    }\n    isSecretDoorway(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge)\n            return false;\n        const layerFlags = this.layerFlags(limitToPlayerKnowledge);\n        return (layerFlags & LayerFlags.L_SECRETLY_PASSABLE) > 0;\n    }\n    blocksPathing(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        if (!this.isWalkableNow(limitToPlayerKnowledge))\n            return true;\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_PATHING_BLOCKER);\n    }\n    blocksVision() {\n        const layerFlags = this.layerFlags();\n        return !!(layerFlags & LayerFlags.L_BLOCKS_VISION);\n    }\n    isLiquid(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_IS_DEEP_LIQUID);\n    }\n    // TODO - Should this look at the tiles instead of the flags?\n    // What if a gas tile is not set with T_GAS?\n    // Should we force T_GAS if layer === GAS when creating a tile?\n    hasGas(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.tileFlags : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_GAS);\n    }\n    markRevealed() {\n        this.flags &= ~Flags.STABLE_MEMORY;\n        if (this.flags & Flags.REVEALED)\n            return false;\n        this.flags |= Flags.REVEALED;\n        return !this.isWall();\n    }\n    obstructsLayer(depth) {\n        return (depth === Depth.SURFACE && this.hasLayerFlag(LayerFlags.L_BLOCKS_SURFACE));\n    }\n    setTile(tileId = null, volume = 0, map) {\n        map = map || DATA.map;\n        let tile;\n        if (tileId === null) {\n            tile = TILES.NULL;\n            tileId = null;\n        }\n        else if (typeof tileId === \"string\") {\n            tile = TILES[tileId];\n        }\n        else if (tileId instanceof Tile) {\n            tile = tileId;\n            tileId = tile.id;\n        }\n        if (!tile) {\n            return Utils.ERROR(\"Unknown tile - \" + tileId);\n        }\n        if (tile.depth > 0 && !this._tiles[0]) {\n            this.setTile(tile.defaultGround || TILES.FLOOR, 0, map); // TODO - do not use FLOOR?  Does map have the tile to use?\n        }\n        const oldTile = this._tiles[tile.depth] || TILES.NULL;\n        const oldTileId = oldTile === TILES.NULL ? null : oldTile.id;\n        if (oldTile.blocksPathing() != tile.blocksPathing()) {\n            DATA.staleLoopMap = true;\n        }\n        if (tile.flags.tile & TileFlags.T_IS_FIRE &&\n            !(oldTile.flags.tile & TileFlags.T_IS_FIRE)) {\n            this.mechFlags |= MechFlags.CAUGHT_FIRE_THIS_TURN;\n        }\n        const blocksVision = tile.flags.layer & LayerFlags.L_BLOCKS_VISION;\n        const oldBlocksVision = oldTile.flags.layer & LayerFlags.L_BLOCKS_VISION;\n        if (map && this.isAnyKindOfVisible() && blocksVision != oldBlocksVision) {\n            map.setFlag(MapFlags.MAP_FOV_CHANGED);\n        }\n        if (oldTileId !== null)\n            this.removeLayer(oldTile);\n        this._tiles[tile.depth] = tileId === null ? null : tile;\n        if (tileId !== null)\n            this.addLayer(tile);\n        if (tile.depth == Depth.LIQUID) {\n            this.liquidVolume =\n                volume + (tileId == oldTileId ? this.liquidVolume : 0);\n            if (map)\n                map.clearFlag(MapFlags.MAP_NO_LIQUID);\n        }\n        else if (tile.depth == Depth.GAS) {\n            this.gasVolume = volume + (tileId == oldTileId ? this.gasVolume : 0);\n            if (map)\n                map.clearFlag(MapFlags.MAP_NO_GAS);\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n        this.flags |= Flags.CELL_CHANGED | Flags.NEEDS_REDRAW;\n        if (map && oldTile.light !== tile.light) {\n            map.clearFlag(MapFlags.MAP_STABLE_GLOW_LIGHTS | MapFlags.MAP_STABLE_LIGHTS);\n        }\n        return true;\n    }\n    clearLayer(depth) {\n        // @ts-ignore\n        if (typeof depth === \"string\")\n            depth = Layer[depth];\n        const current = this._tiles[depth];\n        if (current) {\n            // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n            this.flags |= Flags.CELL_CHANGED;\n            this.removeLayer(current);\n        }\n        this._tiles[depth] = null;\n        if (depth == Depth.LIQUID) {\n            this.liquidVolume = 0;\n        }\n        else if (depth == Depth.GAS) {\n            this.gasVolume = 0;\n        }\n    }\n    clearLayersExcept(except = Depth.GROUND, ground) {\n        const floorTile = ground ? TILES[ground] : this.groundTile;\n        for (let layer = 0; layer < this._tiles.length; layer++) {\n            if (layer != except && layer != Depth.GAS) {\n                if (layer === Depth.GROUND) {\n                    if (floorTile !== this.groundTile)\n                        this.setTile(floorTile);\n                }\n                else {\n                    this.clearLayer(layer);\n                }\n            }\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n        this.flags |= Flags.CELL_CHANGED;\n    }\n    clearLayersWithFlags(tileFlags, tileMechFlags = 0) {\n        for (let i = 0; i < this._tiles.length; ++i) {\n            const tile = this._tiles[i];\n            if (!tile)\n                continue;\n            if (tileFlags && tileMechFlags) {\n                if (tile.flags.tile & tileFlags &&\n                    tile.flags.tileMech & tileMechFlags) {\n                    this.clearLayer(i);\n                }\n            }\n            else if (tileFlags) {\n                if (tile.flags.tile & tileFlags) {\n                    this.clearLayer(i);\n                }\n            }\n            else if (tileMechFlags) {\n                if (tile.flags.tileMech & tileMechFlags) {\n                    this.clearLayer(i);\n                }\n            }\n        }\n        // this.flags |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n    }\n    // EVENTS\n    async activate(name, ctx = {}) {\n        ctx.cell = this;\n        let fired = false;\n        // cell.debug(\"fire event - %s\", name);\n        for (let tile of this.tiles()) {\n            if (!tile.activates)\n                continue;\n            const ev = tile.activates[name];\n            if (ev) {\n                // cell.debug(\" - has event\");\n                if (ev.chance && !random.chance(ev.chance, 10000)) {\n                    continue;\n                }\n                ctx.tile = tile;\n                // cell.debug(\" - spawn event @%d,%d - %s\", ctx.x, ctx.y, name);\n                fired = (await Activation.spawn(ev, ctx)) || fired;\n                // cell.debug(\" - spawned\");\n                if (fired) {\n                    break;\n                }\n            }\n        }\n        if (fired) {\n            // this.mechFlags |= MechFlags.EVENT_FIRED_THIS_TURN;\n        }\n        return fired;\n    }\n    activatesOn(name) {\n        for (let tile of this.tiles()) {\n            if (tile.activatesOn(name))\n                return true;\n        }\n        return false;\n    }\n    // ITEM\n    get item() {\n        return this._item;\n    }\n    set item(item) {\n        if (this.item) {\n            this.removeLayer(this.item);\n        }\n        this._item = item;\n        if (item) {\n            this.flags |= Flags.HAS_ITEM;\n            this.addLayer(item);\n        }\n        else {\n            this.flags &= ~Flags.HAS_ITEM;\n        }\n    }\n    // ACTOR\n    get actor() {\n        return this._actor;\n    }\n    set actor(actor) {\n        if (this.actor) {\n            this.removeLayer(this.actor);\n        }\n        this._actor = actor;\n        if (actor) {\n            this.flags |= Flags.HAS_ACTOR;\n            this.addLayer(actor);\n        }\n        else {\n            this.flags &= ~Flags.HAS_ACTOR;\n        }\n    }\n    addLayer(layer) {\n        if (!layer)\n            return;\n        // this.flags |= Flags.NEEDS_REDRAW;\n        this.flags |= Flags.CELL_CHANGED;\n        let current = this.layers;\n        if (!current ||\n            current.layer.depth > layer.depth ||\n            (current.layer.depth == layer.depth &&\n                current.layer.priority > layer.priority)) {\n            this.layers = {\n                layer,\n                next: current,\n            };\n            return;\n        }\n        while (current.next &&\n            (current.layer.depth < layer.depth ||\n                (current.layer.depth == layer.depth &&\n                    current.layer.priority <= layer.priority))) {\n            current = current.next;\n        }\n        const item = {\n            layer,\n            next: current.next,\n        };\n        current.next = item;\n    }\n    removeLayer(layer) {\n        if (!layer)\n            return false;\n        if (!this.layers)\n            return false;\n        // this.flags |= Flags.NEEDS_REDRAW;\n        this.flags |= Flags.CELL_CHANGED;\n        if (this.layers && this.layers.layer === layer) {\n            this.layers = this.layers.next;\n            return true;\n        }\n        let prev = this.layers;\n        let current = this.layers.next;\n        while (current) {\n            if (current.layer === layer) {\n                prev.next = current.next;\n                return true;\n            }\n            prev = current;\n            current = current.next;\n        }\n        return false;\n    }\n    // MEMORY\n    storeMemory() {\n        const memory = this.memory;\n        memory.tileFlags = this.tileFlags();\n        memory.tileMechFlags = this.tileMechFlags();\n        memory.layerFlags = this.layerFlags();\n        memory.cellFlags = this.flags;\n        memory.cellMechFlags = this.mechFlags;\n        memory.tile = this.topmostTile();\n        if (this.item) {\n            memory.item = this.item;\n            memory.itemQuantity = this.item.quantity;\n        }\n        else {\n            memory.item = null;\n            memory.itemQuantity = 0;\n        }\n        memory.actor = this.actor;\n        getAppearance(this, memory.mixer);\n        if (this.actor && this.isOrWasAnyKindOfVisible()) {\n            if (this.actor.rememberedInCell && this.actor.rememberedInCell !== this) {\n                // console.log(\"remembered in cell change\");\n                this.actor.rememberedInCell.storeMemory();\n                this.actor.rememberedInCell.flags |= Flags.NEEDS_REDRAW;\n            }\n            this.actor.rememberedInCell = this;\n        }\n    }\n}\nexport function make(tile) {\n    const cell = new Cell();\n    if (tile) {\n        cell.setTile(tile);\n    }\n    return cell;\n}\nMake.cell = make;\nexport function getAppearance(cell, dest) {\n    const memory = cell.memory.mixer;\n    memory.blackOut();\n    let needDistinctness = cell.tileMechFlags() & TileMechFlags.TM_VISUALLY_DISTINCT;\n    let current = cell.layers;\n    while (current) {\n        const layer = current.layer;\n        let alpha = layer.sprite.opacity || 100;\n        if (layer.depth == Depth.LIQUID) {\n            alpha = Utils.clamp(cell.liquidVolume || 0, 20, 100);\n        }\n        else if (layer.depth == Depth.GAS) {\n            alpha = Utils.clamp(cell.gasVolume || 0, 20, 100);\n        }\n        memory.drawSprite(layer.sprite, alpha);\n        current = current.next;\n    }\n    memory.fg.multiply(cell.light);\n    memory.bg.multiply(cell.light);\n    memory.bake(!cell.isAnyKindOfVisible()); // turns off dancing if not visible\n    if (needDistinctness) {\n        Color.separate(memory.fg, memory.bg);\n    }\n    dest.drawSprite(memory);\n    return true;\n}\n","import { utils as Utils, random, grid as Grid, fov as Fov, flag as Flag, path as Path, color as Color, colors as COLORS, canvas as Canvas, config as CONFIG, data as DATA, make as Make, } from \"gw-utils\";\nimport * as Cell from \"./cell\";\nimport { Map as Flags, Cell as CellFlags, Tile as TileFlags, CellMech as CellMechFlags, TileMech as TileMechFlags, Depth as TileLayer, Layer as LayerFlags, } from \"./flags\";\nimport * as Light from \"./light\";\nimport * as Layer from \"./layer\";\nexport { Flags };\nUtils.setDefaults(CONFIG, {\n    \"map.deepestLevel\": 99,\n});\nexport class Map {\n    constructor(w, h, opts = {}) {\n        this.locations = {};\n        this.config = {};\n        this._actors = null;\n        this._items = null;\n        this.flags = 0;\n        this.lights = null;\n        this.events = {};\n        this._width = w;\n        this._height = h;\n        this.cells = Grid.make(w, h, () => new Cell.Cell());\n        this.locations = opts.locations || {};\n        this.config = Object.assign({}, opts);\n        this.config.tick = this.config.tick || 100;\n        this._actors = null;\n        this._items = null;\n        this.flags = Flag.from(Flags, Flags.MAP_DEFAULT, opts.flags);\n        const ambient = opts.ambient || opts.ambientLight || opts.light || \"white\";\n        this.ambientLight = Color.make(ambient);\n        this.lights = null;\n        this.id = opts.id;\n        this.events = opts.events || {};\n    }\n    get width() {\n        return this._width;\n    }\n    get height() {\n        return this._height;\n    }\n    async start() { }\n    clear() {\n        this.cells.forEach((c) => c.clear());\n        this.changed = true;\n    }\n    dump(fmt) {\n        this.cells.dump(fmt || ((c) => c.dump()));\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    eachCell(fn) {\n        this.cells.forEach((c, i, j) => fn(c, i, j, this));\n    }\n    forEach(fn) {\n        this.cells.forEach((c, i, j) => fn(c, i, j, this));\n    }\n    forRect(x, y, w, h, fn) {\n        this.cells.forRect(x, y, w, h, (c, i, j) => fn(c, i, j, this));\n    }\n    eachNeighbor(x, y, fn, only4dirs = false) {\n        this.cells.eachNeighbor(x, y, (c, i, j) => fn(c, i, j, this), only4dirs);\n    }\n    count(fn) {\n        let count = 0;\n        this.forEach((c, x, y, g) => {\n            if (fn(c, x, y, g)) {\n                ++count;\n            }\n        });\n        return count;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.cells.isBoundaryXY(x, y);\n    }\n    get changed() {\n        return (this.flags & Flags.MAP_CHANGED) > 0;\n    }\n    set changed(v) {\n        if (v === true) {\n            this.flags |= Flags.MAP_CHANGED;\n        }\n        else if (v === false) {\n            this.flags &= ~Flags.MAP_CHANGED;\n        }\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).flags & flag;\n    }\n    hasCellMechFlag(x, y, flag) {\n        return this.cell(x, y).mechFlags & flag;\n    }\n    hasLayerFlag(x, y, flag) {\n        return this.cell(x, y).hasLayerFlag(flag);\n    }\n    hasTileFlag(x, y, flag) {\n        return this.cell(x, y).hasTileFlag(flag);\n    }\n    hasTileMechFlag(x, y, flag) {\n        return this.cell(x, y).hasTileMechFlag(flag);\n    }\n    redrawCell(cell) {\n        // if (cell.isAnyKindOfVisible()) {\n        cell.needsRedraw = true;\n        this.flags |= Flags.MAP_CHANGED;\n        // }\n    }\n    redrawXY(x, y) {\n        const cell = this.cell(x, y);\n        this.redrawCell(cell);\n    }\n    redrawAll() {\n        this.forEach((c) => {\n            // if (c.isAnyKindOfVisible()) {\n            c.needsRedraw = true;\n            // }\n        });\n        this.changed = true;\n    }\n    drawInto(canvas, opts = {}) {\n        Light.updateLighting(this);\n        if (typeof opts === \"boolean\")\n            opts = { force: opts };\n        const mixer = new Canvas.Mixer();\n        for (let x = 0; x < canvas.width; ++x) {\n            for (let y = 0; y < canvas.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.needsRedraw || opts.force) {\n                    getCellAppearance(this, x, y, mixer);\n                    const glyph = typeof mixer.ch === \"number\" ? mixer.ch : canvas.toGlyph(mixer.ch);\n                    canvas.draw(x, y, glyph, mixer.fg.toInt(), mixer.bg.toInt());\n                    cell.needsRedraw = false;\n                }\n            }\n        }\n    }\n    revealAll() {\n        this.forEach((c) => {\n            c.markRevealed();\n            c.storeMemory();\n        });\n        if (DATA.player) {\n            DATA.player.invalidateCostMap();\n        }\n    }\n    markRevealed(x, y) {\n        if (!this.cell(x, y).markRevealed())\n            return;\n        if (DATA.player) {\n            DATA.player.invalidateCostMap();\n        }\n    }\n    isVisible(x, y) {\n        return this.cell(x, y).isVisible();\n    }\n    isAnyKindOfVisible(x, y) {\n        return this.cell(x, y).isAnyKindOfVisible();\n    }\n    isOrWasAnyKindOfVisible(x, y) {\n        return this.cell(x, y).isOrWasAnyKindOfVisible();\n    }\n    get anyLightChanged() {\n        return (this.flags & Flags.MAP_STABLE_LIGHTS) == 0;\n    }\n    set anyLightChanged(v) {\n        if (v) {\n            this.flags &= ~Flags.MAP_STABLE_LIGHTS;\n        }\n        else {\n            this.flags |= Flags.MAP_STABLE_LIGHTS;\n        }\n    }\n    get ambientLightChanged() {\n        return this.staticLightChanged;\n    }\n    set ambientLightChanged(v) {\n        this.staticLightChanged = v;\n    }\n    get staticLightChanged() {\n        return (this.flags & Flags.MAP_STABLE_GLOW_LIGHTS) == 0;\n    }\n    set staticLightChanged(v) {\n        if (v) {\n            this.flags &= ~(Flags.MAP_STABLE_GLOW_LIGHTS | Flags.MAP_STABLE_LIGHTS);\n        }\n        else {\n            this.flags |= Flags.MAP_STABLE_GLOW_LIGHTS;\n        }\n    }\n    setFlag(flag) {\n        this.flags |= flag;\n        this.changed = true;\n    }\n    setFlags(mapFlag = 0, cellFlag = 0, cellMechFlag = 0) {\n        if (mapFlag) {\n            this.flags |= mapFlag;\n        }\n        if (cellFlag || cellMechFlag) {\n            this.forEach((c) => c.setFlags(cellFlag, cellMechFlag));\n        }\n        this.changed = true;\n    }\n    clearFlag(flag) {\n        this.flags &= ~flag;\n        this.changed = true;\n    }\n    clearFlags(mapFlag = 0, cellFlag = 0, cellMechFlag = 0) {\n        if (mapFlag) {\n            this.flags &= ~mapFlag;\n        }\n        if (cellFlag || cellMechFlag) {\n            this.forEach((cell) => cell.clearFlags(cellFlag, cellMechFlag));\n        }\n        this.changed = true;\n    }\n    // setCellFlag(x: number, y: number, flag: number) {\n    //   this.cell(x, y).flags |= flag;\n    // }\n    setCellFlags(x, y, cellFlag = 0, cellMechFlag = 0) {\n        this.cell(x, y).setFlags(cellFlag, cellMechFlag);\n        this.flags |= Flags.MAP_CHANGED;\n    }\n    clearCellFlags(x, y, cellFlags = 0, cellMechFlags = 0) {\n        this.cell(x, y).clearFlags(cellFlags, cellMechFlags);\n        this.changed = true;\n    }\n    hasTile(x, y, tile) {\n        return this.cells[x][y].hasTile(tile);\n    }\n    layerFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].layerFlags(limitToPlayerKnowledge);\n    }\n    tileFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].tileFlags(limitToPlayerKnowledge);\n    }\n    tileMechFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].tileMechFlags(limitToPlayerKnowledge);\n    }\n    tileWithFlag(x, y, flag = 0) {\n        return this.cells[x][y].tileWithFlag(flag);\n    }\n    tileWithMechFlag(x, y, mechFlag = 0) {\n        return this.cells[x][y].tileWithMechFlag(mechFlag);\n    }\n    hasKnownTileFlag(x, y, flagMask = 0) {\n        return this.cells[x][y].memory.tileFlags & flagMask;\n    }\n    // hasTileInGroup(x, y, ...groups) { return this.cells[x][y].hasTileInGroup(...groups); }\n    // discoveredTileFlags(x: number, y: number) {\n    //   return this.cells[x][y].discoveredTileFlags();\n    // }\n    // hasDiscoveredTileFlag(x: number, y: number, flag = 0) {\n    //   return this.cells[x][y].hasDiscoveredTileFlag(flag);\n    // }\n    isClear(x, y) {\n        return this.cells[x][y].isClear();\n    }\n    isEmpty(x, y) {\n        return this.cells[x][y].isEmpty();\n    }\n    isObstruction(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isObstruction(limitToPlayerKnowledge);\n    }\n    isDoorway(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isDoorway(limitToPlayerKnowledge);\n    }\n    isSecretDoorway(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isSecretDoorway(limitToPlayerKnowledge);\n    }\n    isLiquid(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isLiquid(limitToPlayerKnowledge);\n    }\n    hasGas(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].hasGas(limitToPlayerKnowledge);\n    }\n    blocksPathing(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].blocksPathing(limitToPlayerKnowledge);\n    }\n    blocksVision(x, y) {\n        return this.cells[x][y].blocksVision();\n    }\n    isMoveableNow(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isMoveableNow(limitToPlayerKnowledge);\n    }\n    isWalkableNow(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isWalkableNow(limitToPlayerKnowledge);\n    }\n    canBeWalked(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].canBeWalked(limitToPlayerKnowledge);\n    }\n    topmostTile(x, y, skipGas = false) {\n        return this.cells[x][y].topmostTile(skipGas);\n    }\n    tileFlavor(x, y) {\n        return this.cells[x][y].tileFlavor();\n    }\n    setTile(x, y, tileId, volume = 0) {\n        return this.cell(x, y).setTile(tileId, volume, this);\n    }\n    clearCell(x, y) {\n        this.cell(x, y).clear();\n    }\n    clearCellLayersWithFlags(x, y, tileFlags, tileMechFlags = 0) {\n        const cell = this.cell(x, y);\n        cell.clearLayersWithFlags(tileFlags, tileMechFlags);\n    }\n    clearCellLayers(x, y, nullLiquid = true, nullSurface = true, nullGas = true) {\n        this.changed = true;\n        return this.cell(x, y).clearLayers(nullLiquid, nullSurface, nullGas);\n    }\n    fill(tileId, boundaryTile) {\n        let i, j;\n        if (boundaryTile === undefined) {\n            boundaryTile = tileId;\n        }\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                if (this.isBoundaryXY(i, j)) {\n                    this.setTile(i, j, boundaryTile);\n                }\n                else {\n                    this.setTile(i, j, tileId);\n                }\n            }\n        }\n    }\n    neighborCount(x, y, matchFn, only4dirs = false) {\n        let count = 0;\n        this.eachNeighbor(x, y, (...args) => {\n            if (matchFn(...args))\n                ++count;\n        }, only4dirs);\n        return count;\n    }\n    walkableArcCount(x, y) {\n        if (!this.hasXY(x, y))\n            return -1;\n        return this.cells.arcCount(x, y, (c) => c.isWalkableNow());\n    }\n    diagonalBlocked(x1, y1, x2, y2, limitToPlayerKnowledge = false) {\n        if (x1 == x2 || y1 == y2) {\n            return false; // If it's not a diagonal, it's not diagonally blocked.\n        }\n        if (this.isObstruction(x1, y2, limitToPlayerKnowledge)) {\n            return true;\n        }\n        if (this.isObstruction(x2, y1, limitToPlayerKnowledge)) {\n            return true;\n        }\n        return false;\n    }\n    fillCostGrid(costGrid, costFn) {\n        costFn =\n            costFn || ((c) => (c.isWalkableNow() ? 1 : Path.OBSTRUCTION));\n        this.cells.forEach((cell, i, j) => {\n            if (cell.isClear()) {\n                costGrid[i][j] = Path.OBSTRUCTION;\n            }\n            else {\n                costGrid[i][j] = costFn(cell, i, j, this);\n            }\n        });\n    }\n    matchingNeighbor(x, y, matcher, only4dirs = false) {\n        const maxIndex = only4dirs ? 4 : 8;\n        for (let d = 0; d < maxIndex; ++d) {\n            const dir = Utils.DIRS[d];\n            const i = x + dir[0];\n            const j = y + dir[1];\n            if (this.hasXY(i, j)) {\n                if (matcher(this.cells[i][j], i, j, this))\n                    return [i, j];\n            }\n        }\n        return [-1, -1];\n    }\n    matchingLocNear(x, y, ...args) {\n        let i, j, k;\n        let matcher = args[0];\n        let opts = args[1] || {};\n        const arg = args[0];\n        if (typeof arg !== \"function\") {\n            opts = arg || args[1];\n            matcher = opts.match || Utils.TRUE;\n        }\n        const hallwaysAllowed = opts.hallways || false;\n        const blockingMap = opts.blockingMap || null;\n        const forbidLiquid = opts.liquids === false;\n        const deterministic = opts.deterministic || false;\n        const candidateLocs = [];\n        // count up the number of candidate locations\n        for (k = 0; k < Math.max(this.width, this.height) && !candidateLocs.length; k++) {\n            for (i = x - k; i <= x + k; i++) {\n                for (j = y - k; j <= y + k; j++) {\n                    if (!this.hasXY(i, j))\n                        continue;\n                    const cell = this.cell(i, j);\n                    // if ((i == x-k || i == x+k || j == y-k || j == y+k)\n                    if (Math.ceil(Utils.distanceBetween(x, y, i, j)) == k &&\n                        (!blockingMap || !blockingMap[i][j]) &&\n                        matcher(cell, i, j, this) &&\n                        (!forbidLiquid || !cell.liquid) &&\n                        (hallwaysAllowed || this.walkableArcCount(i, j) < 2)) {\n                        candidateLocs.push([i, j]);\n                    }\n                }\n            }\n        }\n        if (candidateLocs.length == 0) {\n            return [-1, -1];\n        }\n        // and pick one\n        let randIndex = 0;\n        if (deterministic) {\n            randIndex = Math.floor(candidateLocs.length / 2);\n        }\n        else {\n            randIndex = random.number(candidateLocs.length);\n        }\n        return candidateLocs[randIndex];\n    }\n    randomMatchingLoc(opts = {}) {\n        let x;\n        let y;\n        let cell;\n        if (typeof opts === \"function\") {\n            opts = { match: opts };\n        }\n        const sequence = random.sequence(this.width * this.height);\n        const hallwaysAllowed = opts.hallways || false;\n        const blockingMap = opts.blockingMap || null;\n        const forbidLiquid = opts.liquids === false;\n        const matcher = opts.match || Utils.TRUE;\n        const forbidCellFlags = opts.forbidCellFlags || 0;\n        const forbidTileFlags = opts.forbidTileFlags || 0;\n        const forbidTileMechFlags = opts.forbidTileMechFlags || 0;\n        const tile = opts.tile || null;\n        let success = false;\n        let index = 0;\n        while (!success && index < sequence.length) {\n            const v = sequence[index];\n            x = v % this.width;\n            y = Math.floor(v / this.width);\n            cell = this.cell(x, y);\n            if ((!blockingMap || !blockingMap[x][y]) &&\n                (!tile || cell.hasTile(tile)) &&\n                (!forbidLiquid || !cell.liquid) &&\n                (!forbidCellFlags || !(cell.flags & forbidCellFlags)) &&\n                (!forbidTileFlags || !cell.hasTileFlag(forbidTileFlags)) &&\n                (!forbidTileMechFlags || !cell.hasTileMechFlag(forbidTileMechFlags)) &&\n                (hallwaysAllowed || this.walkableArcCount(x, y) < 2) &&\n                matcher(cell, x, y, this)) {\n                success = true;\n            }\n            ++index;\n        }\n        if (!success) {\n            // map.debug('randomMatchingLocation', dungeonType, liquidType, terrainType, ' => FAIL');\n            return [-1, -1];\n        }\n        // map.debug('randomMatchingLocation', dungeonType, liquidType, terrainType, ' => ', x, y);\n        return [x, y];\n    }\n    // LIGHT\n    hasVisibleLight(x, y) {\n        return this.cell(x, y).hasVisibleLight();\n    }\n    addStaticLight(x, y, light) {\n        const info = { x, y, light, next: this.lights };\n        this.lights = info;\n        this.staticLightChanged = true;\n        return info;\n    }\n    removeStaticLight(x, y, light) {\n        let prev = this.lights;\n        if (!prev)\n            return;\n        function matches(info) {\n            if (info.x != x || info.y != y)\n                return false;\n            return !light || light === info.light;\n        }\n        this.staticLightChanged = true;\n        while (prev && matches(prev)) {\n            prev = this.lights = prev.next;\n        }\n        if (!prev)\n            return;\n        let current = prev.next;\n        while (current) {\n            if (matches(current)) {\n                prev.next = current.next;\n            }\n            else {\n                prev = current;\n            }\n            current = current.next;\n        }\n    }\n    eachStaticLight(fn) {\n        Utils.eachChain(this.lights, (info) => fn(info.light, info.x, info.y));\n        this.eachCell((cell, x, y) => {\n            for (let tile of cell.tiles()) {\n                if (tile.light) {\n                    fn(tile.light, x, y);\n                }\n            }\n        });\n    }\n    eachDynamicLight(fn) {\n        Utils.eachChain(this._actors, (actor) => {\n            if (actor.light)\n                fn(actor.light, actor.x, actor.y);\n        });\n    }\n    // Layers\n    addFx(x, y, anim) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        cell.addLayer(anim);\n        anim.x = x;\n        anim.y = y;\n        this.redrawCell(cell);\n        return true;\n    }\n    moveFx(x, y, anim) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        const oldCell = this.cell(anim.x, anim.y);\n        oldCell.removeLayer(anim);\n        this.redrawCell(oldCell);\n        cell.addLayer(anim);\n        this.redrawCell(cell);\n        anim.x = x;\n        anim.y = y;\n        return true;\n    }\n    removeFx(anim) {\n        const oldCell = this.cell(anim.x, anim.y);\n        oldCell.removeLayer(anim);\n        this.redrawCell(oldCell);\n        this.flags |= Flags.MAP_CHANGED;\n        return true;\n    }\n    // ACTORS\n    // will return the PLAYER if the PLAYER is at (x, y).\n    actorAt(x, y) {\n        // creature *\n        if (!this.hasXY(x, y))\n            return null;\n        const cell = this.cell(x, y);\n        return cell.actor;\n    }\n    addActor(x, y, theActor) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.actor) {\n            return false;\n        }\n        cell.actor = theActor; // adjusts the layer\n        theActor.next = this._actors;\n        this._actors = theActor;\n        const flag = theActor === DATA.player ? CellFlags.HAS_PLAYER : CellFlags.HAS_MONSTER;\n        cell.flags |= flag;\n        // if (theActor.flags & Flags.Actor.MK_DETECTED)\n        // {\n        // \tcell.flags |= CellFlags.MONSTER_DETECTED;\n        // }\n        if (theActor.light) {\n            this.anyLightChanged = true;\n        }\n        // If the player moves or an actor that blocks vision and the cell is visible...\n        // -- we need to update the FOV\n        if (theActor.isPlayer() ||\n            (cell.isAnyKindOfVisible() && theActor.blocksVision())) {\n            this.flags |= Flags.MAP_FOV_CHANGED;\n        }\n        theActor.x = x;\n        theActor.y = y;\n        this.redrawCell(cell);\n        return true;\n    }\n    addActorNear(x, y, theActor) {\n        const loc = this.matchingLocNear(x, y, (cell) => {\n            return !theActor.avoidsCell(cell);\n        });\n        if (!loc || loc[0] < 0) {\n            // GW.ui.message(colors.badMessageColor, 'There is no place to put the actor.');\n            return false;\n        }\n        return this.addActor(loc[0], loc[1], theActor);\n    }\n    moveActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        this.removeActor(actor);\n        if (!this.addActor(x, y, actor)) {\n            this.addActor(actor.x, actor.y, actor);\n            return false;\n        }\n        if (actor.light) {\n            this.anyLightChanged = true;\n        }\n        return true;\n    }\n    removeActor(actor) {\n        if (!this.hasXY(actor.x, actor.y))\n            return false;\n        const cell = this.cell(actor.x, actor.y);\n        if (cell.actor === actor) {\n            cell.actor = null;\n            Utils.removeFromChain(this, \"actors\", actor);\n            if (actor.light) {\n                this.anyLightChanged = true;\n            }\n            // If the player moves or an actor that blocks vision and the cell is visible...\n            // -- we need to update the FOV\n            if (actor.isPlayer() ||\n                (cell.isAnyKindOfVisible() && actor.blocksVision())) {\n                this.flags |= Flags.MAP_FOV_CHANGED;\n            }\n            this.redrawCell(cell);\n            return true;\n        }\n        return false;\n    }\n    deleteActorAt(x, y) {\n        const actor = this.actorAt(x, y);\n        if (!actor)\n            return false;\n        this.removeActor(actor);\n        actor.delete();\n        return true;\n    }\n    // dormantAt(x: number, y: number) {  // creature *\n    // \tif (!(this.cell(x, y).flags & CellFlags.HAS_DORMANT_MONSTER)) {\n    // \t\treturn null;\n    // \t}\n    // \treturn this.dormantActors.find( (m) => m.x == x && m.y == y );\n    // }\n    //\n    // addDormant(x, y, actor) {\n    // \ttheActor.x = x;\n    // \ttheActor.y = y;\n    // \tthis.dormant.add(theActor);\n    // \tcell.flags |= (CellFlags.HAS_DORMANT_MONSTER);\n    // \tthis.flags |= Flags.MAP_CHANGED;\n    // \treturn true;\n    // }\n    //\n    // removeDormant(actor) {\n    // \tconst cell = this.cell(actor.x, actor.y);\n    // \tcell.flags &= ~(CellFlags.HAS_DORMANT_MONSTER);\n    // \tcell.flags |= CellFlags.NEEDS_REDRAW;\n    // \tthis.flags |= Flags.MAP_CHANGED;\n    // \tthis.dormant.remove(actor);\n    // }\n    // ITEMS\n    itemAt(x, y) {\n        const cell = this.cell(x, y);\n        return cell.item;\n    }\n    addItem(x, y, theItem) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.item) {\n            // GW.ui.message(colors.badMessageColor, 'There is already an item there.');\n            return false;\n        }\n        theItem.x = x;\n        theItem.y = y;\n        cell.item = theItem; // adjusts the layers\n        theItem.next = this._items;\n        this._items = theItem;\n        if (theItem.light) {\n            this.anyLightChanged = true;\n        }\n        this.redrawCell(cell);\n        if (theItem.isDetected() || CONFIG.D_ITEM_OMNISCIENCE) {\n            cell.flags |= CellFlags.ITEM_DETECTED;\n        }\n        return true;\n    }\n    addItemNear(x, y, theItem) {\n        const loc = this.matchingLocNear(x, y, (cell) => {\n            return !theItem.forbidsCell(cell);\n        });\n        if (!loc || loc[0] < 0) {\n            // GW.ui.message(colors.badMessageColor, 'There is no place to put the item.');\n            return false;\n        }\n        return this.addItem(loc[0], loc[1], theItem);\n    }\n    removeItem(theItem) {\n        const x = theItem.x;\n        const y = theItem.y;\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.item !== theItem)\n            return false;\n        cell.item = null;\n        Utils.removeFromChain(this, \"items\", theItem);\n        if (theItem.light) {\n            this.anyLightChanged = true;\n        }\n        cell.flags &= ~(CellFlags.HAS_ITEM | CellFlags.ITEM_DETECTED);\n        this.redrawCell(cell);\n        return true;\n    }\n    // // PROMOTE\n    //\n    // async promote(x, y, mechFlag) {\n    // \tif (this.hasTileMechFlag(x, y, mechFlag)) {\n    // \t\tconst cell = this.cell(x, y);\n    // \t\tfor (let tile of cell.tiles()) {\n    // \t\t\tif (tile.mechFlags & mechFlag) {\n    // \t\t\t\tawait tile.promote(this, x, y, false);\n    // \t\t\t}\n    // \t\t}\n    // \t}\n    // }\n    gridDisruptsWalkability(blockingGrid, opts = {}) {\n        const walkableGrid = Grid.alloc(this.width, this.height);\n        let disrupts = false;\n        const gridOffsetX = opts.gridOffsetX || 0;\n        const gridOffsetY = opts.gridOffsetY || 0;\n        const bounds = opts.bounds || null; // TODO - Where is this used ???\n        // Get all walkable locations after lake added\n        this.cells.forEach((cell, i, j) => {\n            if (bounds && !bounds.contains(i, j))\n                return; // outside bounds\n            const blockingX = i + gridOffsetX;\n            const blockingY = j + gridOffsetY;\n            if (cell.isClear()) {\n                return; // not walkable\n            }\n            else if (cell.hasTileFlag(TileFlags.T_HAS_STAIRS)) {\n                if (blockingGrid.get(blockingX, blockingY)) {\n                    disrupts = true;\n                }\n                else {\n                    walkableGrid[i][j] = 1;\n                }\n            }\n            else if (cell.canBeWalked()) {\n                if (blockingGrid.get(blockingX, blockingY))\n                    return;\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        Grid.free(walkableGrid);\n        return disrupts;\n    }\n    // FOV\n    // Returns a boolean grid indicating whether each square is in the field of view of (xLoc, yLoc).\n    // forbiddenTileFlags is the set of terrain flags that will block vision (but the blocking cell itself is\n    // illuminated); forbiddenCellFlags is the set of map flags that will block vision.\n    // If cautiousOnWalls is set, we will not illuminate blocking tiles unless the tile one space closer to the origin\n    // is visible to the player; this is to prevent lights from illuminating a wall when the player is on the other\n    // side of the wall.\n    calcFov(grid, x, y, maxRadius, forbiddenCellFlags = 0, forbiddenLayerFlags = LayerFlags.L_BLOCKS_VISION) {\n        maxRadius = maxRadius || this.width + this.height;\n        grid.fill(0);\n        const map = this;\n        const FOV = new Fov.FOV({\n            isBlocked(i, j) {\n                return !!(!grid.hasXY(i, j) ||\n                    map.hasCellFlag(i, j, forbiddenCellFlags) ||\n                    map.hasLayerFlag(i, j, forbiddenLayerFlags));\n            },\n            calcRadius(x, y) {\n                return Math.sqrt(x ** 2 + y ** 2);\n            },\n            setVisible(x, y) {\n                grid[x][y] = 1;\n            },\n            hasXY(x, y) {\n                return grid.hasXY(x, y);\n            },\n        });\n        return FOV.calculate(x, y, maxRadius);\n    }\n    losFromTo(a, b) {\n        if (Utils.equalsXY(a, b))\n            return true;\n        const line = Utils.getLine(a.x, a.y, b.x, b.y);\n        if (!line.length)\n            return false;\n        return !line.some((loc) => {\n            return this.blocksVision(loc[0], loc[1]);\n        });\n    }\n    // MEMORIES\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        cell.storeMemory();\n    }\n    storeMemories() {\n        let x, y;\n        for (x = 0; x < this.width; ++x) {\n            for (y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.flags & CellFlags.ANY_KIND_OF_VISIBLE) {\n                    this.storeMemory(x, y);\n                }\n                cell.flags &= CellFlags.PERMANENT_CELL_FLAGS;\n                cell.mechFlags &= CellMechFlags.PERMANENT_MECH_FLAGS;\n            }\n        }\n    }\n    // TICK\n    async tick() {\n        // map.debug(\"tick\");\n        this.resetCellEvents();\n        for (let x = 0; x < this.width; ++x) {\n            for (let y = 0; y < this.height; ++y) {\n                const cell = this.cells[x][y];\n                await cell.activate(\"tick\", { map: this, x, y, cell, safe: true });\n            }\n        }\n        updateLiquid(this);\n        updateGas(this);\n    }\n    resetCellEvents() {\n        this.forEach((c) => (c.mechFlags &= ~(CellMechFlags.EVENT_FIRED_THIS_TURN | CellMechFlags.EVENT_PROTECTED)));\n    }\n}\nexport function make(w, h, opts = {}, wall) {\n    if (typeof opts === \"string\") {\n        opts = { tile: opts };\n        if (wall) {\n            opts.wall = wall;\n        }\n    }\n    const map = new Map(w, h, opts);\n    const floor = opts.tile || opts.floor || opts.floorTile;\n    const boundary = opts.boundary || opts.wall || opts.wallTile;\n    if (floor) {\n        map.fill(floor, boundary);\n    }\n    if (!DATA.map) {\n        DATA.map = map;\n    }\n    return map;\n}\nMake.map = make;\nexport function from(prefab, charToTile) {\n    if (!Array.isArray(prefab)) {\n        prefab = prefab.split(\"\\n\");\n    }\n    const height = prefab.length;\n    const width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n    const map = make(width, height);\n    prefab.forEach((line, y) => {\n        for (let x = 0; x < width; ++x) {\n            const ch = line[x] || \".\";\n            const tile = charToTile[ch] || \"FLOOR\";\n            map.setTile(x, y, tile);\n        }\n    });\n    return map;\n}\nif (!COLORS.cursor) {\n    Color.install(\"cursor\", COLORS.yellow);\n}\nif (!COLORS.path) {\n    Color.install(\"path\", COLORS.gold);\n}\nexport function getCellAppearance(map, x, y, dest) {\n    dest.blackOut();\n    if (!map.hasXY(x, y))\n        return;\n    const cell = map.cell(x, y);\n    if (cell.isAnyKindOfVisible() &&\n        cell.flags & (CellFlags.CELL_CHANGED | CellFlags.NEEDS_REDRAW)) {\n        Cell.getAppearance(cell, dest);\n    }\n    else {\n        // if (cell.isRevealed()) {\n        dest.drawSprite(cell.memory.mixer);\n    }\n    if (cell.isVisible()) {\n        // keep here to allow for games that do not use fov to work\n    }\n    else if (!cell.isRevealed()) {\n        if (!cell.isAnyKindOfVisible())\n            dest.blackOut();\n    }\n    else if (!cell.isAnyKindOfVisible()) {\n        dest.bg.mix(COLORS.black, 30);\n        dest.fg.mix(COLORS.black, 30);\n    }\n    let needDistinctness = false;\n    if (cell.flags & (CellFlags.IS_CURSOR | CellFlags.IS_IN_PATH)) {\n        const highlight = cell.flags & CellFlags.IS_CURSOR ? COLORS.cursor : COLORS.path;\n        if (cell.hasTileMechFlag(TileMechFlags.TM_INVERT_WHEN_HIGHLIGHTED)) {\n            Color.swap(dest.fg, dest.bg);\n        }\n        else {\n            // if (!GAME.trueColorMode || !dest.needDistinctness) {\n            // dest.fg.mix(highlight, CONFIG.cursorPathIntensity || 20);\n            // }\n            dest.bg.mix(highlight, CONFIG.cursorPathIntensity || 20);\n        }\n        needDistinctness = true;\n    }\n    if (needDistinctness) {\n        Color.separate(dest.fg, dest.bg);\n    }\n    // dest.bake();\n}\nexport function addText(map, x, y, text, fg, bg, layer) {\n    for (let ch of text) {\n        const sprite = Layer.make({\n            ch,\n            fg,\n            bg,\n            depth: layer || TileLayer.GROUND,\n            priority: 200,\n        }); // on top of ground tiles\n        const cell = map.cell(x++, y);\n        cell.addLayer(sprite);\n    }\n}\nexport function updateGas(map) {\n    if (map.flags & Flags.MAP_NO_GAS)\n        return;\n    const newVolume = Grid.alloc(map.width, map.height);\n    map.forEach((c, x, y) => {\n        if (c.hasLayerFlag(LayerFlags.L_BLOCKS_GAS))\n            return;\n        let gas = c.gasTile;\n        let highest = c.gasVolume;\n        let sum = c.gasVolume || 0;\n        let count = 1;\n        map.eachNeighbor(x, y, (n, _i, _j) => {\n            if (n.hasLayerFlag(LayerFlags.L_BLOCKS_GAS))\n                return;\n            ++count;\n            sum += n.gasVolume;\n            if (n.gasVolume > highest) {\n                gas = n.gasTile;\n                highest = n.gasVolume;\n            }\n        });\n        if (sum <= 0)\n            return;\n        const newVol = Math.floor(sum / count);\n        if (c.gasTile != gas) {\n            c.setTile(gas, 0, map); // volume = 0 to start, will change later\n        }\n        newVolume[x][y] += newVol;\n        const rem = sum - count * Math.floor(sum / count);\n        if (rem && random.number(count) < rem) {\n            newVolume[x][y] += 1;\n        }\n        // disperses\n        if (newVolume[x][y] > 0 && gas.dissipate) {\n            if (gas.dissipate > 10000) {\n                newVolume[x][y] -= Math.floor(gas.dissipate / 10000);\n                if (random.chance(gas.dissipate % 10000, 10000)) {\n                    newVolume[x][y] -= 1;\n                }\n            }\n            else if (random.chance(gas.dissipate, 10000)) {\n                newVolume[x][y] -= 1;\n                // console.log(\"dissipate\", reduce, x, y, newVolume[x][y]);\n            }\n        }\n    });\n    // newVolume.dump();\n    let hasGas = false;\n    newVolume.forEach((v, i, j) => {\n        const cell = map.cell(i, j);\n        if (v > 0) {\n            hasGas = true;\n            if (cell.gas && cell.gasVolume !== v) {\n                cell.gasVolume = v;\n                map.redrawCell(cell);\n            }\n        }\n        else if (cell.gas) {\n            cell.clearLayer(TileLayer.GAS);\n            map.redrawCell(cell);\n        }\n    });\n    if (hasGas) {\n        map.flags &= ~Flags.MAP_NO_GAS;\n    }\n    else {\n        map.flags |= Flags.MAP_NO_GAS;\n    }\n    map.changed = true;\n    Grid.free(newVolume);\n}\nexport function updateLiquid(map) {\n    if (map.flags & Flags.MAP_NO_LIQUID)\n        return;\n    const newVolume = Grid.alloc(map.width, map.height);\n    map.forEach((c, x, y) => {\n        if (c.hasLayerFlag(LayerFlags.L_BLOCKS_LIQUID))\n            return;\n        let liquid = c.liquidTile;\n        let highest = c.liquidVolume;\n        let sum = c.liquidVolume || 0;\n        let count = 1;\n        map.eachNeighbor(x, y, (n, _i, _j) => {\n            if (n.hasLayerFlag(LayerFlags.L_BLOCKS_LIQUID))\n                return;\n            ++count;\n            sum += n.liquidVolume;\n            if (n.liquidVolume > highest) {\n                liquid = n.liquidTile;\n                highest = n.liquidVolume;\n            }\n        });\n        if (sum <= 0)\n            return;\n        const newVol = Math.floor(sum / count);\n        if (c.liquidTile != liquid) {\n            c.setTile(liquid, 0, map); // volume = 0 to start, will change later\n        }\n        newVolume[x][y] += newVol;\n        const rem = sum - count * Math.floor(sum / count);\n        if (rem && random.number(count) < rem) {\n            newVolume[x][y] += 1;\n        }\n        // disperses\n        if (newVolume[x][y] > 0 && liquid.dissipate) {\n            if (liquid.dissipate > 10000) {\n                newVolume[x][y] -= Math.floor(liquid.dissipate / 10000);\n                if (random.chance(liquid.dissipate % 10000, 10000)) {\n                    newVolume[x][y] -= 1;\n                }\n            }\n            else if (random.chance(liquid.dissipate, 10000)) {\n                newVolume[x][y] -= 1;\n                // console.log(\"dissipate\", reduce, x, y, newVolume[x][y]);\n            }\n        }\n    });\n    // newVolume.dump();\n    let hasLiquid = false;\n    newVolume.forEach((v, i, j) => {\n        const cell = map.cell(i, j);\n        if (v > 0) {\n            hasLiquid = true;\n            if (cell.liquid && cell.liquidVolume !== v) {\n                cell.liquidVolume = v;\n                map.redrawCell(cell);\n            }\n        }\n        else if (cell.liquid) {\n            cell.clearLayer(TileLayer.LIQUID);\n            map.redrawCell(cell);\n        }\n    });\n    if (hasLiquid) {\n        map.flags &= ~Flags.MAP_NO_LIQUID;\n    }\n    else {\n        map.flags |= Flags.MAP_NO_LIQUID;\n    }\n    map.changed = true;\n    Grid.free(newVolume);\n}\n","import * as Tile from \"./tile\";\n// These are the minimal set of tiles to make the diggers work\nTile.install(\"NULL\", {\n    ch: \"\\u2205\",\n    fg: \"white\",\n    bg: \"black\",\n    flags: \"T_OBSTRUCTS_PASSABILITY\",\n    name: \"eerie nothingness\",\n    article: \"an\",\n    priority: 0,\n});\nTile.install(\"FLOOR\", {\n    ch: \"\\u00b7\",\n    fg: [30, 30, 30, 20, 0, 0, 0],\n    bg: [2, 2, 10, 0, 2, 2, 0],\n    priority: 10,\n    article: \"the\",\n});\nTile.install(\"DOOR\", {\n    ch: \"+\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: \"T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, TM_VISUALLY_DISTINCT\",\n    article: \"a\",\n    activates: {\n        enter: { tile: \"DOOR_OPEN\" },\n        open: { tile: \"DOOR_OPEN_ALWAYS\" },\n    },\n});\nTile.install(\"DOOR_OPEN\", \"DOOR\", {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: \"!L_BLOCKS_ITEMS, !L_BLOCKS_VISION\",\n    name: \"open door\",\n    article: \"an\",\n    activates: {\n        tick: { tile: \"DOOR\", flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\" },\n        enter: null,\n        open: null,\n        close: { tile: \"DOOR\", flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\" },\n    },\n});\nTile.install(\"DOOR_OPEN_ALWAYS\", \"DOOR_OPEN\", {\n    activates: {\n        tick: null,\n        close: { tile: \"DOOR\", flags: \"DFF_SUPERPRIORITY, DFF_ONLY_IF_EMPTY\" },\n    },\n});\nTile.install(\"UP_STAIRS\", {\n    ch: \"<\",\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: \"T_UP_STAIRS, L_BLOCKED_BY_STAIRS, TM_VISUALLY_DISTINCT, TM_LIST_IN_SIDEBAR\",\n    name: \"upward staircase\",\n    article: \"an\",\n});\nTile.install(\"DOWN_STAIRS\", {\n    ch: \">\",\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: \"T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, TM_VISUALLY_DISTINCT, TM_LIST_IN_SIDEBAR\",\n    name: \"downward staircase\",\n    article: \"a\",\n});\nTile.install(\"WALL\", {\n    ch: \"#\",\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: \"L_BLOCKS_EVERYTHING\",\n    article: \"a\",\n    name: \"stone wall\",\n    desc: \"A wall made from rough cut stone.\",\n    flavor: \"a rough stone wall\",\n});\nTile.install(\"LAKE\", {\n    ch: \"~\",\n    fg: [5, 8, 20, 10, 0, 4, 15, true],\n    bg: [10, 15, 41, 6, 5, 5, 5, true],\n    priority: 50,\n    flags: \"T_DEEP_WATER\",\n    name: \"deep water\",\n    article: \"the\",\n});\nTile.install(\"BRIDGE\", {\n    ch: \"=\",\n    fg: [100, 40, 40],\n    priority: 40,\n    depth: \"SURFACE\",\n    flags: \"T_BRIDGE, TM_VISUALLY_DISTINCT\",\n    article: \"a\",\n    ground: \"LAKE\",\n});\n"],"names":["Depth","Fl","Flag","fl","Layer","Activation","Tile","TileMech","Cell","CellMech","Map","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_IS_WALL","DFF_BLOCKED_BY_ITEMS","DFF_BLOCKED_BY_ACTORS","DFF_NULL_SURFACE","DFF_NULL_LIQUID","DFF_NULL_GAS","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","TM_PROMOTES_WITH_KEY","TM_PROMOTES_WITHOUT_KEY","TM_PROMOTES_ON_STEP","TM_PROMOTES_ON_ITEM_REMOVE","TM_PROMOTES_ON_SACRIFICE_ENTRY","TM_PROMOTES_ON_ELECTRICITY","TM_PROMOTES_ON_PLAYER_ENTRY","REVEALED","MAGIC_MAPPED","ITEM_DETECTED","HAS_ITEM","HAS_DORMANT_MONSTER","HAS_STAIRS","STABLE_MEMORY","IMPREGNABLE","VISIBLE","CLAIRVOYANT_VISIBLE","TELEPATHIC_VISIBLE","HAS_PLAYER","HAS_MONSTER","WAS_VISIBLE","WAS_CLAIRVOYANT_VISIBLE","WAS_TELEPATHIC_VISIBLE","IN_FOV","NEEDS_REDRAW","CELL_CHANGED","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_TRAP_FREE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","MAP_STABLE_LIGHTS","MAP_STABLE_GLOW_LIGHTS","MAP_FOV_CHANGED","config","CONFIG","light","INTENSITY_DARK","LIGHT_COMPONENTS","Color","make","Light","[object Object]","color","range","fadeTo","pass","this","passThroughActors","id","from","radius","Range","other","copy","intensity","map","x","y","maintainShadows","isMinersLight","k","lightMultiplier","value","outerRadius","Math","ceil","bake","dispelShadows","fadeToPercent","grid","Grid","alloc","width","height","calcFov","Flags.Cell","HAS_ACTOR","Flags.Layer","overlappedFieldOfView","forCircle","v","i","j","cell","floor","Utils","distanceBetween","flags","IS_IN_SHADOW","ANY_KIND_OF_VISIBLE","free","max","args","length","cached","lights","split","t","trim","Number","parseInt","Array","isArray","Error","install","source","recordOldLights","eachCell","oldLight","lightChanged","zeroOutLights","ambientLight","_i","_j","recordGlowLights","glowLight","restoreGlowLights","updateLighting","anyLightChanged","staticLightChanged","eachStaticLight","paint","eachDynamicLight","CELL_LIT","CELL_DARK","some","isDark","updateDisplayDetail","PLAYER","DATA","player","PLAYERS_LIGHT","ERROR","JSON","stringify","arg","Object","entries","forEach","name","info","darkColor","priority","depth","layer","sprite","GW.make","Light.make","GW.utils","first","GW.flag","Flags","layerFlags","TileEvent","opts","fn","tile","item","chance","volume","spread","decrement","matchTile","needs","next","message","lightFlare","flare","flashColor","flash","messageDisplayed","emit","tileEvent","activations","event","async","spawn","activation","ctx","feat","undefined","safe","hasCellMechFlag","CellMechFlags","EVENT_FIRED_THIS_TURN","DFF_ALWAYS_FIRE","refreshCell","DFF_NO_REDRAW_CELL","abortIfBlocking","DFF_ABORT_IF_BLOCKS_MAP","isVisible","Msg","add","Tile.tiles","Make","blocking","DFF_PERMIT_BLOCKING","blocksPathing","blocksMove","DFF_TREAT_AS_BLOCKING","spawnMap","didSomething","computeSpawnMap","gridDisruptsPassability","bounds","DFF_EVACUATE_CREATURES","evacuateCreatures","DFF_EVACUATE_ITEMS","evacuateItems","DFF_NULLIFY_CELL","nullifyCells","spawnTiles","delete","DFF_PROTECTED","mechFlags","EVENT_PROTECTED","Data","gameHasEnded","actor","activate","Events","DFF_SUBSEQ_ALWAYS","DFF_SUBSEQ_EVERYWHERE","TileFlags","updateMapToShoreThisTurn","redrawXY","changed","DFF_NO_MARK_FIRED","setCellFlags","cellIsOk","hasXY","DFF_BUILD_IN_WALLS","isWall","DFF_MUST_TOUCH_WALLS","ok","eachNeighbor","c","DFF_NO_TOUCH_WALLS","containsXY","hasTile","hasLayerFlag","LayerFlags","dir","x2","y2","madeChange","startProb","probDec","fill","DFF_SPREAD_CIRCLE","random","updateCircle","_v","dist","prob","DFF_SPREAD_LINE","DIRS","number","accomplishedSomething","blockedByOtherLayers","DFF_BLOCKED_BY_OTHER_LAYERS","superpriority","DFF_SUPERPRIORITY","GAS","gasVolume","LIQUID","liquidVolume","obstructsLayer","topmostTile","setTile","removeItem","clone","addItem","nullSurface","nullLiquid","nullGas","clearCellLayers","blockingMap","monst","loc","matchingLocNear","forbidsCell","hallways","moveActor","dest","events","values","f","Layer.Layer","super","Extends","tiles","base","ch","fg","bg","opacity","tileMech","activates","flavor","desc","article","dissipate","defaultGround","assignOmitting","assign","ground","Layer.Flags","MechFlags","key","TileEvent.make","flag","T_PATHING_BLOCKER","result","toString","getName","arguments","cursorPathIntensity","CellMemory","mixer","Canvas","Mixer","itemQuantity","cellFlags","cellMechFlags","tileFlags","tileMechFlags","nullify","_tiles","layers","_actor","_item","data","CELL_DEFAULT","machineNumber","memory","copyObject","clear","_a","GROUND","liquid","surface","SURFACE","gas","groundTile","TILES","NULL","liquidTile","surfaceTile","gasTile","IS_WAS_ANY_KIND_OF_VISIBLE","orMapped","hasTileMechFlag","TileMechFlags","TM_LIST_IN_SIDEBAR","needsRedraw","Light.intensity","LIGHT_CHANGED","limitToPlayerKnowledge","flagMask","cellFlag","cellMechFlag","isAnyKindOfVisible","skipGas","best","bestPriority","tileFlag","mechFlag","useMemory","T_IS_DEEP_LIQUID","T_BRIDGE","isWalkableNow","L_SECRETLY_PASSABLE","T_GAS","tileId","FLOOR","oldTile","oldTileId","staleLoopMap","CAUGHT_FIRE_THIS_TURN","blocksVision","oldBlocksVision","setFlag","MapFlags","removeLayer","addLayer","clearFlag","MAP_NO_LIQUID","MAP_NO_GAS","current","except","floorTile","clearLayer","fired","ev","Activation.spawn","activatesOn","prev","quantity","getAppearance","isOrWasAnyKindOfVisible","rememberedInCell","storeMemory","blackOut","needDistinctness","TM_VISUALLY_DISTINCT","alpha","clamp","drawSprite","multiply","separate","setDefaults","map.deepestLevel","w","h","locations","_actors","_items","_width","_height","cells","Cell.Cell","tick","MAP_DEFAULT","ambient","fmt","dump","forRect","only4dirs","count","g","isBoundaryXY","MAP_CHANGED","hasTileFlag","redrawCell","canvas","Light.updateLighting","force","getCellAppearance","glyph","toGlyph","draw","toInt","markRevealed","invalidateCostMap","ambientLightChanged","mapFlag","setFlags","clearFlags","tileWithFlag","tileWithMechFlag","isClear","isEmpty","isObstruction","isDoorway","isSecretDoorway","isLiquid","hasGas","isMoveableNow","canBeWalked","tileFlavor","clearLayersWithFlags","clearLayers","boundaryTile","matchFn","arcCount","x1","y1","costGrid","costFn","Path","OBSTRUCTION","matcher","maxIndex","d","match","TRUE","hallwaysAllowed","forbidLiquid","liquids","deterministic","candidateLocs","walkableArcCount","push","randIndex","sequence","forbidCellFlags","forbidTileFlags","forbidTileMechFlags","success","index","hasVisibleLight","matches","eachChain","anim","oldCell","theActor","CellFlags","isPlayer","avoidsCell","addActor","removeActor","removeFromChain","actorAt","theItem","isDetected","D_ITEM_OMNISCIENCE","blockingGrid","walkableGrid","disrupts","gridOffsetX","gridOffsetY","contains","blockingX","blockingY","get","floodFill","maxRadius","forbiddenCellFlags","forbiddenLayerFlags","Fov","FOV","isBlocked","hasCellFlag","calcRadius","sqrt","calculate","a","b","equalsXY","line","getLine","PERMANENT_CELL_FLAGS","PERMANENT_MECH_FLAGS","resetCellEvents","updateLiquid","updateGas","wall","boundary","wallTile","Cell.getAppearance","isRevealed","mix","COLORS","black","IS_CURSOR","IS_IN_PATH","highlight","cursor","path","TM_INVERT_WHEN_HIGHLIGHTED","swap","newVolume","highest","sum","n","newVol","rem","TileLayer","hasLiquid","yellow","gold","prefab","charToTile","reduce","len","text","Layer.make","enter","open","close"],"mappings":"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"}