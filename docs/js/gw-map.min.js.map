{"version":3,"file":"gw-map.min.js","sources":["../js/mapFlags.js","../js/light.js","../js/entity.js","../js/tile.js","../js/cell.js","../js/visibility.js","../js/mapEffect.js","../js/analyze.js","../js/map.js","../js/tiles.js"],"sourcesContent":["import { flag as Flag } from 'gw-utils';\nexport var Layer;\n(function (Layer) {\n    Layer[Layer[\"ALL_LAYERS\"] = -1] = \"ALL_LAYERS\";\n    Layer[Layer[\"GROUND\"] = 0] = \"GROUND\";\n    Layer[Layer[\"LIQUID\"] = 1] = \"LIQUID\";\n    Layer[Layer[\"SURFACE\"] = 2] = \"SURFACE\";\n    Layer[Layer[\"GAS\"] = 3] = \"GAS\";\n    Layer[Layer[\"ITEM\"] = 4] = \"ITEM\";\n    Layer[Layer[\"ACTOR\"] = 5] = \"ACTOR\";\n    Layer[Layer[\"PLAYER\"] = 6] = \"PLAYER\";\n    Layer[Layer[\"FX\"] = 7] = \"FX\";\n    Layer[Layer[\"UI\"] = 8] = \"UI\";\n})(Layer || (Layer = {}));\nconst Fl = Flag.fl;\nexport var Entity;\n(function (Entity) {\n    // L_DYNAMIC = Fl(0), // for movable things like actors or items\n    Entity[Entity[\"L_SUPERPRIORITY\"] = Fl(1)] = \"L_SUPERPRIORITY\";\n    Entity[Entity[\"L_SECRETLY_PASSABLE\"] = Fl(2)] = \"L_SECRETLY_PASSABLE\";\n    Entity[Entity[\"L_BLOCKS_MOVE\"] = Fl(3)] = \"L_BLOCKS_MOVE\";\n    Entity[Entity[\"L_BLOCKS_VISION\"] = Fl(4)] = \"L_BLOCKS_VISION\";\n    Entity[Entity[\"L_BLOCKS_SURFACE\"] = Fl(6)] = \"L_BLOCKS_SURFACE\";\n    Entity[Entity[\"L_BLOCKS_LIQUID\"] = Fl(8)] = \"L_BLOCKS_LIQUID\";\n    Entity[Entity[\"L_BLOCKS_GAS\"] = Fl(7)] = \"L_BLOCKS_GAS\";\n    Entity[Entity[\"L_BLOCKS_ITEMS\"] = Fl(5)] = \"L_BLOCKS_ITEMS\";\n    Entity[Entity[\"L_BLOCKS_ACTORS\"] = Fl(11)] = \"L_BLOCKS_ACTORS\";\n    Entity[Entity[\"L_BLOCKS_EFFECTS\"] = Fl(9)] = \"L_BLOCKS_EFFECTS\";\n    Entity[Entity[\"L_BLOCKS_DIAGONAL\"] = Fl(10)] = \"L_BLOCKS_DIAGONAL\";\n    Entity[Entity[\"L_INTERRUPT_WHEN_SEEN\"] = Fl(11)] = \"L_INTERRUPT_WHEN_SEEN\";\n    Entity[Entity[\"L_LIST_IN_SIDEBAR\"] = Fl(12)] = \"L_LIST_IN_SIDEBAR\";\n    Entity[Entity[\"L_VISUALLY_DISTINCT\"] = Fl(13)] = \"L_VISUALLY_DISTINCT\";\n    Entity[Entity[\"L_BRIGHT_MEMORY\"] = Fl(14)] = \"L_BRIGHT_MEMORY\";\n    Entity[Entity[\"L_INVERT_WHEN_HIGHLIGHTED\"] = Fl(15)] = \"L_INVERT_WHEN_HIGHLIGHTED\";\n    Entity[Entity[\"L_BLOCKED_BY_STAIRS\"] = Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_SURFACE |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_ACTORS] = \"L_BLOCKED_BY_STAIRS\";\n    Entity[Entity[\"L_BLOCKS_SCENT\"] = Entity.L_BLOCKS_MOVE | Entity.L_BLOCKS_VISION] = \"L_BLOCKS_SCENT\";\n    Entity[Entity[\"L_DIVIDES_LEVEL\"] = Entity.L_BLOCKS_MOVE] = \"L_DIVIDES_LEVEL\";\n    Entity[Entity[\"L_WAYPOINT_BLOCKER\"] = Entity.L_BLOCKS_MOVE] = \"L_WAYPOINT_BLOCKER\";\n    Entity[Entity[\"L_IS_WALL\"] = Entity.L_BLOCKS_MOVE |\n        Entity.L_BLOCKS_VISION |\n        Entity.L_BLOCKS_LIQUID |\n        Entity.L_BLOCKS_GAS |\n        Entity.L_BLOCKS_EFFECTS |\n        Entity.L_BLOCKS_DIAGONAL] = \"L_IS_WALL\";\n    Entity[Entity[\"L_BLOCKS_EVERYTHING\"] = Entity.L_IS_WALL |\n        Entity.L_BLOCKS_ITEMS |\n        Entity.L_BLOCKS_ACTORS |\n        Entity.L_BLOCKS_SURFACE] = \"L_BLOCKS_EVERYTHING\";\n})(Entity || (Entity = {}));\n///////////////////////////////////////////////////////\n// TILE EVENT\nexport var Activation;\n(function (Activation) {\n    Activation[Activation[\"DFF_SUBSEQ_ALWAYS\"] = Fl(0)] = \"DFF_SUBSEQ_ALWAYS\";\n    Activation[Activation[\"DFF_SUBSEQ_EVERYWHERE\"] = Fl(1)] = \"DFF_SUBSEQ_EVERYWHERE\";\n    Activation[Activation[\"DFF_TREAT_AS_BLOCKING\"] = Fl(2)] = \"DFF_TREAT_AS_BLOCKING\";\n    Activation[Activation[\"DFF_PERMIT_BLOCKING\"] = Fl(3)] = \"DFF_PERMIT_BLOCKING\";\n    Activation[Activation[\"DFF_BLOCKED_BY_OTHER_LAYERS\"] = Fl(4)] = \"DFF_BLOCKED_BY_OTHER_LAYERS\";\n    Activation[Activation[\"DFF_SUPERPRIORITY\"] = Fl(5)] = \"DFF_SUPERPRIORITY\";\n    Activation[Activation[\"DFF_NO_REDRAW_CELL\"] = Fl(6)] = \"DFF_NO_REDRAW_CELL\";\n    Activation[Activation[\"DFF_ABORT_IF_BLOCKS_MAP\"] = Fl(7)] = \"DFF_ABORT_IF_BLOCKS_MAP\";\n    Activation[Activation[\"DFF_BLOCKED_BY_ITEMS\"] = Fl(8)] = \"DFF_BLOCKED_BY_ITEMS\";\n    Activation[Activation[\"DFF_BLOCKED_BY_ACTORS\"] = Fl(9)] = \"DFF_BLOCKED_BY_ACTORS\";\n    Activation[Activation[\"DFF_ALWAYS_FIRE\"] = Fl(10)] = \"DFF_ALWAYS_FIRE\";\n    Activation[Activation[\"DFF_NO_MARK_FIRED\"] = Fl(11)] = \"DFF_NO_MARK_FIRED\";\n    // MUST_REPLACE_LAYER\n    // NEEDS_EMPTY_LAYER\n    Activation[Activation[\"DFF_PROTECTED\"] = Fl(12)] = \"DFF_PROTECTED\";\n    Activation[Activation[\"DFF_SPREAD_CIRCLE\"] = Fl(13)] = \"DFF_SPREAD_CIRCLE\";\n    Activation[Activation[\"DFF_SPREAD_LINE\"] = Fl(14)] = \"DFF_SPREAD_LINE\";\n    Activation[Activation[\"DFF_NULL_SURFACE\"] = Fl(15)] = \"DFF_NULL_SURFACE\";\n    Activation[Activation[\"DFF_NULL_LIQUID\"] = Fl(16)] = \"DFF_NULL_LIQUID\";\n    Activation[Activation[\"DFF_NULL_GAS\"] = Fl(17)] = \"DFF_NULL_GAS\";\n    Activation[Activation[\"DFF_EVACUATE_CREATURES\"] = Fl(18)] = \"DFF_EVACUATE_CREATURES\";\n    Activation[Activation[\"DFF_EVACUATE_ITEMS\"] = Fl(19)] = \"DFF_EVACUATE_ITEMS\";\n    Activation[Activation[\"DFF_BUILD_IN_WALLS\"] = Fl(20)] = \"DFF_BUILD_IN_WALLS\";\n    Activation[Activation[\"DFF_MUST_TOUCH_WALLS\"] = Fl(21)] = \"DFF_MUST_TOUCH_WALLS\";\n    Activation[Activation[\"DFF_NO_TOUCH_WALLS\"] = Fl(22)] = \"DFF_NO_TOUCH_WALLS\";\n    // These should be effect types\n    Activation[Activation[\"DFF_ACTIVATE_DORMANT_MONSTER\"] = Fl(23)] = \"DFF_ACTIVATE_DORMANT_MONSTER\";\n    Activation[Activation[\"DFF_AGGRAVATES_MONSTERS\"] = Fl(24)] = \"DFF_AGGRAVATES_MONSTERS\";\n    Activation[Activation[\"DFF_RESURRECT_ALLY\"] = Fl(25)] = \"DFF_RESURRECT_ALLY\";\n    Activation[Activation[\"DFF_EMIT_EVENT\"] = Fl(26)] = \"DFF_EMIT_EVENT\";\n    Activation[Activation[\"DFF_ONLY_IF_EMPTY\"] = Activation.DFF_BLOCKED_BY_ITEMS | Activation.DFF_BLOCKED_BY_ACTORS] = \"DFF_ONLY_IF_EMPTY\";\n    Activation[Activation[\"DFF_NULLIFY_CELL\"] = Activation.DFF_NULL_SURFACE | Activation.DFF_NULL_LIQUID | Activation.DFF_NULL_GAS] = \"DFF_NULLIFY_CELL\";\n})(Activation || (Activation = {}));\n///////////////////////////////////////////////////////\n// TILE\nexport var Tile;\n(function (Tile) {\n    Tile[Tile[\"T_BRIDGE\"] = Fl(0)] = \"T_BRIDGE\";\n    Tile[Tile[\"T_AUTO_DESCENT\"] = Fl(1)] = \"T_AUTO_DESCENT\";\n    Tile[Tile[\"T_LAVA\"] = Fl(2)] = \"T_LAVA\";\n    Tile[Tile[\"T_DEEP_WATER\"] = Fl(3)] = \"T_DEEP_WATER\";\n    Tile[Tile[\"T_IS_FLAMMABLE\"] = Fl(4)] = \"T_IS_FLAMMABLE\";\n    Tile[Tile[\"T_SPONTANEOUSLY_IGNITES\"] = Fl(5)] = \"T_SPONTANEOUSLY_IGNITES\";\n    Tile[Tile[\"T_IS_FIRE\"] = Fl(6)] = \"T_IS_FIRE\";\n    Tile[Tile[\"T_EXTINGUISHES_FIRE\"] = Fl(7)] = \"T_EXTINGUISHES_FIRE\";\n    Tile[Tile[\"T_IS_SECRET\"] = Fl(8)] = \"T_IS_SECRET\";\n    Tile[Tile[\"T_IS_TRAP\"] = Fl(9)] = \"T_IS_TRAP\";\n    Tile[Tile[\"T_SACRED\"] = Fl(10)] = \"T_SACRED\";\n    Tile[Tile[\"T_UP_STAIRS\"] = Fl(11)] = \"T_UP_STAIRS\";\n    Tile[Tile[\"T_DOWN_STAIRS\"] = Fl(12)] = \"T_DOWN_STAIRS\";\n    Tile[Tile[\"T_PORTAL\"] = Fl(13)] = \"T_PORTAL\";\n    Tile[Tile[\"T_IS_DOOR\"] = Fl(14)] = \"T_IS_DOOR\";\n    Tile[Tile[\"T_ALLOWS_SUBMERGING\"] = Fl(15)] = \"T_ALLOWS_SUBMERGING\";\n    Tile[Tile[\"T_ENTANGLES\"] = Fl(16)] = \"T_ENTANGLES\";\n    Tile[Tile[\"T_REFLECTS\"] = Fl(17)] = \"T_REFLECTS\";\n    Tile[Tile[\"T_STAND_IN_TILE\"] = Fl(18)] = \"T_STAND_IN_TILE\";\n    Tile[Tile[\"T_CONNECTS_LEVEL\"] = Fl(19)] = \"T_CONNECTS_LEVEL\";\n    Tile[Tile[\"T_HAS_STAIRS\"] = Tile.T_UP_STAIRS | Tile.T_DOWN_STAIRS | Tile.T_PORTAL] = \"T_HAS_STAIRS\";\n    Tile[Tile[\"T_OBSTRUCTS_SCENT\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_HAS_STAIRS] = \"T_OBSTRUCTS_SCENT\";\n    Tile[Tile[\"T_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_IS_FIRE |\n        Tile.T_SPONTANEOUSLY_IGNITES |\n        Tile.T_ENTANGLES] = \"T_PATHING_BLOCKER\";\n    Tile[Tile[\"T_DIVIDES_LEVEL\"] = Tile.T_AUTO_DESCENT | Tile.T_IS_TRAP | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_DIVIDES_LEVEL\";\n    Tile[Tile[\"T_LAKE_PATHING_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_LAKE_PATHING_BLOCKER\";\n    Tile[Tile[\"T_WAYPOINT_BLOCKER\"] = Tile.T_AUTO_DESCENT |\n        Tile.T_IS_TRAP |\n        Tile.T_LAVA |\n        Tile.T_DEEP_WATER |\n        Tile.T_SPONTANEOUSLY_IGNITES] = \"T_WAYPOINT_BLOCKER\";\n    Tile[Tile[\"T_MOVES_ITEMS\"] = Tile.T_DEEP_WATER | Tile.T_LAVA] = \"T_MOVES_ITEMS\";\n    Tile[Tile[\"T_CAN_BE_BRIDGED\"] = Tile.T_AUTO_DESCENT | Tile.T_LAVA | Tile.T_DEEP_WATER] = \"T_CAN_BE_BRIDGED\";\n    // T_HARMFUL_TERRAIN = T_CAUSES_POISON |\n    //   T_IS_FIRE |\n    //   T_CAUSES_DAMAGE |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_EXPLOSIVE_DAMAGE,\n    // T_RESPIRATION_IMMUNITIES = T_CAUSES_DAMAGE |\n    //   T_CAUSES_CONFUSION |\n    //   T_CAUSES_PARALYSIS |\n    //   T_CAUSES_NAUSEA,\n    Tile[Tile[\"T_IS_DEEP_LIQUID\"] = Tile.T_LAVA | Tile.T_AUTO_DESCENT | Tile.T_DEEP_WATER] = \"T_IS_DEEP_LIQUID\";\n})(Tile || (Tile = {}));\n///////////////////////////////////////////////////////\n// TILE MECH\nexport var TileMech;\n(function (TileMech) {\n    // TM_PROMOTES_WITH_KEY = Fl(1), // promotes if the key is present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_WITHOUT_KEY = Fl(2), // promotes if the key is NOT present on the tile (in your pack, carried by monster, or lying on the ground)\n    // TM_PROMOTES_ON_STEP = Fl(3), // promotes when a creature, player or item is on the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ITEM_REMOVE = Fl(4), // promotes when an item is lifted from the tile (primarily for altars)\n    // TM_PROMOTES_ON_PLAYER_ENTRY = Fl(5), // promotes when the player enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_SACRIFICE_ENTRY = Fl(6), // promotes when the sacrifice target enters the tile (whether or not levitating)\n    // TM_PROMOTES_ON_ELECTRICITY = Fl(7), // promotes when hit by a lightning bolt\n    // T_CAUSES_POISON = Fl(18), // any non-levitating creature gets 10 poison\n    // T_CAUSES_DAMAGE = Fl(19), // anything on the tile takes max(1-2, 10%) damage per turn\n    // T_CAUSES_NAUSEA = Fl(20), // any creature on the tile becomes nauseous\n    // T_CAUSES_PARALYSIS = Fl(21), // anything caught on this tile is paralyzed\n    // T_CAUSES_CONFUSION = Fl(22), // causes creatures on this tile to become confused\n    // T_CAUSES_HEALING = Fl(23), // heals 20% max HP per turn for any player or non-inanimate monsters\n    // T_CAUSES_EXPLOSIVE_DAMAGE = Fl(25), // is an explosion; deals higher of 15-20 or 50% damage instantly, but not again for five turns\n    TileMech[TileMech[\"TM_IS_WIRED\"] = Fl(9)] = \"TM_IS_WIRED\";\n    TileMech[TileMech[\"TM_IS_CIRCUIT_BREAKER\"] = Fl(10)] = \"TM_IS_CIRCUIT_BREAKER\";\n    TileMech[TileMech[\"TM_VANISHES_UPON_PROMOTION\"] = Fl(15)] = \"TM_VANISHES_UPON_PROMOTION\";\n    TileMech[TileMech[\"TM_EXPLOSIVE_PROMOTE\"] = Fl(21)] = \"TM_EXPLOSIVE_PROMOTE\";\n    TileMech[TileMech[\"TM_SWAP_ENCHANTS_ACTIVATION\"] = Fl(25)] = \"TM_SWAP_ENCHANTS_ACTIVATION\";\n    // TM_PROMOTES = TM_PROMOTES_WITH_KEY |\n    //   TM_PROMOTES_WITHOUT_KEY |\n    //   TM_PROMOTES_ON_STEP |\n    //   TM_PROMOTES_ON_ITEM_REMOVE |\n    //   TM_PROMOTES_ON_SACRIFICE_ENTRY |\n    //   TM_PROMOTES_ON_ELECTRICITY |\n    //   TM_PROMOTES_ON_PLAYER_ENTRY,\n})(TileMech || (TileMech = {}));\n///////////////////////////////////////////////////////\n// CELL\nexport var Cell;\n(function (Cell) {\n    Cell[Cell[\"VISIBLE\"] = Fl(0)] = \"VISIBLE\";\n    Cell[Cell[\"WAS_VISIBLE\"] = Fl(1)] = \"WAS_VISIBLE\";\n    Cell[Cell[\"CLAIRVOYANT_VISIBLE\"] = Fl(2)] = \"CLAIRVOYANT_VISIBLE\";\n    Cell[Cell[\"WAS_CLAIRVOYANT_VISIBLE\"] = Fl(3)] = \"WAS_CLAIRVOYANT_VISIBLE\";\n    Cell[Cell[\"TELEPATHIC_VISIBLE\"] = Fl(4)] = \"TELEPATHIC_VISIBLE\";\n    Cell[Cell[\"WAS_TELEPATHIC_VISIBLE\"] = Fl(5)] = \"WAS_TELEPATHIC_VISIBLE\";\n    Cell[Cell[\"ITEM_DETECTED\"] = Fl(6)] = \"ITEM_DETECTED\";\n    Cell[Cell[\"WAS_ITEM_DETECTED\"] = Fl(7)] = \"WAS_ITEM_DETECTED\";\n    Cell[Cell[\"MONSTER_DETECTED\"] = Fl(8)] = \"MONSTER_DETECTED\";\n    Cell[Cell[\"WAS_MONSTER_DETECTED\"] = Fl(9)] = \"WAS_MONSTER_DETECTED\";\n    Cell[Cell[\"REVEALED\"] = Fl(10)] = \"REVEALED\";\n    Cell[Cell[\"MAGIC_MAPPED\"] = Fl(11)] = \"MAGIC_MAPPED\";\n    Cell[Cell[\"IN_FOV\"] = Fl(12)] = \"IN_FOV\";\n    Cell[Cell[\"WAS_IN_FOV\"] = Fl(13)] = \"WAS_IN_FOV\";\n    Cell[Cell[\"NEEDS_REDRAW\"] = Fl(14)] = \"NEEDS_REDRAW\";\n    Cell[Cell[\"CELL_CHANGED\"] = Fl(15)] = \"CELL_CHANGED\";\n    // These are to help memory\n    Cell[Cell[\"HAS_SURFACE\"] = Fl(16)] = \"HAS_SURFACE\";\n    Cell[Cell[\"HAS_LIQUID\"] = Fl(17)] = \"HAS_LIQUID\";\n    Cell[Cell[\"HAS_GAS\"] = Fl(18)] = \"HAS_GAS\";\n    Cell[Cell[\"HAS_PLAYER\"] = Fl(19)] = \"HAS_PLAYER\";\n    Cell[Cell[\"HAS_ACTOR\"] = Fl(20)] = \"HAS_ACTOR\";\n    Cell[Cell[\"HAS_DORMANT_MONSTER\"] = Fl(21)] = \"HAS_DORMANT_MONSTER\";\n    Cell[Cell[\"HAS_ITEM\"] = Fl(22)] = \"HAS_ITEM\";\n    Cell[Cell[\"IS_IN_PATH\"] = Fl(23)] = \"IS_IN_PATH\";\n    Cell[Cell[\"IS_CURSOR\"] = Fl(24)] = \"IS_CURSOR\";\n    Cell[Cell[\"STABLE_MEMORY\"] = Fl(25)] = \"STABLE_MEMORY\";\n    Cell[Cell[\"LIGHT_CHANGED\"] = Fl(26)] = \"LIGHT_CHANGED\";\n    Cell[Cell[\"CELL_LIT\"] = Fl(27)] = \"CELL_LIT\";\n    Cell[Cell[\"IS_IN_SHADOW\"] = Fl(28)] = \"IS_IN_SHADOW\";\n    Cell[Cell[\"CELL_DARK\"] = Fl(29)] = \"CELL_DARK\";\n    Cell[Cell[\"COLORS_DANCE\"] = Fl(30)] = \"COLORS_DANCE\";\n    Cell[Cell[\"PERMANENT_CELL_FLAGS\"] = Cell.REVEALED |\n        Cell.MAGIC_MAPPED |\n        Cell.ITEM_DETECTED |\n        Cell.HAS_ITEM |\n        Cell.HAS_DORMANT_MONSTER |\n        Cell.STABLE_MEMORY] = \"PERMANENT_CELL_FLAGS\";\n    Cell[Cell[\"ANY_KIND_OF_VISIBLE\"] = Cell.VISIBLE | Cell.CLAIRVOYANT_VISIBLE | Cell.TELEPATHIC_VISIBLE] = \"ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"HAS_ANY_ACTOR\"] = Cell.HAS_PLAYER | Cell.HAS_ACTOR] = \"HAS_ANY_ACTOR\";\n    Cell[Cell[\"IS_WAS_ANY_KIND_OF_VISIBLE\"] = Cell.VISIBLE |\n        Cell.WAS_VISIBLE |\n        Cell.CLAIRVOYANT_VISIBLE |\n        Cell.WAS_CLAIRVOYANT_VISIBLE |\n        Cell.TELEPATHIC_VISIBLE |\n        Cell.WAS_TELEPATHIC_VISIBLE] = \"IS_WAS_ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"WAS_ANY_KIND_OF_VISIBLE\"] = Cell.WAS_VISIBLE |\n        Cell.WAS_CLAIRVOYANT_VISIBLE |\n        Cell.WAS_TELEPATHIC_VISIBLE] = \"WAS_ANY_KIND_OF_VISIBLE\";\n    Cell[Cell[\"CELL_DEFAULT\"] = Cell.VISIBLE | Cell.IN_FOV | Cell.NEEDS_REDRAW | Cell.CELL_CHANGED] = \"CELL_DEFAULT\";\n})(Cell || (Cell = {}));\n///////////////////////////////////////////////////////\n// CELL MECH\nexport var CellMech;\n(function (CellMech) {\n    CellMech[CellMech[\"SEARCHED_FROM_HERE\"] = Fl(0)] = \"SEARCHED_FROM_HERE\";\n    CellMech[CellMech[\"PRESSURE_PLATE_DEPRESSED\"] = Fl(1)] = \"PRESSURE_PLATE_DEPRESSED\";\n    CellMech[CellMech[\"KNOWN_TO_BE_TRAP_FREE\"] = Fl(2)] = \"KNOWN_TO_BE_TRAP_FREE\";\n    CellMech[CellMech[\"CAUGHT_FIRE_THIS_TURN\"] = Fl(4)] = \"CAUGHT_FIRE_THIS_TURN\";\n    CellMech[CellMech[\"EVENT_FIRED_THIS_TURN\"] = Fl(5)] = \"EVENT_FIRED_THIS_TURN\";\n    CellMech[CellMech[\"EVENT_PROTECTED\"] = Fl(6)] = \"EVENT_PROTECTED\";\n    CellMech[CellMech[\"IS_IN_LOOP\"] = Fl(10)] = \"IS_IN_LOOP\";\n    CellMech[CellMech[\"IS_CHOKEPOINT\"] = Fl(11)] = \"IS_CHOKEPOINT\";\n    CellMech[CellMech[\"IS_GATE_SITE\"] = Fl(12)] = \"IS_GATE_SITE\";\n    CellMech[CellMech[\"IS_IN_ROOM_MACHINE\"] = Fl(13)] = \"IS_IN_ROOM_MACHINE\";\n    CellMech[CellMech[\"IS_IN_AREA_MACHINE\"] = Fl(14)] = \"IS_IN_AREA_MACHINE\";\n    CellMech[CellMech[\"IS_POWERED\"] = Fl(15)] = \"IS_POWERED\";\n    CellMech[CellMech[\"IMPREGNABLE\"] = Fl(20)] = \"IMPREGNABLE\";\n    CellMech[CellMech[\"DARKENED\"] = Fl(19)] = \"DARKENED\";\n    CellMech[CellMech[\"IS_IN_MACHINE\"] = CellMech.IS_IN_ROOM_MACHINE | CellMech.IS_IN_AREA_MACHINE] = \"IS_IN_MACHINE\";\n    CellMech[CellMech[\"PERMANENT_MECH_FLAGS\"] = CellMech.SEARCHED_FROM_HERE |\n        CellMech.PRESSURE_PLATE_DEPRESSED |\n        CellMech.KNOWN_TO_BE_TRAP_FREE |\n        CellMech.IS_IN_LOOP |\n        CellMech.IS_CHOKEPOINT |\n        CellMech.IS_GATE_SITE |\n        CellMech.IS_IN_MACHINE |\n        CellMech.IMPREGNABLE] = \"PERMANENT_MECH_FLAGS\";\n})(CellMech || (CellMech = {}));\n///////////////////////////////////////////////////////\n// MAP\nexport var Map;\n(function (Map) {\n    Map[Map[\"MAP_CHANGED\"] = Fl(0)] = \"MAP_CHANGED\";\n    Map[Map[\"MAP_STABLE_GLOW_LIGHTS\"] = Fl(1)] = \"MAP_STABLE_GLOW_LIGHTS\";\n    Map[Map[\"MAP_STABLE_LIGHTS\"] = Fl(2)] = \"MAP_STABLE_LIGHTS\";\n    Map[Map[\"MAP_ALWAYS_LIT\"] = Fl(3)] = \"MAP_ALWAYS_LIT\";\n    Map[Map[\"MAP_SAW_WELCOME\"] = Fl(4)] = \"MAP_SAW_WELCOME\";\n    Map[Map[\"MAP_NO_LIQUID\"] = Fl(5)] = \"MAP_NO_LIQUID\";\n    Map[Map[\"MAP_NO_GAS\"] = Fl(6)] = \"MAP_NO_GAS\";\n    Map[Map[\"MAP_CALC_FOV\"] = Fl(7)] = \"MAP_CALC_FOV\";\n    Map[Map[\"MAP_FOV_CHANGED\"] = Fl(8)] = \"MAP_FOV_CHANGED\";\n    Map[Map[\"MAP_DANCES\"] = Fl(9)] = \"MAP_DANCES\";\n    Map[Map[\"MAP_DEFAULT\"] = Map.MAP_STABLE_LIGHTS | Map.MAP_STABLE_GLOW_LIGHTS] = \"MAP_DEFAULT\";\n})(Map || (Map = {}));\n","import { utils as Utils, range as Range, grid as Grid, color as Color, data as DATA, config as CONFIG, make as Make, } from 'gw-utils';\nimport * as Flags from './mapFlags';\n// const LIGHT_SMOOTHING_THRESHOLD = 150;       // light components higher than this magnitude will be toned down a little\nexport const config = (CONFIG.light = { INTENSITY_DARK: 20 }); // less than 20% for highest color in rgb\nconst LIGHT_COMPONENTS = Color.make();\nexport class Light {\n    constructor(color, range, fadeTo, pass = false) {\n        this.fadeTo = 0;\n        this.passThroughActors = false;\n        this.id = null;\n        this.color = Color.from(color) || null; /* color */\n        this.radius = Range.make(range || 1);\n        this.fadeTo = fadeTo || 0;\n        this.passThroughActors = pass; // generally no, but miner light does (TODO - string parameter?  'false' or 'true')\n    }\n    copy(other) {\n        this.color = other.color;\n        this.radius.copy(other.radius);\n        this.fadeTo = other.fadeTo;\n        this.passThroughActors = other.passThroughActors;\n    }\n    get intensity() {\n        return intensity(this.color);\n    }\n    // Returns true if any part of the light hit cells that are in the player's field of view.\n    paint(map, x, y, maintainShadows = false, isMinersLight = false) {\n        if (!map)\n            return false;\n        let k;\n        // let colorComponents = [0,0,0];\n        let lightMultiplier;\n        let radius = this.radius.value();\n        let outerRadius = Math.ceil(radius);\n        // calcLightComponents(colorComponents, this);\n        LIGHT_COMPONENTS.copy(this.color).bake();\n        // console.log('paint', LIGHT_COMPONENTS.toString(true), x, y, outerRadius);\n        // the miner's light does not dispel IS_IN_SHADOW,\n        // so the player can be in shadow despite casting his own light.\n        const dispelShadows = !isMinersLight &&\n            !maintainShadows &&\n            intensity(LIGHT_COMPONENTS) > config.INTENSITY_DARK;\n        const fadeToPercent = this.fadeTo;\n        const grid = Grid.alloc(map.width, map.height, 0);\n        map.calcFov(grid, x, y, outerRadius, this.passThroughActors ? 0 : Flags.Cell.HAS_ANY_ACTOR, Flags.Entity.L_BLOCKS_VISION);\n        let overlappedFieldOfView = false;\n        grid.forCircle(x, y, outerRadius, (v, i, j) => {\n            if (!v)\n                return;\n            const cell = map.cell(i, j);\n            lightMultiplier = Math.floor(100 -\n                (100 - fadeToPercent) *\n                    (Utils.distanceBetween(x, y, i, j) / radius));\n            for (k = 0; k < 3; k++) {\n                cell.light[k] += Math.floor((LIGHT_COMPONENTS[k] * lightMultiplier) / 100);\n            }\n            if (dispelShadows) {\n                cell.flags.cell &= ~Flags.Cell.IS_IN_SHADOW;\n            }\n            if (cell.flags.cell &\n                (Flags.Cell.IN_FOV | Flags.Cell.ANY_KIND_OF_VISIBLE)) {\n                overlappedFieldOfView = true;\n            }\n            // console.log(i, j, lightMultiplier, cell.light);\n        });\n        if (dispelShadows) {\n            const cell = map.cell(x, y);\n            cell.flags.cell &= ~Flags.Cell.IS_IN_SHADOW;\n        }\n        Grid.free(grid);\n        return overlappedFieldOfView;\n    }\n}\nexport function intensity(color) {\n    return Math.max(color[0], color[1], color[2]);\n}\nexport function make(...args) {\n    if (args.length == 1) {\n        const config = args[0];\n        if (typeof config === 'string') {\n            const cached = lights[config];\n            if (cached)\n                return cached;\n            const [color, radius, fadeTo, pass] = config\n                .split(/[,|]/)\n                .map((t) => t.trim());\n            return new Light(Color.from(color), Range.from(radius || 1), Number.parseInt(fadeTo || '0'), !!pass && pass !== 'false');\n        }\n        else if (Array.isArray(config)) {\n            const [color, radius, fadeTo, pass] = config;\n            return new Light(color, radius, fadeTo, pass);\n        }\n        else if (config && config.color) {\n            return new Light(Color.from(config.color), Range.from(config.radius), Number.parseInt(config.fadeTo || '0'), config.pass);\n        }\n        else {\n            throw new Error('Unknown Light config - ' + config);\n        }\n    }\n    else {\n        const [color, radius, fadeTo, pass] = args;\n        return new Light(color, radius, fadeTo, pass);\n    }\n}\nMake.light = make;\nexport const lights = {};\nexport function from(...args) {\n    if (args.length != 1)\n        Utils.ERROR('Unknown Light config: ' + JSON.stringify(args));\n    const arg = args[0];\n    if (arg instanceof Light)\n        return arg;\n    if (typeof arg === 'string') {\n        const cached = lights[arg];\n        if (cached)\n            return cached;\n    }\n    return make(arg);\n}\nexport function install(id, ...args) {\n    let source;\n    if (args.length == 1) {\n        source = make(args[0]);\n    }\n    else {\n        source = make(args[0], args[1], args[2], args[3]);\n    }\n    lights[id] = source;\n    if (source)\n        source.id = id;\n    return source;\n}\nexport function installAll(config = {}) {\n    const entries = Object.entries(config);\n    entries.forEach(([name, info]) => {\n        install(name, info);\n    });\n}\n// export function calcLightComponents(colorComponents, theLight) {\n// \tconst randComponent = cosmetic.range(0, theLight.color.rand);\n// \tcolorComponents[0] = randComponent + theLight.color.red + cosmetic.range(0, theLight.color.redRand);\n// \tcolorComponents[1] = randComponent + theLight.color.green + cosmetic.range(0, theLight.color.greenRand);\n// \tcolorComponents[2] = randComponent + theLight.color.blue + cosmetic.range(0, theLight.color.blueRand);\n// }\nfunction updateDisplayDetail(map) {\n    map.eachCell((cell, _i, _j) => {\n        // clear light flags\n        cell.flags.cell &= ~(Flags.Cell.CELL_LIT | Flags.Cell.CELL_DARK);\n        if (cell.light.some((v, i) => v !== cell.oldLight[i])) {\n            cell.lightChanged = true;\n        }\n        if (cell.isDark()) {\n            cell.flags.cell |= Flags.Cell.CELL_DARK;\n        }\n        else if (!(cell.flags.cell & Flags.Cell.IS_IN_SHADOW)) {\n            cell.flags.cell |= Flags.Cell.CELL_LIT;\n        }\n    });\n}\n// export function backUpLighting(map: Map.Map, lights: LightDataGrid) {\n//   let k;\n//   map.eachCell((cell, i, j) => {\n//     for (k = 0; k < 3; k++) {\n//       lights[i][j][k] = cell.light[k];\n//     }\n//   });\n// }\n// export function restoreLighting(map: Map.Map, lights: LightDataGrid) {\n//   let k;\n//   map.eachCell((cell, i, j) => {\n//     for (k = 0; k < 3; k++) {\n//       cell.light[k] = lights[i][j][k];\n//     }\n//   });\n// }\nexport function recordOldLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.oldLight[k] = cell.light[k];\n            cell.lightChanged = false;\n        }\n    });\n}\nexport function zeroOutLights(map) {\n    let k;\n    const light = map.ambientLight ? map.ambientLight : [0, 0, 0];\n    map.eachCell((cell, _i, _j) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = light[k];\n        }\n        cell.flags.cell |= Flags.Cell.IS_IN_SHADOW;\n    });\n}\nexport function recordGlowLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.glowLight[k] = cell.light[k];\n        }\n    });\n}\nexport function restoreGlowLights(map) {\n    let k;\n    map.eachCell((cell) => {\n        for (k = 0; k < 3; k++) {\n            cell.light[k] = cell.glowLight[k];\n        }\n    });\n}\nexport function updateLighting(map) {\n    if (!map.anyLightChanged)\n        return false;\n    // Copy Light over oldLight\n    recordOldLights(map);\n    // and then zero out Light.\n    zeroOutLights(map);\n    if (!map.staticLightChanged) {\n        restoreGlowLights(map);\n    }\n    else {\n        // GW.debug.log('painting glow lights.');\n        // Paint all glowing tiles.\n        map.eachStaticLight((light, x, y) => {\n            //   const light = lights[id];\n            if (light) {\n                light.paint(map, x, y);\n            }\n        });\n        recordGlowLights(map);\n        map.staticLightChanged = false;\n    }\n    // Cycle through monsters and paint their lights:\n    map.eachDynamicLight((light, x, y) => {\n        light.paint(map, x, y);\n        // if (monst.mutationIndex >= 0 && mutationCatalog[monst.mutationIndex].light != lights['NO_LIGHT']) {\n        //     paint(map, mutationCatalog[monst.mutationIndex].light, actor.x, actor.y, false, false);\n        // }\n        // if (actor.isBurning()) { // monst.status.burning && !(actor.kind.flags & Flags.Actor.AF_FIERY)) {\n        // \tpaint(map, lights.BURNING_CREATURE, actor.x, actor.y, false, false);\n        // }\n        // if (actor.isTelepathicallyRevealed()) {\n        // \tpaint(map, lights['TELEPATHY_LIGHT'], actor.x, actor.y, false, true);\n        // }\n    });\n    // Also paint telepathy lights for dormant monsters.\n    // for (monst of map.dormantMonsters) {\n    //     if (monsterTelepathicallyRevealed(monst)) {\n    //         paint(map, lights['TELEPATHY_LIGHT'], monst.xLoc, monst.yLoc, false, true);\n    //     }\n    // }\n    updateDisplayDetail(map);\n    // Miner's light:\n    const PLAYER = DATA.player;\n    if (PLAYER) {\n        const PLAYERS_LIGHT = lights.PLAYERS_LIGHT;\n        if (PLAYERS_LIGHT && PLAYERS_LIGHT.radius) {\n            PLAYERS_LIGHT.paint(map, PLAYER.x, PLAYER.y, true, true);\n        }\n    }\n    map.anyLightChanged = false;\n    // if (PLAYER.status.invisible) {\n    //     PLAYER.info.foreColor = playerInvisibleColor;\n    // } else if (playerInDarkness()) {\n    // \tPLAYER.info.foreColor = playerInDarknessColor;\n    // } else if (pmap[PLAYER.xLoc][PLAYER.yLoc].flags & IS_IN_SHADOW) {\n    // \tPLAYER.info.foreColor = playerInShadowColor;\n    // } else {\n    // \tPLAYER.info.foreColor = playerInLightColor;\n    // }\n    return true;\n}\n// TODO - Move?\nexport function playerInDarkness(map, PLAYER, darkColor) {\n    const cell = map.cell(PLAYER.x, PLAYER.y);\n    return cell.isDark(darkColor);\n    // return (\n    //   cell.light[0] + 10 < darkColor.r &&\n    //   cell.light[1] + 10 < darkColor.g &&\n    //   cell.light[2] + 10 < darkColor.b\n    // );\n}\n","import * as GW from 'gw-utils';\nimport { Entity as Flags, Layer } from './mapFlags';\nimport * as Light from './light';\nexport { Flags, Layer };\nexport class Entity {\n    constructor(config) {\n        this.priority = 50;\n        this.layer = 0;\n        this.light = null;\n        this.flags = { layer: 0 };\n        this.sprite = GW.make.sprite(config.sprite || config);\n        this.light = config.light ? Light.make(config.light) : null;\n        this.priority = GW.utils.first(config.priority, 50);\n        this.layer =\n            (config.layer && typeof config.layer !== 'number'\n                ? Layer[config.layer]\n                : config.layer) || 0;\n        // @ts-ignore\n        this.flags.layer = GW.flag.from(Flags, config.layerFlags, config.flags, 0);\n    }\n    hasLayerFlag(flag) {\n        return (this.flags.layer & flag) > 0;\n    }\n}\nexport function make(config) {\n    return new Entity(config);\n}\nGW.make.layer = make;\n","import { flag as Flag, utils as Utils, color as Color, make as Make, effect as Effect, } from 'gw-utils';\nimport { Tile as Flags, TileMech as MechFlags } from './mapFlags';\nimport * as Layer from './entity';\nexport { Flags, MechFlags };\n/** Tile Class */\nexport class Tile extends Layer.Entity {\n    /**\n     * Creates a new Tile object.\n     * @param {Object} [config={}] - The configuration of the Tile\n     * @param {String|Number|String[]} [config.flags=0] - Flags and MechFlags for the tile\n     * @param {String} [config.layer=GROUND] - Name of the layer for this tile\n     * @param {String} [config.ch] - The sprite character\n     * @param {String} [config.fg] - The sprite foreground color\n     * @param {String} [config.bg] - The sprite background color\n     */\n    constructor(config) {\n        super((() => {\n            if (!config.Extends)\n                return config;\n            if (typeof config.Extends === 'string') {\n                config.Extends = tiles[config.Extends];\n                if (!config.Extends)\n                    throw new Error('Unknown tile base - ' + config.Extends);\n            }\n            const base = config.Extends;\n            config.ch = Utils.first(config.ch, base.sprite.ch, -1);\n            config.fg = Utils.first(config.fg, base.sprite.fg, -1);\n            config.bg = Utils.first(config.bg, base.sprite.bg, -1);\n            config.layer = Utils.first(config.layer, base.layer);\n            config.priority = Utils.first(config.priority, base.priority);\n            config.opacity = Utils.first(config.opacity, base.sprite.opacity);\n            config.light = Utils.first(config.light, base.light);\n            return config;\n        })());\n        this.flags = { layer: 0, tile: 0, tileMech: 0 };\n        this.effects = {};\n        this.flavor = null;\n        this.desc = null;\n        this.article = null;\n        this.dissipate = 2000; // 20 * 100 = 20%\n        this.defaultGround = null;\n        let base = config.Extends;\n        if (base) {\n            Utils.assignOmitting(['sprite', 'depth', 'priority', 'activates', 'flags', 'light'], this, base);\n            if (base.effects) {\n                Object.assign(this.effects, base.effects);\n            }\n            Object.assign(this.flags, base.flags);\n        }\n        Utils.assignOmitting([\n            'Extends',\n            'extends',\n            'flags',\n            'layerFlags',\n            'mechFlags',\n            'sprite',\n            'effects',\n            'ch',\n            'fg',\n            'bg',\n            'opacity',\n            'light',\n            'layer',\n            'priority',\n            'flags',\n            'ground',\n            'light',\n        ], this, config);\n        this.name = config.name || (base ? base.name : config.id);\n        this.id = config.id;\n        if (config.ground) {\n            this.defaultGround = config.ground;\n        }\n        // @ts-ignore\n        this.flags.tile = Flag.from(Flags, this.flags.tile, config.flags);\n        // @ts-ignore\n        this.flags.layer = Flag.from(Layer.Flags, this.flags.layer, config.layerFlags || config.flags);\n        // @ts-ignore\n        this.flags.tileMech = Flag.from(MechFlags, this.flags.tileMech, config.mechFlags || config.flags);\n        if (config.effects) {\n            Object.entries(config.effects).forEach(([key, info]) => {\n                if (info) {\n                    if (typeof info === 'string') {\n                        if (tiles[info]) {\n                            info = { tile: info };\n                        }\n                        else {\n                            this.effects[key] = info;\n                            return;\n                        }\n                    }\n                    const activation = Effect.make(info);\n                    this.effects[key] = activation;\n                }\n                else {\n                    delete this.effects[key];\n                }\n            });\n        }\n    }\n    /**\n     * Returns whether or not this tile as the given flag.\n     * Will return true if any bit in the flag is true, so testing with\n     * multiple flags will return true if any of them is set.\n     * @param {number} flag - The flag to check\n     * @returns {boolean} Whether or not the flag is set\n     */\n    hasAllFlags(flag) {\n        return (this.flags.tile & flag) === flag;\n    }\n    hasAllLayerFlags(flag) {\n        return (this.flags.layer & flag) === flag;\n    }\n    hasAllMechFlags(flag) {\n        return (this.flags.tileMech & flag) === flag;\n    }\n    blocksPathing() {\n        return (this.flags.layer & Layer.Flags.L_BLOCKS_MOVE ||\n            this.flags.tile & Flags.T_PATHING_BLOCKER);\n    }\n    hasEffect(name) {\n        return !!this.effects[name];\n    }\n    getName(arg) {\n        let opts = {};\n        if (arg === true || arg === false) {\n            opts.article = arg;\n        }\n        else if (typeof arg === 'string') {\n            opts.article = arg;\n        }\n        else if (arg) {\n            opts = arg;\n        }\n        if (!opts.article && !opts.color)\n            return this.name;\n        let result = this.name;\n        if (opts.color) {\n            let color = opts.color;\n            if (opts.color === true) {\n                color = this.sprite.fg || 'white';\n            }\n            if (typeof color !== 'string') {\n                color = Color.from(color).toString();\n            }\n            result = `Ω${color}Ω${this.name}∆`;\n        }\n        if (opts.article) {\n            let article = typeof opts.article === 'string'\n                ? opts.article\n                : this.article || 'a';\n            result = article + ' ' + result;\n        }\n        return result;\n    }\n    getDescription(opts = {}) {\n        return this.getName(opts);\n    }\n}\n// Types.Tile = Tile;\nexport function make(config) {\n    return new Tile(config);\n}\nMake.tile = make;\nexport const tiles = {};\nexport function install(...args) {\n    let id = args[0];\n    let base = args[1];\n    let config = args[2];\n    if (arguments.length == 1) {\n        config = args[0];\n        base = config.Extends || null;\n        id = config.id;\n    }\n    else if (arguments.length == 2) {\n        config = base;\n    }\n    if (typeof base === 'string') {\n        config.Extends =\n            tiles[base] || Utils.ERROR('Unknown base tile: ' + base);\n    }\n    // config.name = config.name || base.name || id.toLowerCase();\n    config.id = id;\n    const tile = make(config);\n    tiles[id] = tile;\n    return tile;\n}\n/**\n * Adds multiple tiles to the GW.tiles collection.\n * It extracts all the id:opts pairs from the config object and uses\n * them to call addTileKind.\n * @param {Object} config - The tiles to add in [id, config] pairs\n * @returns {void} Nothing\n * @see addTileKind\n */\nexport function installAll(config) {\n    Object.entries(config).forEach(([id, opts]) => {\n        opts.id = id;\n        install(id, opts);\n    });\n}\n","import { color as Color, sprite as Sprite, utils as Utils, config as CONFIG, data as DATA, random, make as Make, effect as Effect, } from 'gw-utils';\nimport { Tile, tiles as TILES } from './tile';\nimport * as Light from './light';\nimport { Cell as Flags, CellMech as MechFlags, Tile as TileFlags, Map as MapFlags, Entity as LayerFlags, Layer, } from './mapFlags';\nexport { Flags, MechFlags };\n// TODO - Move to gw-ui\nColor.install('cursorColor', 25, 100, 150);\nCONFIG.cursorPathIntensity = 50;\nexport class CellMemory {\n    // public cellFlags = 0;\n    // public cellMechFlags = 0;\n    // public layerFlags = 0;\n    // public tileFlags = 0;\n    // public tileMechFlags = 0;\n    constructor() {\n        this.mixer = new Sprite.Mixer();\n        this.item = null;\n        this.itemQuantity = 0;\n        this.actor = null;\n        this.tile = null;\n        this.flags = {\n            cell: 0,\n            cellMech: 0,\n            layer: 0,\n            tile: 0,\n            tileMech: 0,\n        };\n    }\n    clear() {\n        this.mixer.nullify();\n        this.item = null;\n        this.itemQuantity = 0;\n        this.actor = null;\n        this.tile = null;\n        this.flags.cell = 0;\n        this.flags.cellMech = 0;\n        this.flags.layer = 0;\n        this.flags.tile = 0;\n        this.flags.tileMech = 0;\n    }\n    copy(other) {\n        const mixer = this.mixer;\n        Object.assign(this, other);\n        this.mixer = mixer;\n        this.mixer.copy(other.mixer);\n    }\n}\nexport class Cell {\n    constructor() {\n        this._tiles = [];\n        this.layers = null;\n        this._actor = null;\n        this._item = null;\n        this.data = {};\n        this.flags = { cell: Flags.CELL_DEFAULT, cellMech: 0 };\n        this.gasVolume = 0; // quantity of gas in cell\n        this.liquidVolume = 0;\n        this.machineNumber = 0;\n        this.memory = new CellMemory();\n        this.light = [100, 100, 100];\n        this.oldLight = [100, 100, 100];\n        this.glowLight = [100, 100, 100];\n        this.chokeCount = 0;\n    }\n    copy(other) {\n        Utils.copyObject(this, other);\n    }\n    nullify() {\n        for (let i = 0; i < this._tiles.length; ++i) {\n            this._tiles[i] = null;\n        }\n        this.layers = null;\n        this._actor = null;\n        this._item = null;\n        this.data = {};\n        this.flags.cell = Flags.CELL_DEFAULT; // non-terrain cell flags\n        this.flags.cellMech = 0;\n        this.gasVolume = 0; // quantity of gas in cell\n        this.liquidVolume = 0;\n        this.machineNumber = 0;\n        this.memory.clear();\n        this.light = [100, 100, 100];\n        this.oldLight = [100, 100, 100];\n        this.glowLight = [100, 100, 100];\n        this.chokeCount = 0;\n    }\n    clear(floorTile = 'FLOOR') {\n        this.nullify();\n        if (typeof floorTile === 'string') {\n            floorTile = TILES[floorTile];\n        }\n        if (floorTile) {\n            this._tiles[0] = floorTile;\n        }\n    }\n    clearLayers(layerFlag, floorTile = 'FLOOR') {\n        const layers = [Layer.GAS, Layer.LIQUID, Layer.SURFACE, Layer.GROUND];\n        return layers.reduce((out, l) => {\n            if (l & layerFlag) {\n                return this.clearLayer(l, floorTile) || out;\n            }\n            return out;\n        }, false);\n    }\n    // clearLayers(nullLiquid = false, nullSurface = false, nullGas = false) {\n    //     if (nullLiquid) {\n    //         this._tiles[1] = null;\n    //         this.liquidVolume = 0;\n    //     }\n    //     if (nullSurface) {\n    //         this._tiles[2] = null;\n    //     }\n    //     if (nullGas) {\n    //         this._tiles[3] = null;\n    //         this.gasVolume = 0;\n    //     }\n    //     this.flags.cell |= Flags.CELL_CHANGED;\n    // }\n    get ground() {\n        var _a;\n        return ((_a = this._tiles[Layer.GROUND]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get liquid() {\n        var _a;\n        return ((_a = this._tiles[Layer.LIQUID]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get surface() {\n        var _a;\n        return ((_a = this._tiles[Layer.SURFACE]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get gas() {\n        var _a;\n        return ((_a = this._tiles[Layer.GAS]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    get groundTile() {\n        return this._tiles[Layer.GROUND] || TILES.NULL;\n    }\n    get liquidTile() {\n        return this._tiles[Layer.LIQUID] || TILES.NULL;\n    }\n    get surfaceTile() {\n        return this._tiles[Layer.SURFACE] || TILES.NULL;\n    }\n    get gasTile() {\n        return this._tiles[Layer.GAS] || TILES.NULL;\n    }\n    dump() {\n        if (this.actor)\n            return this.actor.sprite.ch;\n        if (this.item)\n            return this.item.sprite.ch;\n        for (let i = this._tiles.length - 1; i >= 0; --i) {\n            if (!this._tiles[i])\n                continue;\n            const tile = this._tiles[i] || TILES.NULL;\n            if (tile.sprite.ch)\n                return tile.sprite.ch;\n        }\n        return TILES.NULL.sprite.ch;\n    }\n    get changed() {\n        return (this.flags.cell & Flags.CELL_CHANGED) > 0;\n    }\n    set changed(v) {\n        if (v) {\n            this.flags.cell |= Flags.CELL_CHANGED;\n        }\n        else {\n            this.flags.cell &= ~Flags.CELL_CHANGED;\n        }\n    }\n    isVisible() {\n        return !!(this.flags.cell & Flags.VISIBLE);\n    }\n    isAnyKindOfVisible() {\n        return !!((this.flags.cell & Flags.ANY_KIND_OF_VISIBLE) /* || CONFIG.playbackOmniscience */);\n    }\n    isOrWasAnyKindOfVisible() {\n        return (this.flags.cell &\n            Flags.IS_WAS_ANY_KIND_OF_VISIBLE /* || CONFIG.playbackOmniscience */);\n    }\n    isRevealed(orMapped = false) {\n        const flag = Flags.REVEALED |\n            Flags.VISIBLE |\n            (orMapped ? Flags.MAGIC_MAPPED : 0);\n        return (this.flags.cell & flag) > 0;\n    }\n    listInSidebar() {\n        return this.hasLayerFlag(LayerFlags.L_LIST_IN_SIDEBAR, true);\n    }\n    get needsRedraw() {\n        return (this.flags.cell & Flags.NEEDS_REDRAW) > 0;\n    }\n    set needsRedraw(v) {\n        if (v) {\n            this.flags.cell |= Flags.NEEDS_REDRAW;\n        }\n        else {\n            this.flags.cell &= ~Flags.NEEDS_REDRAW;\n        }\n    }\n    // TODO - Use functions in LIGHT to check these on cell.light directly???\n    hasVisibleLight() {\n        return Light.intensity(this.light) > CONFIG.light.INTENSITY_DARK;\n    } // TODO\n    isDark(darkColor) {\n        const intensity = darkColor\n            ? Light.intensity(darkColor)\n            : CONFIG.light.INTENSITY_DARK;\n        return Light.intensity(this.light) <= intensity;\n    } // TODO\n    get lightChanged() {\n        return (this.flags.cell & Flags.LIGHT_CHANGED) > 0;\n    }\n    set lightChanged(v) {\n        if (v) {\n            this.flags.cell |= Flags.LIGHT_CHANGED | Flags.NEEDS_REDRAW;\n        }\n        else {\n            this.flags.cell &= ~Flags.LIGHT_CHANGED;\n        }\n    }\n    tile(layer = Layer.GROUND) {\n        return this._tiles[layer] || TILES.NULL;\n    }\n    tileId(layer = Layer.GROUND) {\n        var _a;\n        return ((_a = this._tiles[layer]) === null || _a === void 0 ? void 0 : _a.id) || null;\n    }\n    volume(layer = Layer.GAS) {\n        if (layer === Layer.GAS)\n            return this.gasVolume;\n        if (layer === Layer.LIQUID)\n            return this.liquidVolume;\n        return 0;\n    }\n    setVolume(layer, volume = 0) {\n        if (layer === Layer.GAS) {\n            this.gasVolume = volume;\n        }\n        else if (layer === Layer.LIQUID) {\n            this.liquidVolume = volume;\n        }\n    }\n    *tiles() {\n        for (let tile of this._tiles) {\n            if (tile) {\n                yield tile;\n            }\n        }\n    }\n    layerFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.flags.layer;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.layer;\n        }\n        return flags;\n    }\n    tileFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.flags.tile;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.tile;\n        }\n        return flags;\n    }\n    tileMechFlags(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge && !this.isVisible()) {\n            return this.memory.flags.tileMech;\n        }\n        let flags = 0;\n        for (let tile of this.tiles()) {\n            flags |= tile.flags.tileMech;\n        }\n        return flags;\n    }\n    hasLayerFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = this.layerFlags(limitToPlayerKnowledge);\n        if (flag & flags)\n            return true;\n        let actor = this.actor;\n        let item = this.item;\n        if (limitToPlayerKnowledge) {\n            actor = this.memory.actor;\n            item = this.memory.item;\n        }\n        if (actor && actor.layerFlags() & flag)\n            return true;\n        if (item && item.layerFlags() & flag)\n            return true;\n        return false;\n    }\n    hasAllLayerFlags(flag, limitToPlayerKnowledge = false) {\n        let flags = this.layerFlags(limitToPlayerKnowledge);\n        let actor = this.actor;\n        let item = this.item;\n        if (limitToPlayerKnowledge) {\n            actor = this.memory.actor;\n            item = this.memory.item;\n        }\n        if (actor)\n            flags |= actor.layerFlags();\n        if (item)\n            flags |= item.layerFlags();\n        return (flag & flags) === flag;\n    }\n    hasTileFlag(flagMask, limitToPlayerKnowledge = false) {\n        const tileFlags = this.tileFlags(limitToPlayerKnowledge);\n        return !!(flagMask & tileFlags);\n    }\n    hasAllTileFlags(flags, limitToPlayerKnowledge = false) {\n        return (flags & this.tileFlags(limitToPlayerKnowledge)) === flags;\n    }\n    hasTileMechFlag(flagMask, limitToPlayerKnowledge = false) {\n        const mechFlags = this.tileMechFlags(limitToPlayerKnowledge);\n        return !!(flagMask & mechFlags);\n    }\n    hasAllTileMechFlags(flags, limitToPlayerKnowledge = false) {\n        return (flags & this.tileMechFlags(limitToPlayerKnowledge)) === flags;\n    }\n    setFlags(cellFlag = 0, cellMechFlag = 0) {\n        this.flags.cell |= cellFlag;\n        this.flags.cellMech |= cellMechFlag;\n        // this.flags.cell |= Flags.NEEDS_REDRAW;\n    }\n    clearFlags(cellFlag = 0, cellMechFlag = 0) {\n        this.flags.cell &= ~cellFlag;\n        this.flags.cellMech &= ~cellMechFlag;\n        // if ((~cellFlag) & Flags.NEEDS_REDRAW) {\n        //   this.flags.cell |= Flags.NEEDS_REDRAW;\n        // }\n    }\n    hasFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = limitToPlayerKnowledge && !this.isAnyKindOfVisible()\n            ? this.memory.flags.cell\n            : this.flags.cell;\n        return (flag & flags) > 0;\n    }\n    hasMechFlag(flag, limitToPlayerKnowledge = false) {\n        const flags = limitToPlayerKnowledge && !this.isAnyKindOfVisible()\n            ? this.memory.flags.cellMech\n            : this.flags.cellMech;\n        return (flag & flags) > 0;\n    }\n    hasTile(tile) {\n        let id;\n        if (typeof tile === 'string') {\n            id = tile;\n        }\n        else {\n            id = tile.id;\n        }\n        return this._tiles.some((t) => t && t.id === id);\n    }\n    // hasTileInGroup(...groups) {\n    //   if (groups.length == 1 && Array.isArray(groups[0])) {\n    //     groups = groups[0];\n    //   }\n    //   return this.layers.some( (tileId) => {\n    //     const tile = TILES[tileId] || TILES.NOTHING;\n    //     return Utils.intersect(groups, tile.groups);\n    //   });\n    // }\n    // promotedTileFlags() {\n    //   return this.successorTileFlags(\"promote\");\n    // }\n    // discoveredTileFlags() {\n    //   return this.successorTileFlags(\"discover\");\n    // }\n    // hasDiscoveredTileFlag(flag: number) {\n    //   // if (!this.hasTileMechFlag(TM_IS_SECRET)) return false;\n    //   return this.discoveredTileFlags() & flag;\n    // }\n    topmostTile(skipGas = false) {\n        let best = TILES.NULL;\n        let bestPriority = -10000;\n        for (let layer = Layer.GROUND; layer <= (skipGas ? Layer.LIQUID : Layer.GAS); ++layer) {\n            // @ts-ignore\n            const tile = this._tiles[layer];\n            if (!tile)\n                continue;\n            if (tile.priority > bestPriority) {\n                best = tile;\n                bestPriority = tile.priority;\n            }\n        }\n        return best;\n    }\n    tileWithLayerFlag(layerFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags.layer & layerFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileWithFlag(tileFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags.tile & tileFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileWithMechFlag(mechFlag) {\n        for (let tile of this.tiles()) {\n            if (tile.flags.tileMech & mechFlag)\n                return tile;\n        }\n        return null;\n    }\n    tileDesc() {\n        return this.topmostTile().desc;\n    }\n    tileFlavor() {\n        return this.topmostTile().flavor;\n    }\n    getName(opts = {}) {\n        return this.topmostTile().getName(opts);\n    }\n    isNull() {\n        return this.ground === null;\n    }\n    isClear() {\n        return (this.liquid === null && this.gas === null && this.surface === null);\n    }\n    isEmpty() {\n        return !(this._actor || this._item);\n    }\n    isMoveableNow(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.flags.layer\n            : this.layerFlags(false);\n        return (layerFlags & LayerFlags.L_BLOCKS_MOVE) === 0;\n    }\n    isWalkableNow(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.flags.layer\n            : this.layerFlags(false);\n        if (layerFlags & LayerFlags.L_BLOCKS_MOVE)\n            return false;\n        const tileFlags = useMemory ? this.memory.flags.tile : this.tileFlags();\n        if (!(tileFlags & TileFlags.T_IS_DEEP_LIQUID))\n            return true;\n        return (tileFlags & TileFlags.T_BRIDGE) > 0;\n    }\n    canBeWalked(limitToPlayerKnowledge = false) {\n        if (this.isWalkableNow(limitToPlayerKnowledge))\n            return true;\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        const layerFlags = useMemory\n            ? this.memory.flags.layer\n            : this.layerFlags(false);\n        return (layerFlags & LayerFlags.L_SECRETLY_PASSABLE) > 0;\n    }\n    isWall(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory\n            ? this.memory.flags.layer\n            : this.layerFlags();\n        return (layerFlags & LayerFlags.L_IS_WALL) === LayerFlags.L_IS_WALL;\n    }\n    isObstruction(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory\n            ? this.memory.flags.layer\n            : this.layerFlags();\n        return !!(layerFlags & LayerFlags.L_BLOCKS_DIAGONAL);\n    }\n    isDoorway(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let layerFlags = useMemory\n            ? this.memory.flags.layer\n            : this.layerFlags();\n        return ((layerFlags & LayerFlags.L_BLOCKS_VISION) > 0 &&\n            (layerFlags & LayerFlags.L_BLOCKS_MOVE) === 0);\n    }\n    isSecretDoorway(limitToPlayerKnowledge = false) {\n        if (limitToPlayerKnowledge)\n            return false;\n        const layerFlags = this.layerFlags(limitToPlayerKnowledge);\n        return (layerFlags & LayerFlags.L_SECRETLY_PASSABLE) > 0;\n    }\n    blocksPathing(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        if (!this.isWalkableNow(limitToPlayerKnowledge))\n            return true;\n        let tileFlags = useMemory ? this.memory.flags.tile : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_PATHING_BLOCKER);\n    }\n    blocksVision() {\n        const layerFlags = this.layerFlags();\n        return !!(layerFlags & LayerFlags.L_BLOCKS_VISION);\n    }\n    blocksEffects() {\n        const layerFlags = this.layerFlags();\n        return !!(layerFlags & LayerFlags.L_BLOCKS_EFFECTS);\n    }\n    isLiquid(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let tileFlags = useMemory ? this.memory.flags.tile : this.tileFlags();\n        return !!(tileFlags & TileFlags.T_IS_DEEP_LIQUID);\n    }\n    // TODO - Should this look at the tiles instead of the flags?\n    // What if a gas tile is not set with T_GAS?\n    // Should we force T_GAS if layer === GAS when creating a tile?\n    // Should these be cell flags - indicating we have this layer\n    hasGas(limitToPlayerKnowledge = false) {\n        const useMemory = limitToPlayerKnowledge && !this.isAnyKindOfVisible();\n        let cellFlags = useMemory ? this.memory.flags.cell : this.flags.cell;\n        return !!(cellFlags & Flags.HAS_GAS);\n    }\n    // TODO - Check floor and actor\n    hasKey() {\n        return false;\n    }\n    markRevealed() {\n        this.flags.cell &= ~Flags.STABLE_MEMORY;\n        if (this.flags.cell & Flags.REVEALED)\n            return false;\n        this.flags.cell |= Flags.REVEALED;\n        return !this.isWall();\n    }\n    obstructsLayer(depth) {\n        return (depth === Layer.SURFACE &&\n            this.hasLayerFlag(LayerFlags.L_BLOCKS_SURFACE));\n    }\n    setTile(tileId = null, volume = 0, map) {\n        map = map || DATA.map;\n        let tile;\n        if (tileId === null) {\n            tile = TILES.NULL;\n            tileId = null;\n        }\n        else if (typeof tileId === 'string') {\n            tile = TILES[tileId];\n        }\n        else if (tileId instanceof Tile) {\n            tile = tileId;\n            tileId = tile.id;\n        }\n        if (!tile) {\n            return Utils.ERROR('Unknown tile - ' + tileId);\n        }\n        if (tile.layer > 0 && !this._tiles[0]) {\n            this.setTile(tile.defaultGround || TILES.FLOOR, 0, map); // TODO - do not use FLOOR?  Does map have the tile to use?\n        }\n        const oldTile = this._tiles[tile.layer] || TILES.NULL;\n        const oldTileId = oldTile === TILES.NULL ? null : oldTile.id;\n        if (oldTile.blocksPathing() != tile.blocksPathing()) {\n            DATA.staleLoopMap = true;\n        }\n        if (tile.flags.tile & TileFlags.T_IS_FIRE &&\n            !(oldTile.flags.tile & TileFlags.T_IS_FIRE)) {\n            this.flags.cellMech |= MechFlags.CAUGHT_FIRE_THIS_TURN;\n        }\n        const blocksVision = tile.flags.layer & LayerFlags.L_BLOCKS_VISION;\n        const oldBlocksVision = oldTile.flags.layer & LayerFlags.L_BLOCKS_VISION;\n        if (map &&\n            this.isAnyKindOfVisible() &&\n            blocksVision != oldBlocksVision) {\n            map.setFlag(MapFlags.MAP_FOV_CHANGED);\n        }\n        if (oldTileId !== null)\n            this.removeLayer(oldTile);\n        this._tiles[tile.layer] = tileId === null ? null : tile;\n        if (tileId !== null)\n            this.addLayer(tile);\n        let layerFlag = 0;\n        if (tile.layer == Layer.LIQUID) {\n            layerFlag = Flags.HAS_LIQUID;\n            this.liquidVolume =\n                volume + (tileId == oldTileId ? this.liquidVolume : 0);\n            if (map)\n                map.clearFlag(MapFlags.MAP_NO_LIQUID);\n        }\n        else if (tile.layer == Layer.GAS) {\n            layerFlag = Flags.HAS_GAS;\n            this.gasVolume =\n                volume + (tileId == oldTileId ? this.gasVolume : 0);\n            if (map)\n                map.clearFlag(MapFlags.MAP_NO_GAS);\n        }\n        else if (tile.layer === Layer.SURFACE) {\n            layerFlag = Flags.HAS_SURFACE;\n        }\n        if (tileId) {\n            this.flags.cell |= layerFlag;\n        }\n        else {\n            this.flags.cell &= ~layerFlag;\n        }\n        // this.flags.cell |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n        this.flags.cell |= Flags.CELL_CHANGED | Flags.NEEDS_REDRAW;\n        if (map && oldTile.light !== tile.light) {\n            map.clearFlag(MapFlags.MAP_STABLE_GLOW_LIGHTS | MapFlags.MAP_STABLE_LIGHTS);\n        }\n        return true;\n    }\n    clearLayer(depth, floorTile = 'FLOOR') {\n        // @ts-ignore\n        if (typeof depth === 'string')\n            depth = Layer[depth];\n        const current = this._tiles[depth];\n        let didSomething = false;\n        if (depth === Layer.GROUND) {\n            if (typeof floorTile === 'string') {\n                floorTile = TILES[floorTile] || TILES.FLOOR;\n            }\n        }\n        if (current) {\n            // this.flags.cell |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n            this.flags.cell |= Flags.CELL_CHANGED;\n            this.removeLayer(current);\n            didSomething =\n                current && (depth !== Layer.GROUND || current !== floorTile);\n        }\n        this._tiles[depth] = null;\n        let layerFlag = 0;\n        if (depth == Layer.LIQUID) {\n            layerFlag = Flags.HAS_LIQUID;\n            this.liquidVolume = 0;\n        }\n        else if (depth == Layer.GAS) {\n            layerFlag = Flags.HAS_GAS;\n            this.gasVolume = 0;\n        }\n        else if (depth == Layer.SURFACE) {\n            layerFlag = Flags.HAS_SURFACE;\n        }\n        else if (depth == Layer.GROUND) {\n            this._tiles[Layer.GROUND] = floorTile;\n        }\n        this.flags.cell &= ~layerFlag;\n        return didSomething;\n    }\n    clearLayersExcept(except = Layer.GROUND, ground) {\n        const floorTile = ground ? TILES[ground] : this.groundTile;\n        for (let layer = 0; layer < this._tiles.length; layer++) {\n            if (layer != except && layer != Layer.GAS) {\n                if (layer === Layer.GROUND) {\n                    if (floorTile !== this.groundTile)\n                        this.setTile(floorTile);\n                }\n                else {\n                    this.clearLayer(layer);\n                }\n            }\n        }\n        // this.flags.cell |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n        this.flags.cell |= Flags.CELL_CHANGED;\n    }\n    clearLayersWithFlags(tileFlags, tileMechFlags = 0) {\n        for (let i = 0; i < this._tiles.length; ++i) {\n            const tile = this._tiles[i];\n            if (!tile)\n                continue;\n            if (tileFlags && tileMechFlags) {\n                if (tile.flags.tile & tileFlags &&\n                    tile.flags.tileMech & tileMechFlags) {\n                    this.clearLayer(i);\n                }\n            }\n            else if (tileFlags) {\n                if (tile.flags.tile & tileFlags) {\n                    this.clearLayer(i);\n                }\n            }\n            else if (tileMechFlags) {\n                if (tile.flags.tileMech & tileMechFlags) {\n                    this.clearLayer(i);\n                }\n            }\n        }\n        // this.flags.cell |= (Flags.NEEDS_REDRAW | Flags.CELL_CHANGED);\n    }\n    // EVENTS\n    async activate(name, map, x, y, ctx = {}) {\n        ctx.cell = this;\n        let fired = false;\n        if (ctx.layer !== undefined) {\n            const tile = this.tile(ctx.layer);\n            if (tile && tile.effects) {\n                const ev = tile.effects[name];\n                let effect;\n                if (typeof ev === 'string') {\n                    effect = Effect.effects[ev];\n                }\n                else {\n                    effect = ev;\n                }\n                if (effect) {\n                    // console.log(' - has event');\n                    if (ctx.force ||\n                        !effect.chance ||\n                        random.chance(effect.chance, 10000)) {\n                        ctx.tile = tile;\n                        // console.log(' - spawn event @%d,%d - %s', x, y, name);\n                        fired = await effect.fire(map, x, y, ctx);\n                        // cell.debug(\" - spawned\");\n                    }\n                }\n            }\n        }\n        else {\n            // console.log('fire event - %s', name);\n            for (let tile of this.tiles()) {\n                if (!tile.effects)\n                    continue;\n                const ev = tile.effects[name];\n                // console.log(' - ', ev);\n                let effect;\n                if (typeof ev === 'string') {\n                    effect = Effect.effects[ev];\n                }\n                else {\n                    effect = ev;\n                }\n                if (effect) {\n                    // cell.debug(\" - has event\");\n                    if (ctx.force ||\n                        !effect.chance ||\n                        random.chance(effect.chance, 10000)) {\n                        ctx.tile = tile;\n                        // console.log(' - spawn event @%d,%d - %s', x, y, name);\n                        fired = (await effect.fire(map, x, y, ctx)) || fired;\n                        // cell.debug(\" - spawned\");\n                        if (fired) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return fired;\n    }\n    hasEffect(name) {\n        for (let tile of this.tiles()) {\n            if (tile.hasEffect(name))\n                return true;\n        }\n        return false;\n    }\n    // ITEM\n    get item() {\n        return this._item;\n    }\n    set item(item) {\n        if (this.item) {\n            this.removeLayer(this.item);\n        }\n        this._item = item;\n        if (item) {\n            this.flags.cell |= Flags.HAS_ITEM;\n            this.addLayer(item, Layer.ITEM);\n        }\n        else {\n            this.flags.cell &= ~Flags.HAS_ITEM;\n        }\n    }\n    // ACTOR\n    get actor() {\n        return this._actor;\n    }\n    set actor(actor) {\n        if (this.actor) {\n            this.removeLayer(this.actor);\n        }\n        this._actor = actor;\n        if (actor) {\n            this.flags.cell |= actor.isPlayer()\n                ? Flags.HAS_PLAYER\n                : Flags.HAS_ACTOR;\n            this.addLayer(actor, Layer.ACTOR);\n        }\n        else {\n            this.flags.cell &= ~Flags.HAS_ANY_ACTOR;\n        }\n    }\n    addLayer(obj, layer) {\n        var _a;\n        if (!obj)\n            return;\n        // this.flags.cell |= Flags.NEEDS_REDRAW;\n        this.flags.cell |= Flags.CELL_CHANGED;\n        let current = this.layers;\n        layer = (_a = layer !== null && layer !== void 0 ? layer : obj.layer) !== null && _a !== void 0 ? _a : Layer.GROUND;\n        if (!current ||\n            current.layer > layer ||\n            (current.layer == layer && current.obj.priority > obj.priority)) {\n            this.layers = {\n                obj,\n                layer,\n                next: current,\n            };\n            return;\n        }\n        while (current.next &&\n            (current.next.layer < layer ||\n                (current.next.layer == layer &&\n                    current.next.obj.priority <= obj.priority))) {\n            current = current.next;\n        }\n        const item = {\n            layer,\n            obj,\n            next: current.next,\n        };\n        current.next = item;\n    }\n    removeLayer(layer) {\n        if (!layer)\n            return false;\n        if (!this.layers)\n            return false;\n        // this.flags.cell |= Flags.NEEDS_REDRAW;\n        this.flags.cell |= Flags.CELL_CHANGED;\n        if (this.layers && this.layers.obj === layer) {\n            this.layers = this.layers.next;\n            return true;\n        }\n        let prev = this.layers;\n        let current = this.layers.next;\n        while (current) {\n            if (current.obj === layer) {\n                prev.next = current.next;\n                return true;\n            }\n            prev = current;\n            current = current.next;\n        }\n        return false;\n    }\n    // MEMORY\n    storeMemory() {\n        const memory = this.memory;\n        memory.flags.tile = this.tileFlags();\n        memory.flags.tileMech = this.tileMechFlags();\n        memory.flags.layer = this.layerFlags();\n        memory.flags.cell = this.flags.cell;\n        memory.flags.cellMech = this.flags.cellMech;\n        memory.tile = this.topmostTile();\n        if (this.item && this.isRevealed()) {\n            memory.item = this.item;\n            memory.itemQuantity = this.item.quantity;\n        }\n        else {\n            memory.item = null;\n            memory.itemQuantity = 0;\n        }\n        memory.actor = null;\n        if (this.actor && this.isAnyKindOfVisible()) {\n            memory.actor = this.actor;\n        }\n        getAppearance(this, memory.mixer);\n    }\n}\nexport function make(tile) {\n    const cell = new Cell();\n    if (tile) {\n        cell.setTile(tile);\n    }\n    return cell;\n}\nMake.cell = make;\nexport function getAppearance(cell, dest) {\n    const memory = cell.memory.mixer;\n    memory.blackOut();\n    let needDistinctness = cell.layerFlags() & LayerFlags.L_VISUALLY_DISTINCT;\n    let current = cell.layers;\n    while (current) {\n        const obj = current.obj;\n        let alpha = obj.sprite.opacity || 100;\n        if (current.layer == Layer.LIQUID) {\n            alpha = Utils.clamp(cell.liquidVolume * 34, 20, 100);\n        }\n        else if (current.layer == Layer.GAS) {\n            alpha = Utils.clamp(cell.gasVolume * 34, 20, 100);\n        }\n        if (cell.isAnyKindOfVisible() || current.layer < Layer.ACTOR) {\n            memory.drawSprite(obj.sprite, alpha);\n        }\n        current = current.next;\n    }\n    memory.fg.multiply(cell.light);\n    memory.bg.multiply(cell.light);\n    memory.bake(!cell.isAnyKindOfVisible()); // turns off dancing if not visible\n    if (needDistinctness) {\n        Color.separate(memory.fg, memory.bg);\n    }\n    if (memory.dances) {\n        cell.flags.cell |= Flags.COLORS_DANCE;\n    }\n    else {\n        cell.flags.cell &= ~Flags.COLORS_DANCE;\n    }\n    dest.drawSprite(memory);\n    return true;\n}\n","import * as GW from 'gw-utils';\nimport * as Flags from './mapFlags';\nimport * as Map from './map';\nfunction demoteCellVisibility(cell) {\n    cell.flags.cell &= ~(Flags.Cell.WAS_ANY_KIND_OF_VISIBLE | Flags.Cell.IN_FOV);\n    if (cell.flags.cell & Flags.Cell.VISIBLE) {\n        cell.flags.cell &= ~Flags.Cell.VISIBLE;\n        cell.flags.cell |= Flags.Cell.WAS_VISIBLE;\n    }\n    if (cell.flags.cell & Flags.Cell.CLAIRVOYANT_VISIBLE) {\n        cell.flags.cell &= ~Flags.Cell.CLAIRVOYANT_VISIBLE;\n        cell.flags.cell |= Flags.Cell.WAS_CLAIRVOYANT_VISIBLE;\n    }\n    if (cell.flags.cell & Flags.Cell.TELEPATHIC_VISIBLE) {\n        cell.flags.cell &= ~Flags.Cell.TELEPATHIC_VISIBLE;\n        cell.flags.cell |= Flags.Cell.WAS_TELEPATHIC_VISIBLE;\n    }\n}\nfunction _updateCellVisibility(cell, i, j, map) {\n    const isVisible = cell.flags.cell & Flags.Cell.VISIBLE;\n    const wasVisible = cell.flags.cell & Flags.Cell.WAS_VISIBLE;\n    if (isVisible && wasVisible) {\n        if (cell.lightChanged) {\n            map.redrawCell(cell);\n        }\n    }\n    else if (isVisible && !wasVisible) {\n        // if the cell became visible this move\n        if (!(cell.flags.cell & Flags.Cell.REVEALED) &&\n            GW.data.automationActive) {\n            if (cell.item) {\n                const theItem = cell.item;\n                if (theItem.hasLayerFlag(Flags.Entity.L_INTERRUPT_WHEN_SEEN)) {\n                    GW.message.add('§you§ §see§ ΩitemMessageColorΩ§item§∆.', {\n                        item: theItem,\n                        actor: GW.data.player,\n                    });\n                }\n            }\n            if (!(cell.flags.cell & Flags.Cell.MAGIC_MAPPED) &&\n                cell.hasLayerFlag(Flags.Entity.L_INTERRUPT_WHEN_SEEN)) {\n                const tile = cell.tileWithLayerFlag(Flags.Entity.L_INTERRUPT_WHEN_SEEN);\n                if (tile) {\n                    GW.message.add('§you§ §see§ ΩbackgroundMessageColorΩ§item§∆.', {\n                        actor: GW.data.player,\n                        item: tile.name,\n                    });\n                }\n            }\n        }\n        map.markRevealed(i, j);\n        map.redrawCell(cell);\n    }\n    else if (!isVisible && wasVisible) {\n        // if the cell ceased being visible this move\n        cell.storeMemory();\n        map.redrawCell(cell);\n    }\n    return isVisible;\n}\nfunction _updateCellClairyvoyance(cell, _i, _j, map) {\n    const isClairy = cell.flags.cell & Flags.Cell.CLAIRVOYANT_VISIBLE;\n    const wasClairy = cell.flags.cell & Flags.Cell.WAS_CLAIRVOYANT_VISIBLE;\n    if (isClairy && wasClairy) {\n        if (cell.lightChanged) {\n            map.redrawCell(cell);\n        }\n    }\n    else if (!isClairy && wasClairy) {\n        // ceased being clairvoyantly visible\n        cell.storeMemory();\n        map.redrawCell(cell);\n    }\n    else if (!wasClairy && isClairy) {\n        // became clairvoyantly visible\n        cell.flags.cell &= ~Flags.Cell.STABLE_MEMORY;\n        map.redrawCell(cell);\n    }\n    return isClairy;\n}\nfunction _updateCellTelepathy(cell, _i, _j, map) {\n    const isTele = cell.flags.cell & Flags.Cell.TELEPATHIC_VISIBLE;\n    const wasTele = cell.flags.cell & Flags.Cell.WAS_TELEPATHIC_VISIBLE;\n    if (isTele && wasTele) {\n        if (cell.lightChanged) {\n            map.redrawCell(cell);\n        }\n    }\n    else if (!isTele && wasTele) {\n        // ceased being telepathically visible\n        cell.storeMemory();\n        map.redrawCell(cell);\n    }\n    else if (!wasTele && isTele) {\n        // became telepathically visible\n        if (!(cell.flags.cell & Flags.Cell.REVEALED) &&\n            !cell.hasTileFlag(Flags.Tile.T_PATHING_BLOCKER)) {\n            GW.data.xpxpThisTurn++;\n        }\n        cell.flags.cell &= ~Flags.Cell.STABLE_MEMORY;\n        map.redrawCell(cell);\n    }\n    return isTele;\n}\nfunction _updateCellDetect(cell, _i, _j, map) {\n    const isMonst = cell.flags.cell & Flags.Cell.MONSTER_DETECTED;\n    const wasMonst = cell.flags.cell & Flags.Cell.WAS_MONSTER_DETECTED;\n    if (isMonst && wasMonst) {\n        if (cell.lightChanged) {\n            map.redrawCell(cell);\n        }\n    }\n    else if (!isMonst && wasMonst) {\n        // ceased being detected visible\n        cell.flags.cell &= ~Flags.Cell.STABLE_MEMORY;\n        map.redrawCell(cell);\n        cell.storeMemory();\n    }\n    else if (!wasMonst && isMonst) {\n        // became detected visible\n        cell.flags.cell &= ~Flags.Cell.STABLE_MEMORY;\n        map.redrawCell(cell);\n        cell.storeMemory();\n    }\n    return isMonst;\n}\nfunction promoteCellVisibility(cell, i, j, map) {\n    if (cell.flags.cell & Flags.Cell.IN_FOV &&\n        map.hasVisibleLight(i, j) &&\n        !(cell.flags.cellMech & Flags.CellMech.DARKENED)) {\n        cell.flags.cell |= Flags.Cell.VISIBLE;\n    }\n    if (_updateCellVisibility(cell, i, j, map))\n        return;\n    if (_updateCellClairyvoyance(cell, i, j, map))\n        return;\n    if (_updateCellTelepathy(cell, i, j, map))\n        return;\n    if (_updateCellDetect(cell, i, j, map))\n        return;\n}\nexport function initMap(map) {\n    if (!(map.flags.map & Map.Flags.MAP_CALC_FOV)) {\n        map.setFlags(0, Flags.Cell.REVEALED | Flags.Cell.VISIBLE);\n        return;\n    }\n    map.clearFlags(0, Flags.Cell.IS_WAS_ANY_KIND_OF_VISIBLE);\n}\nexport function update(map, x, y, maxRadius) {\n    if (!(map.flags.map & Map.Flags.MAP_CALC_FOV) || !map.fov)\n        return false;\n    if (x == map.fov.x && y == map.fov.y) {\n        if (!(map.flags.map & Flags.Map.MAP_FOV_CHANGED))\n            return false;\n    }\n    map.flags.map &= ~Flags.Map.MAP_FOV_CHANGED;\n    map.fov.x = x;\n    map.fov.y = y;\n    map.forEach(demoteCellVisibility);\n    // Calculate player's field of view (distinct from what is visible, as lighting hasn't been done yet).\n    const grid = GW.grid.alloc(map.width, map.height, 0);\n    map.calcFov(grid, x, y, maxRadius);\n    grid.forEach((v, i, j) => {\n        if (v) {\n            map.setCellFlags(i, j, Flags.Cell.IN_FOV);\n        }\n    });\n    GW.grid.free(grid);\n    map.setCellFlags(x, y, Flags.Cell.IN_FOV | Flags.Cell.VISIBLE);\n    // if (PLAYER.bonus.clairvoyance < 0) {\n    //   discoverCell(PLAYER.xLoc, PLAYER.yLoc);\n    // }\n    //\n    // if (PLAYER.bonus.clairvoyance != 0) {\n    // \tupdateClairvoyance();\n    // }\n    //\n    // updateTelepathy();\n    // updateMonsterDetection();\n    // updateLighting();\n    map.forEach(promoteCellVisibility);\n    // if (PLAYER.status.hallucinating > 0) {\n    // \tfor (theItem of DUNGEON.items) {\n    // \t\tif ((pmap[theItem.xLoc][theItem.yLoc].flags & DISCOVERED) && refreshDisplay) {\n    // \t\t\trefreshDungeonCell(theItem.xLoc, theItem.yLoc);\n    // \t\t}\n    // \t}\n    // \tfor (monst of DUNGEON.monsters) {\n    // \t\tif ((pmap[monst.xLoc][monst.yLoc].flags & DISCOVERED) && refreshDisplay) {\n    // \t\t\trefreshDungeonCell(monst.xLoc, monst.yLoc);\n    // \t\t}\n    // \t}\n    // }\n    return true;\n}\n","import * as GW from 'gw-utils';\nimport * as Cell from './cell';\nimport * as Tile from './tile';\nimport * as Entity from './entity';\nconst Flags = GW.effect.Flags;\nexport function makeTileEffect(config) {\n    if (!config) {\n        GW.utils.ERROR('Config required to make tile effect.');\n        return null;\n    }\n    if (typeof config === 'string') {\n        config = config.split(/[,|]/).map((t) => t.trim());\n    }\n    if (Array.isArray(config)) {\n        config = {\n            id: config[0],\n            spread: config[1] || 0,\n            decrement: config[2] || 0,\n        };\n    }\n    config.id = config.id || config.tile;\n    config.spread = config.spread || 0;\n    config.decrement = config.decrement || 0;\n    if (config.spread >= 100 && config.decrement <= 0) {\n        config.decrement = 100;\n    }\n    config.matchTile = config.matchTile || config.match || config.needs || null;\n    config.volume = config.volume || 0;\n    if (!config.id) {\n        GW.utils.ERROR('id required to make tile effect.');\n    }\n    return tileEffect.bind(config);\n}\nGW.effect.installType('tile', makeTileEffect);\nexport async function tileEffect(effect, x, y) {\n    const id = this.id;\n    const tile = Tile.tiles[id] || null;\n    if (!tile)\n        return false;\n    const abortIfBlocking = !!(effect.flags & Flags.E_ABORT_IF_BLOCKS_MAP);\n    const isBlocking = !!(abortIfBlocking &&\n        !(effect.flags & Flags.E_PERMIT_BLOCKING) &&\n        (tile.blocksPathing() || effect.flags & Flags.E_TREAT_AS_BLOCKING));\n    let didSomething = false;\n    const map = effect.map;\n    didSomething = computeSpawnMap(this, effect, x, y);\n    if (!didSomething) {\n        return false;\n    }\n    if (abortIfBlocking &&\n        isBlocking &&\n        map.gridDisruptsWalkability(effect.grid)) {\n        // GW.grid.free(spawnMap);\n        return false;\n    }\n    if (effect.flags & Flags.E_EVACUATE_CREATURES) {\n        // first, evacuate creatures, so that they do not re-trigger the tile.\n        if (evacuateCreatures(map, effect.grid)) {\n            didSomething = true;\n        }\n    }\n    if (effect.flags & Flags.E_EVACUATE_ITEMS) {\n        // first, evacuate items, so that they do not re-trigger the tile.\n        if (evacuateItems(map, effect.grid)) {\n            didSomething = true;\n        }\n    }\n    if (effect.flags & Flags.E_CLEAR_CELL) {\n        // first, clear other tiles (not base/ground)\n        if (clearCells(map, effect.grid, effect.flags)) {\n            didSomething = true;\n        }\n    }\n    const spawned = spawnTiles(effect.flags, effect.grid, effect.map, tile, this.volume);\n    if (spawned) {\n        didSomething = true;\n        // await spawnMap.forEachAsync( (v, x, y) => {\n        //     if (!v) return;\n        //     await map.applyInstantEffects(x, y);\n        // });\n        // if (applyEffects) {\n        // if (PLAYER.xLoc == i && PLAYER.yLoc == j && !PLAYER.status.levitating && refresh) {\n        // \tflavorMessage(tileFlavor(PLAYER.xLoc, PLAYER.yLoc));\n        // }\n        // if (cell.actor || cell.item) {\n        // \tfor(let t of cell.tiles()) {\n        // \t\tawait t.applyInstantEffects(map, i, j, cell);\n        // \t\tif (Data.gameHasEnded) {\n        // \t\t\treturn true;\n        // \t\t}\n        // \t}\n        // }\n        // if (tile.flags & TileFlags.T_IS_FIRE) {\n        // \tif (cell.flags & CellFlags.HAS_ITEM) {\n        // \t\ttheItem = map.itemAt(i, j);\n        // \t\tif (theItem.flags & Flags.Item.ITEM_FLAMMABLE) {\n        // \t\t\tawait burnItem(theItem);\n        // \t\t}\n        // \t}\n        // }\n        // }\n    }\n    // GW.grid.free(spawnMap);\n    return didSomething;\n}\n// tick\nexport async function fireAll(map, event) {\n    const willFire = GW.grid.alloc(map.width, map.height);\n    // Figure out which tiles will fire - before we change everything...\n    map.forEach((cell, x, y) => {\n        cell.clearFlags(0, Cell.MechFlags.EVENT_FIRED_THIS_TURN |\n            Cell.MechFlags.EVENT_PROTECTED);\n        for (let tile of cell.tiles()) {\n            const effect = GW.effect.from(tile.effects[event]);\n            if (!effect)\n                continue;\n            let promoteChance = 0;\n            // < 0 means try to fire my neighbors...\n            if (effect.chance < 0) {\n                promoteChance = 0;\n                map.eachNeighbor(x, y, (n, _i, _j) => {\n                    if (!n.hasLayerFlag(Entity.Flags.L_BLOCKS_EFFECTS) &&\n                        n.tileId(tile.layer) != cell.tileId(tile.layer) &&\n                        !(n.flags.cellMech &\n                            Cell.MechFlags.CAUGHT_FIRE_THIS_TURN)) {\n                        // TODO - Should this break from the loop after doing this once or keep going?\n                        promoteChance += -1 * effect.chance;\n                    }\n                }, true);\n            }\n            else {\n                promoteChance = effect.chance || 100 * 100; // 100%\n            }\n            if (!(cell.flags.cellMech & Cell.MechFlags.CAUGHT_FIRE_THIS_TURN) &&\n                GW.random.chance(promoteChance, 10000)) {\n                willFire[x][y] |= GW.flag.fl(tile.layer);\n                // cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n            }\n        }\n    });\n    // Then activate them - so that we don't activate the next generation as part of the forEach\n    await willFire.forEachAsync(async (w, x, y) => {\n        if (!w)\n            return;\n        const cell = map.cell(x, y);\n        if (cell.flags.cellMech & Cell.MechFlags.EVENT_FIRED_THIS_TURN)\n            return;\n        for (let layer = 0; layer <= Entity.Layer.GAS; ++layer) {\n            if (w & GW.flag.fl(layer)) {\n                await cell.activate(event, map, x, y, {\n                    force: true,\n                    layer,\n                });\n            }\n        }\n    });\n    GW.grid.free(willFire);\n}\n// Spawn\nexport function spawnTiles(flags, spawnMap, map, tile, volume = 0) {\n    let i, j;\n    let accomplishedSomething;\n    accomplishedSomething = false;\n    const blockedByOtherLayers = flags & Flags.E_BLOCKED_BY_OTHER_LAYERS;\n    const superpriority = flags & Flags.E_SUPERPRIORITY;\n    // const applyEffects = ctx.refreshCell;\n    volume = volume || 0; // (tile ? tile.volume : 0);\n    for (i = 0; i < spawnMap.width; i++) {\n        for (j = 0; j < spawnMap.height; j++) {\n            if (!spawnMap[i][j])\n                continue; // If it's not flagged for building in the spawn map,\n            // const isRoot = spawnMap[i][j] === 1;\n            spawnMap[i][j] = 0; // so that the spawnmap reflects what actually got built\n            const cell = map.cell(i, j);\n            if (cell.tile(tile.layer) === tile) {\n                // If the new cell already contains the fill terrain,\n                if (tile.layer == Entity.Layer.GAS) {\n                    spawnMap[i][j] = 1;\n                    cell.gasVolume += volume;\n                }\n                else if (tile.layer == Entity.Layer.LIQUID) {\n                    spawnMap[i][j] = 1;\n                    cell.liquidVolume += volume;\n                }\n            }\n            else if ((superpriority ||\n                cell.tile(tile.layer).priority < tile.priority) && // If the terrain in the layer to be overwritten has a higher priority number (unless superpriority),\n                !cell.obstructsLayer(tile.layer) && // If we will be painting into the surface layer when that cell forbids it,\n                (!cell.item || !(flags & Flags.E_BLOCKED_BY_ITEMS)) &&\n                (!cell.actor || !(flags & Flags.E_BLOCKED_BY_ACTORS)) &&\n                (!blockedByOtherLayers ||\n                    cell.topmostTile().priority < tile.priority) // TODO - highestPriorityTile()\n            ) {\n                if (map.setTile(i, j, tile, volume)) {\n                    // if the fill won't violate the priority of the most important terrain in this cell:\n                    spawnMap[i][j] = 1; // so that the spawnmap reflects what actually got built\n                    // map.redrawCell(cell);\n                    // if (volume && cell.gas) {\n                    //     cell.volume += (feat.volume || 0);\n                    // }\n                    cell.flags.cellMech |= Cell.MechFlags.EVENT_FIRED_THIS_TURN;\n                    if (flags & Flags.E_PROTECTED) {\n                        cell.flags.cellMech |= Cell.MechFlags.EVENT_PROTECTED;\n                    }\n                    accomplishedSomething = true;\n                    // debug('- tile', i, j, 'tile=', tile.id);\n                }\n            }\n        }\n    }\n    if (accomplishedSomething) {\n        map.changed = true;\n    }\n    return accomplishedSomething;\n}\n// Spread\nfunction cellIsOk(config, map, x, y, flags, isStart) {\n    if (!map.hasXY(x, y))\n        return false;\n    const cell = map.cell(x, y);\n    if (cell.flags.cellMech & Cell.MechFlags.EVENT_PROTECTED)\n        return false;\n    if (flags & Flags.E_BUILD_IN_WALLS) {\n        if (!cell.isWall())\n            return false;\n    }\n    else if (flags & Flags.E_MUST_TOUCH_WALLS) {\n        let ok = false;\n        map.eachNeighbor(x, y, (c) => {\n            if (c.isWall()) {\n                ok = true;\n            }\n        });\n        if (!ok)\n            return false;\n    }\n    else if (flags & Flags.E_NO_TOUCH_WALLS) {\n        let ok = true;\n        if (cell.isWall())\n            return false; // or on wall\n        map.eachNeighbor(x, y, (c) => {\n            if (c.isWall()) {\n                ok = false;\n            }\n        });\n        if (!ok)\n            return false;\n    }\n    else if (cell.blocksEffects() && !config.matchTile && !isStart) {\n        return false;\n    }\n    // if (ctx.bounds && !ctx.bounds.containsXY(x, y)) return false;\n    if (config.matchTile && !cell.hasTile(config.matchTile))\n        return false;\n    return true;\n}\nexport function computeSpawnMap(config, effect, x, y) {\n    let i, j, dir, t, x2, y2;\n    let madeChange;\n    // const bounds = ctx.bounds || null;\n    // if (bounds) {\n    //   // Activation.debug('- bounds', bounds);\n    // }\n    const map = effect.map;\n    const flags = effect.flags;\n    const grid = effect.grid;\n    let startProb = config.spread || 0;\n    let probDec = config.decrement || 0;\n    const spawnMap = grid;\n    spawnMap.fill(0);\n    spawnMap[x][y] = t = 1; // incremented before anything else happens\n    let count = 1;\n    if (startProb) {\n        madeChange = true;\n        if (startProb >= 100) {\n            probDec = probDec || 100;\n        }\n        if (probDec <= 0) {\n            probDec = startProb;\n        }\n        while (madeChange && startProb > 0) {\n            madeChange = false;\n            t++;\n            for (i = 0; i < map.width; i++) {\n                for (j = 0; j < map.height; j++) {\n                    if (spawnMap[i][j] == t - 1) {\n                        for (dir = 0; dir < 4; dir++) {\n                            x2 = i + GW.utils.DIRS[dir][0];\n                            y2 = j + GW.utils.DIRS[dir][1];\n                            if (spawnMap.hasXY(x2, y2) &&\n                                !spawnMap[x2][y2] &&\n                                cellIsOk(config, map, x2, y2, flags, false) &&\n                                GW.random.chance(startProb)) {\n                                spawnMap[x2][y2] = t;\n                                madeChange = true;\n                                ++count;\n                            }\n                        }\n                    }\n                }\n            }\n            startProb -= probDec;\n        }\n    }\n    if (!cellIsOk(config, map, x, y, flags, true)) {\n        spawnMap[x][y] = 0;\n        --count;\n    }\n    return count > 0;\n}\n// export function spreadCircle(\n//     this: any,\n//     ctx: GW.effect.EffectCtx,\n//     spawnMap: GW.grid.NumGrid\n// ) {\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     let radius = 0;\n//     startProb = startProb || 100;\n//     if (startProb >= 100) {\n//         probDec = probDec || 100;\n//     }\n//     while (GW.random.chance(startProb)) {\n//         startProb -= probDec;\n//         ++radius;\n//     }\n//     // startProb = 100;\n//     // probDec = 0;\n//     spawnMap.updateCircle(x, y, radius, (_v, i, j) => {\n//         if (!cellIsOk(this, i, j, ctx)) return 0;\n//         // const dist = Math.floor(Utils.distanceBetween(x, y, i, j));\n//         // const prob = startProb - dist * probDec;\n//         // if (!random.chance(prob)) return 0;\n//         return 1;\n//     });\n//     // spawnMap[x][y] = 1;\n//     // if (!isOk(flags, x, y, ctx)) {\n//     //     spawnMap[x][y] = 0;\n//     // }\n//     return true;\n// }\n// export function spreadLine(\n//     this: any,\n//     ctx: GW.effect.EffectCtx,\n//     spawnMap: GW.grid.NumGrid\n// ) {\n//     let x2, y2;\n//     let madeChange;\n//     const x = ctx.x;\n//     const y = ctx.y;\n//     let startProb = this.spread || 0;\n//     let probDec = this.decrement || 0;\n//     spawnMap.fill(0);\n//     spawnMap[x][y] = 1; // incremented before anything else happens\n//     if (startProb) {\n//         madeChange = true;\n//         if (startProb >= 100) {\n//             probDec = probDec || 100;\n//         }\n//         x2 = x;\n//         y2 = y;\n//         const dir = GW.utils.DIRS[GW.random.number(4)];\n//         while (madeChange) {\n//             madeChange = false;\n//             x2 = x2 + dir[0];\n//             y2 = y2 + dir[1];\n//             if (\n//                 spawnMap.hasXY(x2, y2) &&\n//                 !spawnMap[x2][y2] &&\n//                 cellIsOk(this, x2, y2, ctx) &&\n//                 GW.random.chance(startProb)\n//             ) {\n//                 spawnMap[x2][y2] = 1;\n//                 madeChange = true;\n//                 startProb -= probDec;\n//             }\n//         }\n//     }\n//     if (!cellIsOk(this, x, y, ctx)) {\n//         spawnMap[x][y] = 0;\n//     }\n//     return true;\n// }\nexport function clearCells(map, spawnMap, flags = 0) {\n    let didSomething = false;\n    const clearAll = (flags & Flags.E_CLEAR_CELL) === Flags.E_CLEAR_CELL;\n    spawnMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (clearAll) {\n            cell.clear();\n        }\n        else {\n            if (flags & Flags.E_CLEAR_GAS) {\n                cell.clearLayer(Entity.Layer.GAS);\n            }\n            if (flags & Flags.E_CLEAR_LIQUID) {\n                cell.clearLayer(Entity.Layer.LIQUID);\n            }\n            if (flags & Flags.E_CLEAR_SURFACE) {\n                cell.clearLayer(Entity.Layer.SURFACE);\n            }\n            if (flags & Flags.E_CLEAR_GROUND) {\n                cell.clearLayer(Entity.Layer.GROUND);\n            }\n        }\n        didSomething = true;\n    });\n    return didSomething;\n}\nexport function evacuateCreatures(map, blockingMap) {\n    let i, j;\n    let didSomething = false;\n    for (i = 0; i < map.width; i++) {\n        for (j = 0; j < map.height; j++) {\n            if (!blockingMap[i][j])\n                continue;\n            const cell = map.cell(i, j);\n            if (!cell.actor)\n                continue;\n            const monst = cell.actor;\n            const loc = map.matchingLocNear(i, j, (cell) => {\n                return !monst.forbidsCell(cell);\n            }, { hallways: true, blockingMap });\n            if (loc && loc[0] >= 0 && loc[1] >= 0) {\n                map.moveActor(loc[0], loc[1], monst);\n                // map.redrawXY(loc[0], loc[1]);\n                didSomething = true;\n            }\n        }\n    }\n    return didSomething;\n}\nexport function evacuateItems(map, blockingMap) {\n    let didSomething = false;\n    blockingMap.forEach((v, i, j) => {\n        if (!v)\n            return;\n        const cell = map.cell(i, j);\n        if (!cell.item)\n            return;\n        const item = cell.item;\n        const loc = map.matchingLocNear(i, j, (dest) => {\n            return !item.forbidsCell(dest);\n        }, { hallways: true, blockingMap });\n        if (loc && loc[0] >= 0 && loc[1] >= 0) {\n            map.removeItem(item);\n            map.addItem(loc[0], loc[1], item);\n            // map.redrawXY(loc[0], loc[1]);\n            didSomething = true;\n        }\n    });\n    return didSomething;\n}\nexport function makeClearEffect(config) {\n    if (!config) {\n        GW.utils.ERROR('Config required to make clear effect.');\n        return null;\n    }\n    if (typeof config === 'string') {\n        config = config\n            .split(/[,|]/)\n            .map((t) => t.trim())\n            .reduce((out, v) => {\n            // @ts-ignore -- huh?\n            const layer = Entity.Layer[v] || 0;\n            return out | layer;\n        }, 0);\n    }\n    else if (config === true) {\n        config = Entity.Layer.ALL_LAYERS;\n    }\n    else if (!Array.isArray(config)) {\n        GW.utils.ERROR('clear effect must have number or string config.');\n        return null;\n    }\n    return clearEffect.bind(config);\n}\nGW.effect.installType('clear', makeClearEffect);\nexport function clearEffect(effect, x, y) {\n    const map = effect.map;\n    if (!map)\n        return false;\n    return map.clearCellLayers(x, y, this);\n}\n","import * as GW from 'gw-utils';\nimport * as FLAGS from './mapFlags';\nexport function analyze(map, updateChokeCounts = true) {\n    updateLoopiness(map);\n    updateChokepoints(map, updateChokeCounts);\n}\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n// TODO - Move to Map?\nexport function updateChokepoints(map, updateCounts) {\n    const passMap = GW.grid.alloc(map.width, map.height);\n    const grid = GW.grid.alloc(map.width, map.height);\n    for (let i = 0; i < map.width; i++) {\n        for (let j = 0; j < map.height; j++) {\n            const cell = map.cell(i, j);\n            if ((cell.hasTileFlag(FLAGS.Tile.T_PATHING_BLOCKER) ||\n                cell.hasLayerFlag(FLAGS.Entity.L_BLOCKS_MOVE)) &&\n                !cell.hasLayerFlag(FLAGS.Entity.L_SECRETLY_PASSABLE)) {\n                // cell.flags &= ~FLAGS.CellMech.IS_IN_LOOP;\n                passMap[i][j] = 0;\n            }\n            else {\n                // cell.flags |= FLAGS.CellMech.IS_IN_LOOP;\n                passMap[i][j] = 1;\n            }\n        }\n    }\n    let passableArcCount;\n    // done finding loops; now flag chokepoints\n    for (let i = 1; i < passMap.width - 1; i++) {\n        for (let j = 1; j < passMap.height - 1; j++) {\n            map.cells[i][j].flags.cellMech &= ~FLAGS.CellMech.IS_CHOKEPOINT;\n            if (passMap[i][j] &&\n                !(map.cells[i][j].flags.cellMech & FLAGS.CellMech.IS_IN_LOOP)) {\n                passableArcCount = 0;\n                for (let dir = 0; dir < 8; dir++) {\n                    const oldX = i + GW.utils.CLOCK_DIRS[(dir + 7) % 8][0];\n                    const oldY = j + GW.utils.CLOCK_DIRS[(dir + 7) % 8][1];\n                    const newX = i + GW.utils.CLOCK_DIRS[dir][0];\n                    const newY = j + GW.utils.CLOCK_DIRS[dir][1];\n                    if ((map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                        passMap[newX][newY]) !=\n                        (map.hasXY(oldX, oldY) && // RUT.Map.makeValidXy(map, oldXy) &&\n                            passMap[oldX][oldY])) {\n                        if (++passableArcCount > 2) {\n                            if ((!passMap[i - 1][j] && !passMap[i + 1][j]) ||\n                                (!passMap[i][j - 1] && !passMap[i][j + 1])) {\n                                map.cells[i][j].flags.cellMech |=\n                                    FLAGS.CellMech.IS_CHOKEPOINT;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (updateCounts) {\n        // Done finding chokepoints; now create a chokepoint map.\n        // The chokepoint map is a number for each passable tile. If the tile is a chokepoint,\n        // then the number indicates the number of tiles that would be rendered unreachable if the\n        // chokepoint were blocked. If the tile is not a chokepoint, then the number indicates\n        // the number of tiles that would be rendered unreachable if the nearest exit chokepoint\n        // were blocked.\n        // The cost of all of this is one depth-first flood-fill per open point that is adjacent to a chokepoint.\n        // Start by setting the chokepoint values really high, and roping off room machines.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                map.cells[i][j].chokeCount = 30000;\n                if (map.cells[i][j].flags.cellMech &\n                    FLAGS.CellMech.IS_IN_ROOM_MACHINE) {\n                    passMap[i][j] = 0;\n                }\n            }\n        }\n        // Scan through and find a chokepoint next to an open point.\n        for (let i = 0; i < map.width; i++) {\n            for (let j = 0; j < map.height; j++) {\n                const cell = map.cells[i][j];\n                if (passMap[i][j] &&\n                    cell.flags.cellMech & FLAGS.CellMech.IS_CHOKEPOINT) {\n                    for (let dir = 0; dir < 4; dir++) {\n                        const newX = i + GW.utils.DIRS[dir][0];\n                        const newY = j + GW.utils.DIRS[dir][1];\n                        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n                            passMap[newX][newY] &&\n                            !(map.cells[newX][newY].flags.cellMech &\n                                FLAGS.CellMech.IS_CHOKEPOINT)) {\n                            // OK, (newX, newY) is an open point and (i, j) is a chokepoint.\n                            // Pretend (i, j) is blocked by changing passMap, and run a flood-fill cell count starting on (newX, newY).\n                            // Keep track of the flooded region in grid[][].\n                            grid.fill(0);\n                            passMap[i][j] = 0;\n                            let cellCount = floodFillCount(map, grid, passMap, newX, newY);\n                            passMap[i][j] = 1;\n                            // CellCount is the size of the region that would be obstructed if the chokepoint were blocked.\n                            // CellCounts less than 4 are not useful, so we skip those cases.\n                            if (cellCount >= 4) {\n                                // Now, on the chokemap, all of those flooded cells should take the lesser of their current value or this resultant number.\n                                for (let i2 = 0; i2 < grid.width; i2++) {\n                                    for (let j2 = 0; j2 < grid.height; j2++) {\n                                        if (grid[i2][j2] &&\n                                            cellCount <\n                                                map.cells[i2][j2].chokeCount) {\n                                            map.cells[i2][j2].chokeCount = cellCount;\n                                            map.cells[i2][j2].flags.cellMech &= ~FLAGS.CellMech\n                                                .IS_GATE_SITE;\n                                        }\n                                    }\n                                }\n                                // The chokepoint itself should also take the lesser of its current value or the flood count.\n                                if (cellCount < cell.chokeCount) {\n                                    cell.chokeCount = cellCount;\n                                    cell.flags.cellMech |=\n                                        FLAGS.CellMech.IS_GATE_SITE;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    GW.grid.free(passMap);\n    GW.grid.free(grid);\n}\n// Assumes it is called with respect to a passable (startX, startY), and that the same is not already included in results.\n// Returns 10000 if the area included an area machine.\nexport function floodFillCount(map, results, passMap, startX, startY) {\n    let count = passMap[startX][startY] == 2 ? 5000 : 1;\n    if (map.cells[startX][startY].flags.cellMech &\n        FLAGS.CellMech.IS_IN_AREA_MACHINE) {\n        count = 10000;\n    }\n    results[startX][startY] = 1;\n    for (let dir = 0; dir < 4; dir++) {\n        const newX = startX + GW.utils.DIRS[dir][0];\n        const newY = startY + GW.utils.DIRS[dir][1];\n        if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, newXy) &&\n            passMap[newX][newY] &&\n            !results[newX][newY]) {\n            count += floodFillCount(map, results, passMap, newX, newY);\n        }\n    }\n    return Math.min(count, 10000);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n// TODO = Move loopiness to Map\nexport function updateLoopiness(map) {\n    map.forEach(resetLoopiness);\n    map.forEach(checkLoopiness);\n    cleanLoopiness(map);\n}\nexport function resetLoopiness(cell, _x, _y, _map) {\n    if ((cell.hasTileFlag(FLAGS.Tile.T_PATHING_BLOCKER) ||\n        cell.hasLayerFlag(FLAGS.Entity.L_BLOCKS_MOVE)) &&\n        !cell.hasLayerFlag(FLAGS.Entity.L_SECRETLY_PASSABLE)) {\n        cell.flags.cellMech &= ~FLAGS.CellMech.IS_IN_LOOP;\n        // passMap[i][j] = false;\n    }\n    else {\n        cell.flags.cellMech |= FLAGS.CellMech.IS_IN_LOOP;\n        // passMap[i][j] = true;\n    }\n}\nexport function checkLoopiness(cell, x, y, map) {\n    let inString;\n    let newX, newY, dir, sdir;\n    let numStrings, maxStringLength, currentStringLength;\n    if (!cell || !(cell.flags.cellMech & FLAGS.CellMech.IS_IN_LOOP)) {\n        return false;\n    }\n    // find an unloopy neighbor to start on\n    for (sdir = 0; sdir < 8; sdir++) {\n        newX = x + GW.utils.CLOCK_DIRS[sdir][0];\n        newY = y + GW.utils.CLOCK_DIRS[sdir][1];\n        if (!map.hasXY(newX, newY))\n            continue;\n        const cell = map.get(newX, newY);\n        if (!cell || !(cell.flags.cellMech & FLAGS.CellMech.IS_IN_LOOP)) {\n            break;\n        }\n    }\n    if (sdir == 8) {\n        // no unloopy neighbors\n        return false; // leave cell loopy\n    }\n    // starting on this unloopy neighbor,\n    // work clockwise and count up:\n    // (a) the number of strings of loopy neighbors, and\n    // (b) the length of the longest such string.\n    numStrings = maxStringLength = currentStringLength = 0;\n    inString = false;\n    for (dir = sdir; dir < sdir + 8; dir++) {\n        newX = x + GW.utils.CLOCK_DIRS[dir % 8][0];\n        newY = y + GW.utils.CLOCK_DIRS[dir % 8][1];\n        if (!map.hasXY(newX, newY))\n            continue;\n        const newCell = map.get(newX, newY);\n        if (newCell && newCell.flags.cellMech & FLAGS.CellMech.IS_IN_LOOP) {\n            currentStringLength++;\n            if (!inString) {\n                if (numStrings > 0) {\n                    return false; // more than one string here; leave loopy\n                }\n                numStrings++;\n                inString = true;\n            }\n        }\n        else if (inString) {\n            if (currentStringLength > maxStringLength) {\n                maxStringLength = currentStringLength;\n            }\n            currentStringLength = 0;\n            inString = false;\n        }\n    }\n    if (inString && currentStringLength > maxStringLength) {\n        maxStringLength = currentStringLength;\n    }\n    if (numStrings == 1 && maxStringLength <= 4) {\n        cell.flags.cellMech &= ~FLAGS.CellMech.IS_IN_LOOP;\n        for (dir = 0; dir < 8; dir++) {\n            const newX = x + GW.utils.CLOCK_DIRS[dir][0];\n            const newY = y + GW.utils.CLOCK_DIRS[dir][1];\n            if (map.hasXY(newX, newY)) {\n                const newCell = map.cell(newX, newY);\n                checkLoopiness(newCell, newX, newY, map);\n            }\n        }\n        return true;\n    }\n    else {\n        return false;\n    }\n}\nexport function fillInnerLoopGrid(map, grid) {\n    for (let x = 0; x < map.width; ++x) {\n        for (let y = 0; y < map.height; ++y) {\n            const cell = map.cells[x][y];\n            if (cell.flags.cellMech & FLAGS.CellMech.IS_IN_LOOP) {\n                grid[x][y] = 1;\n            }\n            else if (x > 0 && y > 0) {\n                const up = map.cells[x][y - 1];\n                const left = map.cells[x - 1][y];\n                if (up.flags.cellMech & FLAGS.CellMech.IS_IN_LOOP &&\n                    left.flags.cellMech & FLAGS.CellMech.IS_IN_LOOP) {\n                    grid[x][y] = 1;\n                }\n            }\n        }\n    }\n}\nexport function cleanLoopiness(map) {\n    // remove extraneous loop markings\n    const grid = GW.grid.alloc(map.width, map.height);\n    fillInnerLoopGrid(map, grid);\n    // const xy = { x: 0, y: 0 };\n    let designationSurvives;\n    for (let i = 0; i < grid.width; i++) {\n        for (let j = 0; j < grid.height; j++) {\n            const cell = map.cell(i, j);\n            if (cell.flags.cellMech & FLAGS.CellMech.IS_IN_LOOP) {\n                designationSurvives = false;\n                for (let dir = 0; dir < 8; dir++) {\n                    let newX = i + GW.utils.CLOCK_DIRS[dir][0];\n                    let newY = j + GW.utils.CLOCK_DIRS[dir][1];\n                    if (map.hasXY(newX, newY) && // RUT.Map.makeValidXy(map, xy, newX, newY) &&\n                        !grid[newX][newY] &&\n                        !(map.cells[newX][newY].flags.cellMech &\n                            FLAGS.CellMech.IS_IN_LOOP)) {\n                        designationSurvives = true;\n                        break;\n                    }\n                }\n                if (!designationSurvives) {\n                    grid[i][j] = 1;\n                    map.cells[i][j].flags.cellMech &= ~FLAGS.CellMech\n                        .IS_IN_LOOP;\n                }\n            }\n        }\n    }\n    GW.grid.free(grid);\n}\n////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////\n","import { utils as Utils, random, grid as Grid, fov as Fov, flag as Flag, path as Path, color as Color, colors as COLORS, canvas as Canvas, config as CONFIG, data as DATA, make as Make, sprite as Sprite, effect as EFFECT, } from 'gw-utils';\nimport * as Cell from './cell';\nimport * as Tile from './tile';\nimport { Map as Flags, Cell as CellFlags, Tile as TileFlags, CellMech as CellMechFlags, TileMech as TileMechFlags, Layer as TileLayer, Entity as LayerFlags, } from './mapFlags';\nimport * as Light from './light';\nimport * as Entity from './entity';\nimport * as Visibility from './visibility';\nimport * as Effect from './mapEffect';\nexport { Flags };\nexport * from './analyze';\nUtils.setDefaults(CONFIG, {\n    'map.deepestLevel': 99,\n});\nexport class Map {\n    constructor(w, h, opts = {}) {\n        this.locations = {};\n        this.config = {};\n        this._actors = null;\n        this._items = null;\n        this.flags = { map: 0 };\n        this.lights = null;\n        this.fov = null;\n        this.effects = {};\n        this._width = w;\n        this._height = h;\n        this.cells = Grid.make(w, h, () => new Cell.Cell());\n        this.locations = opts.locations || {};\n        this.config = Object.assign({}, opts);\n        this.config.tick = this.config.tick || 100;\n        this._actors = null;\n        this._items = null;\n        this.flags.map = Flag.from(Flags, Flags.MAP_DEFAULT, opts.flags);\n        const ambient = opts.ambient || opts.ambientLight || opts.light || 'white';\n        this.ambientLight = Color.make(ambient);\n        if (opts.ambient || opts.ambientLight || opts.light) {\n            this.ambientLightChanged = true;\n        }\n        this.lights = null;\n        this.id = opts.id;\n        if (opts.fov) {\n            this.flags.map |= Flags.MAP_CALC_FOV;\n            this.fov = { x: -1, y: -1 };\n        }\n        if (opts.updateLiquid && typeof opts.updateLiquid === 'function') {\n            this.updateLiquid = opts.updateLiquid.bind(this);\n        }\n        if (opts.updateGas && typeof opts.updateGas === 'function') {\n            this.updateGas = opts.updateGas.bind(this);\n        }\n        Light.updateLighting(this); // to set the ambient light\n        Visibility.initMap(this);\n        if (opts.visible || opts.revealed || !this.fov) {\n            this.revealAll();\n        }\n        if (opts.visible || !this.fov) {\n            this.makeVisible();\n        }\n        this.changed = false;\n    }\n    get width() {\n        return this._width;\n    }\n    get height() {\n        return this._height;\n    }\n    async start() { }\n    clear(floorTile = 'FLOOR') {\n        this.cells.forEach((c) => c.clear(floorTile));\n        this.changed = true;\n    }\n    dump(fmt) {\n        this.cells.dump(fmt || ((c) => c.dump()));\n    }\n    cell(x, y) {\n        return this.cells[x][y];\n    }\n    get(x, y) {\n        return this.cells.get(x, y);\n    }\n    eachCell(fn) {\n        this.cells.forEach((c, i, j) => fn(c, i, j, this));\n    }\n    forEach(fn) {\n        this.cells.forEach((c, i, j) => fn(c, i, j, this));\n    }\n    async forEachAsync(fn) {\n        return this.cells.forEachAsync((c, i, j) => fn(c, i, j, this));\n    }\n    forRect(x, y, w, h, fn) {\n        this.cells.forRect(x, y, w, h, (c, i, j) => fn(c, i, j, this));\n    }\n    eachNeighbor(x, y, fn, only4dirs = false) {\n        this.cells.eachNeighbor(x, y, (c, i, j) => fn(c, i, j, this), only4dirs);\n    }\n    eachNeighborAsync(x, y, fn, only4dirs = false) {\n        return this.cells.eachNeighborAsync(x, y, (c, i, j) => fn(c, i, j, this), only4dirs);\n    }\n    randomEach(fn) {\n        this.cells.randomEach((c, i, j) => fn(c, i, j, this));\n    }\n    count(fn) {\n        let count = 0;\n        this.forEach((c, x, y, g) => {\n            if (fn(c, x, y, g)) {\n                ++count;\n            }\n        });\n        return count;\n    }\n    hasXY(x, y) {\n        return this.cells.hasXY(x, y);\n    }\n    isBoundaryXY(x, y) {\n        return this.cells.isBoundaryXY(x, y);\n    }\n    get changed() {\n        return (this.flags.map & Flags.MAP_CHANGED) > 0;\n    }\n    set changed(v) {\n        if (v === true) {\n            this.flags.map |= Flags.MAP_CHANGED;\n        }\n        else if (v === false) {\n            this.flags.map &= ~Flags.MAP_CHANGED;\n        }\n    }\n    hasCellFlag(x, y, flag) {\n        return this.cell(x, y).flags.cell & flag;\n    }\n    hasCellMechFlag(x, y, flag) {\n        return this.cell(x, y).flags.cellMech & flag;\n    }\n    hasLayerFlag(x, y, flag) {\n        return this.cell(x, y).hasLayerFlag(flag);\n    }\n    hasTileFlag(x, y, flag, limitToPlayerKnowledge = false) {\n        return this.cell(x, y).hasTileFlag(flag, limitToPlayerKnowledge);\n    }\n    hasTileMechFlag(x, y, flag, limitToPlayerKnowledge = false) {\n        return this.cell(x, y).hasTileMechFlag(flag, limitToPlayerKnowledge);\n    }\n    redrawCell(cell) {\n        // if (cell.isAnyKindOfVisible()) {\n        cell.needsRedraw = true;\n        this.flags.map |= Flags.MAP_CHANGED;\n        // }\n    }\n    redrawXY(x, y) {\n        const cell = this.cell(x, y);\n        this.redrawCell(cell);\n    }\n    redrawAll() {\n        this.forEach((c) => {\n            // if (c.isAnyKindOfVisible()) {\n            c.needsRedraw = true;\n            // }\n        });\n        this.changed = true;\n    }\n    drawInto(dest, opts = {}) {\n        Light.updateLighting(this);\n        const buffer = dest instanceof Canvas.Canvas ? dest.buffer : dest;\n        if (typeof opts === 'boolean')\n            opts = { force: opts };\n        const mixer = new Sprite.Mixer();\n        for (let x = 0; x < buffer.width; ++x) {\n            for (let y = 0; y < buffer.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.needsRedraw || opts.force) {\n                    getCellAppearance(this, x, y, mixer);\n                    const glyph = typeof mixer.ch === 'number'\n                        ? mixer.ch\n                        : buffer.toGlyph(mixer.ch);\n                    buffer.draw(x, y, glyph, mixer.fg.toInt(), mixer.bg.toInt());\n                    cell.needsRedraw = false;\n                }\n            }\n        }\n    }\n    revealAll() {\n        this.forEach((c) => {\n            c.markRevealed();\n            c.storeMemory();\n        });\n        // TODO - !!!\n        // if (DATA.player) {\n        //     DATA.player.invalidateCostMap();\n        // }\n    }\n    markRevealed(x, y) {\n        if (!this.cell(x, y).markRevealed())\n            return;\n        // TODO - !!!\n        // if (DATA.player) {\n        //     DATA.player.invalidateCostMap();\n        // }\n    }\n    makeVisible(v = true) {\n        if (v) {\n            this.setFlags(0, Cell.Flags.VISIBLE);\n        }\n        else {\n            this.clearFlags(0, Cell.Flags.ANY_KIND_OF_VISIBLE);\n        }\n    }\n    isVisible(x, y) {\n        return this.cell(x, y).isVisible();\n    }\n    isAnyKindOfVisible(x, y) {\n        return this.cell(x, y).isAnyKindOfVisible();\n    }\n    isOrWasAnyKindOfVisible(x, y) {\n        return this.cell(x, y).isOrWasAnyKindOfVisible();\n    }\n    isRevealed(x, y) {\n        return this.cell(x, y).isRevealed();\n    }\n    get anyLightChanged() {\n        return (this.flags.map & Flags.MAP_STABLE_LIGHTS) == 0;\n    }\n    set anyLightChanged(v) {\n        if (v) {\n            this.flags.map &= ~Flags.MAP_STABLE_LIGHTS;\n        }\n        else {\n            this.flags.map |= Flags.MAP_STABLE_LIGHTS;\n        }\n    }\n    get ambientLightChanged() {\n        return this.staticLightChanged;\n    }\n    set ambientLightChanged(v) {\n        this.staticLightChanged = v;\n    }\n    get staticLightChanged() {\n        return (this.flags.map & Flags.MAP_STABLE_GLOW_LIGHTS) == 0;\n    }\n    set staticLightChanged(v) {\n        if (v) {\n            this.flags.map &= ~(Flags.MAP_STABLE_GLOW_LIGHTS | Flags.MAP_STABLE_LIGHTS);\n        }\n        else {\n            this.flags.map |= Flags.MAP_STABLE_GLOW_LIGHTS;\n        }\n    }\n    setFlag(flag) {\n        this.flags.map |= flag;\n        this.changed = true;\n    }\n    setFlags(mapFlag = 0, cellFlag = 0, cellMechFlag = 0) {\n        if (mapFlag) {\n            this.flags.map |= mapFlag;\n        }\n        if (cellFlag || cellMechFlag) {\n            this.forEach((c) => c.setFlags(cellFlag, cellMechFlag));\n        }\n        this.changed = true;\n    }\n    clearFlag(flag) {\n        this.flags.map &= ~flag;\n        this.changed = true;\n    }\n    clearFlags(mapFlag = 0, cellFlag = 0, cellMechFlag = 0) {\n        if (mapFlag) {\n            this.flags.map &= ~mapFlag;\n        }\n        if (cellFlag || cellMechFlag) {\n            this.forEach((cell) => cell.clearFlags(cellFlag, cellMechFlag));\n        }\n        this.changed = true;\n    }\n    // setCellFlag(x: number, y: number, flag: number) {\n    //   this.cell(x, y).flags |= flag;\n    // }\n    setCellFlags(x, y, cellFlag = 0, cellMechFlag = 0) {\n        this.cell(x, y).setFlags(cellFlag, cellMechFlag);\n        this.flags.map |= Flags.MAP_CHANGED;\n    }\n    clearCellFlags(x, y, cellFlags = 0, cellMechFlags = 0) {\n        this.cell(x, y).clearFlags(cellFlags, cellMechFlags);\n        this.changed = true;\n    }\n    hasTile(x, y, tile) {\n        return this.cells[x][y].hasTile(tile);\n    }\n    layerFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].layerFlags(limitToPlayerKnowledge);\n    }\n    tileFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].tileFlags(limitToPlayerKnowledge);\n    }\n    tileMechFlags(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].tileMechFlags(limitToPlayerKnowledge);\n    }\n    tileWithLayerFlag(x, y, mechFlag = 0) {\n        return this.cells[x][y].tileWithLayerFlag(mechFlag);\n    }\n    tileWithFlag(x, y, flag = 0) {\n        return this.cells[x][y].tileWithFlag(flag);\n    }\n    tileWithMechFlag(x, y, mechFlag = 0) {\n        return this.cells[x][y].tileWithMechFlag(mechFlag);\n    }\n    // hasKnownTileFlag(x: number, y: number, flagMask = 0) {\n    //     return this.cells[x][y].memory.flags.tile & flagMask;\n    // }\n    // hasTileInGroup(x, y, ...groups) { return this.cells[x][y].hasTileInGroup(...groups); }\n    // discoveredTileFlags(x: number, y: number) {\n    //   return this.cells[x][y].discoveredTileFlags();\n    // }\n    // hasDiscoveredTileFlag(x: number, y: number, flag = 0) {\n    //   return this.cells[x][y].hasDiscoveredTileFlag(flag);\n    // }\n    isClear(x, y) {\n        return this.cells[x][y].isClear();\n    }\n    isEmpty(x, y) {\n        return this.cells[x][y].isEmpty();\n    }\n    isObstruction(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isObstruction(limitToPlayerKnowledge);\n    }\n    isDoorway(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isDoorway(limitToPlayerKnowledge);\n    }\n    isSecretDoorway(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isSecretDoorway(limitToPlayerKnowledge);\n    }\n    isLiquid(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isLiquid(limitToPlayerKnowledge);\n    }\n    hasGas(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].hasGas(limitToPlayerKnowledge);\n    }\n    blocksPathing(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].blocksPathing(limitToPlayerKnowledge);\n    }\n    blocksVision(x, y) {\n        return this.cells[x][y].blocksVision();\n    }\n    isMoveableNow(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isMoveableNow(limitToPlayerKnowledge);\n    }\n    isWalkableNow(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].isWalkableNow(limitToPlayerKnowledge);\n    }\n    canBeWalked(x, y, limitToPlayerKnowledge = false) {\n        return this.cells[x][y].canBeWalked(limitToPlayerKnowledge);\n    }\n    topmostTile(x, y, skipGas = false) {\n        return this.cells[x][y].topmostTile(skipGas);\n    }\n    tileFlavor(x, y) {\n        return this.cells[x][y].tileFlavor();\n    }\n    setTile(x, y, tileId, volume = 0) {\n        return this.cell(x, y).setTile(tileId, volume, this);\n    }\n    nullifyCell(x, y) {\n        this.cell(x, y).nullify();\n    }\n    clearCell(x, y) {\n        this.cell(x, y).clear();\n    }\n    clearCellLayers(x, y, layers = -1) {\n        return this.cell(x, y).clearLayers(layers);\n    }\n    clearCellLayersWithFlags(x, y, tileFlags, tileMechFlags = 0) {\n        const cell = this.cell(x, y);\n        cell.clearLayersWithFlags(tileFlags, tileMechFlags);\n    }\n    // clearCellLayers(\n    //     x: number,\n    //     y: number,\n    //     nullLiquid = true,\n    //     nullSurface = true,\n    //     nullGas = true\n    // ) {\n    //     this.changed = true;\n    //     return this.cell(x, y).clearLayers(nullLiquid, nullSurface, nullGas);\n    // }\n    fill(tileId, boundaryTile) {\n        let i, j;\n        if (boundaryTile === undefined) {\n            boundaryTile = tileId;\n        }\n        for (i = 0; i < this.width; ++i) {\n            for (j = 0; j < this.height; ++j) {\n                if (this.isBoundaryXY(i, j)) {\n                    this.setTile(i, j, boundaryTile);\n                }\n                else {\n                    this.setTile(i, j, tileId);\n                }\n            }\n        }\n    }\n    neighborCount(x, y, matchFn, only4dirs = false) {\n        let count = 0;\n        this.eachNeighbor(x, y, (...args) => {\n            if (matchFn(...args))\n                ++count;\n        }, only4dirs);\n        return count;\n    }\n    walkableArcCount(x, y) {\n        if (!this.hasXY(x, y))\n            return -1;\n        return this.cells.arcCount(x, y, (c) => c.isWalkableNow());\n    }\n    diagonalBlocked(x1, y1, x2, y2, limitToPlayerKnowledge = false) {\n        if (x1 == x2 || y1 == y2) {\n            return false; // If it's not a diagonal, it's not diagonally blocked.\n        }\n        if (this.isObstruction(x1, y2, limitToPlayerKnowledge)) {\n            return true;\n        }\n        if (this.isObstruction(x2, y1, limitToPlayerKnowledge)) {\n            return true;\n        }\n        return false;\n    }\n    fillCostGrid(costGrid, costFn) {\n        costFn =\n            costFn ||\n                ((c) => (c.isWalkableNow() ? 1 : Path.OBSTRUCTION));\n        this.cells.forEach((cell, i, j) => {\n            if (cell.isNull()) {\n                costGrid[i][j] = Path.OBSTRUCTION;\n            }\n            else {\n                costGrid[i][j] = costFn(cell, i, j, this);\n            }\n        });\n    }\n    matchingNeighbor(x, y, matcher, only4dirs = false) {\n        return Utils.matchingNeighbor(x, y, (i, j) => {\n            if (!this.hasXY(i, j))\n                return false;\n            return matcher(this.cell(i, j), i, j, this);\n        }, only4dirs);\n    }\n    matchingLocNear(x, y, ...args) {\n        let i, j, k;\n        let matcher = args[0];\n        let opts = args[1] || {};\n        const arg = args[0];\n        if (typeof arg === 'string') {\n            matcher = (c) => c.hasTile(arg);\n        }\n        if (typeof matcher !== 'function') {\n            opts = matcher || opts;\n            matcher = opts.match || Utils.TRUE;\n        }\n        const hallwaysAllowed = opts.hallways !== false;\n        const blockingMap = opts.blockingMap || null;\n        const forbidLiquid = opts.liquids === false;\n        const deterministic = opts.deterministic || false;\n        let candidateLocs = [];\n        let closestDist = (this.width + this.height) * 10;\n        // count up the number of candidate locations\n        for (k = 0; k < Math.max(this.width, this.height) && !candidateLocs.length; k++) {\n            for (i = x - k; i <= x + k; i++) {\n                for (j = y - k; j <= y + k; j++) {\n                    if (!this.hasXY(i, j))\n                        continue;\n                    const cell = this.cell(i, j);\n                    const dist = Math.floor(10 * Utils.distanceBetween(x, y, i, j));\n                    // if ((i == x-k || i == x+k || j == y-k || j == y+k)\n                    if (Math.floor(dist) == k * 10 &&\n                        (!blockingMap || !blockingMap[i][j]) &&\n                        matcher(cell, i, j, this) &&\n                        (!forbidLiquid || !cell.liquid) &&\n                        (hallwaysAllowed || this.walkableArcCount(i, j) < 2)) {\n                        if (dist < closestDist) {\n                            candidateLocs = [[i, j]];\n                            closestDist = dist;\n                        }\n                        else if (dist == closestDist) {\n                            candidateLocs.push([i, j]);\n                        }\n                    }\n                }\n            }\n        }\n        if (candidateLocs.length == 0) {\n            return [-1, -1];\n        }\n        // and pick one\n        let randIndex = 0;\n        if (deterministic) {\n            randIndex = Math.floor(candidateLocs.length / 2);\n        }\n        else {\n            randIndex = random.number(candidateLocs.length);\n        }\n        return candidateLocs[randIndex];\n    }\n    randomMatchingLoc(opts = {}) {\n        let x;\n        let y;\n        let cell;\n        if (typeof opts === 'function') {\n            opts = { match: opts };\n        }\n        const sequence = random.sequence(this.width * this.height);\n        const hallwaysAllowed = opts.hallways || false;\n        const blockingMap = opts.blockingMap || null;\n        const forbidLiquid = opts.liquids === false;\n        const matcher = opts.match || Utils.TRUE;\n        const forbidCellFlags = opts.forbidCellFlags || 0;\n        const forbidLayerFlags = opts.forbidLayerFlags || 0;\n        const forbidTileFlags = opts.forbidTileFlags || 0;\n        const forbidTileMechFlags = opts.forbidTileMechFlags || 0;\n        const tile = opts.tile || null;\n        let success = false;\n        let index = 0;\n        while (!success && index < sequence.length) {\n            const v = sequence[index];\n            x = v % this.width;\n            y = Math.floor(v / this.width);\n            cell = this.cell(x, y);\n            if ((!blockingMap || !blockingMap[x][y]) &&\n                (!tile || cell.hasTile(tile)) &&\n                (!forbidLiquid || !cell.liquid) &&\n                (!forbidCellFlags || !(cell.flags.cell & forbidCellFlags)) &&\n                (!forbidTileFlags || !cell.hasTileFlag(forbidTileFlags)) &&\n                (!forbidLayerFlags || !cell.hasLayerFlag(forbidLayerFlags)) &&\n                (!forbidTileMechFlags ||\n                    !cell.hasTileMechFlag(forbidTileMechFlags)) &&\n                (hallwaysAllowed || this.walkableArcCount(x, y) < 2) &&\n                matcher(cell, x, y, this)) {\n                success = true;\n            }\n            ++index;\n        }\n        if (!success) {\n            // map.debug('randomMatchingLocation', dungeonType, liquidType, terrainType, ' => FAIL');\n            return [-1, -1];\n        }\n        // map.debug('randomMatchingLocation', dungeonType, liquidType, terrainType, ' => ', x, y);\n        return [x, y];\n    }\n    // LIGHT\n    hasVisibleLight(x, y) {\n        return this.cell(x, y).hasVisibleLight();\n    }\n    addStaticLight(x, y, light) {\n        const info = {\n            x,\n            y,\n            light: Light.from(light),\n            next: this.lights,\n        };\n        this.lights = info;\n        this.staticLightChanged = true;\n        return info;\n    }\n    removeStaticLight(x, y, light) {\n        let prev = this.lights;\n        if (!prev)\n            return;\n        function matches(info) {\n            if (info.x != x || info.y != y)\n                return false;\n            return !light || light === info.light;\n        }\n        this.staticLightChanged = true;\n        while (prev && matches(prev)) {\n            prev = this.lights = prev.next;\n        }\n        if (!prev)\n            return;\n        let current = prev.next;\n        while (current) {\n            if (matches(current)) {\n                prev.next = current.next;\n            }\n            else {\n                prev = current;\n            }\n            current = current.next;\n        }\n    }\n    eachStaticLight(fn) {\n        Utils.eachChain(this.lights, (info) => fn(info.light, info.x, info.y));\n        this.eachCell((cell, x, y) => {\n            for (let tile of cell.tiles()) {\n                if (tile.light) {\n                    fn(tile.light, x, y);\n                }\n            }\n        });\n    }\n    eachDynamicLight(fn) {\n        Utils.eachChain(this._actors, (actor) => {\n            if (actor.light)\n                fn(actor.light, actor.x, actor.y);\n        });\n    }\n    // Layers\n    addFx(x, y, anim) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        cell.addLayer(anim);\n        anim.x = x;\n        anim.y = y;\n        this.redrawCell(cell);\n        return true;\n    }\n    moveFx(x, y, anim) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        const oldCell = this.cell(anim.x, anim.y);\n        oldCell.removeLayer(anim);\n        this.redrawCell(oldCell);\n        cell.addLayer(anim);\n        this.redrawCell(cell);\n        anim.x = x;\n        anim.y = y;\n        return true;\n    }\n    removeFx(anim) {\n        const oldCell = this.cell(anim.x, anim.y);\n        oldCell.removeLayer(anim);\n        this.redrawCell(oldCell);\n        this.flags.map |= Flags.MAP_CHANGED;\n        return true;\n    }\n    // ACTORS\n    *actors() {\n        let current = this._actors;\n        while (current) {\n            const next = current.next;\n            yield current;\n            current = next;\n        }\n    }\n    // will return the PLAYER if the PLAYER is at (x, y).\n    actorAt(x, y) {\n        // creature *\n        if (!this.hasXY(x, y))\n            return null;\n        const cell = this.cell(x, y);\n        return cell.actor;\n    }\n    addActor(x, y, theActor) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.actor) {\n            return false;\n        }\n        cell.actor = theActor; // adjusts the layer\n        theActor.next = this._actors;\n        this._actors = theActor;\n        const flag = theActor === DATA.player\n            ? CellFlags.HAS_PLAYER\n            : CellFlags.HAS_ACTOR;\n        cell.flags.cell |= flag;\n        // if (theActor.flags & Flags.Actor.MK_DETECTED)\n        // {\n        // \tcell.flags |= CellFlags.MONSTER_DETECTED;\n        // }\n        if (theActor.light) {\n            this.anyLightChanged = true;\n        }\n        // If the player moves or an actor that blocks vision and the cell is visible...\n        // -- we need to update the FOV\n        if (theActor.isPlayer() ||\n            (cell.isAnyKindOfVisible() && theActor.blocksVision())) {\n            this.flags.map |= Flags.MAP_FOV_CHANGED;\n        }\n        theActor.x = x;\n        theActor.y = y;\n        this.redrawCell(cell);\n        return true;\n    }\n    addActorNear(x, y, theActor) {\n        const loc = this.matchingLocNear(x, y, (cell) => {\n            return !theActor.avoidsCell(cell);\n        });\n        if (!loc || loc[0] < 0) {\n            // GW.ui.message(colors.badMessageColor, 'There is no place to put the actor.');\n            return false;\n        }\n        return this.addActor(loc[0], loc[1], theActor);\n    }\n    moveActor(x, y, actor) {\n        if (!this.hasXY(x, y))\n            return false;\n        this.removeActor(actor);\n        if (actor.rememberedInCell) {\n            const cell = this.cell(x, y);\n            if (cell.isAnyKindOfVisible() !==\n                actor.rememberedInCell.isAnyKindOfVisible()) {\n                actor.rememberedInCell.storeMemory();\n            }\n        }\n        if (!this.addActor(x, y, actor)) {\n            this.addActor(actor.x, actor.y, actor);\n            return false;\n        }\n        if (actor.light) {\n            this.anyLightChanged = true;\n        }\n        return true;\n    }\n    removeActor(actor) {\n        if (!this.hasXY(actor.x, actor.y))\n            return false;\n        const cell = this.cell(actor.x, actor.y);\n        if (cell.actor === actor) {\n            cell.actor = null;\n            Utils.removeFromChain(this, '_actors', actor);\n            if (actor.light) {\n                this.anyLightChanged = true;\n            }\n            // If the player moves or an actor that blocks vision and the cell is visible...\n            // -- we need to update the FOV\n            if (actor.isPlayer() ||\n                (cell.isAnyKindOfVisible() && actor.blocksVision())) {\n                this.flags.map |= Flags.MAP_FOV_CHANGED;\n            }\n            this.redrawCell(cell);\n            return true;\n        }\n        return false;\n    }\n    deleteActorAt(x, y) {\n        const actor = this.actorAt(x, y);\n        if (!actor)\n            return false;\n        this.removeActor(actor);\n        actor.delete();\n        return true;\n    }\n    // dormantAt(x: number, y: number) {  // creature *\n    // \tif (!(this.cell(x, y).flags & CellFlags.HAS_DORMANT_MONSTER)) {\n    // \t\treturn null;\n    // \t}\n    // \treturn this.dormantActors.find( (m) => m.x == x && m.y == y );\n    // }\n    //\n    // addDormant(x, y, actor) {\n    // \ttheActor.x = x;\n    // \ttheActor.y = y;\n    // \tthis.dormant.add(theActor);\n    // \tcell.flags |= (CellFlags.HAS_DORMANT_MONSTER);\n    // \tthis.flags.map |= Flags.MAP_CHANGED;\n    // \treturn true;\n    // }\n    //\n    // removeDormant(actor) {\n    // \tconst cell = this.cell(actor.x, actor.y);\n    // \tcell.flags &= ~(CellFlags.HAS_DORMANT_MONSTER);\n    // \tcell.flags |= CellFlags.NEEDS_REDRAW;\n    // \tthis.flags.map |= Flags.MAP_CHANGED;\n    // \tthis.dormant.remove(actor);\n    // }\n    // ITEMS\n    *items() {\n        let current = this._items;\n        while (current) {\n            const next = current.next;\n            yield current;\n            current = next;\n        }\n    }\n    itemAt(x, y) {\n        const cell = this.cell(x, y);\n        return cell.item;\n    }\n    addItem(x, y, theItem) {\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.item) {\n            // GW.ui.message(colors.badMessageColor, 'There is already an item there.');\n            return false;\n        }\n        theItem.x = x;\n        theItem.y = y;\n        cell.item = theItem; // adjusts the layers\n        theItem.next = this._items;\n        this._items = theItem;\n        if (theItem.light) {\n            this.anyLightChanged = true;\n        }\n        this.redrawCell(cell);\n        if (theItem.isDetected() || CONFIG.D_ITEM_OMNISCIENCE) {\n            cell.flags.cell |= CellFlags.ITEM_DETECTED;\n        }\n        return true;\n    }\n    // addItemNear(x: number, y: number, theItem: Types.ItemType) {\n    //     const loc = this.matchingLocNear(x, y, (cell) => {\n    //         return !theItem.forbidsCell(cell);\n    //     });\n    //     if (!loc || loc[0] < 0) {\n    //         // GW.ui.message(colors.badMessageColor, 'There is no place to put the item.');\n    //         return false;\n    //     }\n    //     return this.addItem(loc[0], loc[1], theItem);\n    // }\n    removeItem(theItem) {\n        const x = theItem.x;\n        const y = theItem.y;\n        if (!this.hasXY(x, y))\n            return false;\n        const cell = this.cell(x, y);\n        if (cell.item !== theItem)\n            return false;\n        cell.item = null;\n        Utils.removeFromChain(this, '_items', theItem);\n        if (theItem.light) {\n            this.anyLightChanged = true;\n        }\n        cell.flags.cell &= ~(CellFlags.HAS_ITEM | CellFlags.ITEM_DETECTED);\n        this.redrawCell(cell);\n        return true;\n    }\n    // // PROMOTE\n    //\n    // async promote(x, y, mechFlag) {\n    // \tif (this.hasTileMechFlag(x, y, mechFlag)) {\n    // \t\tconst cell = this.cell(x, y);\n    // \t\tfor (let tile of cell.tiles()) {\n    // \t\t\tif (tile.mechFlags & mechFlag) {\n    // \t\t\t\tawait tile.promote(this, x, y, false);\n    // \t\t\t}\n    // \t\t}\n    // \t}\n    // }\n    gridDisruptsWalkability(blockingGrid, opts = {}) {\n        const walkableGrid = Grid.alloc(this.width, this.height);\n        let disrupts = false;\n        const gridOffsetX = opts.gridOffsetX || 0;\n        const gridOffsetY = opts.gridOffsetY || 0;\n        const bounds = opts.bounds || null; // TODO - Where is this used ???\n        // Get all walkable locations after lake added\n        this.cells.forEach((cell, i, j) => {\n            if (bounds && !bounds.contains(i, j))\n                return; // outside bounds\n            const blockingX = i + gridOffsetX;\n            const blockingY = j + gridOffsetY;\n            if (cell.isNull()) {\n                return; // not walkable\n            }\n            else if (cell.hasTileFlag(TileFlags.T_HAS_STAIRS)) {\n                if (blockingGrid.get(blockingX, blockingY)) {\n                    disrupts = true;\n                }\n                else {\n                    walkableGrid[i][j] = 1;\n                }\n            }\n            else if (cell.canBeWalked()) {\n                if (blockingGrid.get(blockingX, blockingY))\n                    return;\n                walkableGrid[i][j] = 1;\n            }\n        });\n        let first = true;\n        for (let i = 0; i < walkableGrid.width && !disrupts; ++i) {\n            for (let j = 0; j < walkableGrid.height && !disrupts; ++j) {\n                if (walkableGrid[i][j] == 1) {\n                    if (first) {\n                        walkableGrid.floodFill(i, j, 1, 2);\n                        first = false;\n                    }\n                    else {\n                        disrupts = true;\n                    }\n                }\n            }\n        }\n        Grid.free(walkableGrid);\n        return disrupts;\n    }\n    // FOV\n    // Returns a boolean grid indicating whether each square is in the field of view of (xLoc, yLoc).\n    // forbiddenTileFlags is the set of terrain flags that will block vision (but the blocking cell itself is\n    // illuminated); forbiddenCellFlags is the set of map flags that will block vision.\n    // If cautiousOnWalls is set, we will not illuminate blocking tiles unless the tile one space closer to the origin\n    // is visible to the player; this is to prevent lights from illuminating a wall when the player is on the other\n    // side of the wall.\n    calcFov(grid, x, y, maxRadius, forbiddenCellFlags = 0, forbiddenLayerFlags = LayerFlags.L_BLOCKS_VISION) {\n        maxRadius = maxRadius || this.width + this.height;\n        grid.fill(0);\n        const map = this;\n        const FOV = new Fov.FOV({\n            isBlocked(i, j) {\n                return !!(!grid.hasXY(i, j) ||\n                    map.hasCellFlag(i, j, forbiddenCellFlags) ||\n                    map.hasLayerFlag(i, j, forbiddenLayerFlags));\n            },\n            calcRadius(x, y) {\n                return Math.sqrt(x ** 2 + y ** 2);\n            },\n            setVisible(x, y) {\n                grid[x][y] = 1;\n            },\n            hasXY(x, y) {\n                return grid.hasXY(x, y);\n            },\n        });\n        return FOV.calculate(x, y, maxRadius);\n    }\n    losFromTo(a, b) {\n        if (Utils.equalsXY(a, b))\n            return true;\n        const line = Utils.getLine(a.x, a.y, b.x, b.y);\n        if (!line.length)\n            return false;\n        return !line.some((loc) => {\n            return this.blocksVision(loc[0], loc[1]);\n        });\n    }\n    // MEMORIES\n    storeMemory(x, y) {\n        const cell = this.cell(x, y);\n        cell.storeMemory();\n    }\n    storeMemories() {\n        let x, y;\n        for (x = 0; x < this.width; ++x) {\n            for (y = 0; y < this.height; ++y) {\n                const cell = this.cell(x, y);\n                if (cell.flags.cell & CellFlags.ANY_KIND_OF_VISIBLE) {\n                    cell.storeMemory();\n                }\n                // cell.flags &= CellFlags.PERMANENT_CELL_FLAGS;\n                // cell.mechFlags &= CellMechFlags.PERMANENT_MECH_FLAGS;\n            }\n        }\n    }\n    // TICK\n    async activateCell(x, y, event) {\n        const cell = this.cell(x, y);\n        return await cell.activate(event, this, x, y, { cell });\n    }\n    async activateAll(event) {\n        return Effect.fireAll(this, event);\n    }\n    async tick() {\n        await Effect.fireAll(this, 'tick');\n        // Bookkeeping for fire, pressure plates and key-activated tiles.\n        await this.forEachAsync(async (cell, x, y) => {\n            cell.flags.cellMech &= ~Cell.MechFlags.CAUGHT_FIRE_THIS_TURN;\n            if (!(cell.flags.cell &\n                (CellFlags.HAS_ANY_ACTOR | CellFlags.HAS_ITEM)) &&\n                cell.flags.cellMech & CellMechFlags.PRESSURE_PLATE_DEPRESSED) {\n                cell.flags.cellMech &= ~CellMechFlags.PRESSURE_PLATE_DEPRESSED;\n            }\n            if (cell.hasEffect('noKey') && !cell.hasKey()) {\n                await cell.activate('noKey', this, x, y);\n            }\n        });\n        // now spread the fire...\n        await this.forEachAsync(async (cell, x, y) => {\n            if (cell.hasTileFlag(Tile.Flags.T_IS_FIRE) &&\n                !(cell.flags.cellMech & CellMechFlags.CAUGHT_FIRE_THIS_TURN)) {\n                await this.exposeToFire(x, y, false);\n                await this.eachNeighborAsync(x, y, (_n, i, j) => this.exposeToFire(i, j), true);\n            }\n        });\n        if (!(this.flags.map & Flags.MAP_NO_LIQUID)) {\n            const newVolume = Grid.alloc(this.width, this.height);\n            const calc = calcBaseVolume(this, TileLayer.LIQUID, newVolume);\n            if (calc === CalcType.CALC) {\n                this.updateLiquid(newVolume);\n            }\n            if (calc != CalcType.NONE) {\n                updateVolume(this, TileLayer.LIQUID, newVolume);\n                this.flags.map &= ~Flags.MAP_NO_LIQUID;\n            }\n            else {\n                this.flags.map |= Flags.MAP_NO_LIQUID;\n            }\n            this.changed = true;\n            Grid.free(newVolume);\n        }\n        if (!(this.flags.map & Flags.MAP_NO_GAS)) {\n            const newVolume = Grid.alloc(this.width, this.height);\n            const calc = calcBaseVolume(this, TileLayer.GAS, newVolume);\n            if (calc === CalcType.CALC) {\n                this.updateGas(newVolume);\n            }\n            if (calc != CalcType.NONE) {\n                updateVolume(this, TileLayer.GAS, newVolume);\n                this.flags.map &= ~Flags.MAP_NO_GAS;\n            }\n            else {\n                this.flags.map |= Flags.MAP_NO_GAS;\n            }\n            this.changed = true;\n            Grid.free(newVolume);\n        }\n    }\n    async exposeToFire(x, y, alwaysIgnite = false) {\n        let ignitionChance = 0, bestExtinguishingPriority = 0, explosiveNeighborCount = 0;\n        let fireIgnited = false, explosivePromotion = false;\n        const cell = this.cell(x, y);\n        if (!cell.hasTileFlag(TileFlags.T_IS_FLAMMABLE)) {\n            return false;\n        }\n        // Pick the extinguishing layer with the best priority.\n        for (let tile of cell.tiles()) {\n            if (tile.flags.tile & TileFlags.T_EXTINGUISHES_FIRE &&\n                tile.priority > bestExtinguishingPriority) {\n                bestExtinguishingPriority = tile.priority;\n            }\n        }\n        // Pick the fire type of the most flammable layer that is either gas or equal-or-better priority than the best extinguishing layer.\n        for (let tile of cell.tiles()) {\n            if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE &&\n                (tile.layer === Entity.Layer.GAS ||\n                    tile.priority >= bestExtinguishingPriority)) {\n                const effect = EFFECT.from(tile.effects.fire);\n                if (effect && effect.chance > ignitionChance) {\n                    ignitionChance = effect.chance;\n                }\n            }\n        }\n        if (alwaysIgnite ||\n            (ignitionChance && random.chance(ignitionChance, 10000))) {\n            // If it ignites...\n            fireIgnited = true;\n            // Count explosive neighbors.\n            if (cell.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                this.eachNeighbor(x, y, (n) => {\n                    if (n.hasLayerFlag(Entity.Flags.L_BLOCKS_GAS) ||\n                        n.hasTileFlag(TileFlags.T_IS_FIRE) ||\n                        n.hasTileMechFlag(TileMechFlags.TM_EXPLOSIVE_PROMOTE)) {\n                        ++explosiveNeighborCount;\n                    }\n                });\n                if (explosiveNeighborCount >= 8) {\n                    explosivePromotion = true;\n                }\n            }\n            let event = 'fire';\n            if (explosivePromotion && cell.hasEffect('explode')) {\n                event = 'explode';\n            }\n            for (let tile of cell.tiles()) {\n                if (tile.flags.tile & TileFlags.T_IS_FLAMMABLE) {\n                    if (tile.layer === Entity.Layer.GAS) {\n                        cell.gasVolume = 0;\n                    }\n                    else if (tile.layer === Entity.Layer.LIQUID) {\n                        cell.liquidVolume = 0;\n                    }\n                }\n            }\n            await cell.activate(event, this, x, y, {\n                force: true,\n            });\n            this.redrawCell(cell);\n        }\n        return fireIgnited;\n    }\n    updateLiquid(newVolume) {\n        this.randomEach((c, x, y) => {\n            if (c.hasLayerFlag(Entity.Flags.L_BLOCKS_LIQUID))\n                return;\n            let highVol = 0;\n            let highX = -1;\n            let highY = -1;\n            let highTile = c.liquidTile;\n            let myVol = newVolume[x][y];\n            newVolume.eachNeighbor(x, y, (v, i, j) => {\n                if (v <= myVol)\n                    return;\n                if (v <= highVol)\n                    return;\n                highVol = v;\n                highX = i;\n                highY = j;\n                highTile = this.cell(i, j).liquidTile;\n            });\n            if (highVol > 1) {\n                // guaranteed => myVol < highVol\n                this.setTile(x, y, highTile, 0); // place tile with 0 volume - will force liquid to be same as highest volume liquid neighbor\n                const amt = Math.floor((highVol - myVol) / 9) + 1;\n                newVolume[x][y] += amt;\n                newVolume[highX][highY] -= amt;\n            }\n        });\n        // }\n    }\n    updateGas(newVolume) {\n        const dirs = random.sequence(4).map((i) => Utils.DIRS[i]);\n        const grid = Grid.alloc(this.width, this.height);\n        // push out from my square\n        newVolume.forEach((v, x, y) => {\n            if (!v)\n                return;\n            let adj = v;\n            if (v > 1) {\n                let count = 1;\n                newVolume.eachNeighbor(x, y, () => {\n                    ++count;\n                }, true); // only 4 dirs\n                let avg = Math.floor(v / count);\n                let rem = v - avg * count;\n                grid[x][y] += avg;\n                if (rem > 0) {\n                    grid[x][y] += 1;\n                    rem -= 1;\n                }\n                for (let i = 0; i < dirs.length; ++i) {\n                    const dir = dirs[i];\n                    const x2 = x + dir[0];\n                    const y2 = y + dir[1];\n                    if (grid.hasXY(x2, y2)) {\n                        adj = avg;\n                        if (rem > 0) {\n                            --rem;\n                            ++adj;\n                        }\n                        grid[x2][y2] += adj;\n                    }\n                }\n            }\n            else {\n                grid[x][y] += v;\n            }\n        });\n        newVolume.copy(grid);\n        Grid.free(grid);\n        // newVolume.dump();\n    }\n    resetCellEvents() {\n        this.forEach((c) => (c.flags.cellMech &= ~(CellMechFlags.EVENT_FIRED_THIS_TURN |\n            CellMechFlags.EVENT_PROTECTED)));\n    }\n}\nexport function make(w, h, opts = {}, wall) {\n    if (typeof opts === 'string') {\n        opts = { tile: opts };\n        if (wall) {\n            opts.wall = wall;\n        }\n    }\n    const map = new Map(w, h, opts);\n    let floor = opts.tile || opts.floor || opts.floorTile;\n    if (floor === true) {\n        floor = 'FLOOR';\n    }\n    let boundary = opts.boundary || opts.wall || opts.wallTile;\n    if (boundary === true) {\n        boundary = 'WALL';\n    }\n    if (floor) {\n        map.fill(floor, boundary);\n    }\n    if (!DATA.map) {\n        DATA.map = map;\n    }\n    return map;\n}\nMake.map = make;\nfunction isString(value) {\n    return typeof value === 'string';\n}\nfunction isStringArray(value) {\n    return Array.isArray(value) && typeof value[0] === 'string';\n}\nexport function from(prefab, charToTile, opts = {}) {\n    let height = 0;\n    let width = 0;\n    let map;\n    if (isString(prefab)) {\n        prefab = prefab.split('\\n');\n    }\n    if (isStringArray(prefab)) {\n        height = prefab.length;\n        width = prefab.reduce((len, line) => Math.max(len, line.length), 0);\n        map = make(width, height, opts);\n        prefab.forEach((line, y) => {\n            for (let x = 0; x < width; ++x) {\n                const ch = line[x] || '.';\n                const tile = charToTile[ch] || 'FLOOR';\n                map.setTile(x, y, tile);\n            }\n        });\n    }\n    else {\n        height = prefab.height;\n        width = prefab.width;\n        map = make(width, height, opts);\n        prefab.forEach((v, x, y) => {\n            const tile = charToTile[v] || 'FLOOR';\n            map.setTile(x, y, tile);\n        });\n    }\n    // redo this because we changed the tiles\n    if (opts.visible || opts.revealed) {\n        map.makeVisible();\n        map.revealAll();\n    }\n    if (opts.revealed && !opts.visible) {\n        map.makeVisible(false);\n    }\n    return map;\n}\nif (!COLORS.cursor) {\n    Color.install('cursor', COLORS.yellow);\n}\nif (!COLORS.path) {\n    Color.install('path', COLORS.gold);\n}\nexport function getCellAppearance(map, x, y, dest) {\n    dest.blackOut();\n    if (!map.hasXY(x, y))\n        return;\n    const cell = map.cell(x, y);\n    if (cell.isAnyKindOfVisible() &&\n        cell.flags.cell & (CellFlags.CELL_CHANGED | CellFlags.NEEDS_REDRAW)) {\n        Cell.getAppearance(cell, dest);\n    }\n    else {\n        // if (cell.isRevealed()) {\n        dest.drawSprite(cell.memory.mixer);\n    }\n    if (cell.isVisible()) {\n        // keep here to allow for games that do not use fov to work\n    }\n    else if (!cell.isRevealed()) {\n        if (!cell.isAnyKindOfVisible())\n            dest.blackOut();\n    }\n    else if (!cell.isAnyKindOfVisible()) {\n        dest.bg.mix(COLORS.black, 30);\n        dest.fg.mix(COLORS.black, 30);\n    }\n    let needDistinctness = false;\n    if (cell.flags.cell & (CellFlags.IS_CURSOR | CellFlags.IS_IN_PATH)) {\n        const highlight = cell.flags.cell & CellFlags.IS_CURSOR ? COLORS.cursor : COLORS.path;\n        if (cell.hasLayerFlag(LayerFlags.L_INVERT_WHEN_HIGHLIGHTED)) {\n            Color.swap(dest.fg, dest.bg);\n        }\n        else {\n            // if (!GAME.trueColorMode || !dest.needDistinctness) {\n            // dest.fg.mix(highlight, CONFIG.cursorPathIntensity || 20);\n            // }\n            dest.bg.mix(highlight, CONFIG.cursorPathIntensity || 20);\n        }\n        needDistinctness = true;\n    }\n    if (needDistinctness) {\n        Color.separate(dest.fg, dest.bg);\n    }\n    if (dest.dances) {\n        map.flags.map |= Flags.MAP_DANCES;\n    }\n    // dest.bake();\n}\nexport function addText(map, x, y, text, fg, bg, layer) {\n    for (let ch of text) {\n        const sprite = Entity.make({\n            ch,\n            fg,\n            bg,\n            layer: layer || TileLayer.GROUND,\n            priority: 200,\n        }); // on top of ground tiles\n        const cell = map.cell(x++, y);\n        cell.addLayer(sprite);\n    }\n}\nvar CalcType;\n(function (CalcType) {\n    CalcType[CalcType[\"NONE\"] = 0] = \"NONE\";\n    CalcType[CalcType[\"UPDATE\"] = 1] = \"UPDATE\";\n    CalcType[CalcType[\"CALC\"] = 2] = \"CALC\";\n})(CalcType || (CalcType = {}));\nfunction calcBaseVolume(map, depth, newVolume) {\n    let hasVolume = false;\n    let needsAjustment = false;\n    map.forEach((c, x, y) => {\n        let volume = c.volume(depth);\n        const tile = c.tile(depth);\n        if (volume && tile.dissipate) {\n            if (tile.dissipate > 10000) {\n                volume -= Math.floor(tile.dissipate / 10000);\n                if (random.chance(tile.dissipate % 10000, 10000)) {\n                    volume -= 1;\n                }\n            }\n            else if (random.chance(tile.dissipate, 10000)) {\n                volume -= 1;\n            }\n        }\n        if (volume > 0) {\n            newVolume[x][y] = volume;\n            hasVolume = true;\n            if (volume > 1) {\n                needsAjustment = true;\n            }\n        }\n        else if (tile !== Tile.tiles.NULL) {\n            c.clearLayer(depth);\n            map.redrawCell(c);\n        }\n    });\n    if (needsAjustment)\n        return CalcType.CALC;\n    if (hasVolume)\n        return CalcType.UPDATE;\n    return CalcType.NONE;\n}\nfunction updateVolume(map, depth, newVolume) {\n    newVolume.forEach((v, i, j) => {\n        const cell = map.cell(i, j);\n        const current = cell.volume(depth);\n        const tile = cell.tile(depth);\n        if (v > 0) {\n            // hasLiquid = true;\n            if (current !== v || !tile) {\n                let highVol = current;\n                let highTile = tile;\n                map.eachNeighbor(i, j, (n) => {\n                    if (n.volume(depth) > highVol) {\n                        highVol = n.volume(depth);\n                        highTile = n.tile(depth);\n                    }\n                });\n                if (highTile !== tile) {\n                    cell.setTile(highTile, 0, map);\n                }\n                cell.setVolume(depth, v);\n                map.redrawCell(cell);\n            }\n        }\n        else if (current || tile !== Tile.tiles.NULL) {\n            cell.clearLayer(depth);\n            map.redrawCell(cell);\n        }\n    });\n}\n","import * as Tile from './tile';\n// These are the minimal set of tiles to make the diggers work\nTile.install('NULL', {\n    ch: '\\u2205',\n    fg: 'white',\n    bg: 'black',\n    flags: 'L_BLOCKS_MOVE',\n    name: 'eerie nothingness',\n    article: 'an',\n    priority: 0,\n});\nTile.install('FLOOR', {\n    ch: '\\u00b7',\n    fg: [30, 30, 30, 20, 0, 0, 0],\n    bg: [2, 2, 10, 0, 2, 2, 0],\n    priority: 10,\n    article: 'the',\n});\nTile.install('DOOR', {\n    ch: '+',\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 30,\n    flags: 'T_IS_DOOR, L_BLOCKS_EFFECTS, L_BLOCKS_ITEMS, L_BLOCKS_VISION, L_VISUALLY_DISTINCT',\n    article: 'a',\n    effects: {\n        enter: { tile: 'DOOR_OPEN' },\n        open: { tile: 'DOOR_OPEN_ALWAYS' },\n    },\n});\nTile.install('DOOR_OPEN', 'DOOR', {\n    ch: \"'\",\n    fg: [100, 40, 40],\n    bg: [30, 60, 60],\n    priority: 40,\n    flags: '!L_BLOCKS_ITEMS, !L_BLOCKS_VISION',\n    name: 'open door',\n    article: 'an',\n    effects: {\n        tick: {\n            chance: 100 * 100,\n            tile: 'DOOR',\n            flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY',\n        },\n        enter: null,\n        open: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n});\nTile.install('DOOR_OPEN_ALWAYS', 'DOOR_OPEN', {\n    effects: {\n        tick: null,\n        close: { tile: 'DOOR', flags: 'E_SUPERPRIORITY, E_ONLY_IF_EMPTY' },\n    },\n});\nTile.install('UP_STAIRS', {\n    ch: '<',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_UP_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'upward staircase',\n    article: 'an',\n    effects: {\n        player: { emit: 'UP_STAIRS' },\n    },\n});\nTile.install('DOWN_STAIRS', {\n    ch: '>',\n    fg: [100, 50, 50],\n    bg: [40, 20, 20],\n    priority: 200,\n    flags: 'T_DOWN_STAIRS, L_BLOCKED_BY_STAIRS, L_VISUALLY_DISTINCT, L_LIST_IN_SIDEBAR',\n    name: 'downward staircase',\n    article: 'a',\n    effects: {\n        player: { emit: 'DOWN_STAIRS' },\n    },\n});\nTile.install('WALL', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_BLOCKS_EVERYTHING',\n    article: 'a',\n    name: 'stone wall',\n    desc: 'A wall made from rough cut stone.',\n    flavor: 'a rough stone wall',\n});\nTile.install('IMPREGNABLE', {\n    ch: '#',\n    fg: [7, 7, 7, 0, 3, 3, 3],\n    bg: [40, 40, 40, 10, 10, 0, 5],\n    priority: 100,\n    flags: 'L_BLOCKS_EVERYTHING, IMPREGNABLE',\n    article: 'a',\n    name: 'impregnable wall',\n    desc: 'A wall made from very hard stone.',\n    flavor: 'an impregnable wall',\n});\nTile.install('LAKE', {\n    ch: '~',\n    fg: [5, 8, 20, 10, 0, 4, 15, true],\n    bg: [10, 15, 41, 6, 5, 5, 5, true],\n    priority: 50,\n    flags: 'T_DEEP_WATER',\n    name: 'deep water',\n    article: 'the',\n});\nTile.install('SHALLOW', {\n    ch: '\\u00b7',\n    fg: [5, 8, 10, 10, 0, 4, 15, true],\n    bg: [10, 15, 31, 6, 5, 5, 5, true],\n    priority: 20,\n    name: 'shallow water',\n    article: 'the',\n});\nTile.install('BRIDGE', {\n    ch: '=',\n    fg: [100, 40, 40],\n    priority: 40,\n    layer: 'SURFACE',\n    flags: 'T_BRIDGE, L_VISUALLY_DISTINCT',\n    article: 'a',\n    ground: 'LAKE',\n});\n"],"names":["Layer","Fl","Flag","fl","Entity","Activation","Tile","TileMech","Cell","CellMech","Map","L_BLOCKS_ITEMS","L_BLOCKS_SURFACE","L_BLOCKS_GAS","L_BLOCKS_LIQUID","L_BLOCKS_EFFECTS","L_BLOCKS_ACTORS","L_BLOCKS_MOVE","L_BLOCKS_VISION","L_BLOCKS_DIAGONAL","L_IS_WALL","DFF_BLOCKED_BY_ITEMS","DFF_BLOCKED_BY_ACTORS","DFF_NULL_SURFACE","DFF_NULL_LIQUID","DFF_NULL_GAS","T_UP_STAIRS","T_DOWN_STAIRS","T_PORTAL","T_AUTO_DESCENT","T_LAVA","T_DEEP_WATER","T_SPONTANEOUSLY_IGNITES","T_HAS_STAIRS","T_IS_TRAP","T_IS_FIRE","T_ENTANGLES","REVEALED","MAGIC_MAPPED","ITEM_DETECTED","HAS_ITEM","HAS_DORMANT_MONSTER","STABLE_MEMORY","VISIBLE","CLAIRVOYANT_VISIBLE","TELEPATHIC_VISIBLE","HAS_PLAYER","HAS_ACTOR","WAS_VISIBLE","WAS_CLAIRVOYANT_VISIBLE","WAS_TELEPATHIC_VISIBLE","IN_FOV","NEEDS_REDRAW","CELL_CHANGED","IS_IN_ROOM_MACHINE","IS_IN_AREA_MACHINE","SEARCHED_FROM_HERE","PRESSURE_PLATE_DEPRESSED","KNOWN_TO_BE_TRAP_FREE","IS_IN_LOOP","IS_CHOKEPOINT","IS_GATE_SITE","IS_IN_MACHINE","IMPREGNABLE","MAP_STABLE_LIGHTS","MAP_STABLE_GLOW_LIGHTS","config","CONFIG","light","INTENSITY_DARK","LIGHT_COMPONENTS","Color","make","Light","[object Object]","color","range","fadeTo","pass","this","passThroughActors","id","from","radius","Range","other","copy","intensity","map","x","y","maintainShadows","isMinersLight","k","lightMultiplier","value","outerRadius","Math","ceil","bake","dispelShadows","fadeToPercent","grid","Grid","alloc","width","height","calcFov","Flags.Cell","HAS_ANY_ACTOR","Flags.Entity","overlappedFieldOfView","forCircle","v","i","j","cell","floor","Utils","distanceBetween","flags","IS_IN_SHADOW","ANY_KIND_OF_VISIBLE","free","max","args","length","cached","lights","split","t","trim","Number","parseInt","Array","isArray","Error","ERROR","JSON","stringify","arg","install","source","recordOldLights","eachCell","oldLight","lightChanged","zeroOutLights","ambientLight","_i","_j","recordGlowLights","glowLight","restoreGlowLights","updateLighting","anyLightChanged","staticLightChanged","eachStaticLight","paint","eachDynamicLight","CELL_LIT","CELL_DARK","some","isDark","updateDisplayDetail","PLAYER","DATA","player","PLAYERS_LIGHT","Object","entries","forEach","name","info","darkColor","priority","layer","sprite","GW.make","Light.make","GW.utils","first","GW.flag","Flags","layerFlags","flag","Layer.Entity","super","Extends","tiles","base","ch","fg","bg","opacity","tile","tileMech","effects","flavor","desc","article","dissipate","defaultGround","assignOmitting","assign","ground","Layer.Flags","MechFlags","mechFlags","key","activation","Effect","T_PATHING_BLOCKER","opts","result","toString","getName","arguments","cursorPathIntensity","CellMemory","mixer","Sprite","Mixer","item","itemQuantity","actor","cellMech","nullify","_tiles","layers","_actor","_item","data","CELL_DEFAULT","gasVolume","liquidVolume","machineNumber","memory","chokeCount","copyObject","clear","floorTile","TILES","layerFlag","GAS","LIQUID","SURFACE","GROUND","reduce","out","l","clearLayer","_a","liquid","surface","gas","groundTile","NULL","liquidTile","surfaceTile","gasTile","changed","IS_WAS_ANY_KIND_OF_VISIBLE","orMapped","hasLayerFlag","LayerFlags","L_LIST_IN_SIDEBAR","needsRedraw","Light.intensity","LIGHT_CHANGED","volume","limitToPlayerKnowledge","isVisible","flagMask","tileFlags","tileMechFlags","cellFlag","cellMechFlag","isAnyKindOfVisible","skipGas","best","bestPriority","tileFlag","mechFlag","topmostTile","useMemory","TileFlags","T_IS_DEEP_LIQUID","T_BRIDGE","isWalkableNow","L_SECRETLY_PASSABLE","HAS_GAS","isWall","depth","tileId","setTile","FLOOR","oldTile","oldTileId","blocksPathing","staleLoopMap","CAUGHT_FIRE_THIS_TURN","blocksVision","oldBlocksVision","setFlag","MapFlags","MAP_FOV_CHANGED","removeLayer","addLayer","HAS_LIQUID","clearFlag","MAP_NO_LIQUID","MAP_NO_GAS","HAS_SURFACE","current","didSomething","except","ctx","fired","undefined","ev","effect","force","chance","random","fire","hasEffect","ITEM","isPlayer","ACTOR","obj","next","prev","isRevealed","quantity","getAppearance","dest","blackOut","needDistinctness","L_VISUALLY_DISTINCT","alpha","clamp","drawSprite","multiply","separate","dances","COLORS_DANCE","demoteCellVisibility","WAS_ANY_KIND_OF_VISIBLE","promoteCellVisibility","hasVisibleLight","Flags.CellMech","DARKENED","wasVisible","redrawCell","GW.data","automationActive","theItem","L_INTERRUPT_WHEN_SEEN","GW.message","add","tileWithLayerFlag","markRevealed","storeMemory","_updateCellVisibility","isClairy","wasClairy","_updateCellClairyvoyance","isTele","wasTele","hasTileFlag","Flags.Tile","xpxpThisTurn","_updateCellTelepathy","isMonst","MONSTER_DETECTED","wasMonst","WAS_MONSTER_DETECTED","_updateCellDetect","initMap","Map.Flags","MAP_CALC_FOV","clearFlags","setFlags","maxRadius","fov","Flags.Map","GW.grid","setCellFlags","GW.effect","async","tileEffect","Tile.tiles","abortIfBlocking","E_ABORT_IF_BLOCKS_MAP","isBlocking","E_PERMIT_BLOCKING","E_TREAT_AS_BLOCKING","dir","x2","y2","madeChange","startProb","spread","probDec","decrement","spawnMap","fill","count","DIRS","hasXY","cellIsOk","GW.random","computeSpawnMap","gridDisruptsWalkability","E_EVACUATE_CREATURES","blockingMap","monst","loc","matchingLocNear","forbidsCell","hallways","moveActor","evacuateCreatures","E_EVACUATE_ITEMS","removeItem","addItem","evacuateItems","E_CLEAR_CELL","clearAll","E_CLEAR_GAS","Entity.Layer","E_CLEAR_LIQUID","E_CLEAR_SURFACE","E_CLEAR_GROUND","clearCells","accomplishedSomething","blockedByOtherLayers","E_BLOCKED_BY_OTHER_LAYERS","superpriority","E_SUPERPRIORITY","obstructsLayer","E_BLOCKED_BY_ITEMS","E_BLOCKED_BY_ACTORS","Cell.MechFlags","EVENT_FIRED_THIS_TURN","E_PROTECTED","EVENT_PROTECTED","spawnTiles","fireAll","event","willFire","promoteChance","eachNeighbor","n","Entity.Flags","forEachAsync","w","activate","isStart","E_BUILD_IN_WALLS","E_MUST_TOUCH_WALLS","ok","c","E_NO_TOUCH_WALLS","blocksEffects","matchTile","hasTile","clearEffect","clearCellLayers","updateChokepoints","updateCounts","passMap","FLAGS.Tile","FLAGS.Entity","passableArcCount","cells","FLAGS.CellMech","oldX","CLOCK_DIRS","oldY","newX","newY","cellCount","floodFillCount","i2","j2","results","startX","startY","min","updateLoopiness","resetLoopiness","checkLoopiness","cleanLoopiness","_x","_y","_map","inString","sdir","numStrings","maxStringLength","currentStringLength","get","newCell","fillInnerLoopGrid","up","left","designationSurvives","installType","match","needs","bind","ALL_LAYERS","setDefaults","map.deepestLevel","h","locations","_actors","_items","_width","_height","Cell.Cell","tick","MAP_DEFAULT","ambient","ambientLightChanged","updateLiquid","updateGas","Light.updateLighting","Visibility.initMap","visible","revealed","revealAll","makeVisible","fmt","dump","fn","forRect","only4dirs","eachNeighborAsync","randomEach","g","isBoundaryXY","MAP_CHANGED","hasTileMechFlag","buffer","Canvas","getCellAppearance","glyph","toGlyph","draw","toInt","Cell.Flags","isOrWasAnyKindOfVisible","mapFlag","cellFlags","cellMechFlags","tileWithFlag","tileWithMechFlag","isClear","isEmpty","isObstruction","isDoorway","isSecretDoorway","isLiquid","hasGas","isMoveableNow","canBeWalked","tileFlavor","clearLayers","clearLayersWithFlags","boundaryTile","matchFn","arcCount","x1","y1","costGrid","costFn","Path","OBSTRUCTION","isNull","matcher","matchingNeighbor","TRUE","hallwaysAllowed","forbidLiquid","liquids","deterministic","candidateLocs","closestDist","dist","walkableArcCount","push","randIndex","number","sequence","forbidCellFlags","forbidLayerFlags","forbidTileFlags","forbidTileMechFlags","success","index","Light.from","matches","eachChain","anim","oldCell","theActor","CellFlags","avoidsCell","addActor","removeActor","rememberedInCell","removeFromChain","actorAt","delete","isDetected","D_ITEM_OMNISCIENCE","blockingGrid","walkableGrid","disrupts","gridOffsetX","gridOffsetY","bounds","contains","blockingX","blockingY","floodFill","forbiddenCellFlags","forbiddenLayerFlags","Fov","FOV","isBlocked","hasCellFlag","calcRadius","sqrt","calculate","a","b","equalsXY","line","getLine","Effect.fireAll","CellMechFlags","hasKey","Tile.Flags","exposeToFire","_n","newVolume","calc","calcBaseVolume","TileLayer","CalcType","CALC","NONE","updateVolume","alwaysIgnite","ignitionChance","bestExtinguishingPriority","explosiveNeighborCount","fireIgnited","explosivePromotion","T_IS_FLAMMABLE","T_EXTINGUISHES_FIRE","EFFECT","TileMechFlags","TM_EXPLOSIVE_PROMOTE","highVol","highX","highY","highTile","myVol","amt","dirs","adj","avg","rem","wall","boundary","wallTile","Cell.getAppearance","mix","COLORS","black","IS_CURSOR","IS_IN_PATH","highlight","cursor","path","L_INVERT_WHEN_HIGHLIGHTED","swap","MAP_DANCES","hasVolume","needsAjustment","UPDATE","setVolume","yellow","gold","prefab","charToTile","isStringArray","len","text","Entity.make","updateChokeCounts","enter","open","close","emit"],"mappings":"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"}